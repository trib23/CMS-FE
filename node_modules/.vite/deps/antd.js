"use client";


import { r as __toESM, t as __commonJS } from "./chunk-DUEDWNxO.js";
import { t as require_react } from "./react-DVLWGUHu.js";
import { t as require_react_dom } from "./react-dom-BDz0e_EX.js";
import { $u as EditOutlined_default, Bh as updateCSS, Bu as ExclamationCircleFilled_default, Da as PictureTwoTone_default, Eu as EyeOutlined_default, Fh as noteOnce, Fl as FileTwoTone_default, Fp as CaretDownFilled_default, Gd as DeleteOutlined_default, Gh as presetPalettes, Hh as canUseDom, Ih as warning, Jh as FastColor, Jl as FileOutlined_default, Kh as presetPrimaryColors, Kr as RotateRightOutlined_default, Lh as warning_default$1, Ll as FileTextOutlined_default, Mm as BarsOutlined_default, Mn as StarFilled_default, Mr as SearchOutlined_default, Ni as QuestionCircleOutlined_default, Op as CaretUpOutlined_default, Ou as EyeInvisibleOutlined_default, Pp as CaretDownOutlined_default, Rh as getShadowRoot, Tl as FilterFilled_default, Uh as blue, Up as CalendarOutlined_default, V as WarningFilled_default, Vh as contains, Vs as InfoCircleFilled_default, Wa as PaperClipOutlined_default, Wh as gold, Xh as clsx_default, Xu as EnterOutlined_default, Yh as clsx, Z as VerticalAlignTopOutlined_default, Zh as Context_default$1, Zo as LoadingOutlined_default, Zu as EllipsisOutlined_default, _d as DoubleRightOutlined_default, _o as MinusOutlined_default, a as fillRef, ac as HolderOutlined_default, c as supportRef, cp as ClockCircleOutlined_default, d as useMemo$1, dl as FolderOpenOutlined_default, f as ZoomOutOutlined_default, fa as PlusOutlined_default, fi as ReloadOutlined_default, fs as LeftOutlined_default, gf as CopyOutlined_default, gn as SwapOutlined_default, hn as SwapRightOutlined_default, ho as MinusSquareOutlined_default, i as composeRef, ii as RightOutlined_default, l as useComposeRef, ld as DownloadOutlined_default, ll as FolderOutlined_default, mt as UpOutlined_default, o as getNodeRef, op as CloseCircleFilled_default, p as ZoomInOutlined_default, pd as DownOutlined_default, qh as generate, qr as RotateLeftOutlined_default, rp as CloseOutlined_default, s as supportNodeRef, u as isFragment$1, ua as PlusSquareOutlined_default, vd as DoubleLeftOutlined_default, wp as CheckCircleFilled_default, xp as CheckOutlined_default, zh as removeCSS } from "./es-B_09bbJ_.js";
import { t as require_client } from "./client-C6RURIVx.js";

//#region node_modules/antd/es/_util/getReactMajorVersionCanDelMe.js
var import_react = require_react();
function getReactMajorVersion() {
	return Number.parseInt(import_react.version.split(".")[0], 10);
}

//#endregion
//#region node_modules/@rc-component/util/es/hooks/useEvent.js
function useEvent(callback) {
	const fnRef = import_react.useRef(callback);
	fnRef.current = callback;
	return import_react.useCallback((...args) => fnRef.current?.(...args), []);
}
var useEvent_default = useEvent;

//#endregion
//#region node_modules/@rc-component/util/es/hooks/useLayoutEffect.js
/**
* Wrap `React.useLayoutEffect` which will not throw warning message in test env
*/
var useInternalLayoutEffect = canUseDom() ? import_react.useLayoutEffect : import_react.useEffect;
var useLayoutEffect$1 = (callback, deps) => {
	const firstMountRef = import_react.useRef(true);
	useInternalLayoutEffect(() => {
		return callback(firstMountRef.current);
	}, deps);
	useInternalLayoutEffect(() => {
		firstMountRef.current = false;
		return () => {
			firstMountRef.current = true;
		};
	}, []);
};
const useLayoutUpdateEffect = (callback, deps) => {
	useLayoutEffect$1((firstMount) => {
		if (!firstMount) return callback();
	}, deps);
};
var useLayoutEffect_default = useLayoutEffect$1;

//#endregion
//#region node_modules/@rc-component/util/es/hooks/useState.js
/**
* Same as React.useState but `setState` accept `ignoreDestroy` param to not to setState after destroyed.
* We do not make this auto is to avoid real memory leak.
* Developer should confirm it's safe to ignore themselves.
*/
function useSafeState(defaultValue) {
	const destroyRef = import_react.useRef(false);
	const [value, setValue] = import_react.useState(defaultValue);
	import_react.useEffect(() => {
		destroyRef.current = false;
		return () => {
			destroyRef.current = true;
		};
	}, []);
	function safeSetState(updater, ignoreDestroy) {
		if (ignoreDestroy && destroyRef.current) return;
		setValue(updater);
	}
	return [value, safeSetState];
}

//#endregion
//#region node_modules/@rc-component/util/es/hooks/useControlledState.js
/**
* Similar to `useState` but will use props value if provided.
* From React 18, we do not need safe `useState` since it will not throw for unmounted update.
* This hooks remove the `onChange` & `postState` logic since we only need basic merged state logic.
*/
function useControlledState(defaultStateValue, value) {
	const [innerValue, setInnerValue] = (0, import_react.useState)(defaultStateValue);
	const mergedValue = value !== void 0 ? value : innerValue;
	useLayoutEffect_default((mount) => {
		if (!mount) setInnerValue(value);
	}, [value]);
	return [mergedValue, setInnerValue];
}

//#endregion
//#region node_modules/@rc-component/util/es/utils/get.js
function get(entity, path$1) {
	let current = entity;
	for (let i = 0; i < path$1.length; i += 1) {
		if (current === null || current === void 0) return;
		current = current[path$1[i]];
	}
	return current;
}

//#endregion
//#region node_modules/@rc-component/util/es/utils/set.js
function internalSet(entity, paths, value, removeIfUndefined) {
	if (!paths.length) return value;
	const [path$1, ...restPath] = paths;
	let clone;
	if (!entity && typeof path$1 === "number") clone = [];
	else if (Array.isArray(entity)) clone = [...entity];
	else clone = { ...entity };
	if (removeIfUndefined && value === void 0 && restPath.length === 1) delete clone[path$1][restPath[0]];
	else clone[path$1] = internalSet(clone[path$1], restPath, value, removeIfUndefined);
	return clone;
}
function set(entity, paths, value, removeIfUndefined = false) {
	if (paths.length && removeIfUndefined && value === void 0 && !get(entity, paths.slice(0, -1))) return entity;
	return internalSet(entity, paths, value, removeIfUndefined);
}
function isObject(obj) {
	return typeof obj === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
}
function createEmpty(source) {
	return Array.isArray(source) ? [] : {};
}
var keys = typeof Reflect === "undefined" ? Object.keys : Reflect.ownKeys;
/**
* Merge multiple objects. Support custom merge logic.
* @param sources object sources
* @param config.prepareArray Customize array prepare function.
* It will return empty [] by default.
* So when match array, it will auto be override with next array in sources.
*/
function mergeWith(sources, config = {}) {
	const { prepareArray } = config;
	const finalPrepareArray = prepareArray || (() => []);
	let clone = createEmpty(sources[0]);
	sources.forEach((src) => {
		function internalMerge(path$1, parentLoopSet) {
			const loopSet = new Set(parentLoopSet);
			const value = get(src, path$1);
			const isArr = Array.isArray(value);
			if (isArr || isObject(value)) {
				if (!loopSet.has(value)) {
					loopSet.add(value);
					const originValue = get(clone, path$1);
					if (isArr) clone = set(clone, path$1, finalPrepareArray(originValue, value));
					else if (!originValue || typeof originValue !== "object") clone = set(clone, path$1, createEmpty(value));
					keys(value).forEach((key) => {
						if (Object.getOwnPropertyDescriptor(value, key).enumerable) internalMerge([...path$1, key], loopSet);
					});
				}
			} else clone = set(clone, path$1, value);
		}
		internalMerge([]);
	});
	return clone;
}
/**
* Merge multiple objects into a new single object.
* Arrays will be replaced by default.
*/
function merge$1(...sources) {
	return mergeWith(sources);
}

//#endregion
//#region node_modules/@rc-component/util/es/omit.js
function omit(obj, fields) {
	const clone = Object.assign({}, obj);
	if (Array.isArray(fields)) fields.forEach((key) => {
		delete clone[key];
	});
	return clone;
}

//#endregion
//#region node_modules/@rc-component/util/es/Children/toArray.js
function toArray(children, option = {}) {
	let ret = [];
	import_react.Children.forEach(children, (child) => {
		if ((child === void 0 || child === null) && !option.keepEmpty) return;
		if (Array.isArray(child)) ret = ret.concat(toArray(child));
		else if (isFragment$1(child) && child.props) ret = ret.concat(toArray(child.props.children, option));
		else ret.push(child);
	});
	return ret;
}

//#endregion
//#region node_modules/antd/es/_util/warning.js
function noop$4() {}
var { resetWarned: rcResetWarned } = warning_default$1;
var deprecatedWarnList = null;
var _warning = noop$4;
_warning = (valid, component, message$1) => {
	warning_default$1(valid, `[antd: ${component}] ${message$1}`);
};
var warning$2 = _warning;
const WarningContext = /* @__PURE__ */ import_react.createContext({});
/**
* This is a hook but we not named as `useWarning`
* since this is only used in development.
* We should always wrap this in `if (process.env.NODE_ENV !== 'production')` condition
*/
const devUseWarning = (component) => {
	const { strict } = import_react.useContext(WarningContext);
	const typeWarning = (valid, type$2, message$1) => {
		if (!valid) if (strict === false && type$2 === "deprecated") {
			const existWarning = deprecatedWarnList;
			if (!deprecatedWarnList) deprecatedWarnList = {};
			deprecatedWarnList[component] = deprecatedWarnList[component] || [];
			if (!deprecatedWarnList[component].includes(message$1 || "")) deprecatedWarnList[component].push(message$1 || "");
			if (!existWarning) console.warn("[antd] There exists deprecated usage in your code:", deprecatedWarnList);
		} else warning$2(valid, component, message$1);
	};
	typeWarning.deprecated = (valid, oldProp, newProp, message$1 = "") => {
		typeWarning(valid, "deprecated", `\`${oldProp}\` is deprecated. Please use \`${newProp}\` instead.${message$1 ? ` ${message$1}` : ""}`);
	};
	return typeWarning;
};
var warning_default = warning$2;

//#endregion
//#region node_modules/@rc-component/util/es/Dom/findDOMNode.js
function isDOM(node$1) {
	return node$1 instanceof HTMLElement || node$1 instanceof SVGElement;
}
/**
* Retrieves a DOM node via a ref, and does not invoke `findDOMNode`.
*/
function getDOM(node$1) {
	if (node$1 && typeof node$1 === "object" && isDOM(node$1.nativeElement)) return node$1.nativeElement;
	if (isDOM(node$1)) return node$1;
	return null;
}

//#endregion
//#region node_modules/@rc-component/resize-observer/es/Collection.js
const CollectionContext = /* @__PURE__ */ import_react.createContext(null);
/**
* Collect all the resize event from children ResizeObserver
*/
function Collection({ children, onBatchResize }) {
	const resizeIdRef = import_react.useRef(0);
	const resizeInfosRef = import_react.useRef([]);
	const onCollectionResize = import_react.useContext(CollectionContext);
	const onResize$1 = import_react.useCallback((size, element, data) => {
		resizeIdRef.current += 1;
		const currentId = resizeIdRef.current;
		resizeInfosRef.current.push({
			size,
			element,
			data
		});
		Promise.resolve().then(() => {
			if (currentId === resizeIdRef.current) {
				onBatchResize?.(resizeInfosRef.current);
				resizeInfosRef.current = [];
			}
		});
		onCollectionResize?.(size, element, data);
	}, [onBatchResize, onCollectionResize]);
	return /* @__PURE__ */ import_react.createElement(CollectionContext.Provider, { value: onResize$1 }, children);
}

//#endregion
//#region node_modules/@rc-component/resize-observer/es/utils/observerUtil.js
var elementListeners = /* @__PURE__ */ new Map();
function onResize(entities) {
	entities.forEach((entity) => {
		const { target } = entity;
		elementListeners.get(target)?.forEach((listener) => listener(target));
	});
}
var observer;
function ensureResizeObserver() {
	if (!observer) observer = new ResizeObserver(onResize);
	return observer;
}
function observe(element, callback) {
	if (!elementListeners.has(element)) {
		elementListeners.set(element, /* @__PURE__ */ new Set());
		ensureResizeObserver().observe(element);
	}
	elementListeners.get(element).add(callback);
}
function unobserve(element, callback) {
	if (elementListeners.has(element)) {
		elementListeners.get(element).delete(callback);
		if (!elementListeners.get(element).size) {
			ensureResizeObserver().unobserve(element);
			elementListeners.delete(element);
		}
	}
}

//#endregion
//#region node_modules/@rc-component/resize-observer/es/SingleObserver/index.js
function SingleObserver(props, ref) {
	const { children, disabled } = props;
	const elementRef = import_react.useRef(null);
	const onCollectionResize = import_react.useContext(CollectionContext);
	const isRenderProps = typeof children === "function";
	const mergedChildren = isRenderProps ? children(elementRef) : children;
	const sizeRef = import_react.useRef({
		width: -1,
		height: -1,
		offsetWidth: -1,
		offsetHeight: -1
	});
	const canRef = !isRenderProps && /* @__PURE__ */ import_react.isValidElement(mergedChildren) && supportRef(mergedChildren);
	const mergedRef = useComposeRef(canRef ? getNodeRef(mergedChildren) : null, elementRef);
	const getDomElement = () => {
		return getDOM(elementRef.current);
	};
	import_react.useImperativeHandle(ref, () => getDomElement());
	const propsRef = import_react.useRef(props);
	propsRef.current = props;
	const onInternalResize = import_react.useCallback((target) => {
		const { onResize: onResize$1, data } = propsRef.current;
		const { width, height } = target.getBoundingClientRect();
		const { offsetWidth, offsetHeight } = target;
		/**
		* Resize observer trigger when content size changed.
		* In most case we just care about element size,
		* let's use `boundary` instead of `contentRect` here to avoid shaking.
		*/
		const fixedWidth = Math.floor(width);
		const fixedHeight = Math.floor(height);
		if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
			const size = {
				width: fixedWidth,
				height: fixedHeight,
				offsetWidth,
				offsetHeight
			};
			sizeRef.current = size;
			const mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
			const mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
			const sizeInfo = {
				...size,
				offsetWidth: mergedOffsetWidth,
				offsetHeight: mergedOffsetHeight
			};
			onCollectionResize?.(sizeInfo, target, data);
			if (onResize$1) Promise.resolve().then(() => {
				onResize$1(sizeInfo, target);
			});
		}
	}, []);
	import_react.useEffect(() => {
		const currentElement = getDomElement();
		if (currentElement && !disabled) observe(currentElement, onInternalResize);
		return () => unobserve(currentElement, onInternalResize);
	}, [elementRef.current, disabled]);
	return canRef ? /* @__PURE__ */ import_react.cloneElement(mergedChildren, { ref: mergedRef }) : mergedChildren;
}
var RefSingleObserver = /* @__PURE__ */ import_react.forwardRef(SingleObserver);
RefSingleObserver.displayName = "SingleObserver";
var SingleObserver_default = RefSingleObserver;

//#endregion
//#region node_modules/@rc-component/resize-observer/es/index.js
function _extends$99() {
	_extends$99 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$99.apply(this, arguments);
}
var INTERNAL_PREFIX_KEY = "rc-observer-key";
function ResizeObserver$1(props, ref) {
	const { children } = props;
	const childNodes = typeof children === "function" ? [children] : toArray(children);
	if (childNodes.length > 1) warning(false, "Find more than one child node with `children` in ResizeObserver. Please use ResizeObserver.Collection instead.");
	else if (childNodes.length === 0) warning(false, "`children` of ResizeObserver is empty. Nothing is in observe.");
	return childNodes.map((child, index$1) => {
		const key = child?.key || `${INTERNAL_PREFIX_KEY}-${index$1}`;
		return /* @__PURE__ */ import_react.createElement(SingleObserver_default, _extends$99({}, props, {
			key,
			ref: index$1 === 0 ? ref : void 0
		}), child);
	});
}
var RefResizeObserver = /* @__PURE__ */ import_react.forwardRef(ResizeObserver$1);
RefResizeObserver.displayName = "ResizeObserver";
RefResizeObserver.Collection = Collection;
var es_default$2 = RefResizeObserver;

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray$34(r$1, a) {
	(null == a || a > r$1.length) && (a = r$1.length);
	for (var e$2 = 0, n$1 = Array(a); e$2 < a; e$2++) n$1[e$2] = r$1[e$2];
	return n$1;
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles$8(r$1) {
	if (Array.isArray(r$1)) return _arrayLikeToArray$34(r$1);
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray$8(r$1) {
	if ("undefined" != typeof Symbol && null != r$1[Symbol.iterator] || null != r$1["@@iterator"]) return Array.from(r$1);
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(r$1, a) {
	if (r$1) {
		if ("string" == typeof r$1) return _arrayLikeToArray$34(r$1, a);
		var t$1 = {}.toString.call(r$1).slice(8, -1);
		return "Object" === t$1 && r$1.constructor && (t$1 = r$1.constructor.name), "Map" === t$1 || "Set" === t$1 ? Array.from(r$1) : "Arguments" === t$1 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t$1) ? _arrayLikeToArray$34(r$1, a) : void 0;
	}
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread$8() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(r$1) {
	return _arrayWithoutHoles$8(r$1) || _iterableToArray$8(r$1) || _unsupportedIterableToArray(r$1) || _nonIterableSpread$8();
}

//#endregion
//#region node_modules/@rc-component/util/es/raf.js
var raf = (callback) => +setTimeout(callback, 16);
var caf = (num) => clearTimeout(num);
if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
	raf = (callback) => window.requestAnimationFrame(callback);
	caf = (handle) => window.cancelAnimationFrame(handle);
}
var rafUUID = 0;
var rafIds = /* @__PURE__ */ new Map();
function cleanup(id) {
	rafIds.delete(id);
}
var wrapperRaf = (callback, times = 1) => {
	rafUUID += 1;
	const id = rafUUID;
	function callRef(leftTimes) {
		if (leftTimes === 0) {
			cleanup(id);
			callback();
		} else {
			const realId = raf(() => {
				callRef(leftTimes - 1);
			});
			rafIds.set(id, realId);
		}
	}
	callRef(times);
	return id;
};
wrapperRaf.cancel = (id) => {
	const realId = rafIds.get(id);
	cleanup(id);
	return caf(realId);
};
wrapperRaf.ids = () => rafIds;
var raf_default = wrapperRaf;

//#endregion
//#region node_modules/antd/es/_util/throttleByAnimationFrame.js
function throttleByAnimationFrame(fn) {
	let requestId = null;
	const later = (args) => () => {
		requestId = null;
		fn.apply(void 0, _toConsumableArray(args));
	};
	const throttled = (...args) => {
		if (requestId === null) requestId = raf_default(later(args));
	};
	throttled.cancel = () => {
		raf_default.cancel(requestId);
		requestId = null;
	};
	return throttled;
}
var throttleByAnimationFrame_default = throttleByAnimationFrame;

//#endregion
//#region node_modules/antd/es/config-provider/context.js
const defaultPrefixCls = "ant";
const defaultIconPrefixCls = "anticon";
const Variants = [
	"outlined",
	"borderless",
	"filled",
	"underlined"
];
var defaultGetPrefixCls = (suffixCls, customizePrefixCls) => {
	if (customizePrefixCls) return customizePrefixCls;
	return suffixCls ? `${defaultPrefixCls}-${suffixCls}` : defaultPrefixCls;
};
const ConfigContext = /* @__PURE__ */ import_react.createContext({
	getPrefixCls: defaultGetPrefixCls,
	iconPrefixCls: defaultIconPrefixCls
});
const { Consumer: ConfigConsumer } = ConfigContext;
var EMPTY_OBJECT = {};
/**
* Get ConfigProvider configured component props.
* This help to reduce bundle size for saving `?.` operator.
* Do not use as `useMemo` deps since we do not cache the object here.
*
* NOTE: not refactor this with `useMemo` since memo will cost another memory space,
* which will waste both compare calculation & memory.
*/
function useComponentConfig(propName) {
	const context = import_react.useContext(ConfigContext);
	const { getPrefixCls, direction, getPopupContainer, renderEmpty } = context;
	return {
		classNames: EMPTY_OBJECT,
		styles: EMPTY_OBJECT,
		...context[propName],
		getPrefixCls,
		direction,
		getPopupContainer,
		renderEmpty
	};
}

//#endregion
//#region node_modules/@emotion/hash/dist/hash.browser.esm.js
function murmur2(str) {
	var h = 0;
	var k, i = 0, len = str.length;
	for (; len >= 4; ++i, len -= 4) {
		k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
		k = (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
		k ^= k >>> 24;
		h = (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
	}
	switch (len) {
		case 3: h ^= (str.charCodeAt(i + 2) & 255) << 16;
		case 2: h ^= (str.charCodeAt(i + 1) & 255) << 8;
		case 1:
			h ^= str.charCodeAt(i) & 255;
			h = (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
	}
	h ^= h >>> 13;
	h = (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
	return ((h ^ h >>> 15) >>> 0).toString(36);
}
var hash_browser_esm_default = murmur2;

//#endregion
//#region node_modules/@rc-component/util/es/isEqual.js
/**
* Deeply compares two object literals.
* @param obj1 object 1
* @param obj2 object 2
* @param shallow shallow compare
* @returns
*/
function isEqual(obj1, obj2, shallow = false) {
	const refSet = /* @__PURE__ */ new Set();
	function deepEqual(a, b, level = 1) {
		const circular = refSet.has(a);
		warning_default$1(!circular, "Warning: There may be circular references");
		if (circular) return false;
		if (a === b) return true;
		if (shallow && level > 1) return false;
		refSet.add(a);
		const newLevel = level + 1;
		if (Array.isArray(a)) {
			if (!Array.isArray(b) || a.length !== b.length) return false;
			for (let i = 0; i < a.length; i++) if (!deepEqual(a[i], b[i], newLevel)) return false;
			return true;
		}
		if (a && b && typeof a === "object" && typeof b === "object") {
			const keys$1 = Object.keys(a);
			if (keys$1.length !== Object.keys(b).length) return false;
			return keys$1.every((key) => deepEqual(a[key], b[key], newLevel));
		}
		return false;
	}
	return deepEqual(obj1, obj2);
}
var isEqual_default = isEqual;

//#endregion
//#region node_modules/@ant-design/cssinjs/es/Cache.js
var SPLIT$1 = "%";
/** Connect key with `SPLIT` */
function pathKey(keys$1) {
	return keys$1.join(SPLIT$1);
}
/** Record update id for extract static style order. */
var updateId = 0;
var Entity = class {
	instanceId;
	constructor(instanceId) {
		this.instanceId = instanceId;
	}
	/** @private Internal cache map. Do not access this directly */
	cache = /* @__PURE__ */ new Map();
	/** @private Record update times for each key */
	updateTimes = /* @__PURE__ */ new Map();
	extracted = /* @__PURE__ */ new Set();
	get(keys$1) {
		return this.opGet(pathKey(keys$1));
	}
	/** A fast get cache with `get` concat. */
	opGet(keyPathStr) {
		return this.cache.get(keyPathStr) || null;
	}
	update(keys$1, valueFn) {
		return this.opUpdate(pathKey(keys$1), valueFn);
	}
	/** A fast get cache with `get` concat. */
	opUpdate(keyPathStr, valueFn) {
		const nextValue = valueFn(this.cache.get(keyPathStr));
		if (nextValue === null) {
			this.cache.delete(keyPathStr);
			this.updateTimes.delete(keyPathStr);
		} else {
			this.cache.set(keyPathStr, nextValue);
			this.updateTimes.set(keyPathStr, updateId);
			updateId += 1;
		}
	}
};
var Cache_default = Entity;

//#endregion
//#region node_modules/@ant-design/cssinjs/es/StyleContext.js
const ATTR_TOKEN = "data-token-hash";
const ATTR_MARK = "data-css-hash";
const ATTR_CACHE_PATH = "data-cache-path";
const CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
function createCache() {
	const cssinjsInstanceId = Math.random().toString(12).slice(2);
	if (typeof document !== "undefined" && document.head && document.body) {
		const styles = document.body.querySelectorAll(`style[${ATTR_MARK}]`) || [];
		const { firstChild } = document.head;
		Array.from(styles).forEach((style$1) => {
			style$1[CSS_IN_JS_INSTANCE] ||= cssinjsInstanceId;
			if (style$1[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) document.head.insertBefore(style$1, firstChild);
		});
		const styleHash = {};
		Array.from(document.querySelectorAll(`style[${ATTR_MARK}]`)).forEach((style$1) => {
			const hash$1 = style$1.getAttribute(ATTR_MARK);
			if (styleHash[hash$1]) {
				if (style$1[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) style$1.parentNode?.removeChild(style$1);
			} else styleHash[hash$1] = true;
		});
	}
	return new Cache_default(cssinjsInstanceId);
}
var StyleContext = /* @__PURE__ */ import_react.createContext({
	hashPriority: "low",
	cache: createCache(),
	defaultCache: true,
	autoPrefix: false
});
var StyleContext_default = StyleContext;

//#endregion
//#region node_modules/@ant-design/cssinjs/es/theme/calc/CSSCalculator.js
var CALC_UNIT$1 = "CALC_UNIT";
var regexp$2 = new RegExp(CALC_UNIT$1, "g");

//#endregion
//#region node_modules/@ant-design/cssinjs/es/theme/ThemeCache.js
function sameDerivativeOption(left, right) {
	if (left.length !== right.length) return false;
	for (let i = 0; i < left.length; i++) if (left[i] !== right[i]) return false;
	return true;
}
var ThemeCache = class ThemeCache {
	static MAX_CACHE_SIZE = 20;
	static MAX_CACHE_OFFSET = 5;
	cache;
	keys;
	cacheCallTimes;
	constructor() {
		this.cache = /* @__PURE__ */ new Map();
		this.keys = [];
		this.cacheCallTimes = 0;
	}
	size() {
		return this.keys.length;
	}
	internalGet(derivativeOption, updateCallTimes = false) {
		let cache = { map: this.cache };
		derivativeOption.forEach((derivative$3) => {
			if (!cache) cache = void 0;
			else cache = cache?.map?.get(derivative$3);
		});
		if (cache?.value && updateCallTimes) cache.value[1] = this.cacheCallTimes++;
		return cache?.value;
	}
	get(derivativeOption) {
		return this.internalGet(derivativeOption, true)?.[0];
	}
	has(derivativeOption) {
		return !!this.internalGet(derivativeOption);
	}
	set(derivativeOption, value) {
		if (!this.has(derivativeOption)) {
			if (this.size() + 1 > ThemeCache.MAX_CACHE_SIZE + ThemeCache.MAX_CACHE_OFFSET) {
				const [targetKey] = this.keys.reduce((result, key) => {
					const [, callTimes] = result;
					if (this.internalGet(key)[1] < callTimes) return [key, this.internalGet(key)[1]];
					return result;
				}, [this.keys[0], this.cacheCallTimes]);
				this.delete(targetKey);
			}
			this.keys.push(derivativeOption);
		}
		let cache = this.cache;
		derivativeOption.forEach((derivative$3, index$1) => {
			if (index$1 === derivativeOption.length - 1) cache.set(derivative$3, { value: [value, this.cacheCallTimes++] });
			else {
				const cacheValue = cache.get(derivative$3);
				if (!cacheValue) cache.set(derivative$3, { map: /* @__PURE__ */ new Map() });
				else if (!cacheValue.map) cacheValue.map = /* @__PURE__ */ new Map();
				cache = cache.get(derivative$3).map;
			}
		});
	}
	deleteByPath(currentCache, derivatives) {
		const cache = currentCache.get(derivatives[0]);
		if (derivatives.length === 1) {
			if (!cache.map) currentCache.delete(derivatives[0]);
			else currentCache.set(derivatives[0], { map: cache.map });
			return cache.value?.[0];
		}
		const result = this.deleteByPath(cache.map, derivatives.slice(1));
		if ((!cache.map || cache.map.size === 0) && !cache.value) currentCache.delete(derivatives[0]);
		return result;
	}
	delete(derivativeOption) {
		if (this.has(derivativeOption)) {
			this.keys = this.keys.filter((item) => !sameDerivativeOption(item, derivativeOption));
			return this.deleteByPath(this.cache, derivativeOption);
		}
	}
};

//#endregion
//#region node_modules/@ant-design/cssinjs/es/theme/Theme.js
var uuid$4 = 0;
/**
* Theme with algorithms to derive tokens from design tokens.
* Use `createTheme` first which will help to manage the theme instance cache.
*/
var Theme = class {
	derivatives;
	id;
	constructor(derivatives) {
		this.derivatives = Array.isArray(derivatives) ? derivatives : [derivatives];
		this.id = uuid$4;
		if (derivatives.length === 0) warning(derivatives.length > 0, "[Ant Design CSS-in-JS] Theme should have at least one derivative function.");
		uuid$4 += 1;
	}
	getDerivativeToken(token$1) {
		return this.derivatives.reduce((result, derivative$3) => derivative$3(token$1, result), void 0);
	}
};

//#endregion
//#region node_modules/@ant-design/cssinjs/es/theme/createTheme.js
var cacheThemes = new ThemeCache();
/**
* Same as new Theme, but will always return same one if `derivative` not changed.
*/
function createTheme(derivatives) {
	const derivativeArr = Array.isArray(derivatives) ? derivatives : [derivatives];
	if (!cacheThemes.has(derivativeArr)) cacheThemes.set(derivativeArr, new Theme(derivativeArr));
	return cacheThemes.get(derivativeArr);
}

//#endregion
//#region node_modules/@ant-design/cssinjs/es/util/index.js
var resultCache = /* @__PURE__ */ new WeakMap();
var RESULT_VALUE = {};
function memoResult(callback, deps) {
	let current = resultCache;
	for (let i = 0; i < deps.length; i += 1) {
		const dep = deps[i];
		if (!current.has(dep)) current.set(dep, /* @__PURE__ */ new WeakMap());
		current = current.get(dep);
	}
	if (!current.has(RESULT_VALUE)) current.set(RESULT_VALUE, callback());
	return current.get(RESULT_VALUE);
}
var flattenTokenCache = /* @__PURE__ */ new WeakMap();
/**
* Flatten token to string, this will auto cache the result when token not change
*/
function flattenToken(token$1) {
	let str = flattenTokenCache.get(token$1) || "";
	if (!str) {
		Object.keys(token$1).forEach((key) => {
			const value = token$1[key];
			str += key;
			if (value instanceof Theme) str += value.id;
			else if (value && typeof value === "object") str += flattenToken(value);
			else str += value;
		});
		str = hash_browser_esm_default(str);
		flattenTokenCache.set(token$1, str);
	}
	return str;
}
/**
* Convert derivative token to key string
*/
function token2key(token$1, salt) {
	return hash_browser_esm_default(`${salt}_${flattenToken(token$1)}`);
}
var randomSelectorKey = `random-${Date.now()}-${Math.random()}`.replace(/\./g, "");
const isClientSide = canUseDom();
function unit(num) {
	if (typeof num === "number") return `${num}px`;
	return num;
}
function toStyleStr(style$1, tokenKey, styleId, customizeAttrs = {}, plain = false) {
	if (plain) return style$1;
	const attrs = {
		...customizeAttrs,
		[ATTR_TOKEN]: tokenKey,
		[ATTR_MARK]: styleId
	};
	return `<style ${Object.keys(attrs).map((attr) => {
		const val = attrs[attr];
		return val ? `${attr}="${val}"` : null;
	}).filter((v) => v).join(" ")}>${style$1}</style>`;
}
function where(options) {
	const { hashCls, hashPriority = "low" } = options || {};
	if (!hashCls) return "";
	const hashSelector = `.${hashCls}`;
	return hashPriority === "low" ? `:where(${hashSelector})` : hashSelector;
}

//#endregion
//#region node_modules/@ant-design/cssinjs/es/util/css-variables.js
const token2CSSVar = (token$1, prefix$1 = "") => {
	return `--${prefix$1 ? `${prefix$1}-` : ""}${token$1}`.replace(/([a-z0-9])([A-Z])/g, "$1-$2").replace(/([A-Z]+)([A-Z][a-z0-9]+)/g, "$1-$2").replace(/([a-z])([A-Z0-9])/g, "$1-$2").toLowerCase();
};
const serializeCSSVar = (cssVars, hashId, options) => {
	const { hashCls, hashPriority = "low" } = options || {};
	if (!Object.keys(cssVars).length) return "";
	return `${where({
		hashCls,
		hashPriority
	})}.${hashId}${options?.scope ? `.${options.scope}` : ""}{${Object.entries(cssVars).map(([key, value]) => `${key}:${value};`).join("")}}`;
};
const transformToken = (token$1, themeKey, config) => {
	const { hashCls, hashPriority = "low", prefix: prefix$1, unitless: unitless$1, ignore: ignore$1, preserve: preserve$1 } = config || {};
	const cssVars = {};
	const result = {};
	Object.entries(token$1).forEach(([key, value]) => {
		if (preserve$1?.[key]) result[key] = value;
		else if ((typeof value === "string" || typeof value === "number") && !ignore$1?.[key]) {
			const cssVar = token2CSSVar(key, prefix$1);
			cssVars[cssVar] = typeof value === "number" && !unitless$1?.[key] ? `${value}px` : String(value);
			result[key] = `var(${cssVar})`;
		}
	});
	return [result, serializeCSSVar(cssVars, themeKey, {
		scope: config?.scope,
		hashCls,
		hashPriority
	})];
};

//#endregion
//#region node_modules/@ant-design/cssinjs/es/hooks/useHMR.js
var webpackHMR = false;
function useDevHMR() {
	return webpackHMR;
}
var useHMR_default = useDevHMR;
if (typeof module !== "undefined" && module && module.hot && typeof window !== "undefined") {
	const win = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : null;
	if (win && typeof win.webpackHotUpdate === "function") {
		const originWebpackHotUpdate = win.webpackHotUpdate;
		win.webpackHotUpdate = (...args) => {
			webpackHMR = true;
			setTimeout(() => {
				webpackHMR = false;
			}, 0);
			return originWebpackHotUpdate(...args);
		};
	}
}

//#endregion
//#region node_modules/@ant-design/cssinjs/es/hooks/useGlobalCache.js
var effectMap = /* @__PURE__ */ new Map();
function useGlobalCache(prefix$1, keyPath, cacheFn, onCacheRemove, onCacheEffect) {
	const { cache: globalCache } = import_react.useContext(StyleContext_default);
	const fullPathStr = pathKey([prefix$1, ...keyPath]);
	const HMRUpdate = useHMR_default();
	const buildCache = (updater) => {
		globalCache.opUpdate(fullPathStr, (prevCache) => {
			const [times = 0, cache] = prevCache || [void 0, void 0];
			let tmpCache = cache;
			if (cache && HMRUpdate) {
				onCacheRemove?.(tmpCache, HMRUpdate);
				tmpCache = null;
			}
			const data = [times, tmpCache || cacheFn()];
			return updater ? updater(data) : data;
		});
	};
	import_react.useMemo(() => {
		buildCache();
	}, [fullPathStr]);
	let cacheEntity = globalCache.opGet(fullPathStr);
	if (!cacheEntity) {
		buildCache();
		cacheEntity = globalCache.opGet(fullPathStr);
	}
	const cacheContent = cacheEntity[1];
	(0, import_react.useInsertionEffect)(() => {
		buildCache(([times, cache]) => [times + 1, cache]);
		if (!effectMap.has(fullPathStr)) {
			onCacheEffect?.(cacheContent);
			effectMap.set(fullPathStr, true);
			Promise.resolve().then(() => {
				effectMap.delete(fullPathStr);
			});
		}
		return () => {
			globalCache.opUpdate(fullPathStr, (prevCache) => {
				const [times = 0, cache] = prevCache || [];
				if (times - 1 === 0) {
					onCacheRemove?.(cache, false);
					effectMap.delete(fullPathStr);
					return null;
				}
				return [times - 1, cache];
			});
		};
	}, [fullPathStr]);
	return cacheContent;
}

//#endregion
//#region node_modules/@ant-design/cssinjs/es/hooks/useCacheToken.js
var EMPTY_OVERRIDE = {};
var hashPrefix = "css-dev-only-do-not-override";
var tokenKeys = /* @__PURE__ */ new Map();
function recordCleanToken(tokenKey) {
	tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
}
function removeStyleTags(key, instanceId) {
	if (typeof document !== "undefined") document.querySelectorAll(`style[${ATTR_TOKEN}="${key}"]`).forEach((style$1) => {
		if (style$1[CSS_IN_JS_INSTANCE] === instanceId) style$1.parentNode?.removeChild(style$1);
	});
}
var TOKEN_THRESHOLD = -1;
function cleanTokenStyle(tokenKey, instanceId) {
	tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
	const cleanableKeyList = /* @__PURE__ */ new Set();
	tokenKeys.forEach((value, key) => {
		if (value <= 0) cleanableKeyList.add(key);
	});
	if (tokenKeys.size - cleanableKeyList.size > TOKEN_THRESHOLD) cleanableKeyList.forEach((key) => {
		removeStyleTags(key, instanceId);
		tokenKeys.delete(key);
	});
}
const getComputedToken = (originToken, overrideToken, theme, format$1) => {
	let mergedDerivativeToken = {
		...theme.getDerivativeToken(originToken),
		...overrideToken
	};
	if (format$1) mergedDerivativeToken = format$1(mergedDerivativeToken);
	return mergedDerivativeToken;
};
const TOKEN_PREFIX = "token";
/**
* Cache theme derivative token as global shared one
* @param theme Theme entity
* @param tokens List of tokens, used for cache. Please do not dynamic generate object directly
* @param option Additional config
* @returns Call Theme.getDerivativeToken(tokenObject) to get token
*/
function useCacheToken(theme, tokens, option) {
	const { cache: { instanceId }, container, hashPriority } = (0, import_react.useContext)(StyleContext_default);
	const { salt = "", override = EMPTY_OVERRIDE, formatToken: formatToken$1, getComputedToken: compute, cssVar } = option;
	const mergedToken = memoResult(() => Object.assign({}, ...tokens), tokens);
	const tokenStr = flattenToken(mergedToken);
	const overrideTokenStr = flattenToken(override);
	const cssVarStr = flattenToken(cssVar);
	return useGlobalCache(TOKEN_PREFIX, [
		salt,
		theme.id,
		tokenStr,
		overrideTokenStr,
		cssVarStr
	], () => {
		const mergedDerivativeToken = compute ? compute(mergedToken, override, theme) : getComputedToken(mergedToken, override, theme, formatToken$1);
		const actualToken = { ...mergedDerivativeToken };
		const mergedSalt = `${salt}_${cssVar.prefix}`;
		const hashId = hash_browser_esm_default(mergedSalt);
		const hashCls = `${hashPrefix}-${hashId}`;
		actualToken._tokenKey = token2key(actualToken, mergedSalt);
		const [tokenWithCssVar, cssVarsStr] = transformToken(mergedDerivativeToken, cssVar.key, {
			prefix: cssVar.prefix,
			ignore: cssVar.ignore,
			unitless: cssVar.unitless,
			preserve: cssVar.preserve,
			hashPriority,
			hashCls: cssVar.hashed ? hashCls : void 0
		});
		tokenWithCssVar._hashId = hashId;
		recordCleanToken(cssVar.key);
		return [
			tokenWithCssVar,
			hashCls,
			actualToken,
			cssVarsStr,
			cssVar.key
		];
	}, ([, , , , themeKey]) => {
		cleanTokenStyle(themeKey, instanceId);
	}, ([, , , cssVarsStr, themeKey]) => {
		if (!cssVarsStr) return;
		const style$1 = updateCSS(cssVarsStr, hash_browser_esm_default(`css-var-${themeKey}`), {
			mark: ATTR_MARK,
			prepend: "queue",
			attachTo: container,
			priority: -999
		});
		style$1[CSS_IN_JS_INSTANCE] = instanceId;
		style$1.setAttribute(ATTR_TOKEN, themeKey);
	});
}
const extract = (cache, effectStyles, options) => {
	const [, , realToken, styleStr, cssVarKey] = cache;
	const { plain } = options || {};
	if (!styleStr) return null;
	const styleId = realToken._tokenKey;
	const order = -999;
	return [
		order,
		styleId,
		toStyleStr(styleStr, cssVarKey, styleId, {
			"data-rc-order": "prependQueue",
			"data-rc-priority": `${order}`
		}, plain)
	];
};

//#endregion
//#region node_modules/@emotion/unitless/dist/unitless.browser.esm.js
var unitlessKeys = {
	animationIterationCount: 1,
	borderImageOutset: 1,
	borderImageSlice: 1,
	borderImageWidth: 1,
	boxFlex: 1,
	boxFlexGroup: 1,
	boxOrdinalGroup: 1,
	columnCount: 1,
	columns: 1,
	flex: 1,
	flexGrow: 1,
	flexPositive: 1,
	flexShrink: 1,
	flexNegative: 1,
	flexOrder: 1,
	gridRow: 1,
	gridRowEnd: 1,
	gridRowSpan: 1,
	gridRowStart: 1,
	gridColumn: 1,
	gridColumnEnd: 1,
	gridColumnSpan: 1,
	gridColumnStart: 1,
	msGridRow: 1,
	msGridRowSpan: 1,
	msGridColumn: 1,
	msGridColumnSpan: 1,
	fontWeight: 1,
	lineHeight: 1,
	opacity: 1,
	order: 1,
	orphans: 1,
	tabSize: 1,
	widows: 1,
	zIndex: 1,
	zoom: 1,
	WebkitLineClamp: 1,
	fillOpacity: 1,
	floodOpacity: 1,
	stopOpacity: 1,
	strokeDasharray: 1,
	strokeDashoffset: 1,
	strokeMiterlimit: 1,
	strokeOpacity: 1,
	strokeWidth: 1
};
var unitless_browser_esm_default = unitlessKeys;

//#endregion
//#region node_modules/stylis/src/Enum.js
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var NAMESPACE = "@namespace";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";

//#endregion
//#region node_modules/stylis/src/Utility.js
/**
* @param {number}
* @return {number}
*/
var abs = Math.abs;
/**
* @param {number}
* @return {string}
*/
var from = String.fromCharCode;
/**
* @param {object}
* @return {object}
*/
var assign = Object.assign;
/**
* @param {string} value
* @param {number} length
* @return {number}
*/
function hash(value, length$1) {
	return charat(value, 0) ^ 45 ? (((length$1 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
/**
* @param {string} value
* @return {string}
*/
function trim(value) {
	return value.trim();
}
/**
* @param {string} value
* @param {RegExp} pattern
* @return {string?}
*/
function match$1(value, pattern$3) {
	return (value = pattern$3.exec(value)) ? value[0] : value;
}
/**
* @param {string} value
* @param {(string|RegExp)} pattern
* @param {string} replacement
* @return {string}
*/
function replace(value, pattern$3, replacement) {
	return value.replace(pattern$3, replacement);
}
/**
* @param {string} value
* @param {string} search
* @param {number} position
* @return {number}
*/
function indexof(value, search, position$2) {
	return value.indexOf(search, position$2);
}
/**
* @param {string} value
* @param {number} index
* @return {number}
*/
function charat(value, index$1) {
	return value.charCodeAt(index$1) | 0;
}
/**
* @param {string} value
* @param {number} begin
* @param {number} end
* @return {string}
*/
function substr(value, begin, end) {
	return value.slice(begin, end);
}
/**
* @param {string} value
* @return {number}
*/
function strlen(value) {
	return value.length;
}
/**
* @param {any[]} value
* @return {number}
*/
function sizeof(value) {
	return value.length;
}
/**
* @param {any} value
* @param {any[]} array
* @return {any}
*/
function append(value, array$1) {
	return array$1.push(value), value;
}
/**
* @param {string[]} array
* @param {function} callback
* @return {string}
*/
function combine(array$1, callback) {
	return array$1.map(callback).join("");
}
/**
* @param {string[]} array
* @param {RegExp} pattern
* @return {string[]}
*/
function filter$1(array$1, pattern$3) {
	return array$1.filter(function(value) {
		return !match$1(value, pattern$3);
	});
}

//#endregion
//#region node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position$1 = 0;
var character = 0;
var characters = "";
/**
* @param {string} value
* @param {object | null} root
* @param {object | null} parent
* @param {string} type
* @param {string[] | string} props
* @param {object[] | string} children
* @param {object[]} siblings
* @param {number} length
*/
function node(value, root, parent, type$2, props, children, length$1, siblings) {
	return {
		value,
		root,
		parent,
		type: type$2,
		props,
		children,
		line,
		column,
		length: length$1,
		return: "",
		siblings
	};
}
/**
* @param {object} root
* @param {object} props
* @return {object}
*/
function copy$1(root, props) {
	return assign(node("", null, null, "", null, null, 0, root.siblings), root, { length: -root.length }, props);
}
/**
* @param {object} root
*/
function lift(root) {
	while (root.root) root = copy$1(root.root, { children: [root] });
	append(root, root.siblings);
}
/**
* @return {number}
*/
function char() {
	return character;
}
/**
* @return {number}
*/
function prev() {
	character = position$1 > 0 ? charat(characters, --position$1) : 0;
	if (column--, character === 10) column = 1, line--;
	return character;
}
/**
* @return {number}
*/
function next() {
	character = position$1 < length ? charat(characters, position$1++) : 0;
	if (column++, character === 10) column = 1, line++;
	return character;
}
/**
* @return {number}
*/
function peek() {
	return charat(characters, position$1);
}
/**
* @return {number}
*/
function caret() {
	return position$1;
}
/**
* @param {number} begin
* @param {number} end
* @return {string}
*/
function slice(begin, end) {
	return substr(characters, begin, end);
}
/**
* @param {number} type
* @return {number}
*/
function token(type$2) {
	switch (type$2) {
		case 0:
		case 9:
		case 10:
		case 13:
		case 32: return 5;
		case 33:
		case 43:
		case 44:
		case 47:
		case 62:
		case 64:
		case 126:
		case 59:
		case 123:
		case 125: return 4;
		case 58: return 3;
		case 34:
		case 39:
		case 40:
		case 91: return 2;
		case 41:
		case 93: return 1;
	}
	return 0;
}
/**
* @param {string} value
* @return {any[]}
*/
function alloc(value) {
	return line = column = 1, length = strlen(characters = value), position$1 = 0, [];
}
/**
* @param {any} value
* @return {any}
*/
function dealloc(value) {
	return characters = "", value;
}
/**
* @param {number} type
* @return {string}
*/
function delimit(type$2) {
	return trim(slice(position$1 - 1, delimiter(type$2 === 91 ? type$2 + 2 : type$2 === 40 ? type$2 + 1 : type$2)));
}
/**
* @param {number} type
* @return {string}
*/
function whitespace$1(type$2) {
	while (character = peek()) if (character < 33) next();
	else break;
	return token(type$2) > 2 || token(character) > 3 ? "" : " ";
}
/**
* @param {number} index
* @param {number} count
* @return {string}
*/
function escaping(index$1, count) {
	while (--count && next()) if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97) break;
	return slice(index$1, caret() + (count < 6 && peek() == 32 && next() == 32));
}
/**
* @param {number} type
* @return {number}
*/
function delimiter(type$2) {
	while (next()) switch (character) {
		case type$2: return position$1;
		case 34:
		case 39:
			if (type$2 !== 34 && type$2 !== 39) delimiter(character);
			break;
		case 40:
			if (type$2 === 41) delimiter(type$2);
			break;
		case 92:
			next();
			break;
	}
	return position$1;
}
/**
* @param {number} type
* @param {number} index
* @return {number}
*/
function commenter(type$2, index$1) {
	while (next()) if (type$2 + character === 57) break;
	else if (type$2 + character === 84 && peek() === 47) break;
	return "/*" + slice(index$1, position$1 - 1) + "*" + from(type$2 === 47 ? type$2 : next());
}
/**
* @param {number} index
* @return {string}
*/
function identifier(index$1) {
	while (!token(peek())) next();
	return slice(index$1, position$1);
}

//#endregion
//#region node_modules/stylis/src/Parser.js
/**
* @param {string} value
* @return {object[]}
*/
function compile(value) {
	return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
/**
* @param {string} value
* @param {object} root
* @param {object?} parent
* @param {string[]} rule
* @param {string[]} rules
* @param {string[]} rulesets
* @param {number[]} pseudo
* @param {number[]} points
* @param {string[]} declarations
* @return {object}
*/
function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
	var index$1 = 0;
	var offset$2 = 0;
	var length$1 = pseudo;
	var atrule = 0;
	var property = 0;
	var previous = 0;
	var variable = 1;
	var scanning = 1;
	var ampersand = 1;
	var character$1 = 0;
	var type$2 = "";
	var props = rules;
	var children = rulesets;
	var reference = rule;
	var characters$1 = type$2;
	while (scanning) switch (previous = character$1, character$1 = next()) {
		case 40: if (previous != 108 && charat(characters$1, length$1 - 1) == 58) {
			if (indexof(characters$1 += replace(delimit(character$1), "&", "&\f"), "&\f", abs(index$1 ? points[index$1 - 1] : 0)) != -1) ampersand = -1;
			break;
		}
		case 34:
		case 39:
		case 91:
			characters$1 += delimit(character$1);
			break;
		case 9:
		case 10:
		case 13:
		case 32:
			characters$1 += whitespace$1(previous);
			break;
		case 92:
			characters$1 += escaping(caret() - 1, 7);
			continue;
		case 47:
			switch (peek()) {
				case 42:
				case 47:
					append(comment(commenter(next(), caret()), root, parent, declarations), declarations);
					if ((token(previous || 1) == 5 || token(peek() || 1) == 5) && strlen(characters$1) && substr(characters$1, -1, void 0) !== " ") characters$1 += " ";
					break;
				default: characters$1 += "/";
			}
			break;
		case 123 * variable: points[index$1++] = strlen(characters$1) * ampersand;
		case 125 * variable:
		case 59:
		case 0:
			switch (character$1) {
				case 0:
				case 125: scanning = 0;
				case 59 + offset$2:
					if (ampersand == -1) characters$1 = replace(characters$1, /\f/g, "");
					if (property > 0 && (strlen(characters$1) - length$1 || variable === 0 && previous === 47)) append(property > 32 ? declaration(characters$1 + ";", rule, parent, length$1 - 1, declarations) : declaration(replace(characters$1, " ", "") + ";", rule, parent, length$1 - 2, declarations), declarations);
					break;
				case 59: characters$1 += ";";
				default:
					append(reference = ruleset(characters$1, root, parent, index$1, offset$2, rules, points, type$2, props = [], children = [], length$1, rulesets), rulesets);
					if (character$1 === 123) if (offset$2 === 0) parse(characters$1, root, reference, reference, props, rulesets, length$1, points, children);
					else {
						switch (atrule) {
							case 99: if (charat(characters$1, 3) === 110) break;
							case 108: if (charat(characters$1, 2) === 97) break;
							default: offset$2 = 0;
							case 100:
							case 109:
							case 115:
						}
						if (offset$2) parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type$2, rules, props = [], length$1, children), children), rules, children, length$1, points, rule ? props : children);
						else parse(characters$1, reference, reference, reference, [""], children, 0, points, children);
					}
			}
			index$1 = offset$2 = property = 0, variable = ampersand = 1, type$2 = characters$1 = "", length$1 = pseudo;
			break;
		case 58: length$1 = 1 + strlen(characters$1), property = previous;
		default:
			if (variable < 1) {
				if (character$1 == 123) --variable;
				else if (character$1 == 125 && variable++ == 0 && prev() == 125) continue;
			}
			switch (characters$1 += from(character$1), character$1 * variable) {
				case 38:
					ampersand = offset$2 > 0 ? 1 : (characters$1 += "\f", -1);
					break;
				case 44:
					points[index$1++] = (strlen(characters$1) - 1) * ampersand, ampersand = 1;
					break;
				case 64:
					if (peek() === 45) characters$1 += delimit(next());
					atrule = peek(), offset$2 = length$1 = strlen(type$2 = characters$1 += identifier(caret())), character$1++;
					break;
				case 45: if (previous === 45 && strlen(characters$1) == 2) variable = 0;
			}
	}
	return rulesets;
}
/**
* @param {string} value
* @param {object} root
* @param {object?} parent
* @param {number} index
* @param {number} offset
* @param {string[]} rules
* @param {number[]} points
* @param {string} type
* @param {string[]} props
* @param {string[]} children
* @param {number} length
* @param {object[]} siblings
* @return {object}
*/
function ruleset(value, root, parent, index$1, offset$2, rules, points, type$2, props, children, length$1, siblings) {
	var post = offset$2 - 1;
	var rule = offset$2 === 0 ? rules : [""];
	var size = sizeof(rule);
	for (var i = 0, j = 0, k = 0; i < index$1; ++i) for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x) if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x]))) props[k++] = z;
	return node(value, root, parent, offset$2 === 0 ? RULESET : type$2, props, children, length$1, siblings);
}
/**
* @param {number} value
* @param {object} root
* @param {object?} parent
* @param {object[]} siblings
* @return {object}
*/
function comment(value, root, parent, siblings) {
	return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
}
/**
* @param {string} value
* @param {object} root
* @param {object?} parent
* @param {number} length
* @param {object[]} siblings
* @return {object}
*/
function declaration(value, root, parent, length$1, siblings) {
	return node(value, root, parent, DECLARATION, substr(value, 0, length$1), substr(value, length$1 + 1, -1), length$1, siblings);
}

//#endregion
//#region node_modules/stylis/src/Prefixer.js
/**
* @param {string} value
* @param {number} length
* @param {object[]} children
* @return {string}
*/
function prefix(value, length$1, children) {
	switch (hash(value, length$1)) {
		case 5103: return WEBKIT + "print-" + value + value;
		case 5737:
		case 4201:
		case 3177:
		case 3433:
		case 1641:
		case 4457:
		case 2921:
		case 5572:
		case 6356:
		case 5844:
		case 3191:
		case 6645:
		case 3005:
		case 4215:
		case 6389:
		case 5109:
		case 5365:
		case 5621:
		case 3829:
		case 6391:
		case 5879:
		case 5623:
		case 6135:
		case 4599: return WEBKIT + value + value;
		case 4855: return WEBKIT + value.replace("add", "source-over").replace("substract", "source-out").replace("intersect", "source-in").replace("exclude", "xor") + value;
		case 4789: return MOZ + value + value;
		case 5349:
		case 4246:
		case 4810:
		case 6968:
		case 2756: return WEBKIT + value + MOZ + value + MS + value + value;
		case 5936: switch (charat(value, length$1 + 11)) {
			case 114: return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
			case 108: return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
			case 45: return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
		}
		case 6828:
		case 4268:
		case 2903: return WEBKIT + value + MS + value + value;
		case 6165: return WEBKIT + value + MS + "flex-" + value + value;
		case 5187: return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
		case 5443: return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/g, "") + (!match$1(value, /flex-|baseline/) ? MS + "grid-row-" + replace(value, /flex-|-self/g, "") : "") + value;
		case 4675: return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/g, "") + value;
		case 5548: return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
		case 5292: return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
		case 6060: return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
		case 4554: return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
		case 6187: return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
		case 5495:
		case 3959: return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
		case 4968: return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /space-between/, "justify") + WEBKIT + value + value;
		case 4200:
			if (!match$1(value, /flex-|baseline/)) return MS + "grid-column-align" + substr(value, length$1) + value;
			break;
		case 2592:
		case 3360: return MS + replace(value, "template-", "") + value;
		case 4384:
		case 3616:
			if (children && children.some(function(element, index$1) {
				return length$1 = index$1, match$1(element.props, /grid-\w+-end/);
			})) return ~indexof(value + (children = children[length$1].value), "span", 0) ? value : MS + replace(value, "-start", "") + value + MS + "grid-row-span:" + (~indexof(children, "span", 0) ? match$1(children, /\d+/) : +match$1(children, /\d+/) - +match$1(value, /\d+/)) + ";";
			return MS + replace(value, "-start", "") + value;
		case 4896:
		case 4128: return children && children.some(function(element) {
			return match$1(element.props, /grid-\w+-start/);
		}) ? value : MS + replace(replace(value, "-end", "-span"), "span ", "") + value;
		case 4095:
		case 3583:
		case 4068:
		case 2532: return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
		case 8116:
		case 7059:
		case 5753:
		case 5535:
		case 5445:
		case 5701:
		case 4933:
		case 4677:
		case 5533:
		case 5789:
		case 5021:
		case 4765:
			if (strlen(value) - 1 - length$1 > 6) switch (charat(value, length$1 + 1)) {
				case 109: if (charat(value, length$1 + 4) !== 45) break;
				case 102: return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length$1 + 3) == 108 ? "$3" : "$2-$3")) + value;
				case 115: return ~indexof(value, "stretch", 0) ? prefix(replace(value, "stretch", "fill-available"), length$1, children) + value : value;
			}
			break;
		case 5152:
		case 5920: return replace(value, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(_, a, b, c, d, e$2, f) {
			return MS + a + ":" + b + f + (c ? MS + a + "-span:" + (d ? e$2 : +e$2 - +b) + f : "") + value;
		});
		case 4949:
			if (charat(value, length$1 + 6) === 121) return replace(value, ":", ":" + WEBKIT) + value;
			break;
		case 6444:
			switch (charat(value, charat(value, 14) === 45 ? 18 : 11)) {
				case 120: return replace(value, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
				case 100: return replace(value, ":", ":" + MS) + value;
			}
			break;
		case 5719:
		case 2647:
		case 2135:
		case 3927:
		case 2391: return replace(value, "scroll-", "scroll-snap-") + value;
	}
	return value;
}

//#endregion
//#region node_modules/stylis/src/Serializer.js
/**
* @param {object[]} children
* @param {function} callback
* @return {string}
*/
function serialize(children, callback) {
	var output = "";
	for (var i = 0; i < children.length; i++) output += callback(children[i], i, children, callback) || "";
	return output;
}
/**
* @param {object} element
* @param {number} index
* @param {object[]} children
* @param {function} callback
* @return {string}
*/
function stringify$2(element, index$1, children, callback) {
	switch (element.type) {
		case LAYER: if (element.children.length) break;
		case IMPORT:
		case NAMESPACE:
		case DECLARATION: return element.return = element.return || element.value;
		case COMMENT: return "";
		case KEYFRAMES: return element.return = element.value + "{" + serialize(element.children, callback) + "}";
		case RULESET: if (!strlen(element.value = element.props.join(","))) return "";
	}
	return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}

//#endregion
//#region node_modules/stylis/src/Middleware.js
/**
* @param {function[]} collection
* @return {function}
*/
function middleware(collection) {
	var length$1 = sizeof(collection);
	return function(element, index$1, children, callback) {
		var output = "";
		for (var i = 0; i < length$1; i++) output += collection[i](element, index$1, children, callback) || "";
		return output;
	};
}
/**
* @param {object} element
* @param {number} index
* @param {object[]} children
* @param {function} callback
*/
function prefixer(element, index$1, children, callback) {
	if (element.length > -1) {
		if (!element.return) switch (element.type) {
			case DECLARATION:
				element.return = prefix(element.value, element.length, children);
				return;
			case KEYFRAMES: return serialize([copy$1(element, { value: replace(element.value, "@", "@" + WEBKIT) })], callback);
			case RULESET: if (element.length) return combine(children = element.props, function(value) {
				switch (match$1(value, callback = /(::plac\w+|:read-\w+)/)) {
					case ":read-only":
					case ":read-write":
						lift(copy$1(element, { props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")] }));
						lift(copy$1(element, { props: [value] }));
						assign(element, { props: filter$1(children, callback) });
						break;
					case "::placeholder":
						lift(copy$1(element, { props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")] }));
						lift(copy$1(element, { props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")] }));
						lift(copy$1(element, { props: [replace(value, /:(plac\w+)/, MS + "input-$1")] }));
						lift(copy$1(element, { props: [value] }));
						assign(element, { props: filter$1(children, callback) });
						break;
				}
				return "";
			});
		}
	}
}

//#endregion
//#region node_modules/@ant-design/cssinjs/es/linters/utils.js
function lintWarning(message$1, info) {
	const { path: path$1, parentSelectors } = info;
	warning_default$1(false, `[Ant Design CSS-in-JS] ${path$1 ? `Error in ${path$1}: ` : ""}${message$1}${parentSelectors.length ? ` Selector: ${parentSelectors.join(" | ")}` : ""}`);
}

//#endregion
//#region node_modules/@ant-design/cssinjs/es/linters/contentQuotesLinter.js
var linter$1 = (key, value, info) => {
	if (key === "content") {
		if (typeof value !== "string" || [
			"normal",
			"none",
			"initial",
			"inherit",
			"unset"
		].indexOf(value) === -1 && !/(attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/.test(value) && !value.startsWith("var(") && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== "\"" && value.charAt(0) !== "'")) lintWarning(`You seem to be using a value for 'content' without quotes, try replacing it with \`content: '"${value}"'\`.`, info);
	}
};
var contentQuotesLinter_default = linter$1;

//#endregion
//#region node_modules/@ant-design/cssinjs/es/linters/hashedAnimationLinter.js
var linter = (key, value, info) => {
	if (key === "animation") {
		if (info.hashId && value !== "none") lintWarning(`You seem to be using hashed animation '${value}', in which case 'animationName' with Keyframe as value is recommended.`, info);
	}
};
var hashedAnimationLinter_default = linter;

//#endregion
//#region node_modules/@ant-design/cssinjs/es/util/cacheMapUtil.js
const ATTR_CACHE_MAP = "data-ant-cssinjs-cache-path";
/**
* This marks style from the css file.
* Which means not exist in `<style />` tag.
*/
const CSS_FILE_STYLE = "_FILE_STYLE__";
var cachePathMap;
var fromCSSFile = true;
function prepare() {
	if (!cachePathMap) {
		cachePathMap = {};
		if (canUseDom()) {
			const div = document.createElement("div");
			div.className = ATTR_CACHE_MAP;
			div.style.position = "fixed";
			div.style.visibility = "hidden";
			div.style.top = "-9999px";
			document.body.appendChild(div);
			let content = getComputedStyle(div).content || "";
			content = content.replace(/^"/, "").replace(/"$/, "");
			content.split(";").forEach((item) => {
				const [path$1, hash$1] = item.split(":");
				cachePathMap[path$1] = hash$1;
			});
			const inlineMapStyle = document.querySelector(`style[${ATTR_CACHE_MAP}]`);
			if (inlineMapStyle) {
				fromCSSFile = false;
				inlineMapStyle.parentNode?.removeChild(inlineMapStyle);
			}
			document.body.removeChild(div);
		}
	}
}
function existPath(path$1) {
	prepare();
	return !!cachePathMap[path$1];
}
function getStyleAndHash(path$1) {
	const hash$1 = cachePathMap[path$1];
	let styleStr = null;
	if (hash$1 && canUseDom()) if (fromCSSFile) styleStr = CSS_FILE_STYLE;
	else {
		const style$1 = document.querySelector(`style[${ATTR_MARK}="${cachePathMap[path$1]}"]`);
		if (style$1) styleStr = style$1.innerHTML;
		else delete cachePathMap[path$1];
	}
	return [styleStr, hash$1];
}

//#endregion
//#region node_modules/@ant-design/cssinjs/es/hooks/useStyleRegister.js
var SKIP_CHECK = "_skip_check_";
var MULTI_VALUE = "_multi_value_";
function normalizeStyle(styleStr, autoPrefix) {
	return (autoPrefix ? serialize(compile(styleStr), middleware([prefixer, stringify$2])) : serialize(compile(styleStr), stringify$2)).replace(/\{%%%\:[^;];}/g, ";");
}
function isCompoundCSSProperty(value) {
	return typeof value === "object" && value && (SKIP_CHECK in value || MULTI_VALUE in value);
}
function injectSelectorHash(key, hashId, hashPriority = "high") {
	if (!hashId) return key;
	const hashSelector = where({
		hashCls: hashId,
		hashPriority
	});
	return key.split(",").map((k) => {
		const fullPath = k.trim().split(/\s+/);
		let firstPath = fullPath[0] || "";
		const htmlElement = firstPath.match(/^\w+/)?.[0] || "";
		firstPath = `${htmlElement}${hashSelector}${firstPath.slice(htmlElement.length)}`;
		return [firstPath, ...fullPath.slice(1)].join(" ");
	}).join(",");
}
const parseStyle = (interpolation, config = {}, { root, injectHash, parentSelectors } = {
	root: true,
	parentSelectors: []
}) => {
	const { hashId, layer, path: path$1, hashPriority, transformers = [], linters = [] } = config;
	let styleStr = "";
	let effectStyle = {};
	function parseKeyframes(keyframes) {
		const animationName = keyframes.getName(hashId);
		if (!effectStyle[animationName]) {
			const [parsedStr] = parseStyle(keyframes.style, config, {
				root: false,
				parentSelectors
			});
			effectStyle[animationName] = `@keyframes ${keyframes.getName(hashId)}${parsedStr}`;
		}
	}
	function flattenList(list, fullList = []) {
		list.forEach((item) => {
			if (Array.isArray(item)) flattenList(item, fullList);
			else if (item) fullList.push(item);
		});
		return fullList;
	}
	flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]).forEach((originStyle) => {
		const style$1 = typeof originStyle === "string" && !root ? {} : originStyle;
		if (typeof style$1 === "string") styleStr += `${style$1}\n`;
		else if (style$1._keyframe) parseKeyframes(style$1);
		else {
			const mergedStyle = transformers.reduce((prev$1, trans) => trans?.visit?.(prev$1) || prev$1, style$1);
			Object.keys(mergedStyle).forEach((key) => {
				const value = mergedStyle[key];
				if (typeof value === "object" && value && (key !== "animationName" || !value._keyframe) && !isCompoundCSSProperty(value)) {
					let subInjectHash = false;
					let mergedKey = key.trim();
					let nextRoot = false;
					if ((root || injectHash) && hashId) if (mergedKey.startsWith("@")) subInjectHash = true;
					else if (mergedKey === "&") mergedKey = injectSelectorHash("", hashId, hashPriority);
					else mergedKey = injectSelectorHash(key, hashId, hashPriority);
					else if (root && !hashId && (mergedKey === "&" || mergedKey === "")) {
						mergedKey = "";
						nextRoot = true;
					}
					const [parsedStr, childEffectStyle] = parseStyle(value, config, {
						root: nextRoot,
						injectHash: subInjectHash,
						parentSelectors: [...parentSelectors, mergedKey]
					});
					effectStyle = {
						...effectStyle,
						...childEffectStyle
					};
					styleStr += `${mergedKey}${parsedStr}`;
				} else {
					function appendStyle(cssKey, cssValue) {
						if (typeof value !== "object" || !value?.[SKIP_CHECK]) [
							contentQuotesLinter_default,
							hashedAnimationLinter_default,
							...linters
						].forEach((linter$2) => linter$2(cssKey, cssValue, {
							path: path$1,
							hashId,
							parentSelectors
						}));
						const styleName = cssKey.replace(/[A-Z]/g, (match$2) => `-${match$2.toLowerCase()}`);
						let formatValue$1 = cssValue;
						if (!unitless_browser_esm_default[cssKey] && typeof formatValue$1 === "number" && formatValue$1 !== 0) formatValue$1 = `${formatValue$1}px`;
						if (cssKey === "animationName" && cssValue?._keyframe) {
							parseKeyframes(cssValue);
							formatValue$1 = cssValue.getName(hashId);
						}
						styleStr += `${styleName}:${formatValue$1};`;
					}
					const actualValue = value?.value ?? value;
					if (typeof value === "object" && value?.[MULTI_VALUE] && Array.isArray(actualValue)) actualValue.forEach((item) => {
						appendStyle(key, item);
					});
					else appendStyle(key, actualValue);
				}
			});
		}
	});
	if (!root) styleStr = `{${styleStr}}`;
	else if (layer) {
		if (styleStr) styleStr = `@layer ${layer.name} {${styleStr}}`;
		if (layer.dependencies) effectStyle[`@layer ${layer.name}`] = layer.dependencies.map((deps) => `@layer ${deps}, ${layer.name};`).join("\n");
	}
	return [styleStr, effectStyle];
};
function uniqueHash(path$1, styleStr) {
	return hash_browser_esm_default(`${path$1.join("%")}${styleStr}`);
}
const STYLE_PREFIX = "style";
/**
* Register a style to the global style sheet.
*/
function useStyleRegister(info, styleFn) {
	const { path: path$1, hashId, layer, nonce, clientOnly, order = 0 } = info;
	const { mock, hashPriority, container, transformers, linters, cache, layer: enableLayer, autoPrefix } = import_react.useContext(StyleContext_default);
	const fullPath = [hashId || ""];
	if (enableLayer) fullPath.push("layer");
	fullPath.push(...path$1);
	let isMergedClientSide = isClientSide;
	if (mock !== void 0) isMergedClientSide = mock === "client";
	useGlobalCache(STYLE_PREFIX, fullPath, () => {
		const cachePath = fullPath.join("|");
		if (existPath(cachePath)) {
			const [inlineCacheStyleStr, styleHash] = getStyleAndHash(cachePath);
			if (inlineCacheStyleStr) return [
				inlineCacheStyleStr,
				styleHash,
				{},
				clientOnly,
				order
			];
		}
		const [parsedStyle, effectStyle] = parseStyle(styleFn(), {
			hashId,
			hashPriority,
			layer: enableLayer ? layer : void 0,
			path: path$1.join("-"),
			transformers,
			linters
		});
		const styleStr = normalizeStyle(parsedStyle, autoPrefix || false);
		return [
			styleStr,
			uniqueHash(fullPath, styleStr),
			effectStyle,
			clientOnly,
			order
		];
	}, (cacheValue, fromHMR) => {
		const [, styleId] = cacheValue;
		if (fromHMR && isClientSide) removeCSS(styleId, {
			mark: ATTR_MARK,
			attachTo: container
		});
	}, (cacheValue) => {
		const [styleStr, styleId, effectStyle, , priority] = cacheValue;
		if (isMergedClientSide && styleStr !== CSS_FILE_STYLE) {
			const mergedCSSConfig = {
				mark: ATTR_MARK,
				prepend: enableLayer ? false : "queue",
				attachTo: container,
				priority
			};
			const nonceStr = typeof nonce === "function" ? nonce() : nonce;
			if (nonceStr) mergedCSSConfig.csp = { nonce: nonceStr };
			const effectLayerKeys = [];
			const effectRestKeys = [];
			Object.keys(effectStyle).forEach((key) => {
				if (key.startsWith("@layer")) effectLayerKeys.push(key);
				else effectRestKeys.push(key);
			});
			effectLayerKeys.forEach((effectKey) => {
				updateCSS(normalizeStyle(effectStyle[effectKey], autoPrefix || false), `_layer-${effectKey}`, {
					...mergedCSSConfig,
					prepend: true
				});
			});
			const style$1 = updateCSS(styleStr, styleId, mergedCSSConfig);
			style$1[CSS_IN_JS_INSTANCE] = cache.instanceId;
			style$1.setAttribute(ATTR_CACHE_PATH, fullPath.join("|"));
			effectRestKeys.forEach((effectKey) => {
				updateCSS(normalizeStyle(effectStyle[effectKey], autoPrefix || false), `_effect-${effectKey}`, mergedCSSConfig);
			});
		}
	});
}
const extract$2 = (cache, effectStyles, options) => {
	const [styleStr, styleId, effectStyle, clientOnly, order] = cache;
	const { plain, autoPrefix } = options || {};
	if (clientOnly) return null;
	let keyStyleText = styleStr;
	const sharedAttrs = {
		"data-rc-order": "prependQueue",
		"data-rc-priority": `${order}`
	};
	keyStyleText = toStyleStr(styleStr, void 0, styleId, sharedAttrs, plain);
	if (effectStyle) Object.keys(effectStyle).forEach((effectKey) => {
		if (!effectStyles[effectKey]) {
			effectStyles[effectKey] = true;
			const effectStyleHTML = toStyleStr(normalizeStyle(effectStyle[effectKey], autoPrefix || false), void 0, `_effect-${effectKey}`, sharedAttrs, plain);
			if (effectKey.startsWith("@layer")) keyStyleText = effectStyleHTML + keyStyleText;
			else keyStyleText += effectStyleHTML;
		}
	});
	return [
		order,
		styleId,
		keyStyleText
	];
};

//#endregion
//#region node_modules/@ant-design/cssinjs/es/hooks/useCSSVarRegister.js
const CSS_VAR_PREFIX = "cssVar";
var useCSSVarRegister = (config, fn) => {
	const { key, prefix: prefix$1, unitless: unitless$1, ignore: ignore$1, token: token$1, hashId, scope = "" } = config;
	const { cache: { instanceId }, container, hashPriority } = (0, import_react.useContext)(StyleContext_default);
	const { _tokenKey: tokenKey } = token$1;
	const stylePath = [
		...config.path,
		key,
		scope,
		tokenKey
	];
	return useGlobalCache(CSS_VAR_PREFIX, stylePath, () => {
		const [mergedToken, cssVarsStr] = transformToken(fn(), key, {
			prefix: prefix$1,
			unitless: unitless$1,
			ignore: ignore$1,
			scope,
			hashPriority,
			hashCls: hashId
		});
		return [
			mergedToken,
			cssVarsStr,
			uniqueHash(stylePath, cssVarsStr),
			key
		];
	}, ([, , styleId]) => {
		if (isClientSide) removeCSS(styleId, {
			mark: ATTR_MARK,
			attachTo: container
		});
	}, ([, cssVarsStr, styleId]) => {
		if (!cssVarsStr) return;
		const style$1 = updateCSS(cssVarsStr, styleId, {
			mark: ATTR_MARK,
			prepend: "queue",
			attachTo: container,
			priority: -999
		});
		style$1[CSS_IN_JS_INSTANCE] = instanceId;
		style$1.setAttribute(ATTR_TOKEN, key);
	});
};
const extract$1 = (cache, effectStyles, options) => {
	const [, styleStr, styleId, cssVarKey] = cache;
	const { plain } = options || {};
	if (!styleStr) return null;
	const order = -999;
	return [
		order,
		styleId,
		toStyleStr(styleStr, cssVarKey, styleId, {
			"data-rc-order": "prependQueue",
			"data-rc-priority": `${order}`
		}, plain)
	];
};
var useCSSVarRegister_default = useCSSVarRegister;

//#endregion
//#region node_modules/@ant-design/cssinjs/es/extractStyle.js
var ExtractStyleFns = {
	[STYLE_PREFIX]: extract$2,
	[TOKEN_PREFIX]: extract,
	[CSS_VAR_PREFIX]: extract$1
};

//#endregion
//#region node_modules/@ant-design/cssinjs/es/Keyframes.js
var Keyframe = class {
	name;
	style;
	constructor(name, style$1) {
		this.name = name;
		this.style = style$1;
	}
	getName(hashId = "") {
		return hashId ? `${hashId}-${this.name}` : this.name;
	}
	_keyframe = true;
};
var Keyframes_default = Keyframe;

//#endregion
//#region node_modules/@ant-design/cssinjs/es/transformers/legacyLogicalProperties.js
function noSplit(list) {
	list.notSplit = true;
	return list;
}
var keyMap = {
	inset: [
		"top",
		"right",
		"bottom",
		"left"
	],
	insetBlock: ["top", "bottom"],
	insetBlockStart: ["top"],
	insetBlockEnd: ["bottom"],
	insetInline: ["left", "right"],
	insetInlineStart: ["left"],
	insetInlineEnd: ["right"],
	marginBlock: ["marginTop", "marginBottom"],
	marginBlockStart: ["marginTop"],
	marginBlockEnd: ["marginBottom"],
	marginInline: ["marginLeft", "marginRight"],
	marginInlineStart: ["marginLeft"],
	marginInlineEnd: ["marginRight"],
	paddingBlock: ["paddingTop", "paddingBottom"],
	paddingBlockStart: ["paddingTop"],
	paddingBlockEnd: ["paddingBottom"],
	paddingInline: ["paddingLeft", "paddingRight"],
	paddingInlineStart: ["paddingLeft"],
	paddingInlineEnd: ["paddingRight"],
	borderBlock: noSplit(["borderTop", "borderBottom"]),
	borderBlockStart: noSplit(["borderTop"]),
	borderBlockEnd: noSplit(["borderBottom"]),
	borderInline: noSplit(["borderLeft", "borderRight"]),
	borderInlineStart: noSplit(["borderLeft"]),
	borderInlineEnd: noSplit(["borderRight"]),
	borderBlockWidth: ["borderTopWidth", "borderBottomWidth"],
	borderBlockStartWidth: ["borderTopWidth"],
	borderBlockEndWidth: ["borderBottomWidth"],
	borderInlineWidth: ["borderLeftWidth", "borderRightWidth"],
	borderInlineStartWidth: ["borderLeftWidth"],
	borderInlineEndWidth: ["borderRightWidth"],
	borderBlockStyle: ["borderTopStyle", "borderBottomStyle"],
	borderBlockStartStyle: ["borderTopStyle"],
	borderBlockEndStyle: ["borderBottomStyle"],
	borderInlineStyle: ["borderLeftStyle", "borderRightStyle"],
	borderInlineStartStyle: ["borderLeftStyle"],
	borderInlineEndStyle: ["borderRightStyle"],
	borderBlockColor: ["borderTopColor", "borderBottomColor"],
	borderBlockStartColor: ["borderTopColor"],
	borderBlockEndColor: ["borderBottomColor"],
	borderInlineColor: ["borderLeftColor", "borderRightColor"],
	borderInlineStartColor: ["borderLeftColor"],
	borderInlineEndColor: ["borderRightColor"],
	borderStartStartRadius: ["borderTopLeftRadius"],
	borderStartEndRadius: ["borderTopRightRadius"],
	borderEndStartRadius: ["borderBottomLeftRadius"],
	borderEndEndRadius: ["borderBottomRightRadius"]
};

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o$2) {
	"@babel/helpers - typeof";
	return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof(o$2);
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
var import_react_dom$8 = require_react_dom();
function _arrayWithHoles$31(r$1) {
	if (Array.isArray(r$1)) return r$1;
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit$31(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1["return"] && (u = t$1["return"](), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest$31() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(r$1, e$2) {
	return _arrayWithHoles$31(r$1) || _iterableToArrayLimit$31(r$1, e$2) || _unsupportedIterableToArray(r$1, e$2) || _nonIterableRest$31();
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t$1, r$1) {
	if ("object" != _typeof(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t$1) {
	var i = toPrimitive(t$1, "string");
	return "symbol" == _typeof(i) ? i : i + "";
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(e$2, r$1, t$1) {
	return (r$1 = toPropertyKey(r$1)) in e$2 ? Object.defineProperty(e$2, r$1, {
		value: t$1,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e$2[r$1] = t$1, e$2;
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/objectSpread2.js
function ownKeys$18(e$2, r$1) {
	var t$1 = Object.keys(e$2);
	if (Object.getOwnPropertySymbols) {
		var o$2 = Object.getOwnPropertySymbols(e$2);
		r$1 && (o$2 = o$2.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e$2, r$2).enumerable;
		})), t$1.push.apply(t$1, o$2);
	}
	return t$1;
}
function _objectSpread2(e$2) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$18(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty(e$2, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$2, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$18(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e$2, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e$2;
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(a, n$1) {
	if (!(a instanceof n$1)) throw new TypeError("Cannot call a class as a function");
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties$1(e$2, r$1) {
	for (var t$1 = 0; t$1 < r$1.length; t$1++) {
		var o$2 = r$1[t$1];
		o$2.enumerable = o$2.enumerable || !1, o$2.configurable = !0, "value" in o$2 && (o$2.writable = !0), Object.defineProperty(e$2, toPropertyKey(o$2.key), o$2);
	}
}
function _createClass(e$2, r$1, t$1) {
	return r$1 && _defineProperties$1(e$2.prototype, r$1), t$1 && _defineProperties$1(e$2, t$1), Object.defineProperty(e$2, "prototype", { writable: !1 }), e$2;
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e$2) {
	if (void 0 === e$2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return e$2;
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t$1, e$2) {
	return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t$2, e$3) {
		return t$2.__proto__ = e$3, t$2;
	}, _setPrototypeOf(t$1, e$2);
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(t$1, e$2) {
	if ("function" != typeof e$2 && null !== e$2) throw new TypeError("Super expression must either be null or a function");
	t$1.prototype = Object.create(e$2 && e$2.prototype, { constructor: {
		value: t$1,
		writable: !0,
		configurable: !0
	} }), Object.defineProperty(t$1, "prototype", { writable: !1 }), e$2 && _setPrototypeOf(t$1, e$2);
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(t$1) {
	return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t$2) {
		return t$2.__proto__ || Object.getPrototypeOf(t$2);
	}, _getPrototypeOf(t$1);
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
	try {
		var t$1 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$2) {}
	return (_isNativeReflectConstruct = function _isNativeReflectConstruct$1() {
		return !!t$1;
	})();
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(t$1, e$2) {
	if (e$2 && ("object" == _typeof(e$2) || "function" == typeof e$2)) return e$2;
	if (void 0 !== e$2) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized(t$1);
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/createSuper.js
function _createSuper(t$1) {
	var r$1 = _isNativeReflectConstruct();
	return function() {
		var e$2, o$2 = _getPrototypeOf(t$1);
		if (r$1) {
			var s = _getPrototypeOf(this).constructor;
			e$2 = Reflect.construct(o$2, arguments, s);
		} else e$2 = o$2.apply(this, arguments);
		return _possibleConstructorReturn(this, e$2);
	};
}

//#endregion
//#region node_modules/@ant-design/cssinjs-utils/es/util/calc/calculator.js
var AbstractCalculator = /* @__PURE__ */ _createClass(function AbstractCalculator$1() {
	_classCallCheck(this, AbstractCalculator$1);
});
var calculator_default = AbstractCalculator;

//#endregion
//#region node_modules/@ant-design/cssinjs-utils/es/util/calc/CSSCalculator.js
var CALC_UNIT = "CALC_UNIT";
var regexp$1 = new RegExp(CALC_UNIT, "g");
function unit$1(value) {
	if (typeof value === "number") return "".concat(value).concat(CALC_UNIT);
	return value;
}
var CSSCalculator = /* @__PURE__ */ function(_AbstractCalculator) {
	_inherits(CSSCalculator$1, _AbstractCalculator);
	var _super = _createSuper(CSSCalculator$1);
	function CSSCalculator$1(num, unitlessCssVar) {
		var _this;
		_classCallCheck(this, CSSCalculator$1);
		_this = _super.call(this);
		_defineProperty(_assertThisInitialized(_this), "result", "");
		_defineProperty(_assertThisInitialized(_this), "unitlessCssVar", void 0);
		_defineProperty(_assertThisInitialized(_this), "lowPriority", void 0);
		var numType = _typeof(num);
		_this.unitlessCssVar = unitlessCssVar;
		if (num instanceof CSSCalculator$1) _this.result = "(".concat(num.result, ")");
		else if (numType === "number") _this.result = unit$1(num);
		else if (numType === "string") _this.result = num;
		return _this;
	}
	_createClass(CSSCalculator$1, [
		{
			key: "add",
			value: function add(num) {
				if (num instanceof CSSCalculator$1) this.result = "".concat(this.result, " + ").concat(num.getResult());
				else if (typeof num === "number" || typeof num === "string") this.result = "".concat(this.result, " + ").concat(unit$1(num));
				this.lowPriority = true;
				return this;
			}
		},
		{
			key: "sub",
			value: function sub(num) {
				if (num instanceof CSSCalculator$1) this.result = "".concat(this.result, " - ").concat(num.getResult());
				else if (typeof num === "number" || typeof num === "string") this.result = "".concat(this.result, " - ").concat(unit$1(num));
				this.lowPriority = true;
				return this;
			}
		},
		{
			key: "mul",
			value: function mul(num) {
				if (this.lowPriority) this.result = "(".concat(this.result, ")");
				if (num instanceof CSSCalculator$1) this.result = "".concat(this.result, " * ").concat(num.getResult(true));
				else if (typeof num === "number" || typeof num === "string") this.result = "".concat(this.result, " * ").concat(num);
				this.lowPriority = false;
				return this;
			}
		},
		{
			key: "div",
			value: function div(num) {
				if (this.lowPriority) this.result = "(".concat(this.result, ")");
				if (num instanceof CSSCalculator$1) this.result = "".concat(this.result, " / ").concat(num.getResult(true));
				else if (typeof num === "number" || typeof num === "string") this.result = "".concat(this.result, " / ").concat(num);
				this.lowPriority = false;
				return this;
			}
		},
		{
			key: "getResult",
			value: function getResult(force) {
				return this.lowPriority || force ? "(".concat(this.result, ")") : this.result;
			}
		},
		{
			key: "equal",
			value: function equal(options) {
				var _this2 = this;
				var cssUnit = (options || {}).unit;
				var mergedUnit = true;
				if (typeof cssUnit === "boolean") mergedUnit = cssUnit;
				else if (Array.from(this.unitlessCssVar).some(function(cssVar) {
					return _this2.result.includes(cssVar);
				})) mergedUnit = false;
				this.result = this.result.replace(regexp$1, mergedUnit ? "px" : "");
				if (typeof this.lowPriority !== "undefined") return "calc(".concat(this.result, ")");
				return this.result;
			}
		}
	]);
	return CSSCalculator$1;
}(calculator_default);

//#endregion
//#region node_modules/@ant-design/cssinjs-utils/es/util/calc/NumCalculator.js
var NumCalculator = /* @__PURE__ */ function(_AbstractCalculator) {
	_inherits(NumCalculator$1, _AbstractCalculator);
	var _super = _createSuper(NumCalculator$1);
	function NumCalculator$1(num) {
		var _this;
		_classCallCheck(this, NumCalculator$1);
		_this = _super.call(this);
		_defineProperty(_assertThisInitialized(_this), "result", 0);
		if (num instanceof NumCalculator$1) _this.result = num.result;
		else if (typeof num === "number") _this.result = num;
		return _this;
	}
	_createClass(NumCalculator$1, [
		{
			key: "add",
			value: function add(num) {
				if (num instanceof NumCalculator$1) this.result += num.result;
				else if (typeof num === "number") this.result += num;
				return this;
			}
		},
		{
			key: "sub",
			value: function sub(num) {
				if (num instanceof NumCalculator$1) this.result -= num.result;
				else if (typeof num === "number") this.result -= num;
				return this;
			}
		},
		{
			key: "mul",
			value: function mul(num) {
				if (num instanceof NumCalculator$1) this.result *= num.result;
				else if (typeof num === "number") this.result *= num;
				return this;
			}
		},
		{
			key: "div",
			value: function div(num) {
				if (num instanceof NumCalculator$1) this.result /= num.result;
				else if (typeof num === "number") this.result /= num;
				return this;
			}
		},
		{
			key: "equal",
			value: function equal() {
				return this.result;
			}
		}
	]);
	return NumCalculator$1;
}(calculator_default);
var NumCalculator_default = NumCalculator;

//#endregion
//#region node_modules/@ant-design/cssinjs-utils/es/util/calc/index.js
var genCalc = function genCalc$1(type$2, unitlessCssVar) {
	var Calculator = type$2 === "css" ? CSSCalculator : NumCalculator_default;
	return function(num) {
		return new Calculator(num, unitlessCssVar);
	};
};
var calc_default = genCalc;

//#endregion
//#region node_modules/@ant-design/cssinjs-utils/es/util/getCompVarPrefix.js
var getCompVarPrefix = function getCompVarPrefix$1(component, prefix$1) {
	return "".concat([prefix$1, component.replace(/([A-Z]+)([A-Z][a-z]+)/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2")].filter(Boolean).join("-"));
};
var getCompVarPrefix_default = getCompVarPrefix;

//#endregion
//#region node_modules/@ant-design/cssinjs-utils/es/util/getComponentToken.js
function getComponentToken(component, token$1, defaultToken, options) {
	var customToken = _objectSpread2({}, token$1[component]);
	if (options !== null && options !== void 0 && options.deprecatedTokens) options.deprecatedTokens.forEach(function(_ref) {
		var _ref2 = _slicedToArray(_ref, 2), oldTokenKey = _ref2[0], newTokenKey = _ref2[1];
		warning_default$1(!(customToken !== null && customToken !== void 0 && customToken[oldTokenKey]), "Component Token `".concat(String(oldTokenKey), "` of ").concat(String(component), " is deprecated. Please use `").concat(String(newTokenKey), "` instead."));
		if (customToken !== null && customToken !== void 0 && customToken[oldTokenKey] || customToken !== null && customToken !== void 0 && customToken[newTokenKey]) {
			var _customToken$newToken;
			(_customToken$newToken = customToken[newTokenKey]) !== null && _customToken$newToken !== void 0 || (customToken[newTokenKey] = customToken === null || customToken === void 0 ? void 0 : customToken[oldTokenKey]);
		}
	});
	var mergedToken = _objectSpread2(_objectSpread2({}, defaultToken), customToken);
	Object.keys(mergedToken).forEach(function(key) {
		if (mergedToken[key] === token$1[key]) delete mergedToken[key];
	});
	return mergedToken;
}
var getComponentToken_default = getComponentToken;

//#endregion
//#region node_modules/@ant-design/cssinjs-utils/es/util/statistic.js
var enableStatistic = true;
var recording = true;
/**
* This function will do as `Object.assign` in production. But will use Object.defineProperty:get to
* pass all value access in development. To support statistic field usage with alias token.
*/
function merge() {
	for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) objs[_key] = arguments[_key];
	/* istanbul ignore next */
	if (!enableStatistic) return Object.assign.apply(Object, [{}].concat(objs));
	recording = false;
	var ret = {};
	objs.forEach(function(obj) {
		if (_typeof(obj) !== "object") return;
		Object.keys(obj).forEach(function(key) {
			Object.defineProperty(ret, key, {
				configurable: true,
				enumerable: true,
				get: function get$1() {
					return obj[key];
				}
			});
		});
	});
	recording = true;
	return ret;
}
/** @internal Internal Usage. Not use in your production. */
var statistic = {};
/* istanbul ignore next */
function noop$3() {}
/** Statistic token usage case. Should use `merge` function if you do not want spread record. */
var statisticToken = function statisticToken$1(token$1) {
	var tokenKeys$1;
	var proxy = token$1;
	var flush = noop$3;
	if (enableStatistic && typeof Proxy !== "undefined") {
		tokenKeys$1 = /* @__PURE__ */ new Set();
		proxy = new Proxy(token$1, { get: function get$1(obj, prop) {
			if (recording) {
				var _tokenKeys;
				(_tokenKeys = tokenKeys$1) === null || _tokenKeys === void 0 || _tokenKeys.add(prop);
			}
			return obj[prop];
		} });
		flush = function flush$1(componentName, componentToken) {
			var _statistic$componentN;
			statistic[componentName] = {
				global: Array.from(tokenKeys$1),
				component: _objectSpread2(_objectSpread2({}, (_statistic$componentN = statistic[componentName]) === null || _statistic$componentN === void 0 ? void 0 : _statistic$componentN.component), componentToken)
			};
		};
	}
	return {
		token: proxy,
		keys: tokenKeys$1,
		flush
	};
};
var statistic_default$1 = statisticToken;

//#endregion
//#region node_modules/@ant-design/cssinjs-utils/es/util/getDefaultComponentToken.js
function getDefaultComponentToken(component, token$1, getDefaultToken) {
	if (typeof getDefaultToken === "function") {
		var _token$component;
		return getDefaultToken(merge(token$1, (_token$component = token$1[component]) !== null && _token$component !== void 0 ? _token$component : {}));
	}
	return getDefaultToken !== null && getDefaultToken !== void 0 ? getDefaultToken : {};
}
var getDefaultComponentToken_default = getDefaultComponentToken;

//#endregion
//#region node_modules/@ant-design/cssinjs-utils/es/util/maxmin.js
function genMaxMin(type$2) {
	if (type$2 === "js") return {
		max: Math.max,
		min: Math.min
	};
	return {
		max: function max() {
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
			return "max(".concat(args.map(function(value) {
				return unit(value);
			}).join(","), ")");
		},
		min: function min() {
			for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
			return "min(".concat(args.map(function(value) {
				return unit(value);
			}).join(","), ")");
		}
	};
}
var maxmin_default = genMaxMin;

//#endregion
//#region node_modules/@ant-design/cssinjs-utils/es/_util/hooks/useUniqueMemo.js
var BEAT_LIMIT = 1e3 * 60 * 10;
var uniqueMap = new (/* @__PURE__ */ function() {
	function ArrayKeyMap() {
		_classCallCheck(this, ArrayKeyMap);
		_defineProperty(this, "map", /* @__PURE__ */ new Map());
		_defineProperty(this, "objectIDMap", /* @__PURE__ */ new WeakMap());
		_defineProperty(this, "nextID", 0);
		_defineProperty(this, "lastAccessBeat", /* @__PURE__ */ new Map());
		_defineProperty(this, "accessBeat", 0);
	}
	_createClass(ArrayKeyMap, [
		{
			key: "set",
			value: function set$1(keys$1, value) {
				this.clear();
				var compositeKey = this.getCompositeKey(keys$1);
				this.map.set(compositeKey, value);
				this.lastAccessBeat.set(compositeKey, Date.now());
			}
		},
		{
			key: "get",
			value: function get$1(keys$1) {
				var compositeKey = this.getCompositeKey(keys$1);
				var cache = this.map.get(compositeKey);
				this.lastAccessBeat.set(compositeKey, Date.now());
				this.accessBeat += 1;
				return cache;
			}
		},
		{
			key: "getCompositeKey",
			value: function getCompositeKey(keys$1) {
				var _this = this;
				return keys$1.map(function(key) {
					if (key && _typeof(key) === "object") return "obj_".concat(_this.getObjectID(key));
					return "".concat(_typeof(key), "_").concat(key);
				}).join("|");
			}
		},
		{
			key: "getObjectID",
			value: function getObjectID(obj) {
				if (this.objectIDMap.has(obj)) return this.objectIDMap.get(obj);
				var id = this.nextID;
				this.objectIDMap.set(obj, id);
				this.nextID += 1;
				return id;
			}
		},
		{
			key: "clear",
			value: function clear() {
				var _this2 = this;
				if (this.accessBeat > 1e4) {
					var now$1 = Date.now();
					this.lastAccessBeat.forEach(function(beat, key) {
						if (now$1 - beat > BEAT_LIMIT) {
							_this2.map.delete(key);
							_this2.lastAccessBeat.delete(key);
						}
					});
					this.accessBeat = 0;
				}
			}
		}
	]);
	return ArrayKeyMap;
}())();
/**
* Like `useMemo`, but this hook result will be shared across all instances.
*/
function useUniqueMemo(memoFn, deps) {
	return import_react.useMemo(function() {
		var cachedValue = uniqueMap.get(deps);
		if (cachedValue) return cachedValue;
		var newValue = memoFn();
		uniqueMap.set(deps, newValue);
		return newValue;
	}, deps);
}
var useUniqueMemo_default = useUniqueMemo;

//#endregion
//#region node_modules/@ant-design/cssinjs-utils/es/hooks/useCSP.js
/**
* Provide a default hook since not everyone needs to config this.
*/
var useDefaultCSP = function useDefaultCSP$1() {
	return {};
};
var useCSP_default = useDefaultCSP;

//#endregion
//#region node_modules/@ant-design/cssinjs-utils/es/util/genStyleUtils.js
function genStyleUtils(config) {
	var _config$useCSP = config.useCSP, useCSP = _config$useCSP === void 0 ? useCSP_default : _config$useCSP, useToken$2 = config.useToken, usePrefix = config.usePrefix, getResetStyles$1 = config.getResetStyles, getCommonStyle = config.getCommonStyle, getCompUnitless = config.getCompUnitless;
	function genStyleHooks$1(component, styleFn, getDefaultToken, options) {
		var componentName = Array.isArray(component) ? component[0] : component;
		function prefixToken(key) {
			return "".concat(String(componentName)).concat(key.slice(0, 1).toUpperCase()).concat(key.slice(1));
		}
		var originUnitless = (options === null || options === void 0 ? void 0 : options.unitless) || {};
		var compUnitless = _objectSpread2(_objectSpread2({}, typeof getCompUnitless === "function" ? getCompUnitless(component) : {}), {}, _defineProperty({}, prefixToken("zIndexPopup"), true));
		Object.keys(originUnitless).forEach(function(key) {
			compUnitless[prefixToken(key)] = originUnitless[key];
		});
		var mergedOptions = _objectSpread2(_objectSpread2({}, options), {}, {
			unitless: compUnitless,
			prefixToken
		});
		var useStyle = genComponentStyleHook$1(component, styleFn, getDefaultToken, mergedOptions);
		var useCSSVar = genCSSVarRegister(componentName, getDefaultToken, mergedOptions);
		return function(prefixCls) {
			var rootCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prefixCls;
			return [useStyle(prefixCls, rootCls), useCSSVar(rootCls)];
		};
	}
	function genCSSVarRegister(component, getDefaultToken, options) {
		var compUnitless = options.unitless, prefixToken = options.prefixToken, ignore$1 = options.ignore;
		return function(rootCls) {
			var _useToken = useToken$2(), cssVar = _useToken.cssVar, realToken = _useToken.realToken;
			useCSSVarRegister_default({
				path: [component],
				prefix: cssVar.prefix,
				key: cssVar.key,
				unitless: compUnitless,
				ignore: ignore$1,
				token: realToken,
				scope: rootCls
			}, function() {
				var defaultToken = getDefaultComponentToken_default(component, realToken, getDefaultToken);
				var componentToken = getComponentToken_default(component, realToken, defaultToken, { deprecatedTokens: options === null || options === void 0 ? void 0 : options.deprecatedTokens });
				if (defaultToken) Object.keys(defaultToken).forEach(function(key) {
					componentToken[prefixToken(key)] = componentToken[key];
					delete componentToken[key];
				});
				return componentToken;
			});
			return cssVar === null || cssVar === void 0 ? void 0 : cssVar.key;
		};
	}
	function genComponentStyleHook$1(componentName, styleFn, getDefaultToken) {
		var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
		var cells = Array.isArray(componentName) ? componentName : [componentName, componentName];
		var component = _slicedToArray(cells, 1)[0];
		var concatComponent = cells.join("-");
		var mergedLayer = config.layer || { name: "antd" };
		return function(prefixCls) {
			var rootCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prefixCls;
			var _useToken2 = useToken$2(), theme = _useToken2.theme, realToken = _useToken2.realToken, hashId = _useToken2.hashId, token$1 = _useToken2.token, cssVar = _useToken2.cssVar, zeroRuntime = _useToken2.zeroRuntime;
			if ((0, import_react.useMemo)(function() {
				return zeroRuntime;
			}, [])) return hashId;
			var _usePrefix = usePrefix(), rootPrefixCls = _usePrefix.rootPrefixCls, iconPrefixCls = _usePrefix.iconPrefixCls;
			var csp = useCSP();
			var type$2 = "css";
			var calc = useUniqueMemo_default(function() {
				var unitlessCssVar = /* @__PURE__ */ new Set();
				Object.keys(options.unitless || {}).forEach(function(key) {
					unitlessCssVar.add(token2CSSVar(key, cssVar.prefix));
					unitlessCssVar.add(token2CSSVar(key, getCompVarPrefix_default(component, cssVar.prefix)));
				});
				return calc_default(type$2, unitlessCssVar);
			}, [
				type$2,
				component,
				cssVar === null || cssVar === void 0 ? void 0 : cssVar.prefix
			]);
			var _genMaxMin = maxmin_default(type$2), max = _genMaxMin.max, min = _genMaxMin.min;
			var sharedConfig = {
				theme,
				token: token$1,
				hashId,
				nonce: function nonce() {
					return csp.nonce;
				},
				clientOnly: options.clientOnly,
				layer: mergedLayer,
				order: options.order || -999
			};
			if (typeof getResetStyles$1 === "function") useStyleRegister(_objectSpread2(_objectSpread2({}, sharedConfig), {}, {
				clientOnly: false,
				path: ["Shared", rootPrefixCls]
			}), function() {
				return getResetStyles$1(token$1, {
					prefix: {
						rootPrefixCls,
						iconPrefixCls
					},
					csp
				});
			});
			useStyleRegister(_objectSpread2(_objectSpread2({}, sharedConfig), {}, { path: [
				concatComponent,
				prefixCls,
				iconPrefixCls
			] }), function() {
				if (options.injectStyle === false) return [];
				var _statisticToken = statistic_default$1(token$1), proxyToken = _statisticToken.token, flush = _statisticToken.flush;
				var defaultComponentToken = getDefaultComponentToken_default(component, realToken, getDefaultToken);
				var componentCls = ".".concat(prefixCls);
				var componentToken = getComponentToken_default(component, realToken, defaultComponentToken, { deprecatedTokens: options.deprecatedTokens });
				if (defaultComponentToken && _typeof(defaultComponentToken) === "object") Object.keys(defaultComponentToken).forEach(function(key) {
					defaultComponentToken[key] = "var(".concat(token2CSSVar(key, getCompVarPrefix_default(component, cssVar.prefix)), ")");
				});
				var mergedToken = merge(proxyToken, {
					componentCls,
					prefixCls,
					iconCls: ".".concat(iconPrefixCls),
					antCls: ".".concat(rootPrefixCls),
					calc,
					max,
					min
				}, defaultComponentToken);
				var styleInterpolation = styleFn(mergedToken, {
					hashId,
					prefixCls,
					rootPrefixCls,
					iconPrefixCls
				});
				flush(component, componentToken);
				var commonStyle = typeof getCommonStyle === "function" ? getCommonStyle(mergedToken, prefixCls, rootCls, options.resetFont) : null;
				return [options.resetStyle === false ? null : commonStyle, styleInterpolation];
			});
			return hashId;
		};
	}
	function genSubStyleComponent$1(componentName, styleFn, getDefaultToken) {
		var useStyle = genComponentStyleHook$1(componentName, styleFn, getDefaultToken, _objectSpread2({
			resetStyle: false,
			order: -998
		}, arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}));
		var StyledComponent = function StyledComponent$1(_ref) {
			var prefixCls = _ref.prefixCls, _ref$rootCls = _ref.rootCls;
			useStyle(prefixCls, _ref$rootCls === void 0 ? prefixCls : _ref$rootCls);
			return null;
		};
		StyledComponent.displayName = "SubStyle_".concat(String(Array.isArray(componentName) ? componentName.join(".") : componentName));
		return StyledComponent;
	}
	return {
		genStyleHooks: genStyleHooks$1,
		genSubStyleComponent: genSubStyleComponent$1,
		genComponentStyleHook: genComponentStyleHook$1
	};
}
var genStyleUtils_default = genStyleUtils;

//#endregion
//#region node_modules/antd/es/theme/interface/presetColors.js
const PresetColors = [
	"blue",
	"purple",
	"cyan",
	"green",
	"magenta",
	"pink",
	"red",
	"orange",
	"yellow",
	"volcano",
	"geekblue",
	"lime",
	"gold"
];

//#endregion
//#region node_modules/antd/es/theme/themes/shared/genFontSizes.js
function getLineHeight(fontSize) {
	return (fontSize + 8) / fontSize;
}
function getFontSizes(base) {
	const fontSizes = Array.from({ length: 10 }).map((_, index$1) => {
		const i = index$1 - 1;
		const baseSize = base * Math.E ** (i / 5);
		const intSize = index$1 > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
		return Math.floor(intSize / 2) * 2;
	});
	fontSizes[1] = base;
	return fontSizes.map((size) => ({
		size,
		lineHeight: getLineHeight(size)
	}));
}

//#endregion
//#region node_modules/antd/es/version/version.js
var version_default$1 = "6.1.4";

//#endregion
//#region node_modules/antd/es/version/index.js
var version_default = version_default$1;

//#endregion
//#region node_modules/antd/es/theme/themes/seed.js
const defaultPresetColors = {
	blue: "#1677FF",
	purple: "#722ED1",
	cyan: "#13C2C2",
	green: "#52C41A",
	magenta: "#EB2F96",
	pink: "#EB2F96",
	red: "#F5222D",
	orange: "#FA8C16",
	yellow: "#FADB14",
	volcano: "#FA541C",
	geekblue: "#2F54EB",
	gold: "#FAAD14",
	lime: "#A0D911"
};
var seedToken = {
	...defaultPresetColors,
	colorPrimary: "#1677ff",
	colorSuccess: "#52c41a",
	colorWarning: "#faad14",
	colorError: "#ff4d4f",
	colorInfo: "#1677ff",
	colorLink: "",
	colorTextBase: "",
	colorBgBase: "",
	fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
	fontFamilyCode: `'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace`,
	fontSize: 14,
	lineWidth: 1,
	lineType: "solid",
	motionUnit: .1,
	motionBase: 0,
	motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
	motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
	motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
	motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
	motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
	motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
	motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
	motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
	borderRadius: 6,
	sizeUnit: 4,
	sizeStep: 4,
	sizePopupArrow: 16,
	controlHeight: 32,
	zIndexBase: 0,
	zIndexPopupBase: 1e3,
	opacityImage: 1,
	wireframe: false,
	motion: true
};
var seed_default = seedToken;

//#endregion
//#region node_modules/antd/es/theme/themes/shared/genColorMapToken.js
function genColorMapToken(seed, { generateColorPalettes: generateColorPalettes$2, generateNeutralColorPalettes: generateNeutralColorPalettes$2 }) {
	const { colorSuccess: colorSuccessBase, colorWarning: colorWarningBase, colorError: colorErrorBase, colorInfo: colorInfoBase, colorPrimary: colorPrimaryBase, colorBgBase, colorTextBase } = seed;
	const primaryColors = generateColorPalettes$2(colorPrimaryBase);
	const successColors = generateColorPalettes$2(colorSuccessBase);
	const warningColors = generateColorPalettes$2(colorWarningBase);
	const errorColors = generateColorPalettes$2(colorErrorBase);
	const infoColors = generateColorPalettes$2(colorInfoBase);
	const neutralColors = generateNeutralColorPalettes$2(colorBgBase, colorTextBase);
	const linkColors = generateColorPalettes$2(seed.colorLink || seed.colorInfo);
	const colorErrorBgFilledHover = new FastColor(errorColors[1]).mix(new FastColor(errorColors[3]), 50).toHexString();
	return {
		...neutralColors,
		colorPrimaryBg: primaryColors[1],
		colorPrimaryBgHover: primaryColors[2],
		colorPrimaryBorder: primaryColors[3],
		colorPrimaryBorderHover: primaryColors[4],
		colorPrimaryHover: primaryColors[5],
		colorPrimary: primaryColors[6],
		colorPrimaryActive: primaryColors[7],
		colorPrimaryTextHover: primaryColors[8],
		colorPrimaryText: primaryColors[9],
		colorPrimaryTextActive: primaryColors[10],
		colorSuccessBg: successColors[1],
		colorSuccessBgHover: successColors[2],
		colorSuccessBorder: successColors[3],
		colorSuccessBorderHover: successColors[4],
		colorSuccessHover: successColors[4],
		colorSuccess: successColors[6],
		colorSuccessActive: successColors[7],
		colorSuccessTextHover: successColors[8],
		colorSuccessText: successColors[9],
		colorSuccessTextActive: successColors[10],
		colorErrorBg: errorColors[1],
		colorErrorBgHover: errorColors[2],
		colorErrorBgFilledHover,
		colorErrorBgActive: errorColors[3],
		colorErrorBorder: errorColors[3],
		colorErrorBorderHover: errorColors[4],
		colorErrorHover: errorColors[5],
		colorError: errorColors[6],
		colorErrorActive: errorColors[7],
		colorErrorTextHover: errorColors[8],
		colorErrorText: errorColors[9],
		colorErrorTextActive: errorColors[10],
		colorWarningBg: warningColors[1],
		colorWarningBgHover: warningColors[2],
		colorWarningBorder: warningColors[3],
		colorWarningBorderHover: warningColors[4],
		colorWarningHover: warningColors[4],
		colorWarning: warningColors[6],
		colorWarningActive: warningColors[7],
		colorWarningTextHover: warningColors[8],
		colorWarningText: warningColors[9],
		colorWarningTextActive: warningColors[10],
		colorInfoBg: infoColors[1],
		colorInfoBgHover: infoColors[2],
		colorInfoBorder: infoColors[3],
		colorInfoBorderHover: infoColors[4],
		colorInfoHover: infoColors[4],
		colorInfo: infoColors[6],
		colorInfoActive: infoColors[7],
		colorInfoTextHover: infoColors[8],
		colorInfoText: infoColors[9],
		colorInfoTextActive: infoColors[10],
		colorLinkHover: linkColors[4],
		colorLink: linkColors[6],
		colorLinkActive: linkColors[7],
		colorBgMask: new FastColor("#000").setA(.45).toRgbString(),
		colorWhite: "#fff"
	};
}

//#endregion
//#region node_modules/antd/es/theme/themes/shared/genRadius.js
var genRadius = (radiusBase) => {
	let radiusLG = radiusBase;
	let radiusSM = radiusBase;
	let radiusXS = radiusBase;
	let radiusOuter = radiusBase;
	if (radiusBase < 6 && radiusBase >= 5) radiusLG = radiusBase + 1;
	else if (radiusBase < 16 && radiusBase >= 6) radiusLG = radiusBase + 2;
	else if (radiusBase >= 16) radiusLG = 16;
	if (radiusBase < 7 && radiusBase >= 5) radiusSM = 4;
	else if (radiusBase < 8 && radiusBase >= 7) radiusSM = 5;
	else if (radiusBase < 14 && radiusBase >= 8) radiusSM = 6;
	else if (radiusBase < 16 && radiusBase >= 14) radiusSM = 7;
	else if (radiusBase >= 16) radiusSM = 8;
	if (radiusBase < 6 && radiusBase >= 2) radiusXS = 1;
	else if (radiusBase >= 6) radiusXS = 2;
	if (radiusBase > 4 && radiusBase < 8) radiusOuter = 4;
	else if (radiusBase >= 8) radiusOuter = 6;
	return {
		borderRadius: radiusBase,
		borderRadiusXS: radiusXS,
		borderRadiusSM: radiusSM,
		borderRadiusLG: radiusLG,
		borderRadiusOuter: radiusOuter
	};
};
var genRadius_default = genRadius;

//#endregion
//#region node_modules/antd/es/theme/themes/shared/genCommonMapToken.js
function genCommonMapToken(token$1) {
	const { motionUnit, motionBase, borderRadius, lineWidth } = token$1;
	return {
		motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
		motionDurationMid: `${(motionBase + motionUnit * 2).toFixed(1)}s`,
		motionDurationSlow: `${(motionBase + motionUnit * 3).toFixed(1)}s`,
		lineWidthBold: lineWidth + 1,
		...genRadius_default(borderRadius)
	};
}

//#endregion
//#region node_modules/antd/es/theme/themes/shared/genControlHeight.js
var genControlHeight = (token$1) => {
	const { controlHeight } = token$1;
	return {
		controlHeightSM: controlHeight * .75,
		controlHeightXS: controlHeight * .5,
		controlHeightLG: controlHeight * 1.25
	};
};
var genControlHeight_default = genControlHeight;

//#endregion
//#region node_modules/antd/es/theme/themes/shared/genFontMapToken.js
var genFontMapToken = (fontSize) => {
	const fontSizePairs = getFontSizes(fontSize);
	const fontSizes = fontSizePairs.map((pair) => pair.size);
	const lineHeights = fontSizePairs.map((pair) => pair.lineHeight);
	const fontSizeMD = fontSizes[1];
	const fontSizeSM = fontSizes[0];
	const fontSizeLG = fontSizes[2];
	const lineHeight = lineHeights[1];
	const lineHeightSM = lineHeights[0];
	const lineHeightLG = lineHeights[2];
	return {
		fontSizeSM,
		fontSize: fontSizeMD,
		fontSizeLG,
		fontSizeXL: fontSizes[3],
		fontSizeHeading1: fontSizes[6],
		fontSizeHeading2: fontSizes[5],
		fontSizeHeading3: fontSizes[4],
		fontSizeHeading4: fontSizes[3],
		fontSizeHeading5: fontSizes[2],
		lineHeight,
		lineHeightLG,
		lineHeightSM,
		fontHeight: Math.round(lineHeight * fontSizeMD),
		fontHeightLG: Math.round(lineHeightLG * fontSizeLG),
		fontHeightSM: Math.round(lineHeightSM * fontSizeSM),
		lineHeightHeading1: lineHeights[6],
		lineHeightHeading2: lineHeights[5],
		lineHeightHeading3: lineHeights[4],
		lineHeightHeading4: lineHeights[3],
		lineHeightHeading5: lineHeights[2]
	};
};
var genFontMapToken_default = genFontMapToken;

//#endregion
//#region node_modules/antd/es/theme/themes/shared/genSizeMapToken.js
function genSizeMapToken$1(token$1) {
	const { sizeUnit, sizeStep } = token$1;
	return {
		sizeXXL: sizeUnit * (sizeStep + 8),
		sizeXL: sizeUnit * (sizeStep + 4),
		sizeLG: sizeUnit * (sizeStep + 2),
		sizeMD: sizeUnit * (sizeStep + 1),
		sizeMS: sizeUnit * sizeStep,
		size: sizeUnit * sizeStep,
		sizeSM: sizeUnit * (sizeStep - 1),
		sizeXS: sizeUnit * (sizeStep - 2),
		sizeXXS: sizeUnit * (sizeStep - 3)
	};
}

//#endregion
//#region node_modules/antd/es/theme/themes/default/colorAlgorithm.js
const getAlphaColor$2 = (baseColor, alpha) => new FastColor(baseColor).setA(alpha).toRgbString();
const getSolidColor$1 = (baseColor, brightness) => {
	return new FastColor(baseColor).darken(brightness).toHexString();
};

//#endregion
//#region node_modules/antd/es/theme/themes/default/colors.js
const generateColorPalettes$1 = (baseColor) => {
	const colors = generate(baseColor);
	return {
		1: colors[0],
		2: colors[1],
		3: colors[2],
		4: colors[3],
		5: colors[4],
		6: colors[5],
		7: colors[6],
		8: colors[4],
		9: colors[5],
		10: colors[6]
	};
};
const generateNeutralColorPalettes$1 = (bgBaseColor, textBaseColor) => {
	const colorBgBase = bgBaseColor || "#fff";
	const colorTextBase = textBaseColor || "#000";
	return {
		colorBgBase,
		colorTextBase,
		colorText: getAlphaColor$2(colorTextBase, .88),
		colorTextSecondary: getAlphaColor$2(colorTextBase, .65),
		colorTextTertiary: getAlphaColor$2(colorTextBase, .45),
		colorTextQuaternary: getAlphaColor$2(colorTextBase, .25),
		colorFill: getAlphaColor$2(colorTextBase, .15),
		colorFillSecondary: getAlphaColor$2(colorTextBase, .06),
		colorFillTertiary: getAlphaColor$2(colorTextBase, .04),
		colorFillQuaternary: getAlphaColor$2(colorTextBase, .02),
		colorBgSolid: getAlphaColor$2(colorTextBase, 1),
		colorBgSolidHover: getAlphaColor$2(colorTextBase, .75),
		colorBgSolidActive: getAlphaColor$2(colorTextBase, .95),
		colorBgLayout: getSolidColor$1(colorBgBase, 4),
		colorBgContainer: getSolidColor$1(colorBgBase, 0),
		colorBgElevated: getSolidColor$1(colorBgBase, 0),
		colorBgSpotlight: getAlphaColor$2(colorTextBase, .85),
		colorBgBlur: "transparent",
		colorBorder: getSolidColor$1(colorBgBase, 15),
		colorBorderDisabled: getSolidColor$1(colorBgBase, 15),
		colorBorderSecondary: getSolidColor$1(colorBgBase, 6)
	};
};

//#endregion
//#region node_modules/antd/es/theme/themes/default/index.js
function derivative(token$1) {
	presetPrimaryColors.pink = presetPrimaryColors.magenta;
	presetPalettes.pink = presetPalettes.magenta;
	const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
		const colors = token$1[colorKey] === presetPrimaryColors[colorKey] ? presetPalettes[colorKey] : generate(token$1[colorKey]);
		return Array.from({ length: 10 }, () => 1).reduce((prev$1, _, i) => {
			prev$1[`${colorKey}-${i + 1}`] = colors[i];
			prev$1[`${colorKey}${i + 1}`] = colors[i];
			return prev$1;
		}, {});
	}).reduce((prev$1, cur) => {
		prev$1 = {
			...prev$1,
			...cur
		};
		return prev$1;
	}, {});
	return {
		...token$1,
		...colorPalettes,
		...genColorMapToken(token$1, {
			generateColorPalettes: generateColorPalettes$1,
			generateNeutralColorPalettes: generateNeutralColorPalettes$1
		}),
		...genFontMapToken_default(token$1.fontSize),
		...genSizeMapToken$1(token$1),
		...genControlHeight_default(token$1),
		...genCommonMapToken(token$1)
	};
}

//#endregion
//#region node_modules/antd/es/theme/themes/default/theme.js
var defaultTheme = createTheme(derivative);
var theme_default$1 = defaultTheme;

//#endregion
//#region node_modules/antd/es/theme/context.js
const defaultConfig = {
	token: seed_default,
	override: { override: seed_default },
	hashed: true
};
const DesignTokenContext = /* @__PURE__ */ import_react.createContext(defaultConfig);

//#endregion
//#region node_modules/antd/es/theme/util/getAlphaColor.js
function isStableColor(color) {
	return color >= 0 && color <= 255;
}
function getAlphaColor$1(frontColor, backgroundColor) {
	const { r: fR, g: fG, b: fB, a: originAlpha } = new FastColor(frontColor).toRgb();
	if (originAlpha < 1) return frontColor;
	const { r: bR, g: bG, b: bB } = new FastColor(backgroundColor).toRgb();
	for (let fA = .01; fA <= 1; fA += .01) {
		const r$1 = Math.round((fR - bR * (1 - fA)) / fA);
		const g = Math.round((fG - bG * (1 - fA)) / fA);
		const b = Math.round((fB - bB * (1 - fA)) / fA);
		if (isStableColor(r$1) && isStableColor(g) && isStableColor(b)) return new FastColor({
			r: r$1,
			g,
			b,
			a: Math.round(fA * 100) / 100
		}).toRgbString();
	}
	/* istanbul ignore next */
	return new FastColor({
		r: fR,
		g: fG,
		b: fB,
		a: 1
	}).toRgbString();
}
var getAlphaColor_default = getAlphaColor$1;

//#endregion
//#region node_modules/antd/es/theme/util/alias.js
/**
* Seed (designer) > Derivative (designer) > Alias (developer).
*
* Merge seed & derivative & override token and generate alias token for developer.
*/
function formatToken(derivativeToken) {
	const { override, ...restToken } = derivativeToken;
	const overrideTokens = { ...override };
	Object.keys(seed_default).forEach((token$1) => {
		delete overrideTokens[token$1];
	});
	const mergedToken = {
		...restToken,
		...overrideTokens
	};
	const screenXS = 480;
	const screenSM = 576;
	const screenMD = 768;
	const screenLG = 992;
	const screenXL = 1200;
	const screenXXL = 1600;
	if (mergedToken.motion === false) {
		const fastDuration = "0s";
		mergedToken.motionDurationFast = fastDuration;
		mergedToken.motionDurationMid = fastDuration;
		mergedToken.motionDurationSlow = fastDuration;
	}
	return {
		...mergedToken,
		colorFillContent: mergedToken.colorFillSecondary,
		colorFillContentHover: mergedToken.colorFill,
		colorFillAlter: mergedToken.colorFillQuaternary,
		colorBgContainerDisabled: mergedToken.colorFillTertiary,
		colorBorderBg: mergedToken.colorBgContainer,
		colorSplit: getAlphaColor_default(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
		colorTextPlaceholder: mergedToken.colorTextQuaternary,
		colorTextDisabled: mergedToken.colorTextQuaternary,
		colorTextHeading: mergedToken.colorText,
		colorTextLabel: mergedToken.colorTextSecondary,
		colorTextDescription: mergedToken.colorTextTertiary,
		colorTextLightSolid: mergedToken.colorWhite,
		colorHighlight: mergedToken.colorError,
		colorBgTextHover: mergedToken.colorFillSecondary,
		colorBgTextActive: mergedToken.colorFill,
		colorIcon: mergedToken.colorTextTertiary,
		colorIconHover: mergedToken.colorText,
		colorErrorOutline: getAlphaColor_default(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
		colorWarningOutline: getAlphaColor_default(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
		fontSizeIcon: mergedToken.fontSizeSM,
		lineWidthFocus: mergedToken.lineWidth * 3,
		lineWidth: mergedToken.lineWidth,
		controlOutlineWidth: mergedToken.lineWidth * 2,
		controlInteractiveSize: mergedToken.controlHeight / 2,
		controlItemBgHover: mergedToken.colorFillTertiary,
		controlItemBgActive: mergedToken.colorPrimaryBg,
		controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
		controlItemBgActiveDisabled: mergedToken.colorFill,
		controlTmpOutline: mergedToken.colorFillQuaternary,
		controlOutline: getAlphaColor_default(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
		lineType: mergedToken.lineType,
		borderRadius: mergedToken.borderRadius,
		borderRadiusXS: mergedToken.borderRadiusXS,
		borderRadiusSM: mergedToken.borderRadiusSM,
		borderRadiusLG: mergedToken.borderRadiusLG,
		fontWeightStrong: 600,
		opacityLoading: .65,
		linkDecoration: "none",
		linkHoverDecoration: "none",
		linkFocusDecoration: "none",
		controlPaddingHorizontal: 12,
		controlPaddingHorizontalSM: 8,
		paddingXXS: mergedToken.sizeXXS,
		paddingXS: mergedToken.sizeXS,
		paddingSM: mergedToken.sizeSM,
		padding: mergedToken.size,
		paddingMD: mergedToken.sizeMD,
		paddingLG: mergedToken.sizeLG,
		paddingXL: mergedToken.sizeXL,
		paddingContentHorizontalLG: mergedToken.sizeLG,
		paddingContentVerticalLG: mergedToken.sizeMS,
		paddingContentHorizontal: mergedToken.sizeMS,
		paddingContentVertical: mergedToken.sizeSM,
		paddingContentHorizontalSM: mergedToken.size,
		paddingContentVerticalSM: mergedToken.sizeXS,
		marginXXS: mergedToken.sizeXXS,
		marginXS: mergedToken.sizeXS,
		marginSM: mergedToken.sizeSM,
		margin: mergedToken.size,
		marginMD: mergedToken.sizeMD,
		marginLG: mergedToken.sizeLG,
		marginXL: mergedToken.sizeXL,
		marginXXL: mergedToken.sizeXXL,
		boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
		boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
		boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
		screenXS,
		screenXSMin: screenXS,
		screenXSMax: screenSM - 1,
		screenSM,
		screenSMMin: screenSM,
		screenSMMax: screenMD - 1,
		screenMD,
		screenMDMin: screenMD,
		screenMDMax: screenLG - 1,
		screenLG,
		screenLGMin: screenLG,
		screenLGMax: screenXL - 1,
		screenXL,
		screenXLMin: screenXL,
		screenXLMax: screenXXL - 1,
		screenXXL,
		screenXXLMin: screenXXL,
		boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
		boxShadowCard: `
      0 1px 2px -2px ${new FastColor("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new FastColor("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new FastColor("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
		boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
		boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
		boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
		boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
		boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
		boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
		boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
		boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)",
		...overrideTokens
	};
}

//#endregion
//#region node_modules/antd/es/theme/useToken.js
const unitless = {
	lineHeight: true,
	lineHeightSM: true,
	lineHeightLG: true,
	lineHeightHeading1: true,
	lineHeightHeading2: true,
	lineHeightHeading3: true,
	lineHeightHeading4: true,
	lineHeightHeading5: true,
	opacityLoading: true,
	fontWeightStrong: true,
	zIndexPopupBase: true,
	zIndexBase: true,
	opacityImage: true
};
const ignore = {
	motionBase: true,
	motionUnit: true
};
var preserve = {
	screenXS: true,
	screenXSMin: true,
	screenXSMax: true,
	screenSM: true,
	screenSMMin: true,
	screenSMMax: true,
	screenMD: true,
	screenMDMin: true,
	screenMDMax: true,
	screenLG: true,
	screenLGMin: true,
	screenLGMax: true,
	screenXL: true,
	screenXLMin: true,
	screenXLMax: true,
	screenXXL: true,
	screenXXLMin: true
};
const getComputedToken$1 = (originToken, overrideToken, theme) => {
	const derivativeToken = theme.getDerivativeToken(originToken);
	const { override, ...components$1 } = overrideToken;
	let mergedDerivativeToken = {
		...derivativeToken,
		override
	};
	mergedDerivativeToken = formatToken(mergedDerivativeToken);
	if (components$1) Object.entries(components$1).forEach(([key, value]) => {
		const { theme: componentTheme, ...componentTokens } = value;
		let mergedComponentToken = componentTokens;
		if (componentTheme) mergedComponentToken = getComputedToken$1({
			...mergedDerivativeToken,
			...componentTokens
		}, { override: componentTokens }, componentTheme);
		mergedDerivativeToken[key] = mergedComponentToken;
	});
	return mergedDerivativeToken;
};
function useToken() {
	const { token: rootDesignToken, hashed, theme, override, cssVar: ctxCssVar, zeroRuntime } = import_react.useContext(DesignTokenContext);
	const cssVar = {
		prefix: ctxCssVar?.prefix ?? "ant",
		key: ctxCssVar?.key ?? "css-var-root"
	};
	const salt = `${version_default}-${hashed || ""}`;
	const mergedTheme = theme || theme_default$1;
	const [token$1, hashId, realToken] = useCacheToken(mergedTheme, [seed_default, rootDesignToken], {
		salt,
		override,
		getComputedToken: getComputedToken$1,
		cssVar: {
			...cssVar,
			unitless,
			ignore,
			preserve
		}
	});
	return [
		mergedTheme,
		realToken,
		hashed ? hashId : "",
		token$1,
		cssVar,
		!!zeroRuntime
	];
}

//#endregion
//#region node_modules/antd/es/style/index.js
const textEllipsis = {
	overflow: "hidden",
	whiteSpace: "nowrap",
	textOverflow: "ellipsis"
};
const resetComponent = (token$1, needInheritFontFamily = false) => ({
	boxSizing: "border-box",
	margin: 0,
	padding: 0,
	color: token$1.colorText,
	fontSize: token$1.fontSize,
	lineHeight: token$1.lineHeight,
	listStyle: "none",
	fontFamily: needInheritFontFamily ? "inherit" : token$1.fontFamily
});
const resetIcon = () => ({
	display: "inline-flex",
	alignItems: "center",
	color: "inherit",
	fontStyle: "normal",
	lineHeight: 0,
	textAlign: "center",
	textTransform: "none",
	verticalAlign: "-0.125em",
	textRendering: "optimizeLegibility",
	"-webkit-font-smoothing": "antialiased",
	"-moz-osx-font-smoothing": "grayscale",
	"> *": { lineHeight: 1 },
	svg: { display: "inline-block" }
});
const clearFix = () => ({
	"&::before": {
		display: "table",
		content: "\"\""
	},
	"&::after": {
		display: "table",
		clear: "both",
		content: "\"\""
	}
});
const genLinkStyle = (token$1) => ({ a: {
	color: token$1.colorLink,
	textDecoration: token$1.linkDecoration,
	backgroundColor: "transparent",
	outline: "none",
	cursor: "pointer",
	transition: `color ${token$1.motionDurationSlow}`,
	"-webkit-text-decoration-skip": "objects",
	"&:hover": { color: token$1.colorLinkHover },
	"&:active": { color: token$1.colorLinkActive },
	"&:active, &:hover": {
		textDecoration: token$1.linkHoverDecoration,
		outline: 0
	},
	"&:focus": {
		textDecoration: token$1.linkFocusDecoration,
		outline: 0
	},
	"&[disabled]": {
		color: token$1.colorTextDisabled,
		cursor: "not-allowed"
	}
} });
const genCommonStyle = (token$1, componentPrefixCls, rootCls, resetFont) => {
	const prefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
	const rootPrefixSelector = rootCls ? `.${rootCls}` : prefixSelector;
	const resetStyle = {
		boxSizing: "border-box",
		"&::before, &::after": { boxSizing: "border-box" }
	};
	let resetFontStyle = {};
	if (resetFont !== false) resetFontStyle = {
		fontFamily: token$1.fontFamily,
		fontSize: token$1.fontSize
	};
	return { [rootPrefixSelector]: {
		...resetFontStyle,
		...resetStyle,
		[prefixSelector]: resetStyle
	} };
};
const genFocusOutline = (token$1, offset$2) => ({
	outline: `${unit(token$1.lineWidthFocus)} solid ${token$1.colorPrimaryBorder}`,
	outlineOffset: offset$2 ?? 1,
	transition: "outline-offset 0s, outline 0s"
});
const genFocusStyle = (token$1, offset$2) => ({ "&:focus-visible": genFocusOutline(token$1, offset$2) });
const genIconStyle$1 = (iconPrefixCls) => ({ [`.${iconPrefixCls}`]: {
	...resetIcon(),
	[`.${iconPrefixCls} .${iconPrefixCls}-icon`]: { display: "block" }
} });
const operationUnit = (token$1) => ({
	color: token$1.colorLink,
	textDecoration: token$1.linkDecoration,
	outline: "none",
	cursor: "pointer",
	transition: `all ${token$1.motionDurationSlow}`,
	border: 0,
	padding: 0,
	background: "none",
	userSelect: "none",
	...genFocusStyle(token$1),
	"&:hover": {
		color: token$1.colorLinkHover,
		textDecoration: token$1.linkHoverDecoration
	},
	"&:focus": {
		color: token$1.colorLinkHover,
		textDecoration: token$1.linkFocusDecoration
	},
	"&:active": {
		color: token$1.colorLinkActive,
		textDecoration: token$1.linkHoverDecoration
	}
});

//#endregion
//#region node_modules/antd/es/theme/util/genStyleUtils.js
const { genStyleHooks, genComponentStyleHook, genSubStyleComponent } = genStyleUtils_default({
	usePrefix: () => {
		const { getPrefixCls, iconPrefixCls } = (0, import_react.useContext)(ConfigContext);
		return {
			rootPrefixCls: getPrefixCls(),
			iconPrefixCls
		};
	},
	useToken: () => {
		const [theme, realToken, hashId, token$1, cssVar, zeroRuntime] = useToken();
		return {
			theme,
			realToken,
			hashId,
			token: token$1,
			cssVar,
			zeroRuntime
		};
	},
	useCSP: () => {
		const { csp } = (0, import_react.useContext)(ConfigContext);
		return csp ?? {};
	},
	getResetStyles: (token$1, config) => {
		const linkStyle = genLinkStyle(token$1);
		return [
			linkStyle,
			{ "&": linkStyle },
			genIconStyle$1(config?.prefix.iconPrefixCls ?? defaultIconPrefixCls)
		];
	},
	getCommonStyle: genCommonStyle,
	getCompUnitless: () => unitless
});
const genCssVar = (antCls, componentAbbr) => {
	const cssPrefix = `--${antCls.replace(".", "")}-${componentAbbr}-`;
	return (name, withVar = false) => {
		const raw = `${cssPrefix}${name}`;
		return withVar ? `var(${raw})` : raw;
	};
};

//#endregion
//#region node_modules/antd/es/theme/util/genPresetColor.js
function genPresetColor(token$1, genCss) {
	return PresetColors.reduce((prev$1, colorKey) => {
		const lightColor = token$1[`${colorKey}1`];
		const lightBorderColor = token$1[`${colorKey}3`];
		const darkColor = token$1[`${colorKey}6`];
		const textColor = token$1[`${colorKey}7`];
		return {
			...prev$1,
			...genCss(colorKey, {
				lightColor,
				lightBorderColor,
				darkColor,
				textColor
			})
		};
	}, {});
}

//#endregion
//#region node_modules/antd/es/theme/util/useResetIconStyle.js
var useResetIconStyle = (iconPrefixCls, csp) => {
	const [theme, token$1] = useToken();
	return useStyleRegister({
		theme,
		token: token$1,
		hashId: "",
		path: ["ant-design-icons", iconPrefixCls],
		nonce: () => csp?.nonce,
		layer: { name: "antd" }
	}, () => genIconStyle$1(iconPrefixCls));
};
var useResetIconStyle_default = useResetIconStyle;

//#endregion
//#region node_modules/antd/es/affix/style/index.js
var genSharedAffixStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: {
		position: "fixed",
		zIndex: token$1.zIndexPopup
	} };
};
const prepareComponentToken$57 = (token$1) => ({ zIndexPopup: token$1.zIndexBase + 10 });
var style_default$64 = genStyleHooks("Affix", genSharedAffixStyle, prepareComponentToken$57);

//#endregion
//#region node_modules/antd/es/affix/utils.js
function getTargetRect(target) {
	return target !== window ? target.getBoundingClientRect() : {
		top: 0,
		bottom: window.innerHeight
	};
}
function getFixedTop(placeholderRect, targetRect, offsetTop) {
	if (offsetTop !== void 0 && Math.round(targetRect.top) > Math.round(placeholderRect.top) - offsetTop) return offsetTop + targetRect.top;
}
function getFixedBottom(placeholderRect, targetRect, offsetBottom) {
	if (offsetBottom !== void 0 && Math.round(targetRect.bottom) < Math.round(placeholderRect.bottom) + offsetBottom) return offsetBottom + (window.innerHeight - targetRect.bottom);
}

//#endregion
//#region node_modules/antd/es/affix/index.js
var TRIGGER_EVENTS = [
	"resize",
	"scroll",
	"touchstart",
	"touchmove",
	"touchend",
	"pageshow",
	"load"
];
function getDefaultTarget() {
	return typeof window !== "undefined" ? window : null;
}
var AFFIX_STATUS_NONE = 0;
var AFFIX_STATUS_PREPARE = 1;
var Affix$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { style: style$1, offsetTop, offsetBottom, prefixCls, className, rootClassName, children, target, onChange, onTestUpdatePosition, ...restProps } = props;
	const { getPrefixCls, className: contextClassName, style: contextStyle } = useComponentConfig("affix");
	const { getTargetContainer } = import_react.useContext(ConfigContext);
	const affixPrefixCls = getPrefixCls("affix", prefixCls);
	const [lastAffix, setLastAffix] = import_react.useState(false);
	const [affixStyle, setAffixStyle] = import_react.useState();
	const [placeholderStyle, setPlaceholderStyle] = import_react.useState();
	const status = import_react.useRef(AFFIX_STATUS_NONE);
	const prevTarget = import_react.useRef(null);
	const prevListener = import_react.useRef(null);
	const placeholderNodeRef = import_react.useRef(null);
	const fixedNodeRef = import_react.useRef(null);
	const timer = import_react.useRef(null);
	const targetFunc = target ?? getTargetContainer ?? getDefaultTarget;
	const internalOffsetTop = offsetBottom === void 0 && offsetTop === void 0 ? 0 : offsetTop;
	const measure = () => {
		if (status.current !== AFFIX_STATUS_PREPARE || !fixedNodeRef.current || !placeholderNodeRef.current || !targetFunc) return;
		const targetNode = targetFunc();
		if (targetNode) {
			const newState = { status: AFFIX_STATUS_NONE };
			const placeholderRect = getTargetRect(placeholderNodeRef.current);
			if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) return;
			const targetRect = getTargetRect(targetNode);
			const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);
			const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);
			if (fixedTop !== void 0) {
				newState.affixStyle = {
					position: "fixed",
					top: fixedTop,
					width: placeholderRect.width,
					height: placeholderRect.height
				};
				newState.placeholderStyle = {
					width: placeholderRect.width,
					height: placeholderRect.height
				};
			} else if (fixedBottom !== void 0) {
				newState.affixStyle = {
					position: "fixed",
					bottom: fixedBottom,
					width: placeholderRect.width,
					height: placeholderRect.height
				};
				newState.placeholderStyle = {
					width: placeholderRect.width,
					height: placeholderRect.height
				};
			}
			newState.lastAffix = !!newState.affixStyle;
			if (lastAffix !== newState.lastAffix) onChange?.(newState.lastAffix);
			status.current = newState.status;
			setAffixStyle(newState.affixStyle);
			setPlaceholderStyle(newState.placeholderStyle);
			setLastAffix(newState.lastAffix);
		}
	};
	const prepareMeasure = () => {
		status.current = AFFIX_STATUS_PREPARE;
		measure();
	};
	const updatePosition = throttleByAnimationFrame_default(() => {
		prepareMeasure();
	});
	const lazyUpdatePosition = throttleByAnimationFrame_default(() => {
		if (targetFunc && affixStyle) {
			const targetNode = targetFunc();
			if (targetNode && placeholderNodeRef.current) {
				const targetRect = getTargetRect(targetNode);
				const placeholderRect = getTargetRect(placeholderNodeRef.current);
				const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);
				const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);
				if (fixedTop !== void 0 && affixStyle.top === fixedTop || fixedBottom !== void 0 && affixStyle.bottom === fixedBottom) return;
			}
		}
		prepareMeasure();
	});
	const addListeners = () => {
		const listenerTarget = targetFunc?.();
		if (!listenerTarget) return;
		TRIGGER_EVENTS.forEach((eventName) => {
			if (prevListener.current) prevTarget.current?.removeEventListener(eventName, prevListener.current);
			listenerTarget?.addEventListener(eventName, lazyUpdatePosition);
		});
		prevTarget.current = listenerTarget;
		prevListener.current = lazyUpdatePosition;
	};
	const removeListeners = () => {
		const newTarget = targetFunc?.();
		TRIGGER_EVENTS.forEach((eventName) => {
			newTarget?.removeEventListener(eventName, lazyUpdatePosition);
			if (prevListener.current) prevTarget.current?.removeEventListener(eventName, prevListener.current);
		});
		updatePosition.cancel();
		lazyUpdatePosition.cancel();
	};
	import_react.useImperativeHandle(ref, () => ({ updatePosition }));
	import_react.useEffect(() => {
		timer.current = setTimeout(addListeners);
		return () => {
			if (timer.current) {
				clearTimeout(timer.current);
				timer.current = null;
			}
			removeListeners();
		};
	}, []);
	import_react.useEffect(() => {
		addListeners();
		return () => removeListeners();
	}, [
		target,
		affixStyle,
		lastAffix,
		offsetTop,
		offsetBottom
	]);
	import_react.useEffect(() => {
		updatePosition();
	}, [
		target,
		offsetTop,
		offsetBottom
	]);
	const [hashId, cssVarCls] = style_default$64(affixPrefixCls);
	const mergedCls = clsx({ [clsx(rootClassName, hashId, affixPrefixCls, cssVarCls)]: affixStyle });
	return /* @__PURE__ */ import_react.createElement(es_default$2, { onResize: updatePosition }, /* @__PURE__ */ import_react.createElement("div", {
		style: {
			...contextStyle,
			...style$1
		},
		className: clsx(className, contextClassName),
		ref: placeholderNodeRef,
		...restProps
	}, affixStyle && /* @__PURE__ */ import_react.createElement("div", {
		style: placeholderStyle,
		"aria-hidden": "true"
	}), /* @__PURE__ */ import_react.createElement("div", {
		className: mergedCls,
		ref: fixedNodeRef,
		style: affixStyle
	}, /* @__PURE__ */ import_react.createElement(es_default$2, { onResize: updatePosition }, children))));
});
Affix$1.displayName = "Affix";
var affix_default = Affix$1;

//#endregion
//#region node_modules/@rc-component/motion/es/context.js
const Context$1 = /* @__PURE__ */ import_react.createContext({});
function MotionProvider({ children, ...props }) {
	return /* @__PURE__ */ import_react.createElement(Context$1.Provider, { value: props }, children);
}

//#endregion
//#region node_modules/@rc-component/util/es/hooks/useSyncState.js
/**
* Same as React.useState but will always get latest state.
* This is useful when React merge multiple state updates into one.
* e.g. onTransitionEnd trigger multiple event at once will be merged state update in React.
*/
function useSyncState$3(defaultValue) {
	const [, forceUpdate] = import_react.useReducer((x) => x + 1, 0);
	const currentValueRef = import_react.useRef(defaultValue);
	return [useEvent_default(() => {
		return currentValueRef.current;
	}), useEvent_default((updater) => {
		currentValueRef.current = typeof updater === "function" ? updater(currentValueRef.current) : updater;
		forceUpdate();
	})];
}

//#endregion
//#region node_modules/@rc-component/motion/es/interface.js
const STATUS_NONE = "none";
const STATUS_APPEAR = "appear";
const STATUS_ENTER = "enter";
const STATUS_LEAVE = "leave";
const STEP_NONE = "none";
const STEP_PREPARE = "prepare";
const STEP_START = "start";
const STEP_ACTIVE = "active";
const STEP_ACTIVATED = "end";
/**
* Used for disabled motion case.
* Prepare stage will still work but start & active will be skipped.
*/
const STEP_PREPARED = "prepared";

//#endregion
//#region node_modules/@rc-component/motion/es/util/motion.js
function makePrefixMap(styleProp, eventName) {
	const prefixes = {};
	prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
	prefixes[`Webkit${styleProp}`] = `webkit${eventName}`;
	prefixes[`Moz${styleProp}`] = `moz${eventName}`;
	prefixes[`ms${styleProp}`] = `MS${eventName}`;
	prefixes[`O${styleProp}`] = `o${eventName.toLowerCase()}`;
	return prefixes;
}
function getVendorPrefixes(domSupport, win) {
	const prefixes = {
		animationend: makePrefixMap("Animation", "AnimationEnd"),
		transitionend: makePrefixMap("Transition", "TransitionEnd")
	};
	if (domSupport) {
		if (!("AnimationEvent" in win)) delete prefixes.animationend.animation;
		if (!("TransitionEvent" in win)) delete prefixes.transitionend.transition;
	}
	return prefixes;
}
var vendorPrefixes = getVendorPrefixes(canUseDom(), typeof window !== "undefined" ? window : {});
var style = {};
if (canUseDom()) ({style} = document.createElement("div"));
var prefixedEventNames = {};
function getVendorPrefixedEventName(eventName) {
	if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
	const prefixMap = vendorPrefixes[eventName];
	if (prefixMap) {
		const stylePropList = Object.keys(prefixMap);
		const len = stylePropList.length;
		for (let i = 0; i < len; i += 1) {
			const styleProp = stylePropList[i];
			if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {
				prefixedEventNames[eventName] = prefixMap[styleProp];
				return prefixedEventNames[eventName];
			}
		}
	}
	return "";
}
var internalAnimationEndName = getVendorPrefixedEventName("animationend");
var internalTransitionEndName = getVendorPrefixedEventName("transitionend");
const supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
const animationEndName = internalAnimationEndName || "animationend";
const transitionEndName = internalTransitionEndName || "transitionend";
function getTransitionName$1(transitionName, transitionType) {
	if (!transitionName) return null;
	if (typeof transitionName === "object") return transitionName[transitionType.replace(/-\w/g, (match$2) => match$2[1].toUpperCase())];
	return `${transitionName}-${transitionType}`;
}

//#endregion
//#region node_modules/@rc-component/motion/es/hooks/useDomMotionEvents.js
var useDomMotionEvents_default = ((onInternalMotionEnd) => {
	const cacheElementRef = (0, import_react.useRef)();
	function removeMotionEvents(element) {
		if (element) {
			element.removeEventListener(transitionEndName, onInternalMotionEnd);
			element.removeEventListener(animationEndName, onInternalMotionEnd);
		}
	}
	function patchMotionEvents(element) {
		if (cacheElementRef.current && cacheElementRef.current !== element) removeMotionEvents(cacheElementRef.current);
		if (element && element !== cacheElementRef.current) {
			element.addEventListener(transitionEndName, onInternalMotionEnd);
			element.addEventListener(animationEndName, onInternalMotionEnd);
			cacheElementRef.current = element;
		}
	}
	import_react.useEffect(() => () => {
		removeMotionEvents(cacheElementRef.current);
		cacheElementRef.current = null;
	}, []);
	return [patchMotionEvents, removeMotionEvents];
});

//#endregion
//#region node_modules/@rc-component/motion/es/hooks/useIsomorphicLayoutEffect.js
var useIsomorphicLayoutEffect = canUseDom() ? import_react.useLayoutEffect : import_react.useEffect;
var useIsomorphicLayoutEffect_default = useIsomorphicLayoutEffect;

//#endregion
//#region node_modules/@rc-component/motion/es/hooks/useNextFrame.js
var useNextFrame_default = (() => {
	const nextFrameRef = import_react.useRef(null);
	function cancelNextFrame() {
		raf_default.cancel(nextFrameRef.current);
	}
	function nextFrame(callback, delay = 2) {
		cancelNextFrame();
		const nextFrameId = raf_default(() => {
			if (delay <= 1) callback({ isCanceled: () => nextFrameId !== nextFrameRef.current });
			else nextFrame(callback, delay - 1);
		});
		nextFrameRef.current = nextFrameId;
	}
	import_react.useEffect(() => () => {
		cancelNextFrame();
	}, []);
	return [nextFrame, cancelNextFrame];
});

//#endregion
//#region node_modules/@rc-component/motion/es/hooks/useStepQueue.js
var FULL_STEP_QUEUE = [
	STEP_PREPARE,
	STEP_START,
	STEP_ACTIVE,
	STEP_ACTIVATED
];
var SIMPLE_STEP_QUEUE = [STEP_PREPARE, STEP_PREPARED];
/** Skip current step */
const SkipStep = false;
/** Current step should be update in */
const DoStep = true;
function isActive(step) {
	return step === STEP_ACTIVE || step === STEP_ACTIVATED;
}
var useStepQueue_default = ((status, prepareOnly, callback) => {
	const [step, setStep] = useSafeState(STEP_NONE);
	const [nextFrame, cancelNextFrame] = useNextFrame_default();
	function startQueue() {
		setStep(STEP_PREPARE, true);
	}
	const STEP_QUEUE = prepareOnly ? SIMPLE_STEP_QUEUE : FULL_STEP_QUEUE;
	useIsomorphicLayoutEffect_default(() => {
		if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
			const nextStep = STEP_QUEUE[STEP_QUEUE.indexOf(step) + 1];
			const result = callback(step);
			if (result === SkipStep) setStep(nextStep, true);
			else if (nextStep) nextFrame((info) => {
				function doNext() {
					if (info.isCanceled()) return;
					setStep(nextStep, true);
				}
				if (result === true) doNext();
				else Promise.resolve(result).then(doNext);
			});
		}
	}, [status, step]);
	import_react.useEffect(() => () => {
		cancelNextFrame();
	}, []);
	return [startQueue, step];
});

//#endregion
//#region node_modules/@rc-component/motion/es/hooks/useStatus.js
function useStatus$1(supportMotion, visible, getElement, { motionEnter = true, motionAppear = true, motionLeave = true, motionDeadline, motionLeaveImmediately, onAppearPrepare, onEnterPrepare, onLeavePrepare, onAppearStart, onEnterStart, onLeaveStart, onAppearActive, onEnterActive, onLeaveActive, onAppearEnd, onEnterEnd, onLeaveEnd, onVisibleChanged }) {
	const [asyncVisible, setAsyncVisible] = useSafeState();
	const [getStatus$1, setStatus] = useSyncState$3(STATUS_NONE);
	const [style$1, setStyle] = useSafeState(null);
	const currentStatus = getStatus$1();
	const mountedRef = (0, import_react.useRef)(false);
	const deadlineRef = (0, import_react.useRef)(null);
	function getDomElement() {
		return getElement();
	}
	const activeRef = (0, import_react.useRef)(false);
	/**
	* Clean up status & style
	*/
	function updateMotionEndStatus() {
		setStatus(STATUS_NONE);
		setStyle(null, true);
	}
	const onInternalMotionEnd = useEvent_default((event) => {
		const status = getStatus$1();
		if (status === STATUS_NONE) return;
		const element = getDomElement();
		if (event && !event.deadline && event.target !== element) return;
		const currentActive = activeRef.current;
		let canEnd;
		if (status === STATUS_APPEAR && currentActive) canEnd = onAppearEnd?.(element, event);
		else if (status === STATUS_ENTER && currentActive) canEnd = onEnterEnd?.(element, event);
		else if (status === STATUS_LEAVE && currentActive) canEnd = onLeaveEnd?.(element, event);
		if (currentActive && canEnd !== false) updateMotionEndStatus();
	});
	const [patchMotionEvents] = useDomMotionEvents_default(onInternalMotionEnd);
	const getEventHandlers = (targetStatus) => {
		switch (targetStatus) {
			case STATUS_APPEAR: return {
				[STEP_PREPARE]: onAppearPrepare,
				[STEP_START]: onAppearStart,
				[STEP_ACTIVE]: onAppearActive
			};
			case STATUS_ENTER: return {
				[STEP_PREPARE]: onEnterPrepare,
				[STEP_START]: onEnterStart,
				[STEP_ACTIVE]: onEnterActive
			};
			case STATUS_LEAVE: return {
				[STEP_PREPARE]: onLeavePrepare,
				[STEP_START]: onLeaveStart,
				[STEP_ACTIVE]: onLeaveActive
			};
			default: return {};
		}
	};
	const eventHandlers = import_react.useMemo(() => getEventHandlers(currentStatus), [currentStatus]);
	const [startStep, step] = useStepQueue_default(currentStatus, !supportMotion, (newStep) => {
		if (newStep === STEP_PREPARE) {
			const onPrepare = eventHandlers[STEP_PREPARE];
			if (!onPrepare) return SkipStep;
			return onPrepare(getDomElement());
		}
		if (step in eventHandlers) setStyle(eventHandlers[step]?.(getDomElement(), null) || null);
		if (step === STEP_ACTIVE && currentStatus !== STATUS_NONE) {
			patchMotionEvents(getDomElement());
			if (motionDeadline > 0) {
				clearTimeout(deadlineRef.current);
				deadlineRef.current = setTimeout(() => {
					onInternalMotionEnd({ deadline: true });
				}, motionDeadline);
			}
		}
		if (step === STEP_PREPARED) updateMotionEndStatus();
		return DoStep;
	});
	activeRef.current = isActive(step);
	const visibleRef = (0, import_react.useRef)(null);
	useIsomorphicLayoutEffect_default(() => {
		if (mountedRef.current && visibleRef.current === visible) return;
		setAsyncVisible(visible);
		const isMounted = mountedRef.current;
		mountedRef.current = true;
		let nextStatus;
		if (!isMounted && visible && motionAppear) nextStatus = STATUS_APPEAR;
		if (isMounted && visible && motionEnter) nextStatus = STATUS_ENTER;
		if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) nextStatus = STATUS_LEAVE;
		const nextEventHandlers = getEventHandlers(nextStatus);
		if (nextStatus && (supportMotion || nextEventHandlers[STEP_PREPARE])) {
			setStatus(nextStatus);
			startStep();
		} else setStatus(STATUS_NONE);
		visibleRef.current = visible;
	}, [visible]);
	(0, import_react.useEffect)(() => {
		if (currentStatus === STATUS_APPEAR && !motionAppear || currentStatus === STATUS_ENTER && !motionEnter || currentStatus === STATUS_LEAVE && !motionLeave) setStatus(STATUS_NONE);
	}, [
		motionAppear,
		motionEnter,
		motionLeave
	]);
	(0, import_react.useEffect)(() => () => {
		mountedRef.current = false;
		clearTimeout(deadlineRef.current);
	}, []);
	const firstMountChangeRef = import_react.useRef(false);
	(0, import_react.useEffect)(() => {
		if (asyncVisible) firstMountChangeRef.current = true;
		if (asyncVisible !== void 0 && currentStatus === STATUS_NONE) {
			if (firstMountChangeRef.current || asyncVisible) onVisibleChanged?.(asyncVisible);
			firstMountChangeRef.current = true;
		}
	}, [asyncVisible, currentStatus]);
	let mergedStyle = style$1;
	if (eventHandlers[STEP_PREPARE] && step === STEP_START) mergedStyle = {
		transition: "none",
		...mergedStyle
	};
	return [
		getStatus$1,
		step,
		mergedStyle,
		asyncVisible ?? visible
	];
}

//#endregion
//#region node_modules/@rc-component/motion/es/CSSMotion.js
/**
* `transitionSupport` is used for none transition test case.
* Default we use browser transition event support check.
*/
function genCSSMotion(config) {
	let transitionSupport = config;
	if (typeof config === "object") ({transitionSupport} = config);
	function isSupportTransition(props, contextMotion) {
		return !!(props.motionName && transitionSupport && contextMotion !== false);
	}
	const CSSMotion = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
		const { visible = true, removeOnLeave = true, forceRender, children, motionName, leavedClassName, eventProps } = props;
		const { motion: contextMotion } = import_react.useContext(Context$1);
		const supportMotion = isSupportTransition(props, contextMotion);
		const nodeRef = (0, import_react.useRef)();
		function getDomElement() {
			return getDOM(nodeRef.current);
		}
		const [getStatus$1, statusStep, statusStyle, mergedVisible] = useStatus$1(supportMotion, visible, getDomElement, props);
		const status = getStatus$1();
		const renderedRef = import_react.useRef(mergedVisible);
		if (mergedVisible) renderedRef.current = true;
		const refObj = import_react.useMemo(() => {
			const obj = {};
			Object.defineProperties(obj, {
				nativeElement: {
					enumerable: true,
					get: getDomElement
				},
				inMotion: {
					enumerable: true,
					get: () => () => getStatus$1() !== STATUS_NONE
				},
				enableMotion: {
					enumerable: true,
					get: () => () => supportMotion
				}
			});
			return obj;
		}, []);
		import_react.useImperativeHandle(ref, () => refObj, []);
		let motionChildren;
		const mergedProps = {
			...eventProps,
			visible
		};
		if (!children) motionChildren = null;
		else if (status === STATUS_NONE) if (mergedVisible) motionChildren = children({ ...mergedProps }, nodeRef);
		else if (!removeOnLeave && renderedRef.current && leavedClassName) motionChildren = children({
			...mergedProps,
			className: leavedClassName
		}, nodeRef);
		else if (forceRender || !removeOnLeave && !leavedClassName) motionChildren = children({
			...mergedProps,
			style: { display: "none" }
		}, nodeRef);
		else motionChildren = null;
		else {
			let statusSuffix;
			if (statusStep === STEP_PREPARE) statusSuffix = "prepare";
			else if (isActive(statusStep)) statusSuffix = "active";
			else if (statusStep === STEP_START) statusSuffix = "start";
			const motionCls = getTransitionName$1(motionName, `${status}-${statusSuffix}`);
			motionChildren = children({
				...mergedProps,
				className: clsx(getTransitionName$1(motionName, status), {
					[motionCls]: motionCls && statusSuffix,
					[motionName]: typeof motionName === "string"
				}),
				style: statusStyle
			}, nodeRef);
		}
		if (/* @__PURE__ */ import_react.isValidElement(motionChildren) && supportRef(motionChildren)) {
			if (!getNodeRef(motionChildren)) motionChildren = /* @__PURE__ */ import_react.cloneElement(motionChildren, { ref: nodeRef });
		}
		return motionChildren;
	});
	CSSMotion.displayName = "CSSMotion";
	return CSSMotion;
}
var CSSMotion_default = genCSSMotion(supportTransition);

//#endregion
//#region node_modules/@rc-component/motion/es/util/diff.js
const STATUS_ADD = "add";
const STATUS_KEEP = "keep";
const STATUS_REMOVE = "remove";
const STATUS_REMOVED = "removed";
function wrapKeyToObject(key) {
	let keyObj;
	if (key && typeof key === "object" && "key" in key) keyObj = key;
	else keyObj = { key };
	return {
		...keyObj,
		key: String(keyObj.key)
	};
}
function parseKeys(keys$1 = []) {
	return keys$1.map(wrapKeyToObject);
}
function diffKeys(prevKeys = [], currentKeys = []) {
	let list = [];
	let currentIndex = 0;
	const currentLen = currentKeys.length;
	const prevKeyObjects = parseKeys(prevKeys);
	const currentKeyObjects = parseKeys(currentKeys);
	prevKeyObjects.forEach((keyObj) => {
		let hit = false;
		for (let i = currentIndex; i < currentLen; i += 1) {
			const currentKeyObj = currentKeyObjects[i];
			if (currentKeyObj.key === keyObj.key) {
				if (currentIndex < i) {
					list = list.concat(currentKeyObjects.slice(currentIndex, i).map((obj) => ({
						...obj,
						status: STATUS_ADD
					})));
					currentIndex = i;
				}
				list.push({
					...currentKeyObj,
					status: STATUS_KEEP
				});
				currentIndex += 1;
				hit = true;
				break;
			}
		}
		if (!hit) list.push({
			...keyObj,
			status: STATUS_REMOVE
		});
	});
	if (currentIndex < currentLen) list = list.concat(currentKeyObjects.slice(currentIndex).map((obj) => ({
		...obj,
		status: STATUS_ADD
	})));
	/**
	* Merge same key when it remove and add again:
	*    [1 - add, 2 - keep, 1 - remove] -> [1 - keep, 2 - keep]
	*/
	const keys$1 = {};
	list.forEach(({ key }) => {
		keys$1[key] = (keys$1[key] || 0) + 1;
	});
	Object.keys(keys$1).filter((key) => keys$1[key] > 1).forEach((matchKey) => {
		list = list.filter(({ key, status }) => key !== matchKey || status !== STATUS_REMOVE);
		list.forEach((node$1) => {
			if (node$1.key === matchKey) node$1.status = STATUS_KEEP;
		});
	});
	return list;
}

//#endregion
//#region node_modules/@rc-component/motion/es/CSSMotionList.js
function _extends$98() {
	_extends$98 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$98.apply(this, arguments);
}
var MOTION_PROP_NAMES = [
	"eventProps",
	"visible",
	"children",
	"motionName",
	"motionAppear",
	"motionEnter",
	"motionLeave",
	"motionLeaveImmediately",
	"motionDeadline",
	"removeOnLeave",
	"leavedClassName",
	"onAppearPrepare",
	"onAppearStart",
	"onAppearActive",
	"onAppearEnd",
	"onEnterStart",
	"onEnterActive",
	"onEnterEnd",
	"onLeaveStart",
	"onLeaveActive",
	"onLeaveEnd"
];
/**
* Generate a CSSMotionList component with config
* @param transitionSupport No need since CSSMotionList no longer depends on transition support
* @param CSSMotion CSSMotion component
*/
function genCSSMotionList(transitionSupport, CSSMotion = CSSMotion_default) {
	class CSSMotionList extends import_react.Component {
		static defaultProps = { component: "div" };
		state = { keyEntities: [] };
		static getDerivedStateFromProps({ keys: keys$1 }, { keyEntities }) {
			return { keyEntities: diffKeys(keyEntities, parseKeys(keys$1)).filter((entity) => {
				const prevEntity = keyEntities.find(({ key }) => entity.key === key);
				if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) return false;
				return true;
			}) };
		}
		removeKey = (removeKey) => {
			this.setState((prevState) => {
				return { keyEntities: prevState.keyEntities.map((entity) => {
					if (entity.key !== removeKey) return entity;
					return {
						...entity,
						status: STATUS_REMOVED
					};
				}) };
			}, () => {
				const { keyEntities } = this.state;
				if (keyEntities.filter(({ status }) => status !== STATUS_REMOVED).length === 0 && this.props.onAllRemoved) this.props.onAllRemoved();
			});
		};
		render() {
			const { keyEntities } = this.state;
			const { component, children, onVisibleChanged, onAllRemoved, ...restProps } = this.props;
			const Component$2 = component || import_react.Fragment;
			const motionProps = {};
			MOTION_PROP_NAMES.forEach((prop) => {
				motionProps[prop] = restProps[prop];
				delete restProps[prop];
			});
			delete restProps.keys;
			return /* @__PURE__ */ import_react.createElement(Component$2, restProps, keyEntities.map(({ status, ...eventProps }, index$1) => {
				const visible = status === STATUS_ADD || status === STATUS_KEEP;
				return /* @__PURE__ */ import_react.createElement(CSSMotion, _extends$98({}, motionProps, {
					key: eventProps.key,
					visible,
					eventProps,
					onVisibleChanged: (changedVisible) => {
						onVisibleChanged?.(changedVisible, { key: eventProps.key });
						if (!changedVisible) this.removeKey(eventProps.key);
					}
				}), (props, ref) => children({
					...props,
					index: index$1
				}, ref));
			}));
		}
	}
	return CSSMotionList;
}
var CSSMotionList_default = genCSSMotionList(supportTransition);

//#endregion
//#region node_modules/@rc-component/motion/es/index.js
var es_default$1 = CSSMotion_default;

//#endregion
//#region node_modules/@rc-component/util/es/pickAttrs.js
var propList = `accept acceptCharset accessKey action allowFullScreen allowTransparency
    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge
    charSet checked classID className colSpan cols content contentEditable contextMenu
    controls coords crossOrigin data dateTime default defer dir disabled download draggable
    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder
    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity
    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media
    mediaGroup method min minLength multiple muted name noValidate nonce open
    optimum pattern placeholder poster preload radioGroup readOnly rel required
    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected
    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style
    summary tabIndex target title type useMap value width wmode wrap onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown
    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick
    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown
    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel
    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough
    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata
    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError`.split(/[\s\n]+/);
var ariaPrefix = "aria-";
var dataPrefix = "data-";
function match(key, prefix$1) {
	return key.indexOf(prefix$1) === 0;
}
/**
* Picker props from exist props with filter
* @param props Passed props
* @param ariaOnly boolean | { aria?: boolean; data?: boolean; attr?: boolean; } filter config
*/
function pickAttrs(props, ariaOnly = false) {
	let mergedConfig;
	if (ariaOnly === false) mergedConfig = {
		aria: true,
		data: true,
		attr: true
	};
	else if (ariaOnly === true) mergedConfig = { aria: true };
	else mergedConfig = { ...ariaOnly };
	const attrs = {};
	Object.keys(props).forEach((key) => {
		if (mergedConfig.aria && (key === "role" || match(key, ariaPrefix)) || mergedConfig.data && match(key, dataPrefix) || mergedConfig.attr && propList.includes(key)) attrs[key] = props[key];
	});
	return attrs;
}

//#endregion
//#region node_modules/@rc-component/pagination/es/locale/en_US.js
var locale$4 = {
	items_per_page: "/ page",
	jump_to: "Go to",
	jump_to_confirm: "confirm",
	page: "Page",
	prev_page: "Previous Page",
	next_page: "Next Page",
	prev_5: "Previous 5 Pages",
	next_5: "Next 5 Pages",
	prev_3: "Previous 3 Pages",
	next_3: "Next 3 Pages",
	page_size: "Page Size"
};
var en_US_default$1 = locale$4;

//#endregion
//#region node_modules/@rc-component/picker/es/locale/common.js
var commonLocale = {
	yearFormat: "YYYY",
	dayFormat: "D",
	cellMeridiemFormat: "A",
	monthBeforeYear: true
};

//#endregion
//#region node_modules/@rc-component/picker/es/locale/en_US.js
function _typeof$30(o$2) {
	"@babel/helpers - typeof";
	return _typeof$30 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$30(o$2);
}
function ownKeys$17(e$2, r$1) {
	var t$1 = Object.keys(e$2);
	if (Object.getOwnPropertySymbols) {
		var o$2 = Object.getOwnPropertySymbols(e$2);
		r$1 && (o$2 = o$2.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e$2, r$2).enumerable;
		})), t$1.push.apply(t$1, o$2);
	}
	return t$1;
}
function _objectSpread$17(e$2) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$17(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$28(e$2, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$2, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$17(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e$2, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e$2;
}
function _defineProperty$28(obj, key, value) {
	key = _toPropertyKey$27(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$27(t$1) {
	var i = _toPrimitive$27(t$1, "string");
	return "symbol" == _typeof$30(i) ? i : String(i);
}
function _toPrimitive$27(t$1, r$1) {
	if ("object" != _typeof$30(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$30(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var locale$3 = _objectSpread$17(_objectSpread$17({}, commonLocale), {}, {
	locale: "en_US",
	today: "Today",
	now: "Now",
	backToToday: "Back to today",
	ok: "OK",
	clear: "Clear",
	week: "Week",
	month: "Month",
	year: "Year",
	timeSelect: "select time",
	dateSelect: "select date",
	weekSelect: "Choose a week",
	monthSelect: "Choose a month",
	yearSelect: "Choose a year",
	decadeSelect: "Choose a decade",
	previousMonth: "Previous month (PageUp)",
	nextMonth: "Next month (PageDown)",
	previousYear: "Last year (Control + left)",
	nextYear: "Next year (Control + right)",
	previousDecade: "Last decade",
	nextDecade: "Next decade",
	previousCentury: "Last century",
	nextCentury: "Next century"
});
var en_US_default$5 = locale$3;

//#endregion
//#region node_modules/antd/es/time-picker/locale/en_US.js
var locale$2 = {
	placeholder: "Select time",
	rangePlaceholder: ["Start time", "End time"]
};
var en_US_default$4 = locale$2;

//#endregion
//#region node_modules/antd/es/date-picker/locale/en_US.js
var locale$1 = {
	lang: {
		placeholder: "Select date",
		yearPlaceholder: "Select year",
		quarterPlaceholder: "Select quarter",
		monthPlaceholder: "Select month",
		weekPlaceholder: "Select week",
		rangePlaceholder: ["Start date", "End date"],
		rangeYearPlaceholder: ["Start year", "End year"],
		rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
		rangeMonthPlaceholder: ["Start month", "End month"],
		rangeWeekPlaceholder: ["Start week", "End week"],
		...en_US_default$5
	},
	timePickerLocale: { ...en_US_default$4 }
};
var en_US_default$2 = locale$1;

//#endregion
//#region node_modules/antd/es/calendar/locale/en_US.js
var en_US_default$3 = en_US_default$2;

//#endregion
//#region node_modules/antd/es/locale/en_US.js
var typeTemplate$1 = "${label} is not a valid ${type}";
var localeValues = {
	locale: "en",
	Pagination: en_US_default$1,
	DatePicker: en_US_default$2,
	TimePicker: en_US_default$4,
	Calendar: en_US_default$3,
	global: {
		placeholder: "Please select",
		close: "Close",
		sortable: "sortable"
	},
	Table: {
		filterTitle: "Filter menu",
		filterConfirm: "OK",
		filterReset: "Reset",
		filterEmptyText: "No filters",
		filterCheckAll: "Select all items",
		filterSearchPlaceholder: "Search in filters",
		emptyText: "No data",
		selectAll: "Select current page",
		selectInvert: "Invert current page",
		selectNone: "Clear all data",
		selectionAll: "Select all data",
		sortTitle: "Sort",
		expand: "Expand row",
		collapse: "Collapse row",
		triggerDesc: "Click to sort descending",
		triggerAsc: "Click to sort ascending",
		cancelSort: "Click to cancel sorting"
	},
	Tour: {
		Next: "Next",
		Previous: "Previous",
		Finish: "Finish"
	},
	Modal: {
		okText: "OK",
		cancelText: "Cancel",
		justOkText: "OK"
	},
	Popconfirm: {
		okText: "OK",
		cancelText: "Cancel"
	},
	Transfer: {
		titles: ["", ""],
		searchPlaceholder: "Search here",
		itemUnit: "item",
		itemsUnit: "items",
		remove: "Remove",
		selectCurrent: "Select current page",
		removeCurrent: "Remove current page",
		selectAll: "Select all data",
		deselectAll: "Deselect all data",
		removeAll: "Remove all data",
		selectInvert: "Invert current page"
	},
	Upload: {
		uploading: "Uploading...",
		removeFile: "Remove file",
		uploadError: "Upload error",
		previewFile: "Preview file",
		downloadFile: "Download file"
	},
	Empty: { description: "No data" },
	Icon: { icon: "icon" },
	Text: {
		edit: "Edit",
		copy: "Copy",
		copied: "Copied",
		expand: "Expand",
		collapse: "Collapse"
	},
	Form: {
		optional: "(optional)",
		defaultValidateMessages: {
			default: "Field validation error for ${label}",
			required: "Please enter ${label}",
			enum: "${label} must be one of [${enum}]",
			whitespace: "${label} cannot be a blank character",
			date: {
				format: "${label} date format is invalid",
				parse: "${label} cannot be converted to a date",
				invalid: "${label} is an invalid date"
			},
			types: {
				string: typeTemplate$1,
				method: typeTemplate$1,
				array: typeTemplate$1,
				object: typeTemplate$1,
				number: typeTemplate$1,
				date: typeTemplate$1,
				boolean: typeTemplate$1,
				integer: typeTemplate$1,
				float: typeTemplate$1,
				regexp: typeTemplate$1,
				email: typeTemplate$1,
				url: typeTemplate$1,
				hex: typeTemplate$1
			},
			string: {
				len: "${label} must be ${len} characters",
				min: "${label} must be at least ${min} characters",
				max: "${label} must be up to ${max} characters",
				range: "${label} must be between ${min}-${max} characters"
			},
			number: {
				len: "${label} must be equal to ${len}",
				min: "${label} must be minimum ${min}",
				max: "${label} must be maximum ${max}",
				range: "${label} must be between ${min}-${max}"
			},
			array: {
				len: "Must be ${len} ${label}",
				min: "At least ${min} ${label}",
				max: "At most ${max} ${label}",
				range: "The amount of ${label} must be between ${min}-${max}"
			},
			pattern: { mismatch: "${label} does not match the pattern ${pattern}" }
		}
	},
	QRCode: {
		expired: "QR code expired",
		refresh: "Refresh",
		scanned: "Scanned"
	},
	ColorPicker: {
		presetEmpty: "Empty",
		transparent: "Transparent",
		singleColor: "Single",
		gradientColor: "Gradient"
	}
};
var en_US_default = localeValues;

//#endregion
//#region node_modules/antd/es/modal/locale.js
var runtimeLocale = { ...en_US_default.Modal };
var localeList = [];
var generateLocale = () => localeList.reduce((merged, locale$5) => ({
	...merged,
	...locale$5
}), en_US_default.Modal);
function changeConfirmLocale(newLocale) {
	if (newLocale) {
		const cloneLocale = { ...newLocale };
		localeList.push(cloneLocale);
		runtimeLocale = generateLocale();
		return () => {
			localeList = localeList.filter((locale$5) => locale$5 !== cloneLocale);
			runtimeLocale = generateLocale();
		};
	}
	runtimeLocale = { ...en_US_default.Modal };
}
function getConfirmLocale() {
	return runtimeLocale;
}

//#endregion
//#region node_modules/antd/es/locale/context.js
var LocaleContext = /* @__PURE__ */ (0, import_react.createContext)(void 0);
var context_default$9 = LocaleContext;

//#endregion
//#region node_modules/antd/es/locale/useLocale.js
var useLocale$1 = (componentName, defaultLocale) => {
	const fullLocale = import_react.useContext(context_default$9);
	return [import_react.useMemo(() => {
		const locale$5 = defaultLocale || en_US_default[componentName];
		const localeFromContext = fullLocale?.[componentName] ?? {};
		return {
			...typeof locale$5 === "function" ? locale$5() : locale$5,
			...localeFromContext || {}
		};
	}, [
		componentName,
		defaultLocale,
		fullLocale
	]), import_react.useMemo(() => {
		const localeCode = fullLocale?.locale;
		if (fullLocale?.exist && !localeCode) return en_US_default.locale;
		return localeCode;
	}, [fullLocale])];
};
var useLocale_default = useLocale$1;

//#endregion
//#region node_modules/antd/es/locale/index.js
const ANT_MARK = "internalMark";
var LocaleProvider = (props) => {
	const { locale: locale$5 = {}, children, _ANT_MARK__ } = props;
	devUseWarning("LocaleProvider")(_ANT_MARK__ === ANT_MARK, "deprecated", "`LocaleProvider` is deprecated. Please use `locale` with `ConfigProvider` instead: http://u.ant.design/locale");
	import_react.useEffect(() => {
		return changeConfirmLocale(locale$5?.Modal);
	}, [locale$5]);
	const getMemoizedContextValue = import_react.useMemo(() => ({
		...locale$5,
		exist: true
	}), [locale$5]);
	return /* @__PURE__ */ import_react.createElement(context_default$9.Provider, { value: getMemoizedContextValue }, children);
};
LocaleProvider.displayName = "LocaleProvider";
var locale_default = LocaleProvider;

//#endregion
//#region node_modules/antd/es/_util/extendsObject.js
function mergeProps$1(...items) {
	const ret = {};
	items.forEach((item) => {
		if (item) Object.keys(item).forEach((key) => {
			if (item[key] !== void 0) ret[key] = item[key];
		});
	});
	return ret;
}
var extendsObject_default = mergeProps$1;

//#endregion
//#region node_modules/antd/es/_util/isNonNullable.js
var isNonNullable = (val) => {
	return val !== void 0 && val !== null;
};
var isNonNullable_default = isNonNullable;

//#endregion
//#region node_modules/antd/es/_util/hooks/useClosable.js
const pickClosable = (context) => {
	if (!context) return;
	const { closable, closeIcon } = context;
	return {
		closable,
		closeIcon
	};
};
var EmptyFallbackCloseCollection = {};
var computeClosableConfig = (closable, closeIcon) => {
	if (!closable && (closable === false || closeIcon === false || closeIcon === null)) return false;
	if (closable === void 0 && closeIcon === void 0) return null;
	let closableConfig = { closeIcon: typeof closeIcon !== "boolean" && closeIcon !== null ? closeIcon : void 0 };
	if (closable && typeof closable === "object") closableConfig = {
		...closableConfig,
		...closable
	};
	return closableConfig;
};
var mergeClosableConfigs = (propConfig, contextConfig, fallbackConfig) => {
	if (propConfig === false) return false;
	if (propConfig) return extendsObject_default(fallbackConfig, contextConfig, propConfig);
	if (contextConfig === false) return false;
	if (contextConfig) return extendsObject_default(fallbackConfig, contextConfig);
	return fallbackConfig.closable ? fallbackConfig : false;
};
var computeCloseIcon = (mergedConfig, fallbackCloseCollection, closeLabel) => {
	const { closeIconRender } = fallbackCloseCollection;
	const { closeIcon, ...restConfig } = mergedConfig;
	let finalCloseIcon = closeIcon;
	const ariaOrDataProps = pickAttrs(restConfig, true);
	if (isNonNullable_default(finalCloseIcon)) {
		if (closeIconRender) finalCloseIcon = closeIconRender(finalCloseIcon);
		finalCloseIcon = /* @__PURE__ */ import_react.isValidElement(finalCloseIcon) ? /* @__PURE__ */ import_react.cloneElement(finalCloseIcon, {
			"aria-label": closeLabel,
			...finalCloseIcon.props,
			...ariaOrDataProps
		}) : /* @__PURE__ */ import_react.createElement("span", {
			"aria-label": closeLabel,
			...ariaOrDataProps
		}, finalCloseIcon);
	}
	return [finalCloseIcon, ariaOrDataProps];
};
const computeClosable = (propCloseCollection, contextCloseCollection, fallbackCloseCollection = EmptyFallbackCloseCollection, closeLabel = "Close") => {
	const propConfig = computeClosableConfig(propCloseCollection?.closable, propCloseCollection?.closeIcon);
	const contextConfig = computeClosableConfig(contextCloseCollection?.closable, contextCloseCollection?.closeIcon);
	const mergedFallback = {
		closeIcon: /* @__PURE__ */ import_react.createElement(CloseOutlined_default, null),
		...fallbackCloseCollection
	};
	const mergedConfig = mergeClosableConfigs(propConfig, contextConfig, mergedFallback);
	const closeBtnIsDisabled = typeof mergedConfig !== "boolean" ? !!mergedConfig?.disabled : false;
	if (mergedConfig === false) return [
		false,
		null,
		closeBtnIsDisabled,
		{}
	];
	const [closeIcon, ariaProps] = computeCloseIcon(mergedConfig, mergedFallback, closeLabel);
	return [
		true,
		closeIcon,
		closeBtnIsDisabled,
		ariaProps
	];
};
const useClosable = (propCloseCollection, contextCloseCollection, fallbackCloseCollection = EmptyFallbackCloseCollection) => {
	const [contextLocale] = useLocale_default("global", en_US_default.global);
	return import_react.useMemo(() => {
		return computeClosable(propCloseCollection, contextCloseCollection, {
			closeIcon: /* @__PURE__ */ import_react.createElement(CloseOutlined_default, null),
			...fallbackCloseCollection
		}, contextLocale.close);
	}, [
		propCloseCollection,
		contextCloseCollection,
		fallbackCloseCollection,
		contextLocale.close
	]);
};

//#endregion
//#region node_modules/antd/es/_util/hooks/useForceUpdate.js
const useForceUpdate = () => {
	return import_react.useReducer((ori) => ori + 1, 0);
};

//#endregion
//#region node_modules/antd/es/_util/hooks/useMergedMask.js
var normalizeMaskConfig = (mask) => {
	if (mask && typeof mask === "object") return mask;
	if (typeof mask === "boolean") return {
		enabled: mask,
		blur: mask
	};
	return {};
};
const useMergedMask = (mask, contextMask, prefixCls) => {
	return (0, import_react.useMemo)(() => {
		const maskConfig = normalizeMaskConfig(mask);
		const mergedConfig = {
			...normalizeMaskConfig(contextMask),
			...maskConfig
		};
		const className = mergedConfig.blur !== false ? `${prefixCls}-mask-blur` : void 0;
		return [mergedConfig.enabled !== false, { mask: className }];
	}, [
		mask,
		contextMask,
		prefixCls
	]);
};

//#endregion
//#region node_modules/antd/es/_util/hooks/useMergeSemantic.js
const mergeClassNames = (schema, ...classNames) => {
	const mergedSchema = schema || {};
	return classNames.filter(Boolean).reduce((acc, cur) => {
		Object.keys(cur || {}).forEach((key) => {
			const keySchema = mergedSchema[key];
			const curVal = cur[key];
			if (keySchema && typeof keySchema === "object") if (curVal && typeof curVal === "object") acc[key] = mergeClassNames(keySchema, acc[key], curVal);
			else {
				const { _default: defaultField } = keySchema;
				if (defaultField) {
					acc[key] = acc[key] || {};
					acc[key][defaultField] = clsx(acc[key][defaultField], curVal);
				}
			}
			else acc[key] = clsx(acc[key], curVal);
		});
		return acc;
	}, {});
};
var useSemanticClassNames = (schema, ...classNames) => {
	return import_react.useMemo(() => mergeClassNames.apply(void 0, [schema].concat(classNames)), [schema].concat(classNames));
};
const mergeStyles = (...styles) => {
	return styles.filter(Boolean).reduce((acc, cur = {}) => {
		Object.keys(cur).forEach((key) => {
			acc[key] = {
				...acc[key],
				...cur[key]
			};
		});
		return acc;
	}, {});
};
var useSemanticStyles = (...styles) => {
	return import_react.useMemo(() => mergeStyles.apply(void 0, styles), [].concat(styles));
};
var fillObjectBySchema = (obj, schema) => {
	const newObj = { ...obj };
	Object.keys(schema).forEach((key) => {
		if (key !== "_default") {
			const nestSchema = schema[key];
			const nextValue = newObj[key] || {};
			newObj[key] = nestSchema ? fillObjectBySchema(nextValue, nestSchema) : nextValue;
		}
	});
	return newObj;
};
const resolveStyleOrClass = (value, info) => {
	return typeof value === "function" ? value(info) : value;
};
/**
* @desc Merge classNames and styles from multiple sources. When `schema` is provided, it **must** provide the nest object structure.
* @descZH  classNames  styles `schema` 
*/
const useMergeSemantic = (classNamesList, stylesList, info, schema) => {
	const resolvedClassNamesList = classNamesList.map((classNames) => classNames ? resolveStyleOrClass(classNames, info) : void 0);
	const resolvedStylesList = stylesList.map((styles) => styles ? resolveStyleOrClass(styles, info) : void 0);
	const mergedClassNames = useSemanticClassNames.apply(void 0, [schema].concat(_toConsumableArray(resolvedClassNamesList)));
	const mergedStyles = useSemanticStyles.apply(void 0, _toConsumableArray(resolvedStylesList));
	return import_react.useMemo(() => {
		if (!schema) return [mergedClassNames, mergedStyles];
		return [fillObjectBySchema(mergedClassNames, schema), fillObjectBySchema(mergedStyles, schema)];
	}, [
		mergedClassNames,
		mergedStyles,
		schema
	]);
};

//#endregion
//#region node_modules/antd/es/_util/hooks/useMultipleSelect.js
/**
* @title multipleSelect hooks
* @description multipleSelect by hold down shift key
*/
const useMultipleSelect = (getKey$3) => {
	const [prevSelectedIndex, setPrevSelectedIndex] = (0, import_react.useState)(null);
	return [(0, import_react.useCallback)((currentSelectedIndex, data, selectedKeys) => {
		const configPrevSelectedIndex = prevSelectedIndex ?? currentSelectedIndex;
		const startIndex = Math.min(configPrevSelectedIndex || 0, currentSelectedIndex);
		const endIndex = Math.max(configPrevSelectedIndex || 0, currentSelectedIndex);
		const rangeKeys = data.slice(startIndex, endIndex + 1).map(getKey$3);
		const shouldSelected = rangeKeys.some((rangeKey) => !selectedKeys.has(rangeKey));
		const changedKeys = [];
		rangeKeys.forEach((item) => {
			if (shouldSelected) {
				if (!selectedKeys.has(item)) changedKeys.push(item);
				selectedKeys.add(item);
			} else {
				selectedKeys.delete(item);
				changedKeys.push(item);
			}
		});
		setPrevSelectedIndex(shouldSelected ? endIndex : null);
		return changedKeys;
	}, [prevSelectedIndex]), setPrevSelectedIndex];
};

//#endregion
//#region node_modules/antd/es/_util/hooks/useOrientation.js
var isValidOrientation = (orientation) => {
	return orientation === "horizontal" || orientation === "vertical";
};
const useOrientation = (orientation, vertical, legacyDirection) => {
	return (0, import_react.useMemo)(() => {
		const validOrientation = isValidOrientation(orientation);
		let mergedOrientation;
		if (validOrientation) mergedOrientation = orientation;
		else if (typeof vertical === "boolean") mergedOrientation = vertical ? "vertical" : "horizontal";
		else mergedOrientation = isValidOrientation(legacyDirection) ? legacyDirection : "horizontal";
		return [mergedOrientation, mergedOrientation === "vertical"];
	}, [
		legacyDirection,
		orientation,
		vertical
	]);
};

//#endregion
//#region node_modules/antd/es/_util/hooks/usePatchElement.js
const usePatchElement = () => {
	const [elements, setElements] = import_react.useState([]);
	return [elements, import_react.useCallback((element) => {
		setElements((originElements) => [].concat(_toConsumableArray(originElements), [element]));
		return () => {
			setElements((originElements) => originElements.filter((ele) => ele !== element));
		};
	}, [])];
};

//#endregion
//#region node_modules/antd/es/_util/hooks/useProxyImperativeHandle.js
var fillProxy = (element, handler) => {
	element._antProxy = element._antProxy || {};
	Object.keys(handler).forEach((key) => {
		if (!(key in element._antProxy)) {
			const ori = element[key];
			element._antProxy[key] = ori;
			element[key] = handler[key];
		}
	});
	return element;
};
const useProxyImperativeHandle = (ref, init) => {
	return (0, import_react.useImperativeHandle)(ref, () => {
		const refObj = init();
		const { nativeElement } = refObj;
		if (typeof Proxy !== "undefined") return new Proxy(nativeElement, { get(obj, prop) {
			if (refObj[prop]) return refObj[prop];
			return Reflect.get(obj, prop);
		} });
		return fillProxy(nativeElement, refObj);
	});
};

//#endregion
//#region node_modules/antd/es/_util/hooks/useSyncState.js
const useSyncState = (initialValue) => {
	const ref = import_react.useRef(initialValue);
	const [, forceUpdate] = useForceUpdate();
	return [() => ref.current, (newValue) => {
		ref.current = newValue;
		forceUpdate();
	}];
};

//#endregion
//#region node_modules/antd/es/_util/zindexContext.js
var zIndexContext = /* @__PURE__ */ import_react.createContext(void 0);
zIndexContext.displayName = "zIndexContext";
var zindexContext_default = zIndexContext;

//#endregion
//#region node_modules/antd/es/_util/hooks/useZIndex.js
var CONTAINER_OFFSET = 100;
var CONTAINER_OFFSET_MAX_COUNT = 10;
const CONTAINER_MAX_OFFSET = CONTAINER_OFFSET * CONTAINER_OFFSET_MAX_COUNT;
/**
* Static function will default be the `CONTAINER_MAX_OFFSET`.
* But it still may have children component like Select, Dropdown.
* So the warning zIndex should exceed the `CONTAINER_MAX_OFFSET`.
*/
var CONTAINER_MAX_OFFSET_WITH_CHILDREN = CONTAINER_MAX_OFFSET + CONTAINER_OFFSET;
const containerBaseZIndexOffset = {
	Modal: CONTAINER_OFFSET,
	Drawer: CONTAINER_OFFSET,
	Popover: CONTAINER_OFFSET,
	Popconfirm: CONTAINER_OFFSET,
	Tooltip: CONTAINER_OFFSET,
	Tour: CONTAINER_OFFSET,
	FloatButton: CONTAINER_OFFSET
};
const consumerBaseZIndexOffset = {
	SelectLike: 50,
	Dropdown: 50,
	DatePicker: 50,
	Menu: 50,
	ImagePreview: 1
};
var isContainerType = (type$2) => {
	return type$2 in containerBaseZIndexOffset;
};
const useZIndex = (componentType, customZIndex) => {
	const [, token$1] = useToken();
	const parentZIndex = import_react.useContext(zindexContext_default);
	const isContainer = isContainerType(componentType);
	let result;
	if (customZIndex !== void 0) result = [customZIndex, customZIndex];
	else {
		let zIndex = parentZIndex ?? 0;
		if (isContainer) zIndex += (parentZIndex ? 0 : token$1.zIndexPopupBase) + containerBaseZIndexOffset[componentType];
		else zIndex += consumerBaseZIndexOffset[componentType];
		result = [parentZIndex === void 0 ? customZIndex : zIndex, zIndex];
	}
	{
		const warning$3 = devUseWarning(componentType);
		const maxZIndex = token$1.zIndexPopupBase + CONTAINER_MAX_OFFSET_WITH_CHILDREN;
		const currentZIndex = result[0] || 0;
		warning$3(customZIndex !== void 0 || currentZIndex <= maxZIndex, "usage", "`zIndex` is over design token `zIndexPopupBase` too much. It may cause unexpected override.");
	}
	return result;
};

//#endregion
//#region node_modules/antd/es/_util/reactNode.js
function isFragment(child) {
	return child && /* @__PURE__ */ import_react.isValidElement(child) && child.type === import_react.Fragment;
}
const replaceElement = (element, replacement, props) => {
	if (!/* @__PURE__ */ import_react.isValidElement(element)) return replacement;
	return /* @__PURE__ */ import_react.cloneElement(element, typeof props === "function" ? props(element.props || {}) : props);
};
function cloneElement(element, props) {
	return replaceElement(element, element, props);
}

//#endregion
//#region node_modules/antd/es/alert/style/index.js
var genAlertTypeStyle = (bgColor, borderColor, iconColor, token$1, alertCls) => ({
	background: bgColor,
	border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${borderColor}`,
	[`${alertCls}-icon`]: { color: iconColor }
});
const genBaseStyle$18 = (token$1) => {
	const { componentCls, motionDurationSlow: duration, marginXS, marginSM, fontSize, fontSizeLG, lineHeight, borderRadiusLG: borderRadius, motionEaseInOutCirc, withDescriptionIconSize, colorText, colorTextHeading, withDescriptionPadding, defaultPadding } = token$1;
	return {
		[componentCls]: {
			...resetComponent(token$1),
			position: "relative",
			display: "flex",
			alignItems: "center",
			padding: defaultPadding,
			wordWrap: "break-word",
			borderRadius,
			[`&${componentCls}-rtl`]: { direction: "rtl" },
			[`${componentCls}-section`]: {
				flex: 1,
				minWidth: 0
			},
			[`${componentCls}-icon`]: {
				marginInlineEnd: marginXS,
				lineHeight: 0
			},
			"&-description": {
				display: "none",
				fontSize,
				lineHeight
			},
			"&-title": { color: colorTextHeading },
			[`&${componentCls}-motion-leave`]: {
				overflow: "hidden",
				opacity: 1,
				transition: `max-height ${duration} ${motionEaseInOutCirc}, opacity ${duration} ${motionEaseInOutCirc},
        padding-top ${duration} ${motionEaseInOutCirc}, padding-bottom ${duration} ${motionEaseInOutCirc},
        margin-bottom ${duration} ${motionEaseInOutCirc}`
			},
			[`&${componentCls}-motion-leave-active`]: {
				maxHeight: 0,
				marginBottom: "0 !important",
				paddingTop: 0,
				paddingBottom: 0,
				opacity: 0
			}
		},
		[`${componentCls}-with-description`]: {
			alignItems: "flex-start",
			padding: withDescriptionPadding,
			[`${componentCls}-icon`]: {
				marginInlineEnd: marginSM,
				fontSize: withDescriptionIconSize,
				lineHeight: 0
			},
			[`${componentCls}-title`]: {
				display: "block",
				marginBottom: marginXS,
				color: colorTextHeading,
				fontSize: fontSizeLG
			},
			[`${componentCls}-description`]: {
				display: "block",
				color: colorText
			}
		},
		[`${componentCls}-banner`]: {
			marginBottom: 0,
			border: "0 !important",
			borderRadius: 0
		}
	};
};
const genTypeStyle = (token$1) => {
	const { componentCls, colorSuccess, colorSuccessBorder, colorSuccessBg, colorWarning, colorWarningBorder, colorWarningBg, colorError, colorErrorBorder, colorErrorBg, colorInfo, colorInfoBorder, colorInfoBg } = token$1;
	return { [componentCls]: {
		"&-success": genAlertTypeStyle(colorSuccessBg, colorSuccessBorder, colorSuccess, token$1, componentCls),
		"&-info": genAlertTypeStyle(colorInfoBg, colorInfoBorder, colorInfo, token$1, componentCls),
		"&-warning": genAlertTypeStyle(colorWarningBg, colorWarningBorder, colorWarning, token$1, componentCls),
		"&-error": {
			...genAlertTypeStyle(colorErrorBg, colorErrorBorder, colorError, token$1, componentCls),
			[`${componentCls}-description > pre`]: {
				margin: 0,
				padding: 0
			}
		}
	} };
};
const genActionStyle = (token$1) => {
	const { componentCls, iconCls, motionDurationMid, marginXS, fontSizeIcon, colorIcon, colorIconHover } = token$1;
	return { [componentCls]: {
		"&-actions": { marginInlineStart: marginXS },
		[`${componentCls}-close-icon`]: {
			marginInlineStart: marginXS,
			padding: 0,
			overflow: "hidden",
			fontSize: fontSizeIcon,
			lineHeight: unit(fontSizeIcon),
			backgroundColor: "transparent",
			border: "none",
			outline: "none",
			cursor: "pointer",
			[`${iconCls}-close`]: {
				color: colorIcon,
				transition: `color ${motionDurationMid}`,
				"&:hover": { color: colorIconHover }
			}
		},
		"&-close-text": {
			color: colorIcon,
			transition: `color ${motionDurationMid}`,
			"&:hover": { color: colorIconHover }
		}
	} };
};
const prepareComponentToken$56 = (token$1) => {
	return {
		withDescriptionIconSize: token$1.fontSizeHeading3,
		defaultPadding: `${token$1.paddingContentVerticalSM}px 12px`,
		withDescriptionPadding: `${token$1.paddingMD}px ${token$1.paddingContentHorizontalLG}px`
	};
};
var style_default$63 = genStyleHooks("Alert", (token$1) => [
	genBaseStyle$18(token$1),
	genTypeStyle(token$1),
	genActionStyle(token$1)
], prepareComponentToken$56);

//#endregion
//#region node_modules/antd/es/alert/Alert.js
var iconMapFilled = {
	success: CheckCircleFilled_default,
	info: InfoCircleFilled_default,
	error: CloseCircleFilled_default,
	warning: ExclamationCircleFilled_default
};
var IconNode = (props) => {
	const { icon, prefixCls, type: type$2, className, style: style$1 } = props;
	const iconType = iconMapFilled[type$2] || null;
	if (icon) return replaceElement(icon, /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-icon` }, icon), () => ({
		className: clsx(icon.props.className, className),
		style: style$1
	}));
	return /* @__PURE__ */ import_react.createElement(iconType, {
		className,
		style: style$1
	});
};
var CloseIconNode = (props) => {
	const { isClosable, prefixCls, closeIcon, handleClose, ariaProps, className, style: style$1 } = props;
	const mergedCloseIcon = closeIcon === true || closeIcon === void 0 ? /* @__PURE__ */ import_react.createElement(CloseOutlined_default, null) : closeIcon;
	return isClosable ? /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		onClick: handleClose,
		className: clsx(`${prefixCls}-close-icon`, className),
		tabIndex: 0,
		style: style$1,
		...ariaProps
	}, mergedCloseIcon) : null;
};
var Alert$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { description, prefixCls: customizePrefixCls, message: message$1, title, banner, className, rootClassName, style: style$1, onMouseEnter, onMouseLeave, onClick, afterClose, showIcon, closable, closeText, closeIcon, action, id, styles, classNames, ...otherProps } = props;
	const mergedTitle = title ?? message$1;
	const [closed, setClosed] = import_react.useState(false);
	{
		const warning$3 = devUseWarning("Alert");
		[["closeText", "closable.closeIcon"], ["message", "title"]].forEach(([deprecatedName, newName]) => {
			warning$3.deprecated(!(deprecatedName in props), deprecatedName, newName);
		});
	}
	const internalRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => ({ nativeElement: internalRef.current }));
	const { getPrefixCls, direction, closable: contextClosable, closeIcon: contextCloseIcon, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("alert");
	const prefixCls = getPrefixCls("alert", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$63(prefixCls);
	const { onClose: closableOnClose, afterClose: closableAfterClose } = closable && typeof closable === "object" ? closable : {};
	const handleClose = (e$2) => {
		setClosed(true);
		(closableOnClose ?? props.onClose)?.(e$2);
	};
	const type$2 = import_react.useMemo(() => {
		if (props.type !== void 0) return props.type;
		return banner ? "warning" : "info";
	}, [props.type, banner]);
	const isClosable = import_react.useMemo(() => {
		if (typeof closable === "object" && closable.closeIcon) return true;
		if (closeText) return true;
		if (typeof closable === "boolean") return closable;
		if (closeIcon !== false && isNonNullable_default(closeIcon)) return true;
		return !!contextClosable;
	}, [
		closeText,
		closeIcon,
		closable,
		contextClosable
	]);
	const isShowIcon = banner && showIcon === void 0 ? true : showIcon;
	const mergedProps = {
		...props,
		prefixCls,
		type: type$2,
		showIcon: isShowIcon,
		closable: isClosable
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const alertCls = clsx(prefixCls, `${prefixCls}-${type$2}`, {
		[`${prefixCls}-with-description`]: !!description,
		[`${prefixCls}-no-icon`]: !isShowIcon,
		[`${prefixCls}-banner`]: !!banner,
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, contextClassName, className, rootClassName, mergedClassNames.root, cssVarCls, hashId);
	const restProps = pickAttrs(otherProps, {
		aria: true,
		data: true
	});
	const mergedCloseIcon = import_react.useMemo(() => {
		if (typeof closable === "object" && closable.closeIcon) return closable.closeIcon;
		if (closeText) return closeText;
		if (closeIcon !== void 0) return closeIcon;
		if (typeof contextClosable === "object" && contextClosable.closeIcon) return contextClosable.closeIcon;
		return contextCloseIcon;
	}, [
		closeIcon,
		closable,
		contextClosable,
		closeText,
		contextCloseIcon
	]);
	const mergedAriaProps = import_react.useMemo(() => {
		const merged = closable ?? contextClosable;
		if (typeof merged === "object") return pickAttrs(merged, {
			data: true,
			aria: true
		});
		return {};
	}, [closable, contextClosable]);
	return /* @__PURE__ */ import_react.createElement(es_default$1, {
		visible: !closed,
		motionName: `${prefixCls}-motion`,
		motionAppear: false,
		motionEnter: false,
		onLeaveStart: (node$1) => ({ maxHeight: node$1.offsetHeight }),
		onLeaveEnd: closableAfterClose ?? afterClose
	}, ({ className: motionClassName, style: motionStyle }, setRef) => /* @__PURE__ */ import_react.createElement("div", {
		id,
		ref: composeRef(internalRef, setRef),
		"data-show": !closed,
		className: clsx(alertCls, motionClassName),
		style: {
			...mergedStyles.root,
			...contextStyle,
			...style$1,
			...motionStyle
		},
		onMouseEnter,
		onMouseLeave,
		onClick,
		role: "alert",
		...restProps
	}, isShowIcon ? /* @__PURE__ */ import_react.createElement(IconNode, {
		className: clsx(`${prefixCls}-icon`, mergedClassNames.icon),
		style: mergedStyles.icon,
		description,
		icon: props.icon,
		prefixCls,
		type: type$2
	}) : null, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-section`, mergedClassNames.section),
		style: mergedStyles.section
	}, mergedTitle ? /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-title`, mergedClassNames.title),
		style: mergedStyles.title
	}, mergedTitle) : null, description ? /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-description`, mergedClassNames.description),
		style: mergedStyles.description
	}, description) : null), action ? /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-actions`, mergedClassNames.actions),
		style: mergedStyles.actions
	}, action) : null, /* @__PURE__ */ import_react.createElement(CloseIconNode, {
		className: mergedClassNames.close,
		style: mergedStyles.close,
		isClosable,
		prefixCls,
		closeIcon: mergedCloseIcon,
		handleClose,
		ariaProps: mergedAriaProps
	})));
});
Alert$1.displayName = "Alert";
var Alert_default = Alert$1;

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/callSuper.js
function _callSuper$5(t$1, o$2, e$2) {
	return o$2 = _getPrototypeOf(o$2), _possibleConstructorReturn(t$1, _isNativeReflectConstruct() ? Reflect.construct(o$2, e$2 || [], _getPrototypeOf(t$1).constructor) : o$2.apply(t$1, e$2));
}

//#endregion
//#region node_modules/antd/es/alert/ErrorBoundary.js
var ErrorBoundary = /* @__PURE__ */ function(_React$Component) {
	function ErrorBoundary$1() {
		var _this;
		_classCallCheck(this, ErrorBoundary$1);
		_this = _callSuper$5(this, ErrorBoundary$1, arguments);
		_this.state = {
			error: void 0,
			info: { componentStack: "" }
		};
		return _this;
	}
	_inherits(ErrorBoundary$1, _React$Component);
	return _createClass(ErrorBoundary$1, [{
		key: "componentDidCatch",
		value: function componentDidCatch(error, info) {
			this.setState({
				error,
				info
			});
		}
	}, {
		key: "render",
		value: function render$1() {
			const { message: message$1, title, description, id, children } = this.props;
			const { error, info } = this.state;
			const mergedTitle = title ?? message$1;
			const componentStack = info?.componentStack || null;
			const errorMessage = typeof mergedTitle === "undefined" ? (error || "").toString() : mergedTitle;
			const errorDescription = typeof description === "undefined" ? componentStack : description;
			if (error) return /* @__PURE__ */ import_react.createElement(Alert_default, {
				id,
				type: "error",
				title: errorMessage,
				description: /* @__PURE__ */ import_react.createElement("pre", { style: {
					fontSize: "0.9em",
					overflowX: "auto"
				} }, errorDescription)
			});
			return children;
		}
	}]);
}(import_react.Component);
var ErrorBoundary_default = ErrorBoundary;

//#endregion
//#region node_modules/antd/es/alert/index.js
var Alert = Alert_default;
Alert.ErrorBoundary = ErrorBoundary_default;
var alert_default = Alert;

//#endregion
//#region node_modules/compute-scroll-into-view/dist/index.js
var t = (t$1) => "object" == typeof t$1 && null != t$1 && 1 === t$1.nodeType, e$1 = (t$1, e$2) => (!e$2 || "hidden" !== t$1) && "visible" !== t$1 && "clip" !== t$1, n = (t$1, n$1) => {
	if (t$1.clientHeight < t$1.scrollHeight || t$1.clientWidth < t$1.scrollWidth) {
		const o$2 = getComputedStyle(t$1, null);
		return e$1(o$2.overflowY, n$1) || e$1(o$2.overflowX, n$1) || ((t$2) => {
			const e$2 = ((t$3) => {
				if (!t$3.ownerDocument || !t$3.ownerDocument.defaultView) return null;
				try {
					return t$3.ownerDocument.defaultView.frameElement;
				} catch (t$4) {
					return null;
				}
			})(t$2);
			return !!e$2 && (e$2.clientHeight < t$2.scrollHeight || e$2.clientWidth < t$2.scrollWidth);
		})(t$1);
	}
	return !1;
}, o$1 = (t$1, e$2, n$1, o$2, l$1, r$1, i, s) => r$1 < t$1 && i > e$2 || r$1 > t$1 && i < e$2 ? 0 : r$1 <= t$1 && s <= n$1 || i >= e$2 && s >= n$1 ? r$1 - t$1 - o$2 : i > e$2 && s < n$1 || r$1 < t$1 && s > n$1 ? i - e$2 + l$1 : 0, l = (t$1) => {
	const e$2 = t$1.parentElement;
	return null == e$2 ? t$1.getRootNode().host || null : e$2;
}, r = (e$2, r$1) => {
	var i, s, d, h;
	if ("undefined" == typeof document) return [];
	const { scrollMode: c, block: f, inline: u, boundary: a, skipOverflowHiddenElements: g } = r$1, p = "function" == typeof a ? a : (t$1) => t$1 !== a;
	if (!t(e$2)) throw new TypeError("Invalid target");
	const m = document.scrollingElement || document.documentElement, w = [];
	let W = e$2;
	for (; t(W) && p(W);) {
		if (W = l(W), W === m) {
			w.push(W);
			break;
		}
		null != W && W === document.body && n(W) && !n(document.documentElement) || null != W && n(W, g) && w.push(W);
	}
	const b = null != (s = null == (i = window.visualViewport) ? void 0 : i.width) ? s : innerWidth, H = null != (h = null == (d = window.visualViewport) ? void 0 : d.height) ? h : innerHeight, { scrollX: y, scrollY: M } = window, { height: v, width: E, top: x, right: C, bottom: I, left: R } = e$2.getBoundingClientRect(), { top: T, right: B, bottom: F, left: V } = ((t$1) => {
		const e$3 = window.getComputedStyle(t$1);
		return {
			top: parseFloat(e$3.scrollMarginTop) || 0,
			right: parseFloat(e$3.scrollMarginRight) || 0,
			bottom: parseFloat(e$3.scrollMarginBottom) || 0,
			left: parseFloat(e$3.scrollMarginLeft) || 0
		};
	})(e$2);
	let k = "start" === f || "nearest" === f ? x - T : "end" === f ? I + F : x + v / 2 - T + F, D = "center" === u ? R + E / 2 - V + B : "end" === u ? C + B : R - V;
	const L = [];
	for (let t$1 = 0; t$1 < w.length; t$1++) {
		const e$3 = w[t$1], { height: l$1, width: r$2, top: i$1, right: s$1, bottom: d$1, left: h$1 } = e$3.getBoundingClientRect();
		if ("if-needed" === c && x >= 0 && R >= 0 && I <= H && C <= b && (e$3 === m && !n(e$3) || x >= i$1 && I <= d$1 && R >= h$1 && C <= s$1)) return L;
		const a$1 = getComputedStyle(e$3), g$1 = parseInt(a$1.borderLeftWidth, 10), p$1 = parseInt(a$1.borderTopWidth, 10), W$1 = parseInt(a$1.borderRightWidth, 10), T$1 = parseInt(a$1.borderBottomWidth, 10);
		let B$1 = 0, F$1 = 0;
		const V$1 = "offsetWidth" in e$3 ? e$3.offsetWidth - e$3.clientWidth - g$1 - W$1 : 0, S = "offsetHeight" in e$3 ? e$3.offsetHeight - e$3.clientHeight - p$1 - T$1 : 0, X = "offsetWidth" in e$3 ? 0 === e$3.offsetWidth ? 0 : r$2 / e$3.offsetWidth : 0, Y = "offsetHeight" in e$3 ? 0 === e$3.offsetHeight ? 0 : l$1 / e$3.offsetHeight : 0;
		if (m === e$3) B$1 = "start" === f ? k : "end" === f ? k - H : "nearest" === f ? o$1(M, M + H, H, p$1, T$1, M + k, M + k + v, v) : k - H / 2, F$1 = "start" === u ? D : "center" === u ? D - b / 2 : "end" === u ? D - b : o$1(y, y + b, b, g$1, W$1, y + D, y + D + E, E), B$1 = Math.max(0, B$1 + M), F$1 = Math.max(0, F$1 + y);
		else {
			B$1 = "start" === f ? k - i$1 - p$1 : "end" === f ? k - d$1 + T$1 + S : "nearest" === f ? o$1(i$1, d$1, l$1, p$1, T$1 + S, k, k + v, v) : k - (i$1 + l$1 / 2) + S / 2, F$1 = "start" === u ? D - h$1 - g$1 : "center" === u ? D - (h$1 + r$2 / 2) + V$1 / 2 : "end" === u ? D - s$1 + W$1 + V$1 : o$1(h$1, s$1, r$2, g$1, W$1 + V$1, D, D + E, E);
			const { scrollLeft: t$2, scrollTop: n$1 } = e$3;
			B$1 = 0 === Y ? 0 : Math.max(0, Math.min(n$1 + B$1 / Y, e$3.scrollHeight - l$1 / Y + S)), F$1 = 0 === X ? 0 : Math.max(0, Math.min(t$2 + F$1 / X, e$3.scrollWidth - r$2 / X + V$1)), k += n$1 - B$1, D += t$2 - F$1;
		}
		L.push({
			el: e$3,
			top: B$1,
			left: F$1
		});
	}
	return L;
};

//#endregion
//#region node_modules/scroll-into-view-if-needed/dist/index.js
var o = (t$1) => !1 === t$1 ? {
	block: "end",
	inline: "nearest"
} : ((t$2) => t$2 === Object(t$2) && 0 !== Object.keys(t$2).length)(t$1) ? t$1 : {
	block: "start",
	inline: "nearest"
};
function e(e$2, r$1) {
	if (!e$2.isConnected || !((t$1) => {
		let o$2 = t$1;
		for (; o$2 && o$2.parentNode;) {
			if (o$2.parentNode === document) return !0;
			o$2 = o$2.parentNode instanceof ShadowRoot ? o$2.parentNode.host : o$2.parentNode;
		}
		return !1;
	})(e$2)) return;
	const n$1 = ((t$1) => {
		const o$2 = window.getComputedStyle(t$1);
		return {
			top: parseFloat(o$2.scrollMarginTop) || 0,
			right: parseFloat(o$2.scrollMarginRight) || 0,
			bottom: parseFloat(o$2.scrollMarginBottom) || 0,
			left: parseFloat(o$2.scrollMarginLeft) || 0
		};
	})(e$2);
	if (((t$1) => "object" == typeof t$1 && "function" == typeof t$1.behavior)(r$1)) return r$1.behavior(r(e$2, r$1));
	const l$1 = "boolean" == typeof r$1 || null == r$1 ? void 0 : r$1.behavior;
	for (const { el: a, top: i, left: s } of r(e$2, o(r$1))) {
		const t$1 = i - n$1.top + n$1.bottom, o$2 = s - n$1.left + n$1.right;
		a.scroll({
			top: t$1,
			left: o$2,
			behavior: l$1
		});
	}
}

//#endregion
//#region node_modules/antd/es/_util/getScroll.js
function isWindow(obj) {
	return isNonNullable_default(obj) && obj === obj.window;
}
var getScroll$2 = (target) => {
	if (typeof window === "undefined")
 /* istanbul ignore next */
	return 0;
	let result = 0;
	if (isWindow(target)) result = target.pageYOffset;
	else if (target instanceof Document) result = target.documentElement.scrollTop;
	else if (target instanceof HTMLElement) result = target.scrollTop;
	else if (target) result = target["scrollTop"];
	if (target && !isWindow(target) && typeof result !== "number") result = (target.ownerDocument ?? target).documentElement?.scrollTop;
	return result;
};
var getScroll_default = getScroll$2;

//#endregion
//#region node_modules/antd/es/_util/easings.js
function easeInOutCubic(t$1, b, c, d) {
	const cc = c - b;
	t$1 /= d / 2;
	if (t$1 < 1) return cc / 2 * t$1 * t$1 * t$1 + b;
	return cc / 2 * ((t$1 -= 2) * t$1 * t$1 + 2) + b;
}

//#endregion
//#region node_modules/antd/es/_util/scrollTo.js
function scrollTo(y, options = {}) {
	const { getContainer = () => window, callback, duration = 450 } = options;
	const container = getContainer();
	const scrollTop = getScroll_default(container);
	const startTime = Date.now();
	let rafId;
	const frameFunc = () => {
		const time = Date.now() - startTime;
		const nextScrollTop = easeInOutCubic(time > duration ? duration : time, scrollTop, y, duration);
		if (isWindow(container)) container.scrollTo(window.pageXOffset, nextScrollTop);
		else if (container instanceof Document || container.constructor.name === "HTMLDocument") container.documentElement.scrollTop = nextScrollTop;
		else container.scrollTop = nextScrollTop;
		if (time < duration) rafId = raf_default(frameFunc);
		else if (typeof callback === "function") callback();
	};
	rafId = raf_default(frameFunc);
	return () => {
		raf_default.cancel(rafId);
	};
}

//#endregion
//#region node_modules/antd/es/config-provider/hooks/useCSSVarCls.js
/**
* This hook is only for cssVar to add root className for components.
* If root ClassName is needed, this hook could be refactored with `-root`
* @param prefixCls
*/
var useCSSVarCls = (prefixCls) => `${prefixCls}-css-var`;
var useCSSVarCls_default = useCSSVarCls;

//#endregion
//#region node_modules/antd/es/form/validateMessagesContext.js
var validateMessagesContext_default = /* @__PURE__ */ (0, import_react.createContext)(void 0);

//#endregion
//#region node_modules/@rc-component/portal/es/Context.js
var OrderContext = /* @__PURE__ */ import_react.createContext(null);
var Context_default$2 = OrderContext;

//#endregion
//#region node_modules/@rc-component/portal/es/mock.js
let inline = false;
function inlineMock(nextInline) {
	if (typeof nextInline === "boolean") inline = nextInline;
	return inline;
}

//#endregion
//#region node_modules/@rc-component/portal/es/useDom.js
var EMPTY_LIST$5 = [];
/**
* Will add `div` to document. Nest call will keep order
* @param render Render DOM in document
*/
function useDom(render$1, debug) {
	const [ele] = import_react.useState(() => {
		if (!canUseDom()) return null;
		const defaultEle = document.createElement("div");
		if (debug) defaultEle.setAttribute("data-debug", debug);
		return defaultEle;
	});
	const appendedRef = import_react.useRef(false);
	const queueCreate = import_react.useContext(Context_default$2);
	const [queue, setQueue] = import_react.useState(EMPTY_LIST$5);
	const mergedQueueCreate = queueCreate || (appendedRef.current ? void 0 : (appendFn) => {
		setQueue((origin) => {
			return [appendFn, ...origin];
		});
	});
	function append$1() {
		if (!ele.parentElement) document.body.appendChild(ele);
		appendedRef.current = true;
	}
	function cleanup$1() {
		ele.parentElement?.removeChild(ele);
		appendedRef.current = false;
	}
	useLayoutEffect_default(() => {
		if (render$1) if (queueCreate) queueCreate(append$1);
		else append$1();
		else cleanup$1();
		return cleanup$1;
	}, [render$1]);
	useLayoutEffect_default(() => {
		if (queue.length) {
			queue.forEach((appendFn) => appendFn());
			setQueue(EMPTY_LIST$5);
		}
	}, [queue]);
	return [ele, mergedQueueCreate];
}

//#endregion
//#region node_modules/@rc-component/util/es/getScrollBarSize.js
var cached$1;
function measureScrollbarSize(ele) {
	const randomId = `rc-scrollbar-measure-${Math.random().toString(36).substring(7)}`;
	const measureEle = document.createElement("div");
	measureEle.id = randomId;
	const measureStyle = measureEle.style;
	measureStyle.position = "absolute";
	measureStyle.left = "0";
	measureStyle.top = "0";
	measureStyle.width = "100px";
	measureStyle.height = "100px";
	measureStyle.overflow = "scroll";
	let fallbackWidth;
	let fallbackHeight;
	if (ele) {
		const targetStyle = getComputedStyle(ele);
		measureStyle.scrollbarColor = targetStyle.scrollbarColor;
		measureStyle.scrollbarWidth = targetStyle.scrollbarWidth;
		const webkitScrollbarStyle = getComputedStyle(ele, "::-webkit-scrollbar");
		const width = parseInt(webkitScrollbarStyle.width, 10);
		const height = parseInt(webkitScrollbarStyle.height, 10);
		try {
			updateCSS(`
#${randomId}::-webkit-scrollbar {
${width ? `width: ${webkitScrollbarStyle.width};` : ""}
${height ? `height: ${webkitScrollbarStyle.height};` : ""}
}`, randomId);
		} catch (e$2) {
			console.error(e$2);
			fallbackWidth = width;
			fallbackHeight = height;
		}
	}
	document.body.appendChild(measureEle);
	const scrollWidth = ele && fallbackWidth && !isNaN(fallbackWidth) ? fallbackWidth : measureEle.offsetWidth - measureEle.clientWidth;
	const scrollHeight = ele && fallbackHeight && !isNaN(fallbackHeight) ? fallbackHeight : measureEle.offsetHeight - measureEle.clientHeight;
	document.body.removeChild(measureEle);
	removeCSS(randomId);
	return {
		width: scrollWidth,
		height: scrollHeight
	};
}
function getScrollBarSize(fresh) {
	if (typeof document === "undefined") return 0;
	if (fresh || cached$1 === void 0) cached$1 = measureScrollbarSize();
	return cached$1.width;
}
function getTargetScrollBarSize(target) {
	if (typeof document === "undefined" || !target || !(target instanceof Element)) return {
		width: 0,
		height: 0
	};
	return measureScrollbarSize(target);
}

//#endregion
//#region node_modules/@rc-component/portal/es/util.js
/**
* Test usage export. Do not use in your production
*/
function isBodyOverflowing() {
	return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}

//#endregion
//#region node_modules/@rc-component/portal/es/useScrollLocker.js
var UNIQUE_ID = `rc-util-locker-${Date.now()}`;
var uuid$3 = 0;
function useScrollLocker(lock) {
	const mergedLock = !!lock;
	const [id] = import_react.useState(() => {
		uuid$3 += 1;
		return `${UNIQUE_ID}_${uuid$3}`;
	});
	useLayoutEffect_default(() => {
		if (mergedLock) {
			const scrollbarSize = getTargetScrollBarSize(document.body).width;
			updateCSS(`
html body {
  overflow-y: hidden;
  ${isBodyOverflowing() ? `width: calc(100% - ${scrollbarSize}px);` : ""}
}`, id);
		} else removeCSS(id);
		return () => {
			removeCSS(id);
		};
	}, [mergedLock, id]);
}

//#endregion
//#region node_modules/@rc-component/util/es/hooks/useId.js
function getUseId() {
	return { ...import_react }.useId;
}
var uuid$2 = 0;
var useOriginId = getUseId();
var useId_default = useOriginId ? function useId$1(id) {
	const reactId = useOriginId();
	if (id) return id;
	return reactId;
} : function useCompatId(id) {
	const [innerId, setInnerId] = import_react.useState("ssr-id");
	import_react.useEffect(() => {
		const nextId = uuid$2;
		uuid$2 += 1;
		setInnerId(`rc_unique_${nextId}`);
	}, []);
	if (id) return id;
	return innerId;
};

//#endregion
//#region node_modules/@rc-component/portal/es/useEscKeyDown.js
var stack = [];
var IME_LOCK_DURATION = 200;
var lastCompositionEndTime = 0;
var onGlobalKeyDown = (event) => {
	if (event.key === "Escape" && !event.isComposing) {
		if (Date.now() - lastCompositionEndTime < IME_LOCK_DURATION) return;
		const len = stack.length;
		for (let i = len - 1; i >= 0; i -= 1) stack[i].onEsc({
			top: i === len - 1,
			event
		});
	}
};
var onGlobalCompositionEnd = () => {
	lastCompositionEndTime = Date.now();
};
function attachGlobalEventListeners() {
	window.addEventListener("keydown", onGlobalKeyDown);
	window.addEventListener("compositionend", onGlobalCompositionEnd);
}
function detachGlobalEventListeners() {
	if (stack.length === 0) {
		window.removeEventListener("keydown", onGlobalKeyDown);
		window.removeEventListener("compositionend", onGlobalCompositionEnd);
	}
}
function useEscKeyDown(open$2, onEsc) {
	const id = useId_default();
	const onEventEsc = useEvent_default(onEsc);
	const ensure = () => {
		if (!stack.find((item) => item.id === id)) stack.push({
			id,
			onEsc: onEventEsc
		});
	};
	const clear = () => {
		stack = stack.filter((item) => item.id !== id);
	};
	(0, import_react.useMemo)(() => {
		if (open$2) ensure();
		else if (!open$2) clear();
	}, [open$2]);
	(0, import_react.useEffect)(() => {
		if (open$2) {
			ensure();
			attachGlobalEventListeners();
			return () => {
				clear();
				detachGlobalEventListeners();
			};
		}
	}, [open$2]);
}

//#endregion
//#region node_modules/@rc-component/portal/es/Portal.js
var getPortalContainer = (getContainer) => {
	if (getContainer === false) return false;
	if (!canUseDom() || !getContainer) return null;
	if (typeof getContainer === "string") return document.querySelector(getContainer);
	if (typeof getContainer === "function") return getContainer();
	return getContainer;
};
var Portal = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { open: open$2, autoLock, getContainer, debug, autoDestroy = true, children, onEsc } = props;
	const [shouldRender, setShouldRender] = import_react.useState(open$2);
	const mergedRender = shouldRender || open$2;
	warning_default$1(canUseDom() || !open$2, `Portal only work in client side. Please call 'useEffect' to show Portal instead default render in SSR.`);
	import_react.useEffect(() => {
		if (autoDestroy || open$2) setShouldRender(open$2);
	}, [open$2, autoDestroy]);
	const [innerContainer, setInnerContainer] = import_react.useState(() => getPortalContainer(getContainer));
	import_react.useEffect(() => {
		const customizeContainer = getPortalContainer(getContainer);
		setInnerContainer(() => customizeContainer ?? null);
	});
	const [defaultContainer$1, queueCreate] = useDom(mergedRender && !innerContainer, debug);
	const mergedContainer = innerContainer ?? defaultContainer$1;
	useScrollLocker(autoLock && open$2 && canUseDom() && (mergedContainer === defaultContainer$1 || mergedContainer === document.body));
	useEscKeyDown(open$2, onEsc);
	let childRef = null;
	if (children && supportRef(children) && ref) childRef = getNodeRef(children);
	const mergedRef = useComposeRef(childRef, ref);
	if (!mergedRender || !canUseDom() || innerContainer === void 0) return null;
	const renderInline = mergedContainer === false || inlineMock();
	let reffedChildren = children;
	if (ref) reffedChildren = /* @__PURE__ */ import_react.cloneElement(children, { ref: mergedRef });
	return /* @__PURE__ */ import_react.createElement(Context_default$2.Provider, { value: queueCreate }, renderInline ? reffedChildren : /* @__PURE__ */ (0, import_react_dom$8.createPortal)(reffedChildren, mergedContainer));
});
Portal.displayName = "Portal";
var Portal_default = Portal;

//#endregion
//#region node_modules/@rc-component/portal/es/index.js
var es_default$7 = Portal_default;

//#endregion
//#region node_modules/@rc-component/trigger/es/Popup/Arrow.js
function Arrow(props) {
	const { prefixCls, align, arrow, arrowPos } = props;
	const { className, content, style: style$1 } = arrow || {};
	const { x = 0, y = 0 } = arrowPos;
	const arrowRef = import_react.useRef(null);
	if (!align || !align.points) return null;
	const alignStyle = { position: "absolute" };
	if (align.autoArrow !== false) {
		const popupPoints = align.points[0];
		const targetPoints = align.points[1];
		const popupTB = popupPoints[0];
		const popupLR = popupPoints[1];
		const targetTB = targetPoints[0];
		const targetLR = targetPoints[1];
		if (popupTB === targetTB || !["t", "b"].includes(popupTB)) alignStyle.top = y;
		else if (popupTB === "t") alignStyle.top = 0;
		else alignStyle.bottom = 0;
		if (popupLR === targetLR || !["l", "r"].includes(popupLR)) alignStyle.left = x;
		else if (popupLR === "l") alignStyle.left = 0;
		else alignStyle.right = 0;
	}
	return /* @__PURE__ */ import_react.createElement("div", {
		ref: arrowRef,
		className: clsx(`${prefixCls}-arrow`, className),
		style: {
			...alignStyle,
			...style$1
		}
	}, content);
}

//#endregion
//#region node_modules/@rc-component/trigger/es/Popup/Mask.js
function _extends$97() {
	_extends$97 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$97.apply(this, arguments);
}
function Mask$2(props) {
	const { prefixCls, open: open$2, zIndex, mask, motion: motion$1, mobile } = props;
	if (!mask) return null;
	return /* @__PURE__ */ import_react.createElement(es_default$1, _extends$97({}, motion$1, {
		motionAppear: true,
		visible: open$2,
		removeOnLeave: true
	}), ({ className }) => /* @__PURE__ */ import_react.createElement("div", {
		style: { zIndex },
		className: clsx(`${prefixCls}-mask`, mobile && `${prefixCls}-mobile-mask`, className)
	}));
}

//#endregion
//#region node_modules/@rc-component/trigger/es/Popup/PopupContent.js
var PopupContent = /* @__PURE__ */ import_react.memo(({ children }) => children, (_, next$1) => next$1.cache);
PopupContent.displayName = "PopupContent";
var PopupContent_default = PopupContent;

//#endregion
//#region node_modules/@rc-component/trigger/es/hooks/useOffsetStyle.js
function useOffsetStyle(isMobile$2, ready, open$2, align, offsetR, offsetB, offsetX, offsetY) {
	const AUTO = "auto";
	const offsetStyle = isMobile$2 ? {} : {
		left: "-1000vw",
		top: "-1000vh",
		right: AUTO,
		bottom: AUTO
	};
	if (!isMobile$2 && (ready || !open$2)) {
		const { points } = align;
		const dynamicInset = align.dynamicInset || align._experimental?.dynamicInset;
		const alignRight = dynamicInset && points[0][1] === "r";
		const alignBottom = dynamicInset && points[0][0] === "b";
		if (alignRight) {
			offsetStyle.right = offsetR;
			offsetStyle.left = AUTO;
		} else {
			offsetStyle.left = offsetX;
			offsetStyle.right = AUTO;
		}
		if (alignBottom) {
			offsetStyle.bottom = offsetB;
			offsetStyle.top = AUTO;
		} else {
			offsetStyle.top = offsetY;
			offsetStyle.bottom = AUTO;
		}
	}
	return offsetStyle;
}

//#endregion
//#region node_modules/@rc-component/trigger/es/Popup/index.js
function _extends$96() {
	_extends$96 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$96.apply(this, arguments);
}
var Popup$2 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { onEsc, popup, className, prefixCls, style: style$1, target, onVisibleChanged, open: open$2, keepDom, fresh, onClick, mask, arrow, arrowPos, align, motion: motion$1, maskMotion, mobile, forceRender, getPopupContainer, autoDestroy, portal: Portal$1, children, zIndex, onMouseEnter, onMouseLeave, onPointerEnter, onPointerDownCapture, ready, offsetX, offsetY, offsetR, offsetB, onAlign, onPrepare, onResize: onResize$1, stretch, targetWidth, targetHeight } = props;
	const popupContent = typeof popup === "function" ? popup() : popup;
	const isNodeVisible = open$2 || keepDom;
	const isMobile$2 = !!mobile;
	const [mergedMask, mergedMaskMotion, mergedPopupMotion] = import_react.useMemo(() => {
		if (mobile) return [
			mobile.mask,
			mobile.maskMotion,
			mobile.motion
		];
		return [
			mask,
			maskMotion,
			motion$1
		];
	}, [
		mobile,
		mask,
		maskMotion,
		motion$1
	]);
	const getPopupContainerNeedParams = getPopupContainer?.length > 0;
	const [show, setShow] = import_react.useState(!getPopupContainer || !getPopupContainerNeedParams);
	useLayoutEffect_default(() => {
		if (!show && getPopupContainerNeedParams && target) setShow(true);
	}, [
		show,
		getPopupContainerNeedParams,
		target
	]);
	const onInternalResize = useEvent_default((size, ele) => {
		onResize$1?.(size, ele);
		onAlign();
	});
	const offsetStyle = useOffsetStyle(isMobile$2, ready, open$2, align, offsetR, offsetB, offsetX, offsetY);
	if (!show) return null;
	const miscStyle = {};
	if (stretch) {
		if (stretch.includes("height") && targetHeight) miscStyle.height = targetHeight;
		else if (stretch.includes("minHeight") && targetHeight) miscStyle.minHeight = targetHeight;
		if (stretch.includes("width") && targetWidth) miscStyle.width = targetWidth;
		else if (stretch.includes("minWidth") && targetWidth) miscStyle.minWidth = targetWidth;
	}
	if (!open$2) miscStyle.pointerEvents = "none";
	return /* @__PURE__ */ import_react.createElement(Portal$1, {
		open: forceRender || isNodeVisible,
		getContainer: getPopupContainer && (() => getPopupContainer(target)),
		autoDestroy,
		onEsc
	}, /* @__PURE__ */ import_react.createElement(Mask$2, {
		prefixCls,
		open: open$2,
		zIndex,
		mask: mergedMask,
		motion: mergedMaskMotion,
		mobile: isMobile$2
	}), /* @__PURE__ */ import_react.createElement(es_default$2, {
		onResize: onInternalResize,
		disabled: !open$2
	}, (resizeObserverRef) => {
		return /* @__PURE__ */ import_react.createElement(es_default$1, _extends$96({
			motionAppear: true,
			motionEnter: true,
			motionLeave: true,
			removeOnLeave: false,
			forceRender,
			leavedClassName: `${prefixCls}-hidden`
		}, mergedPopupMotion, {
			onAppearPrepare: onPrepare,
			onEnterPrepare: onPrepare,
			visible: open$2,
			onVisibleChanged: (nextVisible) => {
				motion$1?.onVisibleChanged?.(nextVisible);
				onVisibleChanged(nextVisible);
			}
		}), ({ className: motionClassName, style: motionStyle }, motionRef) => {
			const cls = clsx(prefixCls, motionClassName, className, { [`${prefixCls}-mobile`]: isMobile$2 });
			return /* @__PURE__ */ import_react.createElement("div", {
				ref: composeRef(resizeObserverRef, ref, motionRef),
				className: cls,
				style: {
					"--arrow-x": `${arrowPos.x || 0}px`,
					"--arrow-y": `${arrowPos.y || 0}px`,
					...offsetStyle,
					...miscStyle,
					...motionStyle,
					boxSizing: "border-box",
					zIndex,
					...style$1
				},
				onMouseEnter,
				onMouseLeave,
				onPointerEnter,
				onClick,
				onPointerDownCapture
			}, arrow && /* @__PURE__ */ import_react.createElement(Arrow, {
				prefixCls,
				arrow,
				arrowPos,
				align
			}), /* @__PURE__ */ import_react.createElement(PopupContent_default, { cache: !open$2 && !fresh }, popupContent));
		});
	}), children);
});
Popup$2.displayName = "Popup";
var Popup_default$1 = Popup$2;

//#endregion
//#region node_modules/@rc-component/trigger/es/context.js
var TriggerContext = /* @__PURE__ */ import_react.createContext(null);
var context_default$10 = TriggerContext;
const UniqueContext = /* @__PURE__ */ import_react.createContext(null);

//#endregion
//#region node_modules/@rc-component/trigger/es/hooks/useAction.js
function toArray$8(val) {
	return val ? Array.isArray(val) ? val : [val] : [];
}
function useAction(action, showAction, hideAction) {
	return import_react.useMemo(() => {
		const mergedShowAction = toArray$8(showAction ?? action);
		const mergedHideAction = toArray$8(hideAction ?? action);
		const showActionSet = new Set(mergedShowAction);
		const hideActionSet = new Set(mergedHideAction);
		if (showActionSet.has("hover") && !showActionSet.has("click")) showActionSet.add("touch");
		if (hideActionSet.has("hover") && !hideActionSet.has("click")) hideActionSet.add("touch");
		return [showActionSet, hideActionSet];
	}, [
		action,
		showAction,
		hideAction
	]);
}

//#endregion
//#region node_modules/@rc-component/util/es/Dom/isVisible.js
var isVisible_default = ((element) => {
	if (!element) return false;
	if (element instanceof Element) {
		if (element.offsetParent) return true;
		if (element.getBBox) {
			const { width, height } = element.getBBox();
			if (width || height) return true;
		}
		if (element.getBoundingClientRect) {
			const { width, height } = element.getBoundingClientRect();
			if (width || height) return true;
		}
	}
	return false;
});

//#endregion
//#region node_modules/@rc-component/trigger/es/util.js
function isPointsEq(a1 = [], a2 = [], isAlignPoint) {
	const getVal = (a, index$1) => a[index$1] || "";
	if (isAlignPoint) return getVal(a1, 0) === getVal(a2, 0);
	return getVal(a1, 0) === getVal(a2, 0) && getVal(a1, 1) === getVal(a2, 1);
}
function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
	const { points } = align;
	const placements$4 = Object.keys(builtinPlacements);
	for (let i = 0; i < placements$4.length; i += 1) {
		const placement = placements$4[i];
		if (isPointsEq(builtinPlacements[placement]?.points, points, isAlignPoint)) return `${prefixCls}-placement-${placement}`;
	}
	return "";
}
function getWin(ele) {
	return ele.ownerDocument.defaultView;
}
/**
* Get all the scrollable parent elements of the element
* @param ele       The element to be detected
* @param areaOnly  Only return the parent which will cut visible area
*/
function collectScroller(ele) {
	const scrollerList = [];
	let current = ele?.parentElement;
	const scrollStyle = [
		"hidden",
		"scroll",
		"clip",
		"auto"
	];
	while (current) {
		const { overflowX, overflowY, overflow } = getWin(current).getComputedStyle(current);
		if ([
			overflowX,
			overflowY,
			overflow
		].some((o$2) => scrollStyle.includes(o$2))) scrollerList.push(current);
		current = current.parentElement;
	}
	return scrollerList;
}
function toNum(num, defaultValue = 1) {
	return Number.isNaN(num) ? defaultValue : num;
}
function getPxValue(val) {
	return toNum(parseFloat(val), 0);
}
/**
*
*
*  **************************************
*  *              Border                *
*  *     **************************     *
*  *     *                  *     *     *
*  *  B  *                  *  S  *  B  *
*  *  o  *                  *  c  *  o  *
*  *  r  *      Content     *  r  *  r  *
*  *  d  *                  *  o  *  d  *
*  *  e  *                  *  l  *  e  *
*  *  r  ********************  l  *  r  *
*  *     *        Scroll          *     *
*  *     **************************     *
*  *              Border                *
*  **************************************
*
*/
/**
* Get visible area of element
*/
function getVisibleArea(initArea, scrollerList) {
	const visibleArea = { ...initArea };
	(scrollerList || []).forEach((ele) => {
		if (ele instanceof HTMLBodyElement || ele instanceof HTMLHtmlElement) return;
		const { overflow, overflowClipMargin, borderTopWidth, borderBottomWidth, borderLeftWidth, borderRightWidth } = getWin(ele).getComputedStyle(ele);
		const eleRect = ele.getBoundingClientRect();
		const { offsetHeight: eleOutHeight, clientHeight: eleInnerHeight, offsetWidth: eleOutWidth, clientWidth: eleInnerWidth } = ele;
		const borderTopNum = getPxValue(borderTopWidth);
		const borderBottomNum = getPxValue(borderBottomWidth);
		const borderLeftNum = getPxValue(borderLeftWidth);
		const borderRightNum = getPxValue(borderRightWidth);
		const scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1e3) / 1e3);
		const scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1e3) / 1e3);
		const eleScrollWidth = (eleOutWidth - eleInnerWidth - borderLeftNum - borderRightNum) * scaleX;
		const eleScrollHeight = (eleOutHeight - eleInnerHeight - borderTopNum - borderBottomNum) * scaleY;
		const scaledBorderTopWidth = borderTopNum * scaleY;
		const scaledBorderBottomWidth = borderBottomNum * scaleY;
		const scaledBorderLeftWidth = borderLeftNum * scaleX;
		const scaledBorderRightWidth = borderRightNum * scaleX;
		let clipMarginWidth = 0;
		let clipMarginHeight = 0;
		if (overflow === "clip") {
			const clipNum = getPxValue(overflowClipMargin);
			clipMarginWidth = clipNum * scaleX;
			clipMarginHeight = clipNum * scaleY;
		}
		const eleLeft = eleRect.x + scaledBorderLeftWidth - clipMarginWidth;
		const eleTop = eleRect.y + scaledBorderTopWidth - clipMarginHeight;
		const eleRight = eleLeft + eleRect.width + 2 * clipMarginWidth - scaledBorderLeftWidth - scaledBorderRightWidth - eleScrollWidth;
		const eleBottom = eleTop + eleRect.height + 2 * clipMarginHeight - scaledBorderTopWidth - scaledBorderBottomWidth - eleScrollHeight;
		visibleArea.left = Math.max(visibleArea.left, eleLeft);
		visibleArea.top = Math.max(visibleArea.top, eleTop);
		visibleArea.right = Math.min(visibleArea.right, eleRight);
		visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);
	});
	return visibleArea;
}

//#endregion
//#region node_modules/@rc-component/trigger/es/hooks/useAlign.js
function getUnitOffset(size, offset$2 = 0) {
	const offsetStr = `${offset$2}`;
	const cells = offsetStr.match(/^(.*)\%$/);
	if (cells) return size * (parseFloat(cells[1]) / 100);
	return parseFloat(offsetStr);
}
function getNumberOffset(rect, offset$2) {
	const [offsetX, offsetY] = offset$2 || [];
	return [getUnitOffset(rect.width, offsetX), getUnitOffset(rect.height, offsetY)];
}
function splitPoints(points = "") {
	return [points[0], points[1]];
}
function getAlignPoint(rect, points) {
	const topBottom = points[0];
	const leftRight = points[1];
	let x;
	let y;
	if (topBottom === "t") y = rect.y;
	else if (topBottom === "b") y = rect.y + rect.height;
	else y = rect.y + rect.height / 2;
	if (leftRight === "l") x = rect.x;
	else if (leftRight === "r") x = rect.x + rect.width;
	else x = rect.x + rect.width / 2;
	return {
		x,
		y
	};
}
function reversePoints(points, index$1) {
	const reverseMap = {
		t: "b",
		b: "t",
		l: "r",
		r: "l"
	};
	const clone = [...points];
	clone[index$1] = reverseMap[points[index$1]] || "c";
	return clone;
}
function flatPoints(points) {
	return points.join("");
}
function useAlign(open$2, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign, mobile) {
	const [offsetInfo, setOffsetInfo] = import_react.useState({
		ready: false,
		offsetX: 0,
		offsetY: 0,
		offsetR: 0,
		offsetB: 0,
		arrowX: 0,
		arrowY: 0,
		scaleX: 1,
		scaleY: 1,
		align: builtinPlacements[placement] || {}
	});
	const alignCountRef = import_react.useRef(0);
	const scrollerList = import_react.useMemo(() => {
		if (!popupEle || mobile) return [];
		return collectScroller(popupEle);
	}, [popupEle]);
	const prevFlipRef = import_react.useRef({});
	const resetFlipCache = () => {
		prevFlipRef.current = {};
	};
	if (!open$2) resetFlipCache();
	const onAlign = useEvent_default(() => {
		if (popupEle && target && open$2 && !mobile) {
			const popupElement = popupEle;
			const doc = popupElement.ownerDocument;
			const win = getWin(popupElement);
			const { position: popupPosition } = win.getComputedStyle(popupElement);
			const originLeft = popupElement.style.left;
			const originTop = popupElement.style.top;
			const originRight = popupElement.style.right;
			const originBottom = popupElement.style.bottom;
			const originOverflow = popupElement.style.overflow;
			const placementInfo = {
				...builtinPlacements[placement],
				...popupAlign
			};
			const placeholderElement = doc.createElement("div");
			popupElement.parentElement?.appendChild(placeholderElement);
			placeholderElement.style.left = `${popupElement.offsetLeft}px`;
			placeholderElement.style.top = `${popupElement.offsetTop}px`;
			placeholderElement.style.position = popupPosition;
			placeholderElement.style.height = `${popupElement.offsetHeight}px`;
			placeholderElement.style.width = `${popupElement.offsetWidth}px`;
			popupElement.style.left = "0";
			popupElement.style.top = "0";
			popupElement.style.right = "auto";
			popupElement.style.bottom = "auto";
			popupElement.style.overflow = "hidden";
			let targetRect;
			if (Array.isArray(target)) targetRect = {
				x: target[0],
				y: target[1],
				width: 0,
				height: 0
			};
			else {
				const rect = target.getBoundingClientRect();
				rect.x = rect.x ?? rect.left;
				rect.y = rect.y ?? rect.top;
				targetRect = {
					x: rect.x,
					y: rect.y,
					width: rect.width,
					height: rect.height
				};
			}
			const popupRect = popupElement.getBoundingClientRect();
			const { height, width } = win.getComputedStyle(popupElement);
			popupRect.x = popupRect.x ?? popupRect.left;
			popupRect.y = popupRect.y ?? popupRect.top;
			const { clientWidth, clientHeight, scrollWidth, scrollHeight, scrollTop, scrollLeft } = doc.documentElement;
			const popupHeight = popupRect.height;
			const popupWidth = popupRect.width;
			const targetHeight = targetRect.height;
			const targetWidth = targetRect.width;
			const visibleRegion = {
				left: 0,
				top: 0,
				right: clientWidth,
				bottom: clientHeight
			};
			const scrollRegion = {
				left: -scrollLeft,
				top: -scrollTop,
				right: scrollWidth - scrollLeft,
				bottom: scrollHeight - scrollTop
			};
			let { htmlRegion } = placementInfo;
			const VISIBLE = "visible";
			const VISIBLE_FIRST = "visibleFirst";
			if (htmlRegion !== "scroll" && htmlRegion !== VISIBLE_FIRST) htmlRegion = VISIBLE;
			const isVisibleFirst = htmlRegion === VISIBLE_FIRST;
			const scrollRegionArea = getVisibleArea(scrollRegion, scrollerList);
			const visibleRegionArea = getVisibleArea(visibleRegion, scrollerList);
			const visibleArea = htmlRegion === VISIBLE ? visibleRegionArea : scrollRegionArea;
			const adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea;
			popupElement.style.left = "auto";
			popupElement.style.top = "auto";
			popupElement.style.right = "0";
			popupElement.style.bottom = "0";
			const popupMirrorRect = popupElement.getBoundingClientRect();
			popupElement.style.left = originLeft;
			popupElement.style.top = originTop;
			popupElement.style.right = originRight;
			popupElement.style.bottom = originBottom;
			popupElement.style.overflow = originOverflow;
			popupElement.parentElement?.removeChild(placeholderElement);
			const scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1e3) / 1e3);
			const scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1e3) / 1e3);
			if (scaleX === 0 || scaleY === 0 || isDOM(target) && !isVisible_default(target)) return;
			const { offset: offset$2, targetOffset: targetOffset$3 } = placementInfo;
			let [popupOffsetX, popupOffsetY] = getNumberOffset(popupRect, offset$2);
			const [targetOffsetX, targetOffsetY] = getNumberOffset(targetRect, targetOffset$3);
			targetRect.x -= targetOffsetX;
			targetRect.y -= targetOffsetY;
			const [popupPoint, targetPoint] = placementInfo.points || [];
			const targetPoints = splitPoints(targetPoint);
			const popupPoints = splitPoints(popupPoint);
			const targetAlignPoint = getAlignPoint(targetRect, targetPoints);
			const popupAlignPoint = getAlignPoint(popupRect, popupPoints);
			const nextAlignInfo = { ...placementInfo };
			let nextPoints = [popupPoints, targetPoints];
			let nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;
			let nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;
			function getIntersectionVisibleArea(offsetX, offsetY, area = visibleArea) {
				const l$1 = popupRect.x + offsetX;
				const t$1 = popupRect.y + offsetY;
				const r$1 = l$1 + popupWidth;
				const b = t$1 + popupHeight;
				const visibleL = Math.max(l$1, area.left);
				const visibleT = Math.max(t$1, area.top);
				const visibleR = Math.min(r$1, area.right);
				const visibleB = Math.min(b, area.bottom);
				return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));
			}
			const originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY);
			const originIntersectionRecommendArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY, visibleRegionArea);
			const targetAlignPointTL = getAlignPoint(targetRect, ["t", "l"]);
			const popupAlignPointTL = getAlignPoint(popupRect, ["t", "l"]);
			const targetAlignPointBR = getAlignPoint(targetRect, ["b", "r"]);
			const popupAlignPointBR = getAlignPoint(popupRect, ["b", "r"]);
			const { adjustX, adjustY, shiftX, shiftY } = placementInfo.overflow || {};
			const supportAdjust = (val) => {
				if (typeof val === "boolean") return val;
				return val >= 0;
			};
			let nextPopupY;
			let nextPopupBottom;
			let nextPopupX;
			let nextPopupRight;
			function syncNextPopupPosition() {
				nextPopupY = popupRect.y + nextOffsetY;
				nextPopupBottom = nextPopupY + popupHeight;
				nextPopupX = popupRect.x + nextOffsetX;
				nextPopupRight = nextPopupX + popupWidth;
			}
			syncNextPopupPosition();
			const needAdjustY = supportAdjust(adjustY);
			const sameTB = popupPoints[0] === targetPoints[0];
			if (needAdjustY && popupPoints[0] === "t" && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {
				let tmpNextOffsetY = nextOffsetY;
				if (sameTB) tmpNextOffsetY -= popupHeight - targetHeight;
				else tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;
				const newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);
				const newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);
				if (newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || newVisibleRecommendArea >= originIntersectionRecommendArea)) {
					prevFlipRef.current.bt = true;
					nextOffsetY = tmpNextOffsetY;
					popupOffsetY = -popupOffsetY;
					nextPoints = [reversePoints(nextPoints[0], 0), reversePoints(nextPoints[1], 0)];
				} else prevFlipRef.current.bt = false;
			}
			if (needAdjustY && popupPoints[0] === "b" && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {
				let tmpNextOffsetY = nextOffsetY;
				if (sameTB) tmpNextOffsetY += popupHeight - targetHeight;
				else tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;
				const newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);
				const newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);
				if (newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || newVisibleRecommendArea >= originIntersectionRecommendArea)) {
					prevFlipRef.current.tb = true;
					nextOffsetY = tmpNextOffsetY;
					popupOffsetY = -popupOffsetY;
					nextPoints = [reversePoints(nextPoints[0], 0), reversePoints(nextPoints[1], 0)];
				} else prevFlipRef.current.tb = false;
			}
			const needAdjustX = supportAdjust(adjustX);
			const sameLR = popupPoints[1] === targetPoints[1];
			if (needAdjustX && popupPoints[1] === "l" && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {
				let tmpNextOffsetX = nextOffsetX;
				if (sameLR) tmpNextOffsetX -= popupWidth - targetWidth;
				else tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;
				const newVisibleArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);
				const newVisibleRecommendArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);
				if (newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || newVisibleRecommendArea >= originIntersectionRecommendArea)) {
					prevFlipRef.current.rl = true;
					nextOffsetX = tmpNextOffsetX;
					popupOffsetX = -popupOffsetX;
					nextPoints = [reversePoints(nextPoints[0], 1), reversePoints(nextPoints[1], 1)];
				} else prevFlipRef.current.rl = false;
			}
			if (needAdjustX && popupPoints[1] === "r" && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {
				let tmpNextOffsetX = nextOffsetX;
				if (sameLR) tmpNextOffsetX += popupWidth - targetWidth;
				else tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;
				const newVisibleArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);
				const newVisibleRecommendArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);
				if (newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || newVisibleRecommendArea >= originIntersectionRecommendArea)) {
					prevFlipRef.current.lr = true;
					nextOffsetX = tmpNextOffsetX;
					popupOffsetX = -popupOffsetX;
					nextPoints = [reversePoints(nextPoints[0], 1), reversePoints(nextPoints[1], 1)];
				} else prevFlipRef.current.lr = false;
			}
			nextAlignInfo.points = [flatPoints(nextPoints[0]), flatPoints(nextPoints[1])];
			syncNextPopupPosition();
			const numShiftX = shiftX === true ? 0 : shiftX;
			if (typeof numShiftX === "number") {
				if (nextPopupX < visibleRegionArea.left) {
					nextOffsetX -= nextPopupX - visibleRegionArea.left - popupOffsetX;
					if (targetRect.x + targetWidth < visibleRegionArea.left + numShiftX) nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX;
				}
				if (nextPopupRight > visibleRegionArea.right) {
					nextOffsetX -= nextPopupRight - visibleRegionArea.right - popupOffsetX;
					if (targetRect.x > visibleRegionArea.right - numShiftX) nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX;
				}
			}
			const numShiftY = shiftY === true ? 0 : shiftY;
			if (typeof numShiftY === "number") {
				if (nextPopupY < visibleRegionArea.top) {
					nextOffsetY -= nextPopupY - visibleRegionArea.top - popupOffsetY;
					if (targetRect.y + targetHeight < visibleRegionArea.top + numShiftY) nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY;
				}
				if (nextPopupBottom > visibleRegionArea.bottom) {
					nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom - popupOffsetY;
					if (targetRect.y > visibleRegionArea.bottom - numShiftY) nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY;
				}
			}
			const popupLeft = popupRect.x + nextOffsetX;
			const popupRight = popupLeft + popupWidth;
			const popupTop = popupRect.y + nextOffsetY;
			const popupBottom = popupTop + popupHeight;
			const targetLeft = targetRect.x;
			const targetRight = targetLeft + targetWidth;
			const targetTop = targetRect.y;
			const targetBottom = targetTop + targetHeight;
			/** Arrow X of popup offset */
			const nextArrowX = (Math.max(popupLeft, targetLeft) + Math.min(popupRight, targetRight)) / 2 - popupLeft;
			const nextArrowY = (Math.max(popupTop, targetTop) + Math.min(popupBottom, targetBottom)) / 2 - popupTop;
			onPopupAlign?.(popupEle, nextAlignInfo);
			let offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width);
			let offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);
			if (scaleX === 1) {
				nextOffsetX = Math.round(nextOffsetX);
				offsetX4Right = Math.round(offsetX4Right);
			}
			if (scaleY === 1) {
				nextOffsetY = Math.round(nextOffsetY);
				offsetY4Bottom = Math.round(offsetY4Bottom);
			}
			setOffsetInfo({
				ready: true,
				offsetX: nextOffsetX / scaleX,
				offsetY: nextOffsetY / scaleY,
				offsetR: offsetX4Right / scaleX,
				offsetB: offsetY4Bottom / scaleY,
				arrowX: nextArrowX / scaleX,
				arrowY: nextArrowY / scaleY,
				scaleX,
				scaleY,
				align: nextAlignInfo
			});
		}
	});
	const triggerAlign = () => {
		alignCountRef.current += 1;
		const id = alignCountRef.current;
		Promise.resolve().then(() => {
			if (alignCountRef.current === id) onAlign();
		});
	};
	const resetReady = () => {
		setOffsetInfo((ori) => ({
			...ori,
			ready: false
		}));
	};
	useLayoutEffect_default(resetReady, [placement]);
	useLayoutEffect_default(() => {
		if (!open$2) resetReady();
	}, [open$2]);
	return [
		offsetInfo.ready,
		offsetInfo.offsetX,
		offsetInfo.offsetY,
		offsetInfo.offsetR,
		offsetInfo.offsetB,
		offsetInfo.arrowX,
		offsetInfo.arrowY,
		offsetInfo.scaleX,
		offsetInfo.scaleY,
		offsetInfo.align,
		triggerAlign
	];
}

//#endregion
//#region node_modules/@rc-component/trigger/es/hooks/useDelay.js
function useDelay$1() {
	const delayRef = import_react.useRef(null);
	const clearDelay = () => {
		if (delayRef.current) {
			clearTimeout(delayRef.current);
			delayRef.current = null;
		}
	};
	const delayInvoke = (callback, delay) => {
		clearDelay();
		if (delay === 0) callback();
		else delayRef.current = setTimeout(() => {
			callback();
		}, delay * 1e3);
	};
	import_react.useEffect(() => {
		return () => {
			clearDelay();
		};
	}, []);
	return delayInvoke;
}

//#endregion
//#region node_modules/@rc-component/trigger/es/hooks/useWatch.js
function useWatch$1(open$2, target, popup, onAlign, onScroll) {
	useLayoutEffect_default(() => {
		if (open$2 && target && popup) {
			const targetElement = target;
			const popupElement = popup;
			const targetScrollList = collectScroller(targetElement);
			const popupScrollList = collectScroller(popupElement);
			const win = getWin(popupElement);
			const mergedList = new Set([
				win,
				...targetScrollList,
				...popupScrollList
			]);
			function notifyScroll() {
				onAlign();
				onScroll();
			}
			mergedList.forEach((scroller) => {
				scroller.addEventListener("scroll", notifyScroll, { passive: true });
			});
			win.addEventListener("resize", notifyScroll, { passive: true });
			onAlign();
			return () => {
				mergedList.forEach((scroller) => {
					scroller.removeEventListener("scroll", notifyScroll);
					win.removeEventListener("resize", notifyScroll);
				});
			};
		}
	}, [
		open$2,
		target,
		popup
	]);
}

//#endregion
//#region node_modules/@rc-component/trigger/es/hooks/useWinClick.js
/**
* Close if click on the window.
* Return the function that click on the Popup element.
*/
function useWinClick(open$2, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen) {
	const openRef = import_react.useRef(open$2);
	openRef.current = open$2;
	const popupPointerDownRef = import_react.useRef(false);
	import_react.useEffect(() => {
		if (clickToHide && popupEle && (!mask || maskClosable)) {
			const onPointerDown = () => {
				popupPointerDownRef.current = false;
			};
			const onTriggerClose = (e$2) => {
				if (openRef.current && !inPopupOrChild(e$2.composedPath?.()?.[0] || e$2.target) && !popupPointerDownRef.current) triggerOpen(false);
			};
			const win = getWin(popupEle);
			win.addEventListener("pointerdown", onPointerDown, true);
			win.addEventListener("mousedown", onTriggerClose, true);
			win.addEventListener("contextmenu", onTriggerClose, true);
			const targetShadowRoot = getShadowRoot(targetEle);
			if (targetShadowRoot) {
				targetShadowRoot.addEventListener("mousedown", onTriggerClose, true);
				targetShadowRoot.addEventListener("contextmenu", onTriggerClose, true);
			}
			if (targetEle) {
				const targetRoot = targetEle.getRootNode?.();
				const popupRoot = popupEle.getRootNode?.();
				warning(targetRoot === popupRoot, `trigger element and popup element should in same shadow root.`);
			}
			return () => {
				win.removeEventListener("pointerdown", onPointerDown, true);
				win.removeEventListener("mousedown", onTriggerClose, true);
				win.removeEventListener("contextmenu", onTriggerClose, true);
				if (targetShadowRoot) {
					targetShadowRoot.removeEventListener("mousedown", onTriggerClose, true);
					targetShadowRoot.removeEventListener("contextmenu", onTriggerClose, true);
				}
			};
		}
	}, [
		clickToHide,
		targetEle,
		popupEle,
		mask,
		maskClosable
	]);
	function onPopupPointerDown() {
		popupPointerDownRef.current = true;
	}
	return onPopupPointerDown;
}

//#endregion
//#region node_modules/@rc-component/trigger/es/UniqueProvider/useTargetState.js
/**
* Control the state of popup bind target:
* 1. When set `target`. Do show the popup.
* 2. When `target` is removed. Do hide the popup.
* 3. When `target` change to another one:
*  a. We wait motion finish of previous popup.
*  b. Then we set new target and show the popup.
* 4. During appear/enter animation, cache new options and apply after animation completes.
*/
function useTargetState() {
	const [options, setOptions] = import_react.useState(null);
	const [open$2, setOpen] = import_react.useState(false);
	const [isAnimating, setIsAnimating] = import_react.useState(false);
	const pendingOptionsRef = import_react.useRef(null);
	return [
		useEvent_default((nextOptions) => {
			if (nextOptions === false) {
				pendingOptionsRef.current = null;
				setOpen(false);
			} else if (isAnimating && open$2) pendingOptionsRef.current = nextOptions;
			else {
				setOpen(true);
				setOptions(nextOptions);
				pendingOptionsRef.current = null;
				if (!open$2) setIsAnimating(true);
			}
		}),
		open$2,
		options,
		useEvent_default((visible) => {
			if (visible) {
				setIsAnimating(false);
				if (pendingOptionsRef.current) {
					setOptions(pendingOptionsRef.current);
					pendingOptionsRef.current = null;
				}
			} else {
				setIsAnimating(false);
				pendingOptionsRef.current = null;
			}
		})
	];
}

//#endregion
//#region node_modules/@rc-component/trigger/es/UniqueProvider/UniqueContainer.js
function _extends$95() {
	_extends$95 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$95.apply(this, arguments);
}
var UniqueContainer = (props) => {
	const { prefixCls, isMobile: isMobile$2, ready, open: open$2, align, offsetR, offsetB, offsetX, offsetY, arrowPos, popupSize, motion: motion$1, uniqueContainerClassName, uniqueContainerStyle } = props;
	const containerCls = `${prefixCls}-unique-container`;
	const [motionVisible, setMotionVisible] = import_react.useState(false);
	const offsetStyle = useOffsetStyle(isMobile$2, ready, open$2, align, offsetR, offsetB, offsetX, offsetY);
	const cachedOffsetStyleRef = import_react.useRef(offsetStyle);
	if (ready) cachedOffsetStyleRef.current = offsetStyle;
	const sizeStyle = {};
	if (popupSize) {
		sizeStyle.width = popupSize.width;
		sizeStyle.height = popupSize.height;
	}
	return /* @__PURE__ */ import_react.createElement(es_default$1, _extends$95({
		motionAppear: true,
		motionEnter: true,
		motionLeave: true,
		removeOnLeave: false,
		leavedClassName: `${containerCls}-hidden`
	}, motion$1, {
		visible: open$2,
		onVisibleChanged: (nextVisible) => {
			setMotionVisible(nextVisible);
		}
	}), ({ className: motionClassName, style: motionStyle }) => {
		const cls = clsx(containerCls, motionClassName, uniqueContainerClassName, { [`${containerCls}-visible`]: motionVisible });
		return /* @__PURE__ */ import_react.createElement("div", {
			className: cls,
			style: {
				"--arrow-x": `${arrowPos?.x || 0}px`,
				"--arrow-y": `${arrowPos?.y || 0}px`,
				...cachedOffsetStyleRef.current,
				...sizeStyle,
				...motionStyle,
				...uniqueContainerStyle
			}
		});
	});
};
var UniqueContainer_default = UniqueContainer;

//#endregion
//#region node_modules/@rc-component/trigger/es/UniqueProvider/index.js
var UniqueProvider$1 = ({ children, postTriggerProps }) => {
	const [trigger, open$2, options, onTargetVisibleChanged] = useTargetState();
	const mergedOptions = import_react.useMemo(() => {
		if (!options || !postTriggerProps) return options;
		return postTriggerProps(options);
	}, [options, postTriggerProps]);
	const [popupEle, setPopupEle] = import_react.useState(null);
	const [popupSize, setPopupSize] = import_react.useState(null);
	const externalPopupRef = import_react.useRef(null);
	const setPopupRef = useEvent_default((node$1) => {
		externalPopupRef.current = node$1;
		if (isDOM(node$1) && popupEle !== node$1) setPopupEle(node$1);
	});
	const isOpenRef = import_react.useRef(null);
	const delayInvoke = useDelay$1();
	const show = useEvent_default((showOptions, isOpen) => {
		isOpenRef.current = isOpen;
		delayInvoke(() => {
			trigger(showOptions);
		}, showOptions.delay);
	});
	const hide = (delay) => {
		delayInvoke(() => {
			if (isOpenRef.current?.()) return;
			trigger(false);
		}, delay);
	};
	const onVisibleChanged = useEvent_default((visible) => {
		onTargetVisibleChanged(visible);
	});
	const [ready, offsetX, offsetY, offsetR, offsetB, arrowX, arrowY, , , alignInfo, onAlign] = useAlign(open$2, popupEle, mergedOptions?.target, mergedOptions?.popupPlacement, mergedOptions?.builtinPlacements || {}, mergedOptions?.popupAlign, void 0, false);
	const alignedClassName = import_react.useMemo(() => {
		if (!mergedOptions) return "";
		return clsx(getAlignPopupClassName(mergedOptions.builtinPlacements || {}, mergedOptions.prefixCls || "", alignInfo, false), mergedOptions.getPopupClassNameFromAlign?.(alignInfo));
	}, [
		alignInfo,
		mergedOptions?.getPopupClassNameFromAlign,
		mergedOptions?.builtinPlacements,
		mergedOptions?.prefixCls
	]);
	const contextValue = import_react.useMemo(() => ({
		show,
		hide
	}), []);
	import_react.useEffect(() => {
		onAlign();
	}, [mergedOptions?.target]);
	const onPrepare = useEvent_default(() => {
		onAlign();
		return Promise.resolve();
	});
	const subPopupElements = import_react.useRef({});
	const parentContext = import_react.useContext(context_default$10);
	const triggerContextValue = import_react.useMemo(() => ({ registerSubPopup: (id, subPopupEle) => {
		subPopupElements.current[id] = subPopupEle;
		parentContext?.registerSubPopup(id, subPopupEle);
	} }), [parentContext]);
	const prefixCls = mergedOptions?.prefixCls;
	return /* @__PURE__ */ import_react.createElement(UniqueContext.Provider, { value: contextValue }, children, mergedOptions && /* @__PURE__ */ import_react.createElement(context_default$10.Provider, { value: triggerContextValue }, /* @__PURE__ */ import_react.createElement(Popup_default$1, {
		ref: setPopupRef,
		portal: es_default$7,
		onEsc: mergedOptions.onEsc,
		prefixCls,
		popup: mergedOptions.popup,
		className: clsx(mergedOptions.popupClassName, alignedClassName, `${prefixCls}-unique-controlled`),
		style: mergedOptions.popupStyle,
		target: mergedOptions.target,
		open: open$2,
		keepDom: true,
		fresh: true,
		autoDestroy: false,
		onVisibleChanged,
		ready,
		offsetX,
		offsetY,
		offsetR,
		offsetB,
		onAlign,
		onPrepare,
		onResize: (size) => setPopupSize({
			width: size.offsetWidth,
			height: size.offsetHeight
		}),
		arrowPos: {
			x: arrowX,
			y: arrowY
		},
		align: alignInfo,
		zIndex: mergedOptions.zIndex,
		mask: mergedOptions.mask,
		arrow: mergedOptions.arrow,
		motion: mergedOptions.popupMotion,
		maskMotion: mergedOptions.maskMotion,
		getPopupContainer: mergedOptions.getPopupContainer
	}, /* @__PURE__ */ import_react.createElement(UniqueContainer_default, {
		prefixCls,
		isMobile: false,
		ready,
		open: open$2,
		align: alignInfo,
		offsetR,
		offsetB,
		offsetX,
		offsetY,
		arrowPos: {
			x: arrowX,
			y: arrowY
		},
		popupSize,
		motion: mergedOptions.popupMotion,
		uniqueContainerClassName: clsx(mergedOptions.uniqueContainerClassName, alignedClassName),
		uniqueContainerStyle: mergedOptions.uniqueContainerStyle
	}))));
};
var UniqueProvider_default$1 = UniqueProvider$1;

//#endregion
//#region node_modules/@rc-component/trigger/es/index.js
var import_react_dom$7 = require_react_dom();
function generateTrigger(PortalComponent = es_default$7) {
	const Trigger = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
		const { prefixCls = "rc-trigger-popup", children, action = "hover", showAction, hideAction, popupVisible, defaultPopupVisible, onOpenChange, afterOpenChange, onPopupVisibleChange, afterPopupVisibleChange, mouseEnterDelay, mouseLeaveDelay = .1, focusDelay, blurDelay, mask, maskClosable = true, getPopupContainer, forceRender, autoDestroy, popup, popupClassName, uniqueContainerClassName, uniqueContainerStyle, popupStyle, popupPlacement, builtinPlacements = {}, popupAlign, zIndex, stretch, getPopupClassNameFromAlign, fresh, unique, alignPoint, onPopupClick, onPopupAlign, arrow, popupMotion, maskMotion, mobile, ...restProps } = props;
		const mergedAutoDestroy = autoDestroy || false;
		const openUncontrolled = popupVisible === void 0;
		const isMobile$2 = !!mobile;
		const subPopupElements = import_react.useRef({});
		const parentContext = import_react.useContext(context_default$10);
		const context = import_react.useMemo(() => {
			return { registerSubPopup: (id$1, subPopupEle) => {
				subPopupElements.current[id$1] = subPopupEle;
				parentContext?.registerSubPopup(id$1, subPopupEle);
			} };
		}, [parentContext]);
		const uniqueContext = import_react.useContext(UniqueContext);
		const id = useId_default();
		const [popupEle, setPopupEle] = import_react.useState(null);
		const externalPopupRef = import_react.useRef(null);
		const setPopupRef = useEvent_default((node$1) => {
			externalPopupRef.current = node$1;
			if (isDOM(node$1) && popupEle !== node$1) setPopupEle(node$1);
			parentContext?.registerSubPopup(id, node$1);
		});
		const [targetEle, setTargetEle] = import_react.useState(null);
		const externalForwardRef = import_react.useRef(null);
		const setTargetRef = useEvent_default((node$1) => {
			if (isDOM(node$1) && targetEle !== node$1) {
				setTargetEle(node$1);
				externalForwardRef.current = node$1;
			}
		});
		const cloneProps = {};
		const inPopupOrChild = useEvent_default((ele) => {
			const childDOM = targetEle;
			return childDOM?.contains(ele) || getShadowRoot(childDOM)?.host === ele || ele === childDOM || popupEle?.contains(ele) || getShadowRoot(popupEle)?.host === ele || ele === popupEle || Object.values(subPopupElements.current).some((subPopupEle) => subPopupEle?.contains(ele) || ele === subPopupEle);
		});
		const innerArrow = arrow ? { ...arrow !== true ? arrow : {} } : null;
		const [internalOpen, setInternalOpen] = useControlledState(defaultPopupVisible || false, popupVisible);
		const mergedOpen = internalOpen || false;
		const child = import_react.useMemo(() => {
			const nextChild = typeof children === "function" ? children({ open: mergedOpen }) : children;
			return import_react.Children.only(nextChild);
		}, [children, mergedOpen]);
		const originChildProps = child?.props || {};
		const isOpen = useEvent_default(() => mergedOpen);
		const getUniqueOptions = useEvent_default((delay = 0) => ({
			popup,
			target: targetEle,
			delay,
			prefixCls,
			popupClassName,
			uniqueContainerClassName,
			uniqueContainerStyle,
			popupStyle,
			popupPlacement,
			builtinPlacements,
			popupAlign,
			zIndex,
			mask,
			maskClosable,
			popupMotion,
			maskMotion,
			arrow: innerArrow,
			getPopupContainer,
			getPopupClassNameFromAlign,
			id,
			onEsc
		}));
		useLayoutEffect_default(() => {
			if (uniqueContext && unique && targetEle && !openUncontrolled && !parentContext) if (mergedOpen) uniqueContext.show(getUniqueOptions(mouseEnterDelay), isOpen);
			else uniqueContext.hide(mouseLeaveDelay);
		}, [mergedOpen, targetEle]);
		const openRef = import_react.useRef(mergedOpen);
		openRef.current = mergedOpen;
		const internalTriggerOpen = useEvent_default((nextOpen) => {
			(0, import_react_dom$7.flushSync)(() => {
				if (mergedOpen !== nextOpen) {
					setInternalOpen(nextOpen);
					onOpenChange?.(nextOpen);
					onPopupVisibleChange?.(nextOpen);
				}
			});
		});
		const delayInvoke = useDelay$1();
		const triggerOpen = (nextOpen, delay = 0) => {
			if (popupVisible !== void 0) {
				delayInvoke(() => {
					internalTriggerOpen(nextOpen);
				}, delay);
				return;
			}
			if (uniqueContext && unique && openUncontrolled && !parentContext) {
				if (nextOpen) uniqueContext.show(getUniqueOptions(delay), isOpen);
				else uniqueContext.hide(delay);
				return;
			}
			delayInvoke(() => {
				internalTriggerOpen(nextOpen);
			}, delay);
		};
		function onEsc({ top }) {
			if (top) triggerOpen(false);
		}
		const [inMotion, setInMotion] = import_react.useState(false);
		useLayoutEffect_default((firstMount) => {
			if (!firstMount || mergedOpen) setInMotion(true);
		}, [mergedOpen]);
		const [motionPrepareResolve, setMotionPrepareResolve] = import_react.useState(null);
		const [mousePos, setMousePos] = import_react.useState(null);
		const setMousePosByEvent = (event) => {
			setMousePos([event.clientX, event.clientY]);
		};
		const [ready, offsetX, offsetY, offsetR, offsetB, arrowX, arrowY, scaleX, scaleY, alignInfo, onAlign] = useAlign(mergedOpen, popupEle, alignPoint && mousePos !== null ? mousePos : targetEle, popupPlacement, builtinPlacements, popupAlign, onPopupAlign, isMobile$2);
		const [showActions, hideActions] = useAction(action, showAction, hideAction);
		const clickToShow = showActions.has("click");
		const clickToHide = hideActions.has("click") || hideActions.has("contextMenu");
		const triggerAlign = useEvent_default(() => {
			if (!inMotion) onAlign();
		});
		const onScroll = () => {
			if (openRef.current && alignPoint && clickToHide) triggerOpen(false);
		};
		useWatch$1(mergedOpen, targetEle, popupEle, triggerAlign, onScroll);
		useLayoutEffect_default(() => {
			triggerAlign();
		}, [mousePos, popupPlacement]);
		useLayoutEffect_default(() => {
			if (mergedOpen && !builtinPlacements?.[popupPlacement]) triggerAlign();
		}, [JSON.stringify(popupAlign)]);
		const alignedClassName = import_react.useMemo(() => {
			return clsx(getAlignPopupClassName(builtinPlacements, prefixCls, alignInfo, alignPoint), getPopupClassNameFromAlign?.(alignInfo));
		}, [
			alignInfo,
			getPopupClassNameFromAlign,
			builtinPlacements,
			prefixCls,
			alignPoint
		]);
		import_react.useImperativeHandle(ref, () => ({
			nativeElement: externalForwardRef.current,
			popupElement: externalPopupRef.current,
			forceAlign: triggerAlign
		}));
		const [targetWidth, setTargetWidth] = import_react.useState(0);
		const [targetHeight, setTargetHeight] = import_react.useState(0);
		const syncTargetSize = () => {
			if (stretch && targetEle) {
				const rect = targetEle.getBoundingClientRect();
				setTargetWidth(rect.width);
				setTargetHeight(rect.height);
			}
		};
		const onTargetResize = () => {
			syncTargetSize();
			triggerAlign();
		};
		const onVisibleChanged = (visible) => {
			setInMotion(false);
			onAlign();
			afterOpenChange?.(visible);
			afterPopupVisibleChange?.(visible);
		};
		const onPrepare = () => new Promise((resolve) => {
			syncTargetSize();
			setMotionPrepareResolve(() => resolve);
		});
		useLayoutEffect_default(() => {
			if (motionPrepareResolve) {
				onAlign();
				motionPrepareResolve();
				setMotionPrepareResolve(null);
			}
		}, [motionPrepareResolve]);
		/**
		* Util wrapper for trigger action
		* @param eventName  Listen event name
		* @param nextOpen  Next open state after trigger
		* @param delay Delay to trigger open change
		* @param callback Callback if current event need additional action
		* @param ignoreCheck  Ignore current event if check return true
		*/
		function wrapperAction(eventName, nextOpen, delay, callback, ignoreCheck) {
			cloneProps[eventName] = (event, ...args) => {
				if (!ignoreCheck || !ignoreCheck()) {
					callback?.(event);
					triggerOpen(nextOpen, delay);
				}
				originChildProps[eventName]?.(event, ...args);
			};
		}
		const touchToShow = showActions.has("touch");
		const touchToHide = hideActions.has("touch");
		/** Used for prevent `hover` event conflict with mobile env */
		const touchedRef = import_react.useRef(false);
		if (touchToShow || touchToHide) cloneProps.onTouchStart = (...args) => {
			touchedRef.current = true;
			if (openRef.current && touchToHide) triggerOpen(false);
			else if (!openRef.current && touchToShow) triggerOpen(true);
			originChildProps.onTouchStart?.(...args);
		};
		if (clickToShow || clickToHide) cloneProps.onClick = (event, ...args) => {
			if (openRef.current && clickToHide) triggerOpen(false);
			else if (!openRef.current && clickToShow) {
				setMousePosByEvent(event);
				triggerOpen(true);
			}
			originChildProps.onClick?.(event, ...args);
			touchedRef.current = false;
		};
		const onPopupPointerDown = useWinClick(mergedOpen, clickToHide || touchToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen);
		const hoverToShow = showActions.has("hover");
		const hoverToHide = hideActions.has("hover");
		let onPopupMouseEnter;
		let onPopupMouseLeave;
		const ignoreMouseTrigger = () => {
			return touchedRef.current;
		};
		if (hoverToShow) {
			const onMouseEnterCallback = (event) => {
				setMousePosByEvent(event);
			};
			wrapperAction("onMouseEnter", true, mouseEnterDelay, onMouseEnterCallback, ignoreMouseTrigger);
			wrapperAction("onPointerEnter", true, mouseEnterDelay, onMouseEnterCallback, ignoreMouseTrigger);
			onPopupMouseEnter = (event) => {
				if ((mergedOpen || inMotion) && popupEle?.contains(event.target)) triggerOpen(true, mouseEnterDelay);
			};
			if (alignPoint) cloneProps.onMouseMove = (event) => {
				originChildProps.onMouseMove?.(event);
			};
		}
		if (hoverToHide) {
			wrapperAction("onMouseLeave", false, mouseLeaveDelay, void 0, ignoreMouseTrigger);
			wrapperAction("onPointerLeave", false, mouseLeaveDelay, void 0, ignoreMouseTrigger);
			onPopupMouseLeave = () => {
				triggerOpen(false, mouseLeaveDelay);
			};
		}
		if (showActions.has("focus")) wrapperAction("onFocus", true, focusDelay);
		if (hideActions.has("focus")) wrapperAction("onBlur", false, blurDelay);
		if (showActions.has("contextMenu")) cloneProps.onContextMenu = (event, ...args) => {
			if (openRef.current && hideActions.has("contextMenu")) triggerOpen(false);
			else {
				setMousePosByEvent(event);
				triggerOpen(true);
			}
			event.preventDefault();
			originChildProps.onContextMenu?.(event, ...args);
		};
		const rendedRef = import_react.useRef(false);
		rendedRef.current ||= forceRender || mergedOpen || inMotion;
		const mergedChildrenProps = {
			...originChildProps,
			...cloneProps
		};
		const passedProps = {};
		[
			"onContextMenu",
			"onClick",
			"onMouseDown",
			"onTouchStart",
			"onMouseEnter",
			"onMouseLeave",
			"onFocus",
			"onBlur"
		].forEach((eventName) => {
			if (restProps[eventName]) passedProps[eventName] = (...args) => {
				mergedChildrenProps[eventName]?.(...args);
				restProps[eventName](...args);
			};
		});
		const arrowPos = {
			x: arrowX,
			y: arrowY
		};
		const triggerNode = /* @__PURE__ */ import_react.cloneElement(child, {
			...mergedChildrenProps,
			...passedProps
		});
		return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(es_default$2, {
			disabled: !mergedOpen,
			ref: setTargetRef,
			onResize: onTargetResize
		}, triggerNode), rendedRef.current && (!uniqueContext || !unique) && /* @__PURE__ */ import_react.createElement(context_default$10.Provider, { value: context }, /* @__PURE__ */ import_react.createElement(Popup_default$1, {
			portal: PortalComponent,
			ref: setPopupRef,
			prefixCls,
			popup,
			className: clsx(popupClassName, !isMobile$2 && alignedClassName),
			style: popupStyle,
			target: targetEle,
			onMouseEnter: onPopupMouseEnter,
			onMouseLeave: onPopupMouseLeave,
			onPointerEnter: onPopupMouseEnter,
			zIndex,
			open: mergedOpen,
			keepDom: inMotion,
			fresh,
			onClick: onPopupClick,
			onPointerDownCapture: onPopupPointerDown,
			mask,
			motion: popupMotion,
			maskMotion,
			onVisibleChanged,
			onPrepare,
			forceRender,
			autoDestroy: mergedAutoDestroy,
			getPopupContainer,
			onEsc,
			align: alignInfo,
			arrow: innerArrow,
			arrowPos,
			ready,
			offsetX,
			offsetY,
			offsetR,
			offsetB,
			onAlign: triggerAlign,
			stretch,
			targetWidth: targetWidth / scaleX,
			targetHeight: targetHeight / scaleY,
			mobile
		})));
	});
	Trigger.displayName = "Trigger";
	return Trigger;
}
var es_default$6 = generateTrigger(es_default$7);

//#endregion
//#region node_modules/antd/es/tooltip/UniqueProvider/MotionContent.js
var MotionContent = ({ children }) => {
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const rootPrefixCls = getPrefixCls();
	/* istanbul ignore next */
	if (!/* @__PURE__ */ import_react.isValidElement(children)) return children;
	return /* @__PURE__ */ import_react.createElement(es_default$1, {
		visible: true,
		motionName: `${rootPrefixCls}-fade`,
		motionAppear: true,
		motionEnter: true,
		motionLeave: false,
		removeOnLeave: false
	}, ({ style: motionStyle, className: motionClassName }) => {
		const { className, style: style$1 } = children.props;
		const mergedStyles = {
			...style$1,
			...motionStyle
		};
		return /* @__PURE__ */ import_react.cloneElement(children, {
			className: clsx(className, motionClassName),
			style: mergedStyles
		});
	});
};
var MotionContent_default = MotionContent;

//#endregion
//#region node_modules/antd/es/tooltip/UniqueProvider/index.js
var cachedPlacements = [null, null];
function uniqueBuiltinPlacements(ori) {
	if (cachedPlacements[0] !== ori) {
		const target = {};
		Object.keys(ori).forEach((placement) => {
			target[placement] = {
				...ori[placement],
				dynamicInset: false
			};
		});
		cachedPlacements[0] = ori;
		cachedPlacements[1] = target;
	}
	return cachedPlacements[1];
}
var UniqueProvider = ({ children }) => {
	const renderPopup = (options) => {
		const popupEle = typeof options.popup === "function" ? options.popup() : options.popup;
		const { id, builtinPlacements } = options;
		const parsedPlacements = uniqueBuiltinPlacements(builtinPlacements);
		return {
			...options,
			getPopupContainer: null,
			arrow: false,
			popup: /* @__PURE__ */ import_react.createElement(MotionContent_default, { key: id }, popupEle),
			builtinPlacements: parsedPlacements
		};
	};
	return /* @__PURE__ */ import_react.createElement(UniqueProvider_default$1, { postTriggerProps: renderPopup }, children);
};
var UniqueProvider_default = UniqueProvider;

//#endregion
//#region node_modules/antd/es/config-provider/DisabledContext.js
var DisabledContext = /* @__PURE__ */ import_react.createContext(false);
const DisabledContextProvider = ({ children, disabled }) => {
	const originDisabled = import_react.useContext(DisabledContext);
	return /* @__PURE__ */ import_react.createElement(DisabledContext.Provider, { value: disabled ?? originDisabled }, children);
};
var DisabledContext_default = DisabledContext;

//#endregion
//#region node_modules/antd/es/config-provider/SizeContext.js
var SizeContext = /* @__PURE__ */ import_react.createContext(void 0);
const SizeContextProvider = ({ children, size }) => {
	const originSize = import_react.useContext(SizeContext);
	return /* @__PURE__ */ import_react.createElement(SizeContext.Provider, { value: size || originSize }, children);
};
var SizeContext_default = SizeContext;

//#endregion
//#region node_modules/antd/es/config-provider/hooks/useConfig.js
function useConfig() {
	return {
		componentDisabled: (0, import_react.useContext)(DisabledContext_default),
		componentSize: (0, import_react.useContext)(SizeContext_default)
	};
}
var useConfig_default = useConfig;

//#endregion
//#region node_modules/antd/es/config-provider/hooks/useTheme.js
function useTheme(theme, parentTheme, config) {
	const warning$3 = devUseWarning("ConfigProvider");
	const themeConfig = theme || {};
	const parentThemeConfig = themeConfig.inherit === false || !parentTheme ? {
		...defaultConfig,
		hashed: parentTheme?.hashed ?? defaultConfig.hashed,
		cssVar: parentTheme?.cssVar
	} : parentTheme;
	const themeKey = (0, import_react.useId)();
	{
		const cssVarEnabled = themeConfig.cssVar || parentThemeConfig.cssVar;
		const validKey = !!(typeof themeConfig.cssVar === "object" && themeConfig.cssVar?.key || themeKey);
		warning$3(!cssVarEnabled || validKey, "breaking", "Missing key in `cssVar` config. Please upgrade to React 18 or set `cssVar.key` manually in each ConfigProvider inside `cssVar` enabled ConfigProvider.");
	}
	return useMemo$1(() => {
		if (!theme) return parentTheme;
		const mergedComponents = { ...parentThemeConfig.components };
		Object.keys(theme.components || {}).forEach((componentName) => {
			mergedComponents[componentName] = {
				...mergedComponents[componentName],
				...theme.components[componentName]
			};
		});
		const cssVarKey = `css-var-${themeKey.replace(/:/g, "")}`;
		const mergedCssVar = {
			prefix: config?.prefixCls,
			...parentThemeConfig.cssVar,
			...themeConfig.cssVar,
			key: themeConfig.cssVar?.key || cssVarKey
		};
		return {
			...parentThemeConfig,
			...themeConfig,
			token: {
				...parentThemeConfig.token,
				...themeConfig.token
			},
			components: mergedComponents,
			cssVar: mergedCssVar
		};
	}, [themeConfig, parentThemeConfig], (prev$1, next$1) => prev$1.some((prevTheme, index$1) => {
		const nextTheme = next$1[index$1];
		return !isEqual_default(prevTheme, nextTheme, true);
	}));
}

//#endregion
//#region node_modules/antd/es/config-provider/MotionWrapper.js
var MotionCacheContext = /* @__PURE__ */ import_react.createContext(true);
MotionCacheContext.displayName = "MotionCacheContext";
function MotionWrapper(props) {
	const parentMotion = import_react.useContext(MotionCacheContext);
	const { children } = props;
	const [, token$1] = useToken();
	const { motion: motion$1 } = token$1;
	const needWrapMotionProviderRef = import_react.useRef(false);
	needWrapMotionProviderRef.current || (needWrapMotionProviderRef.current = parentMotion !== motion$1);
	if (needWrapMotionProviderRef.current) return /* @__PURE__ */ import_react.createElement(MotionCacheContext.Provider, { value: motion$1 }, /* @__PURE__ */ import_react.createElement(MotionProvider, { motion: motion$1 }, children));
	return children;
}

//#endregion
//#region node_modules/antd/es/config-provider/PropWarning.js
/**
* Warning for ConfigProviderProps.
* This will be empty function in production.
*/
var PropWarning = /* @__PURE__ */ import_react.memo(({ dropdownMatchSelectWidth }) => {
	devUseWarning("ConfigProvider").deprecated(dropdownMatchSelectWidth === void 0, "dropdownMatchSelectWidth", "popupMatchSelectWidth");
	return null;
});
PropWarning.displayName = "PropWarning";
var PropWarning_default = PropWarning;

//#endregion
//#region node_modules/antd/es/config-provider/index.js
/**
* Since too many feedback using static method like `Modal.confirm` not getting theme, we record the
* theme register info here to help developer get warning info.
*/
var existThemeConfig = false;
const warnContext = (componentName) => {
	warning_default(!existThemeConfig, componentName, `Static function can not consume context like dynamic theme. Please use 'App' component instead.`);
};
var PASSED_PROPS = [
	"getTargetContainer",
	"getPopupContainer",
	"renderEmpty",
	"input",
	"pagination",
	"form",
	"select",
	"button"
];
var globalPrefixCls;
var globalIconPrefixCls;
var globalTheme;
var globalHolderRender;
function getGlobalPrefixCls() {
	return globalPrefixCls || defaultPrefixCls;
}
function getGlobalIconPrefixCls() {
	return globalIconPrefixCls || defaultIconPrefixCls;
}
var setGlobalConfig = (props) => {
	const { prefixCls, iconPrefixCls, theme, holderRender } = props;
	if (prefixCls !== void 0) globalPrefixCls = prefixCls;
	if (iconPrefixCls !== void 0) globalIconPrefixCls = iconPrefixCls;
	if ("holderRender" in props) globalHolderRender = holderRender;
	if (theme) globalTheme = theme;
};
const globalConfig = () => ({
	getPrefixCls: (suffixCls, customizePrefixCls) => {
		if (customizePrefixCls) return customizePrefixCls;
		return suffixCls ? `${getGlobalPrefixCls()}-${suffixCls}` : getGlobalPrefixCls();
	},
	getIconPrefixCls: getGlobalIconPrefixCls,
	getRootPrefixCls: () => {
		if (globalPrefixCls) return globalPrefixCls;
		return getGlobalPrefixCls();
	},
	getTheme: () => globalTheme,
	holderRender: globalHolderRender
});
var ProviderChildren = (props) => {
	const { children, csp: customCsp, autoInsertSpaceInButton, alert, affix, anchor, form, locale: locale$5, componentSize, direction, space, splitter, virtual, dropdownMatchSelectWidth, popupMatchSelectWidth, popupOverflow, legacyLocale, parentContext, iconPrefixCls: customIconPrefixCls, theme, componentDisabled, segmented, statistic: statistic$1, spin, calendar, carousel, cascader, collapse, typography, checkbox, descriptions, divider, drawer, skeleton, steps, image, layout, list, mentions, modal, progress, result, slider, breadcrumb, masonry, menu, pagination, input, textArea, otp, empty: empty$1, badge, radio, rate, ribbon, switch: SWITCH, transfer, avatar, message: message$1, tag, table, card, cardMeta, tabs, timeline, timePicker, upload: upload$1, notification: notification$1, tree, colorPicker, datePicker, rangePicker, flex, wave, dropdown, warning: warningConfig, tour, tooltip, popover, popconfirm, qrcode, floatButton, floatButtonGroup, variant, inputNumber, treeSelect, watermark } = props;
	const getPrefixCls = import_react.useCallback((suffixCls, customizePrefixCls) => {
		const { prefixCls } = props;
		if (customizePrefixCls) return customizePrefixCls;
		const mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
		return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
	}, [parentContext.getPrefixCls, props.prefixCls]);
	const iconPrefixCls = customIconPrefixCls || parentContext.iconPrefixCls || defaultIconPrefixCls;
	const csp = customCsp || parentContext.csp;
	useResetIconStyle_default(iconPrefixCls, csp);
	const mergedTheme = useTheme(theme, parentContext.theme, { prefixCls: getPrefixCls("") });
	existThemeConfig = existThemeConfig || !!mergedTheme;
	const baseConfig = {
		csp,
		autoInsertSpaceInButton,
		alert,
		affix,
		anchor,
		locale: locale$5 || legacyLocale,
		direction,
		space,
		splitter,
		virtual,
		popupMatchSelectWidth: popupMatchSelectWidth ?? dropdownMatchSelectWidth,
		popupOverflow,
		getPrefixCls,
		iconPrefixCls,
		theme: mergedTheme,
		segmented,
		statistic: statistic$1,
		spin,
		calendar,
		carousel,
		cascader,
		collapse,
		typography,
		checkbox,
		descriptions,
		divider,
		drawer,
		skeleton,
		steps,
		image,
		input,
		textArea,
		otp,
		layout,
		list,
		mentions,
		modal,
		progress,
		result,
		slider,
		breadcrumb,
		masonry,
		menu,
		pagination,
		empty: empty$1,
		badge,
		radio,
		rate,
		ribbon,
		switch: SWITCH,
		transfer,
		avatar,
		message: message$1,
		tag,
		table,
		card,
		cardMeta,
		tabs,
		timeline,
		timePicker,
		upload: upload$1,
		notification: notification$1,
		tree,
		colorPicker,
		datePicker,
		rangePicker,
		flex,
		wave,
		dropdown,
		warning: warningConfig,
		tour,
		tooltip,
		popover,
		popconfirm,
		qrcode,
		floatButton,
		floatButtonGroup,
		variant,
		inputNumber,
		treeSelect,
		watermark
	};
	devUseWarning("ConfigProvider")(!("autoInsertSpaceInButton" in props), "deprecated", "`autoInsertSpaceInButton` is deprecated. Please use `{ button: { autoInsertSpace: boolean }}` instead.");
	const config = { ...parentContext };
	Object.keys(baseConfig).forEach((key) => {
		if (baseConfig[key] !== void 0) config[key] = baseConfig[key];
	});
	PASSED_PROPS.forEach((propName) => {
		const propValue = props[propName];
		if (propValue) config[propName] = propValue;
	});
	if (typeof autoInsertSpaceInButton !== "undefined") config.button = {
		autoInsertSpace: autoInsertSpaceInButton,
		...config.button
	};
	const memoedConfig = useMemo$1(() => config, config, (prevConfig, currentConfig) => {
		const prevKeys = Object.keys(prevConfig);
		const currentKeys = Object.keys(currentConfig);
		return prevKeys.length !== currentKeys.length || prevKeys.some((key) => prevConfig[key] !== currentConfig[key]);
	});
	const { layer } = import_react.useContext(StyleContext_default);
	const memoIconContextValue = import_react.useMemo(() => ({
		prefixCls: iconPrefixCls,
		csp,
		layer: layer ? "antd" : void 0
	}), [
		iconPrefixCls,
		csp,
		layer
	]);
	let childNode = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(PropWarning_default, { dropdownMatchSelectWidth }), children);
	const validateMessages = import_react.useMemo(() => merge$1(en_US_default.Form?.defaultValidateMessages || {}, memoedConfig.locale?.Form?.defaultValidateMessages || {}, memoedConfig.form?.validateMessages || {}, form?.validateMessages || {}), [memoedConfig, form?.validateMessages]);
	if (Object.keys(validateMessages).length > 0) childNode = /* @__PURE__ */ import_react.createElement(validateMessagesContext_default.Provider, { value: validateMessages }, childNode);
	if (locale$5) childNode = /* @__PURE__ */ import_react.createElement(locale_default, {
		locale: locale$5,
		_ANT_MARK__: ANT_MARK
	}, childNode);
	if (iconPrefixCls || csp) childNode = /* @__PURE__ */ import_react.createElement(Context_default$1.Provider, { value: memoIconContextValue }, childNode);
	if (componentSize) childNode = /* @__PURE__ */ import_react.createElement(SizeContextProvider, { size: componentSize }, childNode);
	childNode = /* @__PURE__ */ import_react.createElement(MotionWrapper, null, childNode);
	if (tooltip?.unique) childNode = /* @__PURE__ */ import_react.createElement(UniqueProvider_default, null, childNode);
	const memoTheme = import_react.useMemo(() => {
		const { algorithm, token: token$1, components: components$1, cssVar, ...rest } = mergedTheme || {};
		const themeObj = algorithm && (!Array.isArray(algorithm) || algorithm.length > 0) ? createTheme(algorithm) : theme_default$1;
		const parsedComponents = {};
		Object.entries(components$1 || {}).forEach(([componentName, componentToken]) => {
			const parsedToken = { ...componentToken };
			if ("algorithm" in parsedToken) {
				if (parsedToken.algorithm === true) parsedToken.theme = themeObj;
				else if (Array.isArray(parsedToken.algorithm) || typeof parsedToken.algorithm === "function") parsedToken.theme = createTheme(parsedToken.algorithm);
				delete parsedToken.algorithm;
			}
			parsedComponents[componentName] = parsedToken;
		});
		const mergedToken = {
			...seed_default,
			...token$1
		};
		return {
			...rest,
			theme: themeObj,
			token: mergedToken,
			components: parsedComponents,
			override: {
				override: mergedToken,
				...parsedComponents
			},
			cssVar
		};
	}, [mergedTheme]);
	if (theme) childNode = /* @__PURE__ */ import_react.createElement(DesignTokenContext.Provider, { value: memoTheme }, childNode);
	if (memoedConfig.warning) childNode = /* @__PURE__ */ import_react.createElement(WarningContext.Provider, { value: memoedConfig.warning }, childNode);
	if (componentDisabled !== void 0) childNode = /* @__PURE__ */ import_react.createElement(DisabledContextProvider, { disabled: componentDisabled }, childNode);
	return /* @__PURE__ */ import_react.createElement(ConfigContext.Provider, { value: memoedConfig }, childNode);
};
var ConfigProvider = (props) => {
	const context = import_react.useContext(ConfigContext);
	const antLocale = import_react.useContext(context_default$9);
	return /* @__PURE__ */ import_react.createElement(ProviderChildren, {
		parentContext: context,
		legacyLocale: antLocale,
		...props
	});
};
ConfigProvider.ConfigContext = ConfigContext;
ConfigProvider.SizeContext = SizeContext_default;
ConfigProvider.config = setGlobalConfig;
ConfigProvider.useConfig = useConfig_default;
Object.defineProperty(ConfigProvider, "SizeContext", { get: () => {
	warning_default(false, "ConfigProvider", "ConfigProvider.SizeContext is deprecated. Please use `ConfigProvider.useConfig().componentSize` instead.");
	return SizeContext_default;
} });
ConfigProvider.displayName = "ConfigProvider";
var config_provider_default = ConfigProvider;

//#endregion
//#region node_modules/antd/es/anchor/context.js
var AnchorContext = /* @__PURE__ */ import_react.createContext(void 0);
var context_default$8 = AnchorContext;

//#endregion
//#region node_modules/antd/es/anchor/AnchorLink.js
var AnchorLink = (props) => {
	const { href, title, prefixCls: customizePrefixCls, children, className, target, replace: replace$1 } = props;
	const { registerLink, unregisterLink, scrollTo: scrollTo$1, onClick, activeLink, direction, classNames: mergedClassNames, styles: mergedStyles } = import_react.useContext(context_default$8) || {};
	import_react.useEffect(() => {
		registerLink?.(href);
		return () => {
			unregisterLink?.(href);
		};
	}, [href]);
	const handleClick = (e$2) => {
		onClick?.(e$2, {
			title,
			href
		});
		scrollTo$1?.(href);
		if (e$2.defaultPrevented) return;
		if (href.startsWith("http://") || href.startsWith("https://")) {
			if (replace$1) {
				e$2.preventDefault();
				window.location.replace(href);
			}
			return;
		}
		e$2.preventDefault();
		const historyMethod = replace$1 ? "replaceState" : "pushState";
		window.history[historyMethod](null, "", href);
	};
	devUseWarning("Anchor.Link")(!children || direction !== "horizontal", "usage", "`Anchor.Link children` is not supported when `Anchor` direction is horizontal");
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("anchor", customizePrefixCls);
	const active = activeLink === href;
	const wrapperClassName = clsx(`${prefixCls}-link`, className, mergedClassNames?.item, { [`${prefixCls}-link-active`]: active });
	const titleClassName = clsx(`${prefixCls}-link-title`, mergedClassNames?.itemTitle, { [`${prefixCls}-link-title-active`]: active });
	return /* @__PURE__ */ import_react.createElement("div", {
		className: wrapperClassName,
		style: mergedStyles?.item
	}, /* @__PURE__ */ import_react.createElement("a", {
		className: titleClassName,
		style: mergedStyles?.itemTitle,
		href,
		title: typeof title === "string" ? title : "",
		target,
		onClick: handleClick
	}, title), direction !== "horizontal" ? children : null);
};
var AnchorLink_default = AnchorLink;

//#endregion
//#region node_modules/antd/es/anchor/style/index.js
var genSharedAnchorStyle = (token$1) => {
	const { componentCls, holderOffsetBlock, motionDurationSlow, lineWidthBold, colorPrimary, lineType, colorSplit, calc } = token$1;
	return { [`${componentCls}-wrapper`]: {
		marginBlockStart: calc(holderOffsetBlock).mul(-1).equal(),
		paddingBlockStart: holderOffsetBlock,
		[componentCls]: {
			...resetComponent(token$1),
			position: "relative",
			paddingInlineStart: lineWidthBold,
			[`${componentCls}-link`]: {
				paddingBlock: token$1.linkPaddingBlock,
				paddingInline: `${unit(token$1.linkPaddingInlineStart)} 0`,
				"&-title": {
					...textEllipsis,
					position: "relative",
					display: "block",
					marginBlockEnd: token$1.anchorTitleBlock,
					color: token$1.colorText,
					transition: `all ${token$1.motionDurationSlow}`,
					"&:only-child": { marginBlockEnd: 0 }
				},
				[`&-active > ${componentCls}-link-title`]: { color: token$1.colorPrimary },
				[`${componentCls}-link`]: { paddingBlock: token$1.anchorPaddingBlockSecondary }
			}
		},
		[`&:not(${componentCls}-wrapper-horizontal)`]: { [componentCls]: {
			"&::before": {
				position: "absolute",
				insetInlineStart: 0,
				top: 0,
				height: "100%",
				borderInlineStart: `${unit(lineWidthBold)} ${lineType} ${colorSplit}`,
				content: "\" \""
			},
			[`${componentCls}-ink`]: {
				position: "absolute",
				insetInlineStart: 0,
				display: "none",
				transform: "translateY(-50%)",
				transition: `top ${motionDurationSlow} ease-in-out`,
				width: lineWidthBold,
				backgroundColor: colorPrimary,
				[`&${componentCls}-ink-visible`]: { display: "inline-block" }
			}
		} },
		[`${componentCls}-fixed ${componentCls}-ink ${componentCls}-ink`]: { display: "none" }
	} };
};
var genSharedAnchorHorizontalStyle = (token$1) => {
	const { componentCls, motionDurationSlow, lineWidthBold, colorPrimary } = token$1;
	return { [`${componentCls}-wrapper-horizontal`]: {
		position: "relative",
		"&::before": {
			position: "absolute",
			left: {
				_skip_check_: true,
				value: 0
			},
			right: {
				_skip_check_: true,
				value: 0
			},
			bottom: 0,
			borderBottom: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}`,
			content: "\" \""
		},
		[componentCls]: {
			overflowX: "scroll",
			position: "relative",
			display: "flex",
			scrollbarWidth: "none",
			"&::-webkit-scrollbar": { display: "none" },
			[`${componentCls}-link:first-of-type`]: { paddingInline: 0 },
			[`${componentCls}-ink`]: {
				position: "absolute",
				bottom: 0,
				transition: `left ${motionDurationSlow} ease-in-out, width ${motionDurationSlow} ease-in-out`,
				height: lineWidthBold,
				backgroundColor: colorPrimary
			}
		}
	} };
};
const prepareComponentToken$55 = (token$1) => ({
	linkPaddingBlock: token$1.paddingXXS,
	linkPaddingInlineStart: token$1.padding
});
var style_default$62 = genStyleHooks("Anchor", (token$1) => {
	const { fontSize, fontSizeLG, paddingXXS, calc } = token$1;
	const anchorToken = merge(token$1, {
		holderOffsetBlock: paddingXXS,
		anchorPaddingBlockSecondary: calc(paddingXXS).div(2).equal(),
		anchorTitleBlock: calc(fontSize).div(14).mul(3).equal(),
		anchorBallSize: calc(fontSizeLG).div(2).equal()
	});
	return [genSharedAnchorStyle(anchorToken), genSharedAnchorHorizontalStyle(anchorToken)];
}, prepareComponentToken$55);

//#endregion
//#region node_modules/antd/es/anchor/Anchor.js
function getDefaultContainer() {
	return window;
}
function getOffsetTop(element, container) {
	if (!element.getClientRects().length) return 0;
	const rect = element.getBoundingClientRect();
	if (rect.width || rect.height) {
		if (container === window) return rect.top - element.ownerDocument.documentElement.clientTop;
		return rect.top - container.getBoundingClientRect().top;
	}
	return rect.top;
}
var sharpMatcherRegex = /#([\S ]+)$/;
var Anchor$1 = (props) => {
	const { rootClassName, prefixCls: customPrefixCls, className, style: style$1, offsetTop, affix = true, showInkInFixed = false, children, items, direction: anchorDirection = "vertical", bounds, targetOffset: targetOffset$3, onClick, onChange, getContainer, getCurrentAnchor, replace: replace$1, classNames, styles } = props;
	{
		const warning$3 = devUseWarning("Anchor");
		warning$3.deprecated(!children, "Anchor children", "items");
		warning$3(!(anchorDirection === "horizontal" && items?.some((n$1) => "children" in n$1)), "usage", "`Anchor items#children` is not supported when `Anchor` direction is horizontal.");
	}
	const [links, setLinks] = import_react.useState([]);
	const [activeLink, setActiveLink] = import_react.useState(null);
	const activeLinkRef = import_react.useRef(activeLink);
	const wrapperRef = import_react.useRef(null);
	const spanLinkNode = import_react.useRef(null);
	const animating = import_react.useRef(false);
	const scrollRequestId = import_react.useRef(null);
	const { direction, getPrefixCls, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("anchor");
	const { getTargetContainer } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("anchor", customPrefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$62(prefixCls, rootCls);
	const getCurrentContainer = getContainer ?? getTargetContainer ?? getDefaultContainer;
	const dependencyListItem = JSON.stringify(links);
	const registerLink = useEvent_default((link) => {
		if (!links.includes(link)) setLinks((prev$1) => [].concat(_toConsumableArray(prev$1), [link]));
	});
	const unregisterLink = useEvent_default((link) => {
		if (links.includes(link)) setLinks((prev$1) => prev$1.filter((i) => i !== link));
	});
	const updateInk = () => {
		const linkNode = wrapperRef.current?.querySelector(`.${prefixCls}-link-title-active`);
		if (linkNode && spanLinkNode.current) {
			const { style: inkStyle } = spanLinkNode.current;
			const horizontalAnchor = anchorDirection === "horizontal";
			inkStyle.top = horizontalAnchor ? "" : `${linkNode.offsetTop + linkNode.clientHeight / 2}px`;
			inkStyle.height = horizontalAnchor ? "" : `${linkNode.clientHeight}px`;
			inkStyle.left = horizontalAnchor ? `${linkNode.offsetLeft}px` : "";
			inkStyle.width = horizontalAnchor ? `${linkNode.clientWidth}px` : "";
			if (horizontalAnchor) e(linkNode, {
				scrollMode: "if-needed",
				block: "nearest"
			});
		}
	};
	const getInternalCurrentAnchor = (_links, _offsetTop = 0, _bounds = 5) => {
		const linkSections = [];
		const container = getCurrentContainer();
		_links.forEach((link) => {
			const sharpLinkMatch = sharpMatcherRegex.exec(link?.toString());
			if (!sharpLinkMatch) return;
			const target = document.getElementById(sharpLinkMatch[1]);
			if (target) {
				const top = getOffsetTop(target, container);
				if (top <= _offsetTop + _bounds) linkSections.push({
					link,
					top
				});
			}
		});
		if (linkSections.length) return linkSections.reduce((prev$1, curr) => curr.top > prev$1.top ? curr : prev$1).link;
		return "";
	};
	const setCurrentActiveLink = useEvent_default((link) => {
		if (activeLinkRef.current === link) return;
		const newLink = typeof getCurrentAnchor === "function" ? getCurrentAnchor(link) : link;
		setActiveLink(newLink);
		activeLinkRef.current = newLink;
		onChange?.(link);
	});
	const handleScroll = import_react.useCallback(() => {
		if (animating.current) return;
		setCurrentActiveLink(getInternalCurrentAnchor(links, targetOffset$3 !== void 0 ? targetOffset$3 : offsetTop || 0, bounds));
	}, [
		links,
		targetOffset$3,
		offsetTop,
		bounds
	]);
	const handleScrollTo = import_react.useCallback((link) => {
		const previousActiveLink = activeLinkRef.current;
		setCurrentActiveLink(link);
		const sharpLinkMatch = sharpMatcherRegex.exec(link);
		if (!sharpLinkMatch) return;
		const targetElement = document.getElementById(sharpLinkMatch[1]);
		if (!targetElement) return;
		if (animating.current) {
			if (previousActiveLink === link) return;
			scrollRequestId.current?.();
		}
		const container = getCurrentContainer();
		let y = getScroll_default(container) + getOffsetTop(targetElement, container);
		y -= targetOffset$3 !== void 0 ? targetOffset$3 : offsetTop || 0;
		animating.current = true;
		scrollRequestId.current = scrollTo(y, {
			getContainer: getCurrentContainer,
			callback() {
				animating.current = false;
			}
		});
	}, [targetOffset$3, offsetTop]);
	const mergedProps = {
		...props,
		direction: anchorDirection
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const wrapperClass = clsx(hashId, cssVarCls, rootCls, rootClassName, `${prefixCls}-wrapper`, {
		[`${prefixCls}-wrapper-horizontal`]: anchorDirection === "horizontal",
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, className, contextClassName, mergedClassNames.root);
	const anchorClass = clsx(prefixCls, { [`${prefixCls}-fixed`]: !affix && !showInkInFixed });
	const inkClass = clsx(`${prefixCls}-ink`, mergedClassNames.indicator, { [`${prefixCls}-ink-visible`]: activeLink });
	const wrapperStyle = {
		maxHeight: offsetTop ? `calc(100vh - ${offsetTop}px)` : "100vh",
		...mergedStyles.root,
		...contextStyle,
		...style$1
	};
	const createNestedLink = (options) => Array.isArray(options) ? options.map((item) => /* @__PURE__ */ import_react.createElement(AnchorLink_default, {
		replace: replace$1,
		...item,
		key: item.key
	}, anchorDirection === "vertical" && createNestedLink(item.children))) : null;
	const anchorContent = /* @__PURE__ */ import_react.createElement("div", {
		ref: wrapperRef,
		className: wrapperClass,
		style: wrapperStyle
	}, /* @__PURE__ */ import_react.createElement("div", { className: anchorClass }, /* @__PURE__ */ import_react.createElement("span", {
		className: inkClass,
		ref: spanLinkNode,
		style: mergedStyles.indicator
	}), "items" in props ? createNestedLink(items) : children));
	import_react.useEffect(() => {
		const scrollContainer = getCurrentContainer();
		handleScroll();
		scrollContainer?.addEventListener("scroll", handleScroll);
		return () => {
			scrollContainer?.removeEventListener("scroll", handleScroll);
		};
	}, [dependencyListItem]);
	import_react.useEffect(() => {
		if (typeof getCurrentAnchor === "function") setCurrentActiveLink(getCurrentAnchor(activeLinkRef.current || ""));
	}, [getCurrentAnchor]);
	import_react.useEffect(() => {
		updateInk();
	}, [
		anchorDirection,
		getCurrentAnchor,
		dependencyListItem,
		activeLink
	]);
	const memoizedContextValue = import_react.useMemo(() => ({
		registerLink,
		unregisterLink,
		scrollTo: handleScrollTo,
		activeLink,
		onClick,
		direction: anchorDirection,
		classNames: mergedClassNames,
		styles: mergedStyles
	}), [
		activeLink,
		onClick,
		handleScrollTo,
		anchorDirection,
		mergedStyles,
		mergedClassNames
	]);
	const affixProps = affix && typeof affix === "object" ? affix : void 0;
	return /* @__PURE__ */ import_react.createElement(context_default$8.Provider, { value: memoizedContextValue }, affix ? /* @__PURE__ */ import_react.createElement(affix_default, {
		offsetTop,
		target: getCurrentContainer,
		...affixProps
	}, anchorContent) : anchorContent);
};
Anchor$1.displayName = "Anchor";
var Anchor_default = Anchor$1;

//#endregion
//#region node_modules/antd/es/anchor/index.js
var Anchor = Anchor_default;
Anchor.Link = AnchorLink_default;
var anchor_default = Anchor;

//#endregion
//#region node_modules/@rc-component/util/es/KeyCode.js
/**
* @ignore
* some key-codes definition and utils from closure-library
* @author yiminghe@gmail.com
*/
var KeyCode = {
	MAC_ENTER: 3,
	BACKSPACE: 8,
	TAB: 9,
	NUM_CENTER: 12,
	ENTER: 13,
	SHIFT: 16,
	CTRL: 17,
	ALT: 18,
	PAUSE: 19,
	CAPS_LOCK: 20,
	ESC: 27,
	SPACE: 32,
	PAGE_UP: 33,
	PAGE_DOWN: 34,
	END: 35,
	HOME: 36,
	LEFT: 37,
	UP: 38,
	RIGHT: 39,
	DOWN: 40,
	PRINT_SCREEN: 44,
	INSERT: 45,
	DELETE: 46,
	ZERO: 48,
	ONE: 49,
	TWO: 50,
	THREE: 51,
	FOUR: 52,
	FIVE: 53,
	SIX: 54,
	SEVEN: 55,
	EIGHT: 56,
	NINE: 57,
	QUESTION_MARK: 63,
	A: 65,
	B: 66,
	C: 67,
	D: 68,
	E: 69,
	F: 70,
	G: 71,
	H: 72,
	I: 73,
	J: 74,
	K: 75,
	L: 76,
	M: 77,
	N: 78,
	O: 79,
	P: 80,
	Q: 81,
	R: 82,
	S: 83,
	T: 84,
	U: 85,
	V: 86,
	W: 87,
	X: 88,
	Y: 89,
	Z: 90,
	META: 91,
	WIN_KEY_RIGHT: 92,
	CONTEXT_MENU: 93,
	NUM_ZERO: 96,
	NUM_ONE: 97,
	NUM_TWO: 98,
	NUM_THREE: 99,
	NUM_FOUR: 100,
	NUM_FIVE: 101,
	NUM_SIX: 102,
	NUM_SEVEN: 103,
	NUM_EIGHT: 104,
	NUM_NINE: 105,
	NUM_MULTIPLY: 106,
	NUM_PLUS: 107,
	NUM_MINUS: 109,
	NUM_PERIOD: 110,
	NUM_DIVISION: 111,
	F1: 112,
	F2: 113,
	F3: 114,
	F4: 115,
	F5: 116,
	F6: 117,
	F7: 118,
	F8: 119,
	F9: 120,
	F10: 121,
	F11: 122,
	F12: 123,
	NUMLOCK: 144,
	SEMICOLON: 186,
	DASH: 189,
	EQUALS: 187,
	COMMA: 188,
	PERIOD: 190,
	SLASH: 191,
	APOSTROPHE: 192,
	SINGLE_QUOTE: 222,
	OPEN_SQUARE_BRACKET: 219,
	BACKSLASH: 220,
	CLOSE_SQUARE_BRACKET: 221,
	WIN_KEY: 224,
	MAC_FF_META: 224,
	WIN_IME: 229,
	isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e$2) {
		const { keyCode } = e$2;
		if (e$2.altKey && !e$2.ctrlKey || e$2.metaKey || keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) return false;
		switch (keyCode) {
			case KeyCode.ALT:
			case KeyCode.CAPS_LOCK:
			case KeyCode.CONTEXT_MENU:
			case KeyCode.CTRL:
			case KeyCode.DOWN:
			case KeyCode.END:
			case KeyCode.ESC:
			case KeyCode.HOME:
			case KeyCode.INSERT:
			case KeyCode.LEFT:
			case KeyCode.MAC_FF_META:
			case KeyCode.META:
			case KeyCode.NUMLOCK:
			case KeyCode.NUM_CENTER:
			case KeyCode.PAGE_DOWN:
			case KeyCode.PAGE_UP:
			case KeyCode.PAUSE:
			case KeyCode.PRINT_SCREEN:
			case KeyCode.RIGHT:
			case KeyCode.SHIFT:
			case KeyCode.UP:
			case KeyCode.WIN_KEY:
			case KeyCode.WIN_KEY_RIGHT: return false;
			default: return true;
		}
	},
	isCharacterKey: function isCharacterKey(keyCode) {
		if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) return true;
		if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) return true;
		if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) return true;
		if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) return true;
		switch (keyCode) {
			case KeyCode.SPACE:
			case KeyCode.QUESTION_MARK:
			case KeyCode.NUM_PLUS:
			case KeyCode.NUM_MINUS:
			case KeyCode.NUM_PERIOD:
			case KeyCode.NUM_DIVISION:
			case KeyCode.SEMICOLON:
			case KeyCode.DASH:
			case KeyCode.EQUALS:
			case KeyCode.COMMA:
			case KeyCode.PERIOD:
			case KeyCode.SLASH:
			case KeyCode.APOSTROPHE:
			case KeyCode.SINGLE_QUOTE:
			case KeyCode.OPEN_SQUARE_BRACKET:
			case KeyCode.BACKSLASH:
			case KeyCode.CLOSE_SQUARE_BRACKET: return true;
			default: return false;
		}
	},
	isEditableTarget: function isEditableTarget(e$2) {
		const target = e$2.target;
		if (!(target instanceof HTMLElement)) return false;
		const tagName = target.tagName;
		if (tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT" || target.isContentEditable) return true;
		return false;
	}
};
var KeyCode_default = KeyCode;

//#endregion
//#region node_modules/@rc-component/notification/es/Notice.js
function _extends$94() {
	_extends$94 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$94.apply(this, arguments);
}
var Notify = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls, style: style$1, className, duration = 4.5, showProgress, pauseOnHover = true, eventKey, content, closable, props: divProps, onClick, onNoticeClose, times, hovering: forcedHovering } = props;
	const [hovering, setHovering] = import_react.useState(false);
	const [percent, setPercent] = import_react.useState(0);
	const [spentTime, setSpentTime] = import_react.useState(0);
	const mergedHovering = forcedHovering || hovering;
	const mergedDuration = typeof duration === "number" ? duration : 0;
	const mergedShowProgress = mergedDuration > 0 && showProgress;
	const onInternalClose = () => {
		onNoticeClose(eventKey);
	};
	const onCloseKeyDown = (e$2) => {
		if (e$2.key === "Enter" || e$2.code === "Enter" || e$2.keyCode === KeyCode_default.ENTER) onInternalClose();
	};
	import_react.useEffect(() => {
		if (!mergedHovering && mergedDuration > 0) {
			const start = Date.now() - spentTime;
			const timeout = setTimeout(() => {
				onInternalClose();
			}, mergedDuration * 1e3 - spentTime);
			return () => {
				if (pauseOnHover) clearTimeout(timeout);
				setSpentTime(Date.now() - start);
			};
		}
	}, [
		mergedDuration,
		mergedHovering,
		times
	]);
	import_react.useEffect(() => {
		if (!mergedHovering && mergedShowProgress && (pauseOnHover || spentTime === 0)) {
			const start = performance.now();
			let animationFrame;
			const calculate = () => {
				cancelAnimationFrame(animationFrame);
				animationFrame = requestAnimationFrame((timestamp) => {
					const runtime = timestamp + spentTime - start;
					const progress = Math.min(runtime / (mergedDuration * 1e3), 1);
					setPercent(progress * 100);
					if (progress < 1) calculate();
				});
			};
			calculate();
			return () => {
				if (pauseOnHover) cancelAnimationFrame(animationFrame);
			};
		}
	}, [
		mergedDuration,
		spentTime,
		mergedHovering,
		mergedShowProgress,
		times
	]);
	const closableObj = import_react.useMemo(() => {
		if (typeof closable === "object" && closable !== null) return closable;
		return {};
	}, [closable]);
	const ariaProps = pickAttrs(closableObj, true);
	const validPercent = 100 - (!percent || percent < 0 ? 0 : percent > 100 ? 100 : percent);
	const noticePrefixCls = `${prefixCls}-notice`;
	return /* @__PURE__ */ import_react.createElement("div", _extends$94({}, divProps, {
		ref,
		className: clsx(noticePrefixCls, className, { [`${noticePrefixCls}-closable`]: closable }),
		style: style$1,
		onMouseEnter: (e$2) => {
			setHovering(true);
			divProps?.onMouseEnter?.(e$2);
		},
		onMouseLeave: (e$2) => {
			setHovering(false);
			divProps?.onMouseLeave?.(e$2);
		},
		onClick
	}), /* @__PURE__ */ import_react.createElement("div", { className: `${noticePrefixCls}-content` }, content), closable && /* @__PURE__ */ import_react.createElement("button", _extends$94({
		className: `${noticePrefixCls}-close`,
		onKeyDown: onCloseKeyDown,
		"aria-label": "Close"
	}, ariaProps, { onClick: (e$2) => {
		e$2.preventDefault();
		e$2.stopPropagation();
		onInternalClose();
	} }), closableObj.closeIcon ?? "x"), mergedShowProgress && /* @__PURE__ */ import_react.createElement("progress", {
		className: `${noticePrefixCls}-progress`,
		max: "100",
		value: validPercent
	}, validPercent + "%"));
});
var Notice_default = Notify;

//#endregion
//#region node_modules/@rc-component/notification/es/NotificationProvider.js
const NotificationContext = /* @__PURE__ */ import_react.createContext({});
var NotificationProvider = ({ children, classNames }) => {
	return /* @__PURE__ */ import_react.createElement(NotificationContext.Provider, { value: { classNames } }, children);
};
var NotificationProvider_default = NotificationProvider;

//#endregion
//#region node_modules/@rc-component/notification/es/hooks/useStack.js
var DEFAULT_OFFSET$2 = 8;
var DEFAULT_THRESHOLD = 3;
var DEFAULT_GAP = 16;
var useStack = (config) => {
	const result = {
		offset: DEFAULT_OFFSET$2,
		threshold: DEFAULT_THRESHOLD,
		gap: DEFAULT_GAP
	};
	if (config && typeof config === "object") {
		result.offset = config.offset ?? DEFAULT_OFFSET$2;
		result.threshold = config.threshold ?? DEFAULT_THRESHOLD;
		result.gap = config.gap ?? DEFAULT_GAP;
	}
	return [!!config, result];
};
var useStack_default = useStack;

//#endregion
//#region node_modules/@rc-component/notification/es/NoticeList.js
function _extends$93() {
	_extends$93 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$93.apply(this, arguments);
}
var NoticeList = (props) => {
	const { configList, placement, prefixCls, className, style: style$1, motion: motion$1, onAllNoticeRemoved, onNoticeClose, stack: stackConfig } = props;
	const { classNames: ctxCls } = (0, import_react.useContext)(NotificationContext);
	const dictRef = (0, import_react.useRef)({});
	const [latestNotice, setLatestNotice] = (0, import_react.useState)(null);
	const [hoverKeys, setHoverKeys] = (0, import_react.useState)([]);
	const keys$1 = configList.map((config) => ({
		config,
		key: String(config.key)
	}));
	const [stack$1, { offset: offset$2, threshold, gap }] = useStack_default(stackConfig);
	const expanded = stack$1 && (hoverKeys.length > 0 || keys$1.length <= threshold);
	const placementMotion = typeof motion$1 === "function" ? motion$1(placement) : motion$1;
	(0, import_react.useEffect)(() => {
		if (stack$1 && hoverKeys.length > 1) setHoverKeys((prev$1) => prev$1.filter((key) => keys$1.some(({ key: dataKey }) => key === dataKey)));
	}, [
		hoverKeys,
		keys$1,
		stack$1
	]);
	(0, import_react.useEffect)(() => {
		if (stack$1 && dictRef.current[keys$1[keys$1.length - 1]?.key]) setLatestNotice(dictRef.current[keys$1[keys$1.length - 1]?.key]);
	}, [keys$1, stack$1]);
	return /* @__PURE__ */ import_react.createElement(CSSMotionList_default, _extends$93({
		key: placement,
		className: clsx(prefixCls, `${prefixCls}-${placement}`, ctxCls?.list, className, {
			[`${prefixCls}-stack`]: !!stack$1,
			[`${prefixCls}-stack-expanded`]: expanded
		}),
		style: style$1,
		keys: keys$1,
		motionAppear: true
	}, placementMotion, { onAllRemoved: () => {
		onAllNoticeRemoved(placement);
	} }), ({ config, className: motionClassName, style: motionStyle, index: motionIndex }, nodeRef) => {
		const { key, times } = config;
		const strKey = String(key);
		const { className: configClassName, style: configStyle, classNames: configClassNames, styles: configStyles, ...restConfig } = config;
		const dataIndex = keys$1.findIndex((item) => item.key === strKey);
		const stackStyle = {};
		if (stack$1) {
			const index$1 = keys$1.length - 1 - (dataIndex > -1 ? dataIndex : motionIndex - 1);
			const transformX = placement === "top" || placement === "bottom" ? "-50%" : "0";
			if (index$1 > 0) {
				stackStyle.height = expanded ? dictRef.current[strKey]?.offsetHeight : latestNotice?.offsetHeight;
				let verticalOffset = 0;
				for (let i = 0; i < index$1; i++) verticalOffset += dictRef.current[keys$1[keys$1.length - 1 - i].key]?.offsetHeight + gap;
				stackStyle.transform = `translate3d(${transformX}, ${(expanded ? verticalOffset : index$1 * offset$2) * (placement.startsWith("top") ? 1 : -1)}px, 0) scaleX(${!expanded && latestNotice?.offsetWidth && dictRef.current[strKey]?.offsetWidth ? (latestNotice?.offsetWidth - offset$2 * 2 * (index$1 < 3 ? index$1 : 3)) / dictRef.current[strKey]?.offsetWidth : 1})`;
			} else stackStyle.transform = `translate3d(${transformX}, 0, 0)`;
		}
		return /* @__PURE__ */ import_react.createElement("div", {
			ref: nodeRef,
			className: clsx(`${prefixCls}-notice-wrapper`, motionClassName, configClassNames?.wrapper),
			style: {
				...motionStyle,
				...stackStyle,
				...configStyles?.wrapper
			},
			onMouseEnter: () => setHoverKeys((prev$1) => prev$1.includes(strKey) ? prev$1 : [...prev$1, strKey]),
			onMouseLeave: () => setHoverKeys((prev$1) => prev$1.filter((k) => k !== strKey))
		}, /* @__PURE__ */ import_react.createElement(Notice_default, _extends$93({}, restConfig, {
			ref: (node$1) => {
				if (dataIndex > -1) dictRef.current[strKey] = node$1;
				else delete dictRef.current[strKey];
			},
			prefixCls,
			classNames: configClassNames,
			styles: configStyles,
			className: clsx(configClassName, ctxCls?.notice),
			style: configStyle,
			times,
			key,
			eventKey: key,
			onNoticeClose,
			hovering: stack$1 && hoverKeys.length > 0
		})));
	});
};
NoticeList.displayName = "NoticeList";
var NoticeList_default = NoticeList;

//#endregion
//#region node_modules/@rc-component/notification/es/Notifications.js
var import_react_dom$6 = require_react_dom();
var Notifications = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls = "rc-notification", container, motion: motion$1, maxCount, className, style: style$1, onAllRemoved, stack: stack$1, renderNotifications: renderNotifications$2 } = props;
	const [configList, setConfigList] = import_react.useState([]);
	const onNoticeClose = (key) => {
		const config = configList.find((item) => item.key === key);
		const closable = config?.closable;
		const { onClose: closableOnClose } = closable && typeof closable === "object" ? closable : {};
		closableOnClose?.();
		config?.onClose?.();
		setConfigList((list) => list.filter((item) => item.key !== key));
	};
	import_react.useImperativeHandle(ref, () => ({
		open: (config) => {
			setConfigList((list) => {
				let clone = [...list];
				const index$1 = clone.findIndex((item) => item.key === config.key);
				const innerConfig = { ...config };
				if (index$1 >= 0) {
					innerConfig.times = (list[index$1]?.times || 0) + 1;
					clone[index$1] = innerConfig;
				} else {
					innerConfig.times = 0;
					clone.push(innerConfig);
				}
				if (maxCount > 0 && clone.length > maxCount) clone = clone.slice(-maxCount);
				return clone;
			});
		},
		close: (key) => {
			onNoticeClose(key);
		},
		destroy: () => {
			setConfigList([]);
		}
	}));
	const [placements$4, setPlacements] = import_react.useState({});
	import_react.useEffect(() => {
		const nextPlacements = {};
		configList.forEach((config) => {
			const { placement = "topRight" } = config;
			if (placement) {
				nextPlacements[placement] = nextPlacements[placement] || [];
				nextPlacements[placement].push(config);
			}
		});
		Object.keys(placements$4).forEach((placement) => {
			nextPlacements[placement] = nextPlacements[placement] || [];
		});
		setPlacements(nextPlacements);
	}, [configList]);
	const onAllNoticeRemoved = (placement) => {
		setPlacements((originPlacements) => {
			const clone = { ...originPlacements };
			if (!(clone[placement] || []).length) delete clone[placement];
			return clone;
		});
	};
	const emptyRef = import_react.useRef(false);
	import_react.useEffect(() => {
		if (Object.keys(placements$4).length > 0) emptyRef.current = true;
		else if (emptyRef.current) {
			onAllRemoved?.();
			emptyRef.current = false;
		}
	}, [placements$4]);
	if (!container) return null;
	const placementList = Object.keys(placements$4);
	return /* @__PURE__ */ (0, import_react_dom$6.createPortal)(/* @__PURE__ */ import_react.createElement(import_react.Fragment, null, placementList.map((placement) => {
		const placementConfigList = placements$4[placement];
		const list = /* @__PURE__ */ import_react.createElement(NoticeList_default, {
			key: placement,
			configList: placementConfigList,
			placement,
			prefixCls,
			className: className?.(placement),
			style: style$1?.(placement),
			motion: motion$1,
			onNoticeClose,
			onAllNoticeRemoved,
			stack: stack$1
		});
		return renderNotifications$2 ? renderNotifications$2(list, {
			prefixCls,
			key: placement
		}) : list;
	})), container);
});
Notifications.displayName = "Notifications";
var Notifications_default = Notifications;

//#endregion
//#region node_modules/@rc-component/notification/es/hooks/useNotification.js
var defaultGetContainer = () => document.body;
var uniqueKey = 0;
function mergeConfig(...objList) {
	const clone = {};
	objList.forEach((obj) => {
		if (obj) Object.keys(obj).forEach((key) => {
			const val = obj[key];
			if (val !== void 0) clone[key] = val;
		});
	});
	return clone;
}
function useNotification$1(rootConfig = {}) {
	const { getContainer = defaultGetContainer, motion: motion$1, prefixCls, maxCount, className, style: style$1, onAllRemoved, stack: stack$1, renderNotifications: renderNotifications$2, ...shareConfig } = rootConfig;
	const [container, setContainer] = import_react.useState();
	const notificationsRef = import_react.useRef();
	const contextHolder = /* @__PURE__ */ import_react.createElement(Notifications_default, {
		container,
		ref: notificationsRef,
		prefixCls,
		motion: motion$1,
		maxCount,
		className,
		style: style$1,
		onAllRemoved,
		stack: stack$1,
		renderNotifications: renderNotifications$2
	});
	const [taskQueue$2, setTaskQueue] = import_react.useState([]);
	const open$2 = useEvent_default((config) => {
		const mergedConfig = mergeConfig(shareConfig, config);
		if (mergedConfig.key === null || mergedConfig.key === void 0) {
			mergedConfig.key = `rc-notification-${uniqueKey}`;
			uniqueKey += 1;
		}
		setTaskQueue((queue) => [...queue, {
			type: "open",
			config: mergedConfig
		}]);
	});
	const api = import_react.useMemo(() => ({
		open: open$2,
		close: (key) => {
			setTaskQueue((queue) => [...queue, {
				type: "close",
				key
			}]);
		},
		destroy: () => {
			setTaskQueue((queue) => [...queue, { type: "destroy" }]);
		}
	}), []);
	import_react.useEffect(() => {
		setContainer(getContainer());
	});
	import_react.useEffect(() => {
		if (notificationsRef.current && taskQueue$2.length) {
			taskQueue$2.forEach((task) => {
				switch (task.type) {
					case "open":
						notificationsRef.current.open(task.config);
						break;
					case "close":
						notificationsRef.current.close(task.key);
						break;
					case "destroy":
						notificationsRef.current.destroy();
						break;
				}
			});
			let oriTaskQueue;
			let tgtTaskQueue;
			setTaskQueue((oriQueue) => {
				if (oriTaskQueue !== oriQueue || !tgtTaskQueue) {
					oriTaskQueue = oriQueue;
					tgtTaskQueue = oriQueue.filter((task) => !taskQueue$2.includes(task));
				}
				return tgtTaskQueue;
			});
		}
	}, [taskQueue$2]);
	return [api, contextHolder];
}

//#endregion
//#region node_modules/antd/es/message/style/index.js
var genMessageStyle = (token$1) => {
	const { componentCls, iconCls, boxShadow, colorText, colorSuccess, colorError, colorWarning, colorInfo, fontSizeLG, motionEaseInOutCirc, motionDurationSlow, marginXS, paddingXS, borderRadiusLG, zIndexPopup, contentPadding, contentBg } = token$1;
	const noticeCls = `${componentCls}-notice`;
	const messageMoveIn = new Keyframes_default("MessageMoveIn", {
		"0%": {
			padding: 0,
			transform: "translateY(-100%)",
			opacity: 0
		},
		"100%": {
			padding: paddingXS,
			transform: "translateY(0)",
			opacity: 1
		}
	});
	const messageMoveOut = new Keyframes_default("MessageMoveOut", {
		"0%": {
			maxHeight: token$1.height,
			padding: paddingXS,
			opacity: 1
		},
		"100%": {
			maxHeight: 0,
			padding: 0,
			opacity: 0
		}
	});
	const noticeStyle = {
		padding: paddingXS,
		textAlign: "center",
		[`${componentCls}-custom-content`]: {
			display: "flex",
			alignItems: "center"
		},
		[`${componentCls}-custom-content > ${iconCls}`]: {
			marginInlineEnd: marginXS,
			fontSize: fontSizeLG
		},
		[`${noticeCls}-content`]: {
			display: "inline-block",
			padding: contentPadding,
			background: contentBg,
			borderRadius: borderRadiusLG,
			boxShadow,
			pointerEvents: "all"
		},
		[`${componentCls}-success > ${iconCls}`]: { color: colorSuccess },
		[`${componentCls}-error > ${iconCls}`]: { color: colorError },
		[`${componentCls}-warning > ${iconCls}`]: { color: colorWarning },
		[`${componentCls}-info > ${iconCls},
      ${componentCls}-loading > ${iconCls}`]: { color: colorInfo }
	};
	return [
		{ [componentCls]: {
			...resetComponent(token$1),
			color: colorText,
			position: "fixed",
			top: marginXS,
			width: "100%",
			pointerEvents: "none",
			zIndex: zIndexPopup,
			[`${componentCls}-move-up`]: { animationFillMode: "forwards" },
			[`
        ${componentCls}-move-up-appear,
        ${componentCls}-move-up-enter
      `]: {
				animationName: messageMoveIn,
				animationDuration: motionDurationSlow,
				animationPlayState: "paused",
				animationTimingFunction: motionEaseInOutCirc
			},
			[`
        ${componentCls}-move-up-appear${componentCls}-move-up-appear-active,
        ${componentCls}-move-up-enter${componentCls}-move-up-enter-active
      `]: { animationPlayState: "running" },
			[`${componentCls}-move-up-leave`]: {
				animationName: messageMoveOut,
				animationDuration: motionDurationSlow,
				animationPlayState: "paused",
				animationTimingFunction: motionEaseInOutCirc
			},
			[`${componentCls}-move-up-leave${componentCls}-move-up-leave-active`]: { animationPlayState: "running" },
			"&-rtl": {
				direction: "rtl",
				span: { direction: "rtl" }
			}
		} },
		{ [componentCls]: { [`${noticeCls}-wrapper`]: { ...noticeStyle } } },
		{ [`${componentCls}-notice-pure-panel`]: {
			...noticeStyle,
			padding: 0,
			textAlign: "start"
		} }
	];
};
const prepareComponentToken$54 = (token$1) => ({
	zIndexPopup: token$1.zIndexPopupBase + CONTAINER_MAX_OFFSET + 10,
	contentBg: token$1.colorBgElevated,
	contentPadding: `${(token$1.controlHeightLG - token$1.fontSize * token$1.lineHeight) / 2}px ${token$1.paddingSM}px`
});
var style_default$61 = genStyleHooks("Message", (token$1) => {
	return genMessageStyle(merge(token$1, { height: 150 }));
}, prepareComponentToken$54);

//#endregion
//#region node_modules/antd/es/message/PurePanel.js
const TypeIcon = {
	info: /* @__PURE__ */ import_react.createElement(InfoCircleFilled_default, null),
	success: /* @__PURE__ */ import_react.createElement(CheckCircleFilled_default, null),
	error: /* @__PURE__ */ import_react.createElement(CloseCircleFilled_default, null),
	warning: /* @__PURE__ */ import_react.createElement(ExclamationCircleFilled_default, null),
	loading: /* @__PURE__ */ import_react.createElement(LoadingOutlined_default, null)
};
const PureContent$1 = (props) => {
	const { prefixCls, type: type$2, icon, children, classNames: pureContentClassNames, styles } = props;
	const iconNode = cloneElement(icon || type$2 && TypeIcon[type$2], (currentProps) => {
		const mergedStyle = {
			...currentProps?.style,
			...styles?.icon
		};
		return {
			className: clsx(currentProps.className, pureContentClassNames?.icon),
			style: mergedStyle
		};
	});
	return /* @__PURE__ */ import_react.createElement("div", { className: clsx(`${prefixCls}-custom-content`, `${prefixCls}-${type$2}`) }, iconNode, /* @__PURE__ */ import_react.createElement("span", {
		className: pureContentClassNames?.content,
		style: styles?.content
	}, children));
};
/** @private Internal Component. Do not use in your production. */
var PurePanel$14 = (props) => {
	const { prefixCls: staticPrefixCls, className, style: style$1, type: type$2, icon, content, classNames: messageClassNames, styles, ...restProps } = props;
	const { getPrefixCls, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("message");
	const prefixCls = staticPrefixCls || getPrefixCls("message");
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$61(prefixCls, rootCls);
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, messageClassNames], [contextStyles, styles], { props });
	return /* @__PURE__ */ import_react.createElement(Notice_default, {
		...restProps,
		prefixCls,
		className: clsx(contextClassName, mergedClassNames.root, className, hashId, `${prefixCls}-notice-pure-panel`, cssVarCls, rootCls),
		style: {
			...mergedStyles.root,
			...contextStyle,
			...style$1
		},
		eventKey: "pure",
		duration: null,
		content: /* @__PURE__ */ import_react.createElement(PureContent$1, {
			prefixCls,
			type: type$2,
			icon,
			classNames: mergedClassNames,
			styles: mergedStyles
		}, content)
	});
};
var PurePanel_default$6 = PurePanel$14;

//#endregion
//#region node_modules/antd/es/message/util.js
function getMotion$2(prefixCls, transitionName) {
	return { motionName: transitionName ?? `${prefixCls}-move-up` };
}
/** Wrap message open with promise like function */
function wrapPromiseFn(openFn) {
	let closeFn;
	const closePromise = new Promise((resolve) => {
		closeFn = openFn(() => {
			resolve(true);
		});
	});
	const result = () => {
		closeFn?.();
	};
	result.then = (filled, rejected) => closePromise.then(filled, rejected);
	result.promise = closePromise;
	return result;
}

//#endregion
//#region node_modules/antd/es/message/useMessage.js
var DEFAULT_OFFSET$1 = 8;
var DEFAULT_DURATION$1 = 3;
var Wrapper$1 = ({ children, prefixCls }) => {
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$61(prefixCls, rootCls);
	return /* @__PURE__ */ import_react.createElement(NotificationProvider_default, { classNames: { list: clsx(hashId, cssVarCls, rootCls) } }, children);
};
var renderNotifications$1 = (node$1, { prefixCls, key }) => /* @__PURE__ */ import_react.createElement(Wrapper$1, {
	prefixCls,
	key
}, node$1);
var Holder$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { top, prefixCls: staticPrefixCls, getContainer: staticGetContainer, maxCount, duration = DEFAULT_DURATION$1, rtl, transitionName, onAllRemoved, pauseOnHover = true } = props;
	const { getPrefixCls, direction, getPopupContainer } = useComponentConfig("message");
	const { message: message$1 } = import_react.useContext(ConfigContext);
	const prefixCls = staticPrefixCls || getPrefixCls("message");
	const getStyle$2 = () => ({
		left: "50%",
		transform: "translateX(-50%)",
		top: top ?? DEFAULT_OFFSET$1
	});
	const getClassName = () => clsx({ [`${prefixCls}-rtl`]: rtl ?? direction === "rtl" });
	const getNotificationMotion = () => getMotion$2(prefixCls, transitionName);
	const [mergedClassNames, mergedStyles] = useMergeSemantic([props?.classNames, message$1?.classNames], [props?.styles, message$1?.styles], { props });
	const [api, holder] = useNotification$1({
		prefixCls,
		style: getStyle$2,
		className: getClassName,
		motion: getNotificationMotion,
		closable: false,
		duration,
		getContainer: () => staticGetContainer?.() || getPopupContainer?.() || document.body,
		maxCount,
		onAllRemoved,
		renderNotifications: renderNotifications$1,
		pauseOnHover
	});
	import_react.useImperativeHandle(ref, () => ({
		...api,
		prefixCls,
		message: message$1,
		classNames: mergedClassNames,
		styles: mergedStyles
	}));
	return holder;
});
var keyIndex = 0;
function useInternalMessage(messageConfig) {
	const holderRef = import_react.useRef(null);
	const warning$3 = devUseWarning("Message");
	return [import_react.useMemo(() => {
		const close = (key) => {
			holderRef.current?.close(key);
		};
		const open$2 = (config) => {
			if (!holderRef.current) {
				warning$3(false, "usage", "You are calling notice in render which will break in React 18 concurrent mode. Please trigger in effect instead.");
				const fakeResult = () => {};
				fakeResult.then = () => {};
				return fakeResult;
			}
			const { open: originOpen, prefixCls, message: message$1, classNames: originClassNames, styles: originStyles } = holderRef.current;
			const contextClassName = message$1?.className || {};
			const contextStyle = message$1?.style || {};
			const rawContextClassNames = message$1?.classNames || {};
			const rawContextStyles = message$1?.styles || {};
			const noticePrefixCls = `${prefixCls}-notice`;
			const { content, icon, type: type$2, key, className, style: style$1, onClose, classNames: configClassNames = {}, styles = {}, ...restConfig } = config;
			let mergedKey = key;
			if (!isNonNullable_default(mergedKey)) {
				keyIndex += 1;
				mergedKey = `antd-message-${keyIndex}`;
			}
			const contextConfig = {
				...messageConfig,
				...config
			};
			const contextClassNames = resolveStyleOrClass(rawContextClassNames, { props: contextConfig });
			const semanticClassNames = resolveStyleOrClass(configClassNames, { props: contextConfig });
			const contextStyles = resolveStyleOrClass(rawContextStyles, { props: contextConfig });
			const semanticStyles = resolveStyleOrClass(styles, { props: contextConfig });
			const mergedClassNames = mergeClassNames(void 0, contextClassNames, semanticClassNames, originClassNames);
			const mergedStyles = mergeStyles(contextStyles, semanticStyles, originStyles);
			return wrapPromiseFn((resolve) => {
				originOpen({
					...restConfig,
					key: mergedKey,
					content: /* @__PURE__ */ import_react.createElement(PureContent$1, {
						prefixCls,
						type: type$2,
						icon,
						classNames: mergedClassNames,
						styles: mergedStyles
					}, content),
					placement: "top",
					className: clsx({ [`${noticePrefixCls}-${type$2}`]: type$2 }, className, contextClassName, mergedClassNames.root),
					style: {
						...mergedStyles.root,
						...contextStyle,
						...style$1
					},
					onClose: () => {
						onClose?.();
						resolve();
					}
				});
				return () => {
					close(mergedKey);
				};
			});
		};
		const destroy$2 = (key) => {
			if (key !== void 0) close(key);
			else holderRef.current?.destroy();
		};
		const clone = {
			open: open$2,
			destroy: destroy$2
		};
		[
			"info",
			"success",
			"warning",
			"error",
			"loading"
		].forEach((type$2) => {
			const typeOpen$1 = (jointContent, duration, onClose) => {
				let config;
				if (jointContent && typeof jointContent === "object" && "content" in jointContent) config = jointContent;
				else config = { content: jointContent };
				let mergedDuration;
				let mergedOnClose;
				if (typeof duration === "function") mergedOnClose = duration;
				else {
					mergedDuration = duration;
					mergedOnClose = onClose;
				}
				return open$2({
					onClose: mergedOnClose,
					duration: mergedDuration,
					...config,
					type: type$2
				});
			};
			clone[type$2] = typeOpen$1;
		});
		return clone;
	}, []), /* @__PURE__ */ import_react.createElement(Holder$1, {
		key: "message-holder",
		...messageConfig,
		ref: holderRef
	})];
}
function useMessage(messageConfig) {
	return useInternalMessage(messageConfig);
}

//#endregion
//#region node_modules/@rc-component/util/es/React/render.js
var import_client = require_client();
var MARK = "__rc_react_root__";
function render(node$1, container) {
	const root = container[MARK] || (0, import_client.createRoot)(container);
	root.render(node$1);
	container[MARK] = root;
}
async function unmount(container) {
	return Promise.resolve().then(() => {
		container[MARK]?.unmount();
		delete container[MARK];
	});
}

//#endregion
//#region node_modules/antd/es/_util/motion.js
var getCollapsedHeight = () => ({
	height: 0,
	opacity: 0
});
var getRealHeight = (node$1) => {
	const { scrollHeight } = node$1;
	return {
		height: scrollHeight,
		opacity: 1
	};
};
var getCurrentHeight = (node$1) => ({ height: node$1 ? node$1.offsetHeight : 0 });
var skipOpacityTransition = (_, event) => event?.deadline === true || event.propertyName === "height";
var initCollapseMotion = (rootCls = defaultPrefixCls) => ({
	motionName: `${rootCls}-motion-collapse`,
	onAppearStart: getCollapsedHeight,
	onEnterStart: getCollapsedHeight,
	onAppearActive: getRealHeight,
	onEnterActive: getRealHeight,
	onLeaveStart: getCurrentHeight,
	onLeaveActive: getCollapsedHeight,
	onAppearEnd: skipOpacityTransition,
	onEnterEnd: skipOpacityTransition,
	onLeaveEnd: skipOpacityTransition,
	motionDeadline: 500
});
var getTransitionName = (rootPrefixCls, motion$1, transitionName) => {
	if (transitionName !== void 0) return transitionName;
	return `${rootPrefixCls}-${motion$1}`;
};
var motion_default = initCollapseMotion;

//#endregion
//#region node_modules/antd/es/_util/wave/style.js
var genWaveStyle = (token$1) => {
	const { componentCls, colorPrimary } = token$1;
	return { [componentCls]: {
		position: "absolute",
		background: "transparent",
		pointerEvents: "none",
		boxSizing: "border-box",
		color: `var(--wave-color, ${colorPrimary})`,
		boxShadow: `0 0 0 0 currentcolor`,
		opacity: .2,
		"&.wave-motion-appear": {
			transition: [`box-shadow 0.4s ${token$1.motionEaseOutCirc}`, `opacity 2s ${token$1.motionEaseOutCirc}`].join(","),
			"&-active": {
				boxShadow: `0 0 0 6px currentcolor`,
				opacity: 0
			},
			"&.wave-quick": { transition: [`box-shadow ${token$1.motionDurationSlow} ${token$1.motionEaseInOut}`, `opacity ${token$1.motionDurationSlow} ${token$1.motionEaseInOut}`].join(",") }
		}
	} };
};
var style_default$60 = genComponentStyleHook("Wave", genWaveStyle);

//#endregion
//#region node_modules/antd/es/_util/wave/interface.js
const TARGET_CLS = `${defaultPrefixCls}-wave-target`;

//#endregion
//#region node_modules/antd/es/_util/wave/util.js
function isValidWaveColor(color) {
	return color && typeof color === "string" && color !== "#fff" && color !== "#ffffff" && color !== "rgb(255, 255, 255)" && color !== "rgba(255, 255, 255, 1)" && !/rgba\((?:\d*, ){3}0\)/.test(color) && color !== "transparent" && color !== "canvastext";
}
function getTargetWaveColor(node$1, colorSource = null) {
	const style$1 = getComputedStyle(node$1);
	const { borderTopColor, borderColor, backgroundColor } = style$1;
	if (colorSource && isValidWaveColor(style$1[colorSource])) return style$1[colorSource];
	return [
		borderTopColor,
		borderColor,
		backgroundColor
	].find(isValidWaveColor) ?? null;
}

//#endregion
//#region node_modules/antd/es/_util/wave/WaveEffect.js
function validateNum(value) {
	return Number.isNaN(value) ? 0 : value;
}
var WaveEffect = (props) => {
	const { className, target, component, colorSource } = props;
	const divRef = import_react.useRef(null);
	const [color, setWaveColor] = import_react.useState(null);
	const [borderRadius, setBorderRadius] = import_react.useState([]);
	const [left, setLeft] = import_react.useState(0);
	const [top, setTop] = import_react.useState(0);
	const [width, setWidth] = import_react.useState(0);
	const [height, setHeight] = import_react.useState(0);
	const [enabled, setEnabled] = import_react.useState(false);
	const waveStyle = {
		left,
		top,
		width,
		height,
		borderRadius: borderRadius.map((radius$1) => `${radius$1}px`).join(" ")
	};
	if (color) waveStyle["--wave-color"] = color;
	function syncPos() {
		const nodeStyle = getComputedStyle(target);
		setWaveColor(getTargetWaveColor(target, colorSource));
		const isStatic = nodeStyle.position === "static";
		const { borderLeftWidth, borderTopWidth } = nodeStyle;
		setLeft(isStatic ? target.offsetLeft : validateNum(-Number.parseFloat(borderLeftWidth)));
		setTop(isStatic ? target.offsetTop : validateNum(-Number.parseFloat(borderTopWidth)));
		setWidth(target.offsetWidth);
		setHeight(target.offsetHeight);
		const { borderTopLeftRadius, borderTopRightRadius, borderBottomLeftRadius, borderBottomRightRadius } = nodeStyle;
		setBorderRadius([
			borderTopLeftRadius,
			borderTopRightRadius,
			borderBottomRightRadius,
			borderBottomLeftRadius
		].map((radius$1) => validateNum(Number.parseFloat(radius$1))));
	}
	import_react.useEffect(() => {
		if (target) {
			const id = raf_default(() => {
				syncPos();
				setEnabled(true);
			});
			let resizeObserver;
			if (typeof ResizeObserver !== "undefined") {
				resizeObserver = new ResizeObserver(syncPos);
				resizeObserver.observe(target);
			}
			return () => {
				raf_default.cancel(id);
				resizeObserver?.disconnect();
			};
		}
	}, [target]);
	if (!enabled) return null;
	const isSmallComponent = (component === "Checkbox" || component === "Radio") && target?.classList.contains(TARGET_CLS);
	return /* @__PURE__ */ import_react.createElement(es_default$1, {
		visible: true,
		motionAppear: true,
		motionName: "wave-motion",
		motionDeadline: 5e3,
		onAppearEnd: (_, event) => {
			if (event.deadline || event.propertyName === "opacity") {
				const holder = divRef.current?.parentElement;
				unmount(holder).then(() => {
					holder?.remove();
				});
			}
			return false;
		}
	}, ({ className: motionClassName }, ref) => /* @__PURE__ */ import_react.createElement("div", {
		ref: composeRef(divRef, ref),
		className: clsx(className, motionClassName, { "wave-quick": isSmallComponent }),
		style: waveStyle
	}));
};
var showWaveEffect = (target, info) => {
	const { component } = info;
	if (component === "Checkbox" && !target.querySelector("input")?.checked) return;
	const holder = document.createElement("div");
	holder.style.position = "absolute";
	holder.style.left = "0px";
	holder.style.top = "0px";
	target?.insertBefore(holder, target?.firstChild);
	render(/* @__PURE__ */ import_react.createElement(WaveEffect, {
		...info,
		target
	}), holder);
};
var WaveEffect_default = showWaveEffect;

//#endregion
//#region node_modules/antd/es/_util/wave/useWave.js
var useWave = (nodeRef, className, component, colorSource) => {
	const { wave } = import_react.useContext(ConfigContext);
	const [, token$1, hashId] = useToken();
	const showWave = useEvent_default((event) => {
		const node$1 = nodeRef.current;
		if (wave?.disabled || !node$1) return;
		const targetNode = node$1.querySelector(`.${TARGET_CLS}`) || node$1;
		const { showEffect } = wave || {};
		(showEffect || WaveEffect_default)(targetNode, {
			className,
			token: token$1,
			component,
			event,
			hashId,
			colorSource
		});
	});
	const rafId = import_react.useRef(null);
	import_react.useEffect(() => () => {
		raf_default.cancel(rafId.current);
	}, []);
	const showDebounceWave = (event) => {
		raf_default.cancel(rafId.current);
		rafId.current = raf_default(() => {
			showWave(event);
		});
	};
	return showDebounceWave;
};
var useWave_default = useWave;

//#endregion
//#region node_modules/antd/es/_util/wave/index.js
var Wave = (props) => {
	const { children, disabled, component, colorSource } = props;
	const { getPrefixCls } = (0, import_react.useContext)(ConfigContext);
	const containerRef = (0, import_react.useRef)(null);
	const prefixCls = getPrefixCls("wave");
	const showWave = useWave_default(containerRef, clsx(prefixCls, style_default$60(prefixCls)), component, colorSource);
	import_react.useEffect(() => {
		const node$1 = containerRef.current;
		if (!node$1 || node$1.nodeType !== window.Node.ELEMENT_NODE || disabled) return;
		const onClick = (e$2) => {
			if (!isVisible_default(e$2.target) || !node$1.getAttribute || node$1.getAttribute("disabled") || node$1.disabled || node$1.className.includes("disabled") && !node$1.className.includes("disabled:") || node$1.getAttribute("aria-disabled") === "true" || node$1.className.includes("-leave")) return;
			showWave(e$2);
		};
		node$1.addEventListener("click", onClick, true);
		return () => {
			node$1.removeEventListener("click", onClick, true);
		};
	}, [disabled]);
	if (!/* @__PURE__ */ import_react.isValidElement(children)) return children ?? null;
	return cloneElement(children, { ref: supportRef(children) ? composeRef(getNodeRef(children), containerRef) : containerRef });
};
Wave.displayName = "Wave";
var wave_default = Wave;

//#endregion
//#region node_modules/antd/es/config-provider/hooks/useSize.js
var useSize = (customSize) => {
	const size = import_react.useContext(SizeContext_default);
	return import_react.useMemo(() => {
		if (!customSize) return size;
		if (typeof customSize === "string") return customSize ?? size;
		if (typeof customSize === "function") return customSize(size);
		return size;
	}, [customSize, size]);
};
var useSize_default = useSize;

//#endregion
//#region node_modules/antd/es/space/style/compact.js
var genSpaceCompactStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: {
		display: "inline-flex",
		"&-block": {
			display: "flex",
			width: "100%"
		},
		"&-vertical": { flexDirection: "column" },
		"&-rtl": { direction: "rtl" }
	} };
};
var compact_default$2 = genStyleHooks(["Space", "Compact"], (token$1) => [genSpaceCompactStyle(token$1)], () => ({}), { resetStyle: false });

//#endregion
//#region node_modules/antd/es/space/Compact.js
const SpaceCompactItemContext = /* @__PURE__ */ import_react.createContext(null);
const useCompactItemContext = (prefixCls, direction) => {
	const compactItemContext = import_react.useContext(SpaceCompactItemContext);
	const compactItemClassnames = import_react.useMemo(() => {
		if (!compactItemContext) return "";
		const { compactDirection, isFirstItem, isLastItem } = compactItemContext;
		const separator = compactDirection === "vertical" ? "-vertical-" : "-";
		return clsx(`${prefixCls}-compact${separator}item`, {
			[`${prefixCls}-compact${separator}first-item`]: isFirstItem,
			[`${prefixCls}-compact${separator}last-item`]: isLastItem,
			[`${prefixCls}-compact${separator}item-rtl`]: direction === "rtl"
		});
	}, [
		prefixCls,
		direction,
		compactItemContext
	]);
	return {
		compactSize: compactItemContext?.compactSize,
		compactDirection: compactItemContext?.compactDirection,
		compactItemClassnames
	};
};
const NoCompactStyle = (props) => {
	const { children } = props;
	return /* @__PURE__ */ import_react.createElement(SpaceCompactItemContext.Provider, { value: null }, children);
};
var CompactItem = (props) => {
	const { children, ...others } = props;
	return /* @__PURE__ */ import_react.createElement(SpaceCompactItemContext.Provider, { value: import_react.useMemo(() => others, [others]) }, children);
};
var Compact = (props) => {
	const { getPrefixCls, direction: directionConfig } = import_react.useContext(ConfigContext);
	const { size, direction, orientation, block, prefixCls: customizePrefixCls, className, rootClassName, children, vertical, ...restProps } = props;
	devUseWarning("Space.Compact").deprecated(!direction, "direction", "orientation");
	const [mergedOrientation, mergedVertical] = useOrientation(orientation, vertical, direction);
	const mergedSize = useSize_default((ctx) => size ?? ctx);
	const prefixCls = getPrefixCls("space-compact", customizePrefixCls);
	const [hashId] = compact_default$2(prefixCls);
	const clx = clsx(prefixCls, hashId, {
		[`${prefixCls}-rtl`]: directionConfig === "rtl",
		[`${prefixCls}-block`]: block,
		[`${prefixCls}-vertical`]: mergedVertical
	}, className, rootClassName);
	const compactItemContext = import_react.useContext(SpaceCompactItemContext);
	const childNodes = toArray(children);
	const nodes = import_react.useMemo(() => childNodes.map((child, i) => {
		const key = child?.key || `${prefixCls}-item-${i}`;
		return /* @__PURE__ */ import_react.createElement(CompactItem, {
			key,
			compactSize: mergedSize,
			compactDirection: mergedOrientation,
			isFirstItem: i === 0 && (!compactItemContext || compactItemContext?.isFirstItem),
			isLastItem: i === childNodes.length - 1 && (!compactItemContext || compactItemContext?.isLastItem)
		}, child);
	}), [
		childNodes,
		compactItemContext,
		mergedOrientation,
		mergedSize,
		prefixCls
	]);
	if (childNodes.length === 0) return null;
	return /* @__PURE__ */ import_react.createElement("div", {
		className: clx,
		...restProps
	}, nodes);
};
var Compact_default = Compact;

//#endregion
//#region node_modules/antd/es/button/ButtonGroup.js
const GroupSizeContext = /* @__PURE__ */ import_react.createContext(void 0);
var ButtonGroup = (props) => {
	const { getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const { prefixCls: customizePrefixCls, size, className, ...others } = props;
	const prefixCls = getPrefixCls("btn-group", customizePrefixCls);
	const [, , hashId] = useToken();
	const sizeCls = import_react.useMemo(() => {
		switch (size) {
			case "large": return "lg";
			case "small": return "sm";
			default: return "";
		}
	}, [size]);
	{
		const warning$3 = devUseWarning("Button.Group");
		warning$3.deprecated(false, "Button.Group", "Space.Compact");
		warning$3(!size || [
			"large",
			"small",
			"middle"
		].includes(size), "usage", "Invalid prop `size`.");
	}
	const classes = clsx(prefixCls, {
		[`${prefixCls}-${sizeCls}`]: sizeCls,
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, className, hashId);
	return /* @__PURE__ */ import_react.createElement(GroupSizeContext.Provider, { value: size }, /* @__PURE__ */ import_react.createElement("div", {
		...others,
		className: classes
	}));
};
var ButtonGroup_default = ButtonGroup;

//#endregion
//#region node_modules/antd/es/button/buttonHelpers.js
var rxTwoCNChar = /^[\u4E00-\u9FA5]{2}$/;
const isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
function convertLegacyProps(type$2) {
	if (type$2 === "danger") return { danger: true };
	return { type: type$2 };
}
function isString(str) {
	return typeof str === "string";
}
function isUnBorderedButtonVariant(type$2) {
	return type$2 === "text" || type$2 === "link";
}
function splitCNCharsBySpace(child, needInserted, style$1, className) {
	if (!isNonNullable_default(child) || child === "") return;
	const SPACE = needInserted ? " " : "";
	if (typeof child !== "string" && typeof child !== "number" && isString(child.type) && isTwoCNChar(child.props.children)) return cloneElement(child, (oriProps) => ({
		...oriProps,
		children: oriProps.children.split("").join(SPACE),
		className,
		style: style$1
	}));
	if (isString(child)) return /* @__PURE__ */ import_react.createElement("span", {
		className,
		style: style$1
	}, isTwoCNChar(child) ? child.split("").join(SPACE) : child);
	if (isFragment(child)) return /* @__PURE__ */ import_react.createElement("span", {
		className,
		style: style$1
	}, child);
	return cloneElement(child, (oriProps) => ({
		...oriProps,
		className: clsx(oriProps.className, className) || void 0,
		style: {
			...oriProps.style,
			...style$1
		}
	}));
}
function spaceChildren(children, needInserted, style$1, className) {
	let isPrevChildPure = false;
	const childList = [];
	import_react.Children.forEach(children, (child) => {
		const type$2 = typeof child;
		const isCurrentChildPure = type$2 === "string" || type$2 === "number";
		if (isPrevChildPure && isCurrentChildPure) {
			const lastIndex = childList.length - 1;
			childList[lastIndex] = `${childList[lastIndex]}${child}`;
		} else childList.push(child);
		isPrevChildPure = isCurrentChildPure;
	});
	return import_react.Children.map(childList, (child) => splitCNCharsBySpace(child, needInserted, style$1, className));
}
const _ButtonColorTypes = [
	"default",
	"primary",
	"danger"
].concat(_toConsumableArray(PresetColors));

//#endregion
//#region node_modules/antd/es/button/IconWrapper.js
var IconWrapper = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	const { className, style: style$1, children, prefixCls } = props;
	const iconWrapperCls = clsx(`${prefixCls}-icon`, className);
	return /* @__PURE__ */ import_react.createElement("span", {
		ref,
		className: iconWrapperCls,
		style: style$1
	}, children);
});
var IconWrapper_default = IconWrapper;

//#endregion
//#region node_modules/antd/es/button/DefaultLoadingIcon.js
var InnerLoadingIcon = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	const { prefixCls, className, style: style$1, iconClassName } = props;
	const mergedIconCls = clsx(`${prefixCls}-loading-icon`, className);
	return /* @__PURE__ */ import_react.createElement(IconWrapper_default, {
		prefixCls,
		className: mergedIconCls,
		style: style$1,
		ref
	}, /* @__PURE__ */ import_react.createElement(LoadingOutlined_default, { className: iconClassName }));
});
var getCollapsedWidth = () => ({
	width: 0,
	opacity: 0,
	transform: "scale(0)"
});
var getRealWidth = (node$1) => ({
	width: node$1.scrollWidth,
	opacity: 1,
	transform: "scale(1)"
});
var DefaultLoadingIcon = (props) => {
	const { prefixCls, loading, existIcon, className, style: style$1, mount } = props;
	const visible = !!loading;
	if (existIcon) return /* @__PURE__ */ import_react.createElement(InnerLoadingIcon, {
		prefixCls,
		className,
		style: style$1
	});
	return /* @__PURE__ */ import_react.createElement(es_default$1, {
		visible,
		motionName: `${prefixCls}-loading-icon-motion`,
		motionAppear: !mount,
		motionEnter: !mount,
		motionLeave: !mount,
		removeOnLeave: true,
		onAppearStart: getCollapsedWidth,
		onAppearActive: getRealWidth,
		onEnterStart: getCollapsedWidth,
		onEnterActive: getRealWidth,
		onLeaveStart: getRealWidth,
		onLeaveActive: getCollapsedWidth
	}, ({ className: motionCls, style: motionStyle }, ref) => {
		const mergedStyle = {
			...style$1,
			...motionStyle
		};
		return /* @__PURE__ */ import_react.createElement(InnerLoadingIcon, {
			prefixCls,
			className: clsx(className, motionCls),
			style: mergedStyle,
			ref
		});
	});
};
var DefaultLoadingIcon_default = DefaultLoadingIcon;

//#endregion
//#region node_modules/antd/es/button/style/group.js
var genButtonBorderStyle = (buttonTypeCls, borderColor) => ({ [`> span, > ${buttonTypeCls}`]: {
	"&:not(:last-child)": { [`&, & > ${buttonTypeCls}`]: { "&:not(:disabled)": { borderInlineEndColor: borderColor } } },
	"&:not(:first-child)": { [`&, & > ${buttonTypeCls}`]: { "&:not(:disabled)": { borderInlineStartColor: borderColor } } }
} });
var genGroupStyle$3 = (token$1) => {
	const { componentCls, fontSize, lineWidth, groupBorderColor, colorErrorHover } = token$1;
	return { [`${componentCls}-group`]: [
		{
			position: "relative",
			display: "inline-flex",
			[`> span, > ${componentCls}`]: {
				"&:not(:last-child)": { [`&, & > ${componentCls}`]: {
					borderStartEndRadius: 0,
					borderEndEndRadius: 0
				} },
				"&:not(:first-child)": {
					marginInlineStart: token$1.calc(lineWidth).mul(-1).equal(),
					[`&, & > ${componentCls}`]: {
						borderStartStartRadius: 0,
						borderEndStartRadius: 0
					}
				}
			},
			[componentCls]: {
				position: "relative",
				zIndex: 1,
				"&:hover, &:focus, &:active": { zIndex: 2 },
				"&[disabled]": { zIndex: 0 }
			},
			[`${componentCls}-icon-only`]: { fontSize }
		},
		genButtonBorderStyle(`${componentCls}-primary`, groupBorderColor),
		genButtonBorderStyle(`${componentCls}-danger`, colorErrorHover)
	] };
};
var group_default$2 = genGroupStyle$3;

//#endregion
//#region node_modules/@rc-component/color-picker/es/color.js
const getRoundNumber$1 = (value) => Math.round(Number(value || 0));
var convertHsb2Hsv = (color) => {
	if (color instanceof FastColor) return color;
	if (color && typeof color === "object" && "h" in color && "b" in color) {
		const { b, ...resets } = color;
		return {
			...resets,
			v: b
		};
	}
	if (typeof color === "string" && /hsb/.test(color)) return color.replace(/hsb/, "hsv");
	return color;
};
var Color = class extends FastColor {
	constructor(color) {
		super(convertHsb2Hsv(color));
	}
	toHsbString() {
		const hsb = this.toHsb();
		const saturation = getRoundNumber$1(hsb.s * 100);
		const lightness = getRoundNumber$1(hsb.b * 100);
		const hue = getRoundNumber$1(hsb.h);
		const alpha = hsb.a;
		const hsbString = `hsb(${hue}, ${saturation}%, ${lightness}%)`;
		const hsbaString = `hsba(${hue}, ${saturation}%, ${lightness}%, ${alpha.toFixed(alpha === 0 ? 0 : 2)})`;
		return alpha === 1 ? hsbString : hsbaString;
	}
	toHsb() {
		const { v, ...resets } = this.toHsv();
		return {
			...resets,
			b: v,
			a: this.a
		};
	}
};

//#endregion
//#region node_modules/@rc-component/color-picker/es/util.js
const ColorPickerPrefixCls = "rc-color-picker";
const generateColor$1 = (color) => {
	if (color instanceof Color) return color;
	return new Color(color);
};
const defaultColor = generateColor$1("#1677ff");
const calculateColor = (props) => {
	const { offset: offset$2, targetRef, containerRef, color, type: type$2 } = props;
	const { width, height } = containerRef.current.getBoundingClientRect();
	const { width: targetWidth, height: targetHeight } = targetRef.current.getBoundingClientRect();
	const centerOffsetX = targetWidth / 2;
	const centerOffsetY = targetHeight / 2;
	const saturation = (offset$2.x + centerOffsetX) / width;
	const bright = 1 - (offset$2.y + centerOffsetY) / height;
	const hsb = color.toHsb();
	const alphaOffset = saturation;
	const hueOffset = (offset$2.x + centerOffsetX) / width * 360;
	if (type$2) switch (type$2) {
		case "hue": return generateColor$1({
			...hsb,
			h: hueOffset <= 0 ? 0 : hueOffset
		});
		case "alpha": return generateColor$1({
			...hsb,
			a: alphaOffset <= 0 ? 0 : alphaOffset
		});
	}
	return generateColor$1({
		h: hsb.h,
		s: saturation <= 0 ? 0 : saturation,
		b: bright >= 1 ? 1 : bright,
		a: hsb.a
	});
};
const calcOffset = (color, type$2) => {
	const hsb = color.toHsb();
	switch (type$2) {
		case "hue": return {
			x: hsb.h / 360 * 100,
			y: 50
		};
		case "alpha": return {
			x: color.a * 100,
			y: 50
		};
		default: return {
			x: hsb.s * 100,
			y: (1 - hsb.b) * 100
		};
	}
};

//#endregion
//#region node_modules/@rc-component/color-picker/es/components/ColorBlock.js
var ColorBlock = ({ color, prefixCls, className, style: style$1, onClick }) => {
	const colorBlockCls = `${prefixCls}-color-block`;
	return /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(colorBlockCls, className),
		style: style$1,
		onClick
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: `${colorBlockCls}-inner`,
		style: { background: color }
	}));
};
var ColorBlock_default = ColorBlock;

//#endregion
//#region node_modules/@rc-component/color-picker/es/hooks/useColorDrag.js
function getPosition$2(e$2) {
	const obj = "touches" in e$2 ? e$2.touches[0] : e$2;
	const scrollXOffset = document.documentElement.scrollLeft || document.body.scrollLeft || window.pageXOffset;
	const scrollYOffset = document.documentElement.scrollTop || document.body.scrollTop || window.pageYOffset;
	return {
		pageX: obj.pageX - scrollXOffset,
		pageY: obj.pageY - scrollYOffset
	};
}
function useColorDrag(props) {
	const { targetRef, containerRef, direction, onDragChange, onDragChangeComplete, calculate, color, disabledDrag } = props;
	const [offsetValue, setOffsetValue] = (0, import_react.useState)({
		x: 0,
		y: 0
	});
	const mouseMoveRef = (0, import_react.useRef)(null);
	const mouseUpRef = (0, import_react.useRef)(null);
	(0, import_react.useEffect)(() => {
		setOffsetValue(calculate());
	}, [color]);
	(0, import_react.useEffect)(() => () => {
		document.removeEventListener("mousemove", mouseMoveRef.current);
		document.removeEventListener("mouseup", mouseUpRef.current);
		document.removeEventListener("touchmove", mouseMoveRef.current);
		document.removeEventListener("touchend", mouseUpRef.current);
		mouseMoveRef.current = null;
		mouseUpRef.current = null;
	}, []);
	const updateOffset = (e$2) => {
		const { pageX, pageY } = getPosition$2(e$2);
		const { x: rectX, y: rectY, width, height } = containerRef.current.getBoundingClientRect();
		const { width: targetWidth, height: targetHeight } = targetRef.current.getBoundingClientRect();
		const centerOffsetX = targetWidth / 2;
		const centerOffsetY = targetHeight / 2;
		const offsetX = Math.max(0, Math.min(pageX - rectX, width)) - centerOffsetX;
		const offsetY = Math.max(0, Math.min(pageY - rectY, height)) - centerOffsetY;
		const calcOffset$1 = {
			x: offsetX,
			y: direction === "x" ? offsetValue.y : offsetY
		};
		if (targetWidth === 0 && targetHeight === 0 || targetWidth !== targetHeight) return false;
		onDragChange?.(calcOffset$1);
	};
	const onDragMove = (e$2) => {
		e$2.preventDefault();
		updateOffset(e$2);
	};
	const onDragStop = (e$2) => {
		e$2.preventDefault();
		document.removeEventListener("mousemove", mouseMoveRef.current);
		document.removeEventListener("mouseup", mouseUpRef.current);
		document.removeEventListener("touchmove", mouseMoveRef.current);
		document.removeEventListener("touchend", mouseUpRef.current);
		mouseMoveRef.current = null;
		mouseUpRef.current = null;
		onDragChangeComplete?.();
	};
	const onDragStart = (e$2) => {
		document.removeEventListener("mousemove", mouseMoveRef.current);
		document.removeEventListener("mouseup", mouseUpRef.current);
		if (disabledDrag) return;
		updateOffset(e$2);
		document.addEventListener("mousemove", onDragMove);
		document.addEventListener("mouseup", onDragStop);
		document.addEventListener("touchmove", onDragMove);
		document.addEventListener("touchend", onDragStop);
		mouseMoveRef.current = onDragMove;
		mouseUpRef.current = onDragStop;
	};
	return [offsetValue, onDragStart];
}
var useColorDrag_default = useColorDrag;

//#endregion
//#region node_modules/@rc-component/color-picker/es/components/Handler.js
var Handler = ({ size = "default", color, prefixCls }) => {
	return /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-handler`, { [`${prefixCls}-handler-sm`]: size === "small" }),
		style: { backgroundColor: color }
	});
};
var Handler_default = Handler;

//#endregion
//#region node_modules/@rc-component/color-picker/es/components/Palette.js
var Palette = ({ children, style: style$1, prefixCls }) => {
	return /* @__PURE__ */ import_react.createElement("div", {
		className: `${prefixCls}-palette`,
		style: {
			position: "relative",
			...style$1
		}
	}, children);
};
var Palette_default = Palette;

//#endregion
//#region node_modules/@rc-component/color-picker/es/components/Transform.js
var Transform = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	const { children, x, y } = props;
	return /* @__PURE__ */ import_react.createElement("div", {
		ref,
		style: {
			position: "absolute",
			left: `${x}%`,
			top: `${y}%`,
			zIndex: 1,
			transform: "translate(-50%, -50%)"
		}
	}, children);
});
var Transform_default = Transform;

//#endregion
//#region node_modules/@rc-component/color-picker/es/components/Picker.js
var Picker$1 = ({ color, onChange, prefixCls, onChangeComplete, disabled }) => {
	const pickerRef = (0, import_react.useRef)();
	const transformRef = (0, import_react.useRef)();
	const colorRef = (0, import_react.useRef)(color);
	const [offset$2, dragStartHandle] = useColorDrag_default({
		color,
		containerRef: pickerRef,
		targetRef: transformRef,
		calculate: () => calcOffset(color),
		onDragChange: useEvent_default((offsetValue) => {
			const calcColor = calculateColor({
				offset: offsetValue,
				targetRef: transformRef,
				containerRef: pickerRef,
				color
			});
			colorRef.current = calcColor;
			onChange(calcColor);
		}),
		onDragChangeComplete: () => onChangeComplete?.(colorRef.current),
		disabledDrag: disabled
	});
	return /* @__PURE__ */ import_react.createElement("div", {
		ref: pickerRef,
		className: `${prefixCls}-select`,
		onMouseDown: dragStartHandle,
		onTouchStart: dragStartHandle
	}, /* @__PURE__ */ import_react.createElement(Palette_default, { prefixCls }, /* @__PURE__ */ import_react.createElement(Transform_default, {
		x: offset$2.x,
		y: offset$2.y,
		ref: transformRef
	}, /* @__PURE__ */ import_react.createElement(Handler_default, {
		color: color.toRgbString(),
		prefixCls
	})), /* @__PURE__ */ import_react.createElement("div", {
		className: `${prefixCls}-saturation`,
		style: {
			backgroundColor: `hsl(${color.toHsb().h},100%, 50%)`,
			backgroundImage: "linear-gradient(0deg, #000, transparent),linear-gradient(90deg, #fff, hsla(0, 0%, 100%, 0))"
		}
	})));
};
var Picker_default = Picker$1;

//#endregion
//#region node_modules/@rc-component/color-picker/es/hooks/useColorState.js
var useColorState = (defaultValue, value) => {
	const [mergedValue, setValue] = useControlledState(defaultValue, value);
	return [(0, import_react.useMemo)(() => generateColor$1(mergedValue), [mergedValue]), setValue];
};
var useColorState_default = useColorState;

//#endregion
//#region node_modules/@rc-component/color-picker/es/components/Gradient.js
var Gradient = ({ colors, children, direction = "to right", type: type$2, prefixCls }) => {
	const gradientColors = (0, import_react.useMemo)(() => colors.map((color, idx) => {
		let result = generateColor$1(color);
		if (type$2 === "alpha" && idx === colors.length - 1) result = new Color(result.setA(1));
		return result.toRgbString();
	}).join(","), [colors, type$2]);
	return /* @__PURE__ */ import_react.createElement("div", {
		className: `${prefixCls}-gradient`,
		style: {
			position: "absolute",
			inset: 0,
			background: `linear-gradient(${direction}, ${gradientColors})`
		}
	}, children);
};
var Gradient_default = Gradient;

//#endregion
//#region node_modules/@rc-component/color-picker/es/components/Slider.js
var Slider$3 = (props) => {
	const { prefixCls, colors, disabled, onChange, onChangeComplete, color, type: type$2 } = props;
	const sliderRef = (0, import_react.useRef)(null);
	const transformRef = (0, import_react.useRef)(null);
	const colorRef = (0, import_react.useRef)(color);
	const getValue$1 = (c) => {
		return type$2 === "hue" ? c.getHue() : c.a * 100;
	};
	const [offset$2, dragStartHandle] = useColorDrag_default({
		color,
		targetRef: transformRef,
		containerRef: sliderRef,
		calculate: () => calcOffset(color, type$2),
		onDragChange: useEvent_default((offsetValue) => {
			const calcColor = calculateColor({
				offset: offsetValue,
				targetRef: transformRef,
				containerRef: sliderRef,
				color,
				type: type$2
			});
			colorRef.current = calcColor;
			onChange(getValue$1(calcColor));
		}),
		onDragChangeComplete() {
			onChangeComplete(getValue$1(colorRef.current));
		},
		direction: "x",
		disabledDrag: disabled
	});
	const handleColor = import_react.useMemo(() => {
		if (type$2 === "hue") {
			const hsb = color.toHsb();
			hsb.s = 1;
			hsb.b = 1;
			hsb.a = 1;
			return new Color(hsb);
		}
		return color;
	}, [color, type$2]);
	const gradientList = import_react.useMemo(() => colors.map((info) => `${info.color} ${info.percent}%`), [colors]);
	return /* @__PURE__ */ import_react.createElement("div", {
		ref: sliderRef,
		className: clsx(`${prefixCls}-slider`, `${prefixCls}-slider-${type$2}`),
		onMouseDown: dragStartHandle,
		onTouchStart: dragStartHandle
	}, /* @__PURE__ */ import_react.createElement(Palette_default, { prefixCls }, /* @__PURE__ */ import_react.createElement(Transform_default, {
		x: offset$2.x,
		y: offset$2.y,
		ref: transformRef
	}, /* @__PURE__ */ import_react.createElement(Handler_default, {
		size: "small",
		color: handleColor.toHexString(),
		prefixCls
	})), /* @__PURE__ */ import_react.createElement(Gradient_default, {
		colors: gradientList,
		type: type$2,
		prefixCls
	})));
};
var Slider_default$1 = Slider$3;

//#endregion
//#region node_modules/@rc-component/color-picker/es/hooks/useComponent.js
function useComponent(components$1) {
	return import_react.useMemo(() => {
		const { slider } = components$1 || {};
		return [slider || Slider_default$1];
	}, [components$1]);
}

//#endregion
//#region node_modules/@rc-component/color-picker/es/ColorPicker.js
function _extends$92() {
	_extends$92 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$92.apply(this, arguments);
}
var HUE_COLORS = [
	{
		color: "rgb(255, 0, 0)",
		percent: 0
	},
	{
		color: "rgb(255, 255, 0)",
		percent: 17
	},
	{
		color: "rgb(0, 255, 0)",
		percent: 33
	},
	{
		color: "rgb(0, 255, 255)",
		percent: 50
	},
	{
		color: "rgb(0, 0, 255)",
		percent: 67
	},
	{
		color: "rgb(255, 0, 255)",
		percent: 83
	},
	{
		color: "rgb(255, 0, 0)",
		percent: 100
	}
];
var ColorPicker$1 = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	const { value, defaultValue, prefixCls = ColorPickerPrefixCls, onChange, onChangeComplete, className, style: style$1, panelRender, disabledAlpha = false, disabled = false, components: components$1 } = props;
	const [Slider$4] = useComponent(components$1);
	const [colorValue, setColorValue] = useColorState_default(defaultValue || defaultColor, value);
	const alphaColor = (0, import_react.useMemo)(() => colorValue.setA(1).toRgbString(), [colorValue]);
	const handleChange = (data, type$2) => {
		if (!value) setColorValue(data);
		onChange?.(data, type$2);
	};
	const getHueColor = (hue) => new Color(colorValue.setHue(hue));
	const getAlphaColor$3 = (alpha) => new Color(colorValue.setA(alpha / 100));
	const onHueChange = (hue) => {
		handleChange(getHueColor(hue), {
			type: "hue",
			value: hue
		});
	};
	const onAlphaChange = (alpha) => {
		handleChange(getAlphaColor$3(alpha), {
			type: "alpha",
			value: alpha
		});
	};
	const onHueChangeComplete = (hue) => {
		if (onChangeComplete) onChangeComplete(getHueColor(hue));
	};
	const onAlphaChangeComplete = (alpha) => {
		if (onChangeComplete) onChangeComplete(getAlphaColor$3(alpha));
	};
	const mergeCls = clsx(`${prefixCls}-panel`, className, { [`${prefixCls}-panel-disabled`]: disabled });
	const sharedSliderProps = {
		prefixCls,
		disabled,
		color: colorValue
	};
	const defaultPanel = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(Picker_default, _extends$92({ onChange: handleChange }, sharedSliderProps, { onChangeComplete })), /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-slider-container` }, /* @__PURE__ */ import_react.createElement("div", { className: clsx(`${prefixCls}-slider-group`, { [`${prefixCls}-slider-group-disabled-alpha`]: disabledAlpha }) }, /* @__PURE__ */ import_react.createElement(Slider$4, _extends$92({}, sharedSliderProps, {
		type: "hue",
		colors: HUE_COLORS,
		min: 0,
		max: 359,
		value: colorValue.getHue(),
		onChange: onHueChange,
		onChangeComplete: onHueChangeComplete
	})), !disabledAlpha && /* @__PURE__ */ import_react.createElement(Slider$4, _extends$92({}, sharedSliderProps, {
		type: "alpha",
		colors: [{
			percent: 0,
			color: "rgba(255, 0, 4, 0)"
		}, {
			percent: 100,
			color: alphaColor
		}],
		min: 0,
		max: 100,
		value: colorValue.a * 100,
		onChange: onAlphaChange,
		onChangeComplete: onAlphaChangeComplete
	}))), /* @__PURE__ */ import_react.createElement(ColorBlock_default, {
		color: colorValue.toRgbString(),
		prefixCls
	})));
	return /* @__PURE__ */ import_react.createElement("div", {
		className: mergeCls,
		style: style$1,
		ref
	}, typeof panelRender === "function" ? panelRender(defaultPanel) : defaultPanel);
});
ColorPicker$1.displayName = "ColorPicker";
var ColorPicker_default$1 = ColorPicker$1;

//#endregion
//#region node_modules/@rc-component/color-picker/es/index.js
var es_default$19 = ColorPicker_default$1;

//#endregion
//#region node_modules/antd/es/color-picker/color.js
const toHexFormat = (value, alpha) => value?.replace(/[^\w/]/g, "").slice(0, alpha ? 8 : 6) || "";
const getHex = (value, alpha) => value ? toHexFormat(value, alpha) : "";
let AggregationColor = /* @__PURE__ */ function() {
	function AggregationColor$1(color) {
		_classCallCheck(this, AggregationColor$1);
		this.cleared = false;
		if (color instanceof AggregationColor$1) {
			this.metaColor = color.metaColor.clone();
			this.colors = color.colors?.map((info) => ({
				color: new AggregationColor$1(info.color),
				percent: info.percent
			}));
			this.cleared = color.cleared;
			return;
		}
		const isArray = Array.isArray(color);
		if (isArray && color.length) {
			this.colors = color.map(({ color: c, percent }) => ({
				color: new AggregationColor$1(c),
				percent
			}));
			this.metaColor = new Color(this.colors[0].color.metaColor);
		} else this.metaColor = new Color(isArray ? "" : color);
		if (!color || isArray && !this.colors) {
			this.metaColor = this.metaColor.setA(0);
			this.cleared = true;
		}
	}
	return _createClass(AggregationColor$1, [
		{
			key: "toHsb",
			value: function toHsb() {
				return this.metaColor.toHsb();
			}
		},
		{
			key: "toHsbString",
			value: function toHsbString() {
				return this.metaColor.toHsbString();
			}
		},
		{
			key: "toHex",
			value: function toHex() {
				return getHex(this.toHexString(), this.metaColor.a < 1);
			}
		},
		{
			key: "toHexString",
			value: function toHexString() {
				return this.metaColor.toHexString();
			}
		},
		{
			key: "toRgb",
			value: function toRgb() {
				return this.metaColor.toRgb();
			}
		},
		{
			key: "toRgbString",
			value: function toRgbString() {
				return this.metaColor.toRgbString();
			}
		},
		{
			key: "isGradient",
			value: function isGradient() {
				return !!this.colors && !this.cleared;
			}
		},
		{
			key: "getColors",
			value: function getColors() {
				return this.colors || [{
					color: this,
					percent: 0
				}];
			}
		},
		{
			key: "toCssString",
			value: function toCssString() {
				const { colors } = this;
				if (colors) return `linear-gradient(90deg, ${colors.map((c) => `${c.color.toRgbString()} ${c.percent}%`).join(", ")})`;
				return this.metaColor.toRgbString();
			}
		},
		{
			key: "equals",
			value: function equals(color) {
				if (!color || this.isGradient() !== color.isGradient()) return false;
				if (!this.isGradient()) return this.toHexString() === color.toHexString();
				return this.colors.length === color.colors.length && this.colors.every((c, i) => {
					const target = color.colors[i];
					return c.percent === target.percent && c.color.equals(target.color);
				});
			}
		}
	]);
}();

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/extends.js
function _extends$26() {
	return _extends$26 = Object.assign ? Object.assign.bind() : function(n$1) {
		for (var e$2 = 1; e$2 < arguments.length; e$2++) {
			var t$1 = arguments[e$2];
			for (var r$1 in t$1) ({}).hasOwnProperty.call(t$1, r$1) && (n$1[r$1] = t$1[r$1]);
		}
		return n$1;
	}, _extends$26.apply(null, arguments);
}

//#endregion
//#region node_modules/@rc-component/collapse/es/PanelContent.js
var PanelContent = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls, forceRender, className, style: style$1, children, isActive: isActive$1, role, classNames: customizeClassNames, styles } = props;
	const [rendered, setRendered] = import_react.useState(isActive$1 || forceRender);
	import_react.useEffect(() => {
		if (forceRender || isActive$1) setRendered(true);
	}, [forceRender, isActive$1]);
	if (!rendered) return null;
	return /* @__PURE__ */ import_react.createElement("div", {
		ref,
		className: clsx(`${prefixCls}-panel`, {
			[`${prefixCls}-panel-active`]: isActive$1,
			[`${prefixCls}-panel-inactive`]: !isActive$1
		}, className),
		style: style$1,
		role
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-body`, customizeClassNames?.body),
		style: styles?.body
	}, children));
});
PanelContent.displayName = "PanelContent";
var PanelContent_default = PanelContent;

//#endregion
//#region node_modules/@rc-component/collapse/es/Panel.js
var CollapsePanel$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { showArrow = true, headerClass, isActive: isActive$1, onItemClick, forceRender, className, classNames: customizeClassNames = {}, styles = {}, prefixCls, collapsible, accordion, panelKey, extra, header, expandIcon, openMotion, destroyOnHidden, children, ...resetProps } = props;
	const disabled = collapsible === "disabled";
	const ifExtraExist = extra !== null && extra !== void 0 && typeof extra !== "boolean";
	const collapsibleProps = {
		onClick: () => {
			onItemClick?.(panelKey);
		},
		onKeyDown: (e$2) => {
			if (e$2.key === "Enter" || e$2.keyCode === KeyCode_default.ENTER || e$2.which === KeyCode_default.ENTER) onItemClick?.(panelKey);
		},
		role: accordion ? "tab" : "button",
		["aria-expanded"]: isActive$1,
		["aria-disabled"]: disabled,
		tabIndex: disabled ? -1 : 0
	};
	const iconNodeInner = typeof expandIcon === "function" ? expandIcon(props) : /* @__PURE__ */ import_react.createElement("i", { className: "arrow" });
	const iconNode = iconNodeInner && /* @__PURE__ */ import_react.createElement("div", _extends$26({
		className: clsx(`${prefixCls}-expand-icon`, customizeClassNames?.icon),
		style: styles?.icon
	}, ["header", "icon"].includes(collapsible) ? collapsibleProps : {}), iconNodeInner);
	const collapsePanelClassNames = clsx(`${prefixCls}-item`, {
		[`${prefixCls}-item-active`]: isActive$1,
		[`${prefixCls}-item-disabled`]: disabled
	}, className);
	const headerProps = {
		className: clsx(headerClass, `${prefixCls}-header`, { [`${prefixCls}-collapsible-${collapsible}`]: !!collapsible }, customizeClassNames?.header),
		style: styles?.header,
		...["header", "icon"].includes(collapsible) ? {} : collapsibleProps
	};
	return /* @__PURE__ */ import_react.createElement("div", _extends$26({}, resetProps, {
		ref,
		className: collapsePanelClassNames
	}), /* @__PURE__ */ import_react.createElement("div", headerProps, showArrow && iconNode, /* @__PURE__ */ import_react.createElement("span", _extends$26({
		className: clsx(`${prefixCls}-title`, customizeClassNames?.title),
		style: styles?.title
	}, collapsible === "header" ? collapsibleProps : {}), header), ifExtraExist && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-extra` }, extra)), /* @__PURE__ */ import_react.createElement(es_default$1, _extends$26({
		visible: isActive$1,
		leavedClassName: `${prefixCls}-panel-hidden`
	}, openMotion, {
		forceRender,
		removeOnLeave: destroyOnHidden
	}), ({ className: motionClassName, style: motionStyle }, motionRef) => {
		return /* @__PURE__ */ import_react.createElement(PanelContent_default, {
			ref: motionRef,
			prefixCls,
			className: motionClassName,
			classNames: customizeClassNames,
			style: motionStyle,
			styles,
			isActive: isActive$1,
			forceRender,
			role: accordion ? "tabpanel" : void 0
		}, children);
	}));
});
var Panel_default$4 = CollapsePanel$1;

//#endregion
//#region node_modules/@rc-component/collapse/es/hooks/useItems.js
var convertItemsToNodes$1 = (items, props) => {
	const { prefixCls, accordion, collapsible, destroyOnHidden, onItemClick, activeKey, openMotion, expandIcon, classNames: collapseClassNames, styles } = props;
	return items.map((item, index$1) => {
		const { children, label, key: rawKey, collapsible: rawCollapsible, onItemClick: rawOnItemClick, destroyOnHidden: rawDestroyOnHidden, ...restProps } = item;
		const key = String(rawKey ?? index$1);
		const mergeCollapsible = rawCollapsible ?? collapsible;
		const mergedDestroyOnHidden = rawDestroyOnHidden ?? destroyOnHidden;
		const handleItemClick = (value) => {
			if (mergeCollapsible === "disabled") return;
			onItemClick(value);
			rawOnItemClick?.(value);
		};
		let isActive$1 = false;
		if (accordion) isActive$1 = activeKey[0] === key;
		else isActive$1 = activeKey.indexOf(key) > -1;
		return /* @__PURE__ */ import_react.createElement(Panel_default$4, _extends$26({}, restProps, {
			classNames: collapseClassNames,
			styles,
			prefixCls,
			key,
			panelKey: key,
			isActive: isActive$1,
			accordion,
			openMotion,
			expandIcon,
			header: label,
			collapsible: mergeCollapsible,
			onItemClick: handleItemClick,
			destroyOnHidden: mergedDestroyOnHidden
		}), children);
	});
};
/**
* @deprecated The next major version will be removed
*/
var getNewChild = (child, index$1, props) => {
	if (!child) return null;
	const { prefixCls, accordion, collapsible, destroyOnHidden, onItemClick, activeKey, openMotion, expandIcon, classNames: collapseClassNames, styles } = props;
	const key = child.key || String(index$1);
	const { header, headerClass, destroyOnHidden: childDestroyOnHidden, collapsible: childCollapsible, onItemClick: childOnItemClick } = child.props;
	let isActive$1 = false;
	if (accordion) isActive$1 = activeKey[0] === key;
	else isActive$1 = activeKey.indexOf(key) > -1;
	const mergeCollapsible = childCollapsible ?? collapsible;
	const handleItemClick = (value) => {
		if (mergeCollapsible === "disabled") return;
		onItemClick(value);
		childOnItemClick?.(value);
	};
	const childProps = {
		key,
		panelKey: key,
		header,
		headerClass,
		classNames: collapseClassNames,
		styles,
		isActive: isActive$1,
		prefixCls,
		destroyOnHidden: childDestroyOnHidden ?? destroyOnHidden,
		openMotion,
		accordion,
		children: child.props.children,
		onItemClick: handleItemClick,
		expandIcon,
		collapsible: mergeCollapsible
	};
	if (typeof child.type === "string") return child;
	Object.keys(childProps).forEach((propName) => {
		if (typeof childProps[propName] === "undefined") delete childProps[propName];
	});
	return /* @__PURE__ */ import_react.cloneElement(child, childProps);
};
function useItems$4(items, rawChildren, props) {
	if (Array.isArray(items)) return convertItemsToNodes$1(items, props);
	return toArray(rawChildren).map((child, index$1) => getNewChild(child, index$1, props));
}
var useItems_default$1 = useItems$4;

//#endregion
//#region node_modules/@rc-component/collapse/es/Collapse.js
function getActiveKeysArray(activeKey) {
	let currentActiveKey = activeKey;
	if (!Array.isArray(currentActiveKey)) {
		const activeKeyType = typeof currentActiveKey;
		currentActiveKey = activeKeyType === "number" || activeKeyType === "string" ? [currentActiveKey] : [];
	}
	return currentActiveKey.map((key) => String(key));
}
var Collapse$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls = "rc-collapse", destroyOnHidden = false, style: style$1, accordion, className, children, collapsible, openMotion, expandIcon, activeKey: rawActiveKey, defaultActiveKey, onChange, items, classNames: customizeClassNames, styles } = props;
	const collapseClassName = clsx(prefixCls, className);
	const [internalActiveKey, setActiveKey] = useControlledState(defaultActiveKey, rawActiveKey);
	const activeKey = getActiveKeysArray(internalActiveKey);
	const triggerActiveKey = useEvent_default((next$1) => {
		const nextKeys = getActiveKeysArray(next$1);
		setActiveKey(nextKeys);
		onChange?.(nextKeys);
	});
	const onItemClick = (key) => {
		if (accordion) triggerActiveKey(activeKey[0] === key ? [] : [key]);
		else triggerActiveKey(activeKey.includes(key) ? activeKey.filter((item) => item !== key) : [...activeKey, key]);
	};
	warning_default$1(!children, "[rc-collapse] `children` will be removed in next major version. Please use `items` instead.");
	const mergedChildren = useItems_default$1(items, children, {
		prefixCls,
		accordion,
		openMotion,
		expandIcon,
		collapsible,
		destroyOnHidden,
		onItemClick,
		activeKey,
		classNames: customizeClassNames,
		styles
	});
	return /* @__PURE__ */ import_react.createElement("div", _extends$26({
		ref,
		className: collapseClassName,
		style: style$1,
		role: accordion ? "tablist" : void 0
	}, pickAttrs(props, {
		aria: true,
		data: true
	})), mergedChildren);
});
var Collapse_default$1 = Object.assign(Collapse$1, { Panel: Panel_default$4 });

//#endregion
//#region node_modules/@rc-component/collapse/es/index.js
var es_default$35 = Collapse_default$1;
/**
* @deprecated use `items` instead, will be removed in `v4.0.0`
*/
const { Panel: Panel$4 } = Collapse_default$1;

//#endregion
//#region node_modules/antd/es/collapse/CollapsePanel.js
var CollapsePanel = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	devUseWarning("Collapse.Panel").deprecated(!("disabled" in props), "disabled", "collapsible=\"disabled\"");
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const { prefixCls: customizePrefixCls, className, showArrow = true } = props;
	const prefixCls = getPrefixCls("collapse", customizePrefixCls);
	const collapsePanelClassName = clsx({ [`${prefixCls}-no-arrow`]: !showArrow }, className);
	return /* @__PURE__ */ import_react.createElement(es_default$35.Panel, {
		ref,
		...props,
		prefixCls,
		className: collapsePanelClassName
	});
});
var CollapsePanel_default = CollapsePanel;

//#endregion
//#region node_modules/antd/es/style/motion/collapse.js
var genCollapseMotion = (token$1) => ({ [token$1.componentCls]: {
	[`${token$1.antCls}-motion-collapse-legacy`]: {
		overflow: "hidden",
		"&-active": { transition: `height ${token$1.motionDurationMid} ${token$1.motionEaseInOut},
        opacity ${token$1.motionDurationMid} ${token$1.motionEaseInOut} !important` }
	},
	[`${token$1.antCls}-motion-collapse`]: {
		overflow: "hidden",
		transition: `height ${token$1.motionDurationMid} ${token$1.motionEaseInOut},
        opacity ${token$1.motionDurationMid} ${token$1.motionEaseInOut} !important`
	}
} });
var collapse_default$1 = genCollapseMotion;

//#endregion
//#region node_modules/antd/es/style/motion/motion.js
var initMotionCommon = (duration) => ({
	animationDuration: duration,
	animationFillMode: "both"
});
var initMotionCommonLeave = (duration) => ({
	animationDuration: duration,
	animationFillMode: "both"
});
const initMotion = (motionCls, inKeyframes, outKeyframes, duration, sameLevel = false) => {
	const sameLevelPrefix = sameLevel ? "&" : "";
	return {
		[`
      ${sameLevelPrefix}${motionCls}-enter,
      ${sameLevelPrefix}${motionCls}-appear
    `]: {
			...initMotionCommon(duration),
			animationPlayState: "paused"
		},
		[`${sameLevelPrefix}${motionCls}-leave`]: {
			...initMotionCommonLeave(duration),
			animationPlayState: "paused"
		},
		[`
      ${sameLevelPrefix}${motionCls}-enter${motionCls}-enter-active,
      ${sameLevelPrefix}${motionCls}-appear${motionCls}-appear-active
    `]: {
			animationName: inKeyframes,
			animationPlayState: "running"
		},
		[`${sameLevelPrefix}${motionCls}-leave${motionCls}-leave-active`]: {
			animationName: outKeyframes,
			animationPlayState: "running",
			pointerEvents: "none"
		}
	};
};

//#endregion
//#region node_modules/antd/es/style/motion/fade.js
const fadeIn = new Keyframes_default("antFadeIn", {
	"0%": { opacity: 0 },
	"100%": { opacity: 1 }
});
const fadeOut = new Keyframes_default("antFadeOut", {
	"0%": { opacity: 1 },
	"100%": { opacity: 0 }
});
/**
* Initialize fade motion styles
*
* Generates CSS styles for fade in/out transition animations when elements are shown/hidden.
* Supports enter, appear, and leave animation states.
*
* @param token - Object containing design tokens and CSS class prefix
* @param sameLevel - Controls CSS selector nesting behavior:
*   - `false` (default): Generates descendant selectors like `.ant-fade-enter`, `.ant-fade-appear`
*   - `true`: Generates same-level selectors with `&` prefix like `&.ant-fade-enter`, `&.ant-fade-appear`
*   Use `true` when the motion classes are applied to the same element as the parent selector,
*   Use `false` when the motion classes are applied to child elements
* @returns CSS interpolation object containing fade motion styles
*
* @example
* ```ts
* // For child elements (default behavior)
* const fadeStyles = initFadeMotion(token);
* // Generates: .parent .ant-fade-enter { ... }
*
* // For same element
* const sameLevelFadeStyles = initFadeMotion(token, true);
* // Generates: .parent.ant-fade-enter { ... }
* ```
*/
const initFadeMotion = (token$1, sameLevel = false) => {
	const { antCls } = token$1;
	const motionCls = `${antCls}-fade`;
	const sameLevelPrefix = sameLevel ? "&" : "";
	return [initMotion(motionCls, fadeIn, fadeOut, token$1.motionDurationMid, sameLevel), {
		[`
        ${sameLevelPrefix}${motionCls}-enter,
        ${sameLevelPrefix}${motionCls}-appear
      `]: {
			opacity: 0,
			animationTimingFunction: "linear"
		},
		[`${sameLevelPrefix}${motionCls}-leave`]: { animationTimingFunction: "linear" }
	}];
};

//#endregion
//#region node_modules/antd/es/style/motion/move.js
const moveDownIn = new Keyframes_default("antMoveDownIn", {
	"0%": {
		transform: "translate3d(0, 100%, 0)",
		transformOrigin: "0 0",
		opacity: 0
	},
	"100%": {
		transform: "translate3d(0, 0, 0)",
		transformOrigin: "0 0",
		opacity: 1
	}
});
const moveDownOut = new Keyframes_default("antMoveDownOut", {
	"0%": {
		transform: "translate3d(0, 0, 0)",
		transformOrigin: "0 0",
		opacity: 1
	},
	"100%": {
		transform: "translate3d(0, 100%, 0)",
		transformOrigin: "0 0",
		opacity: 0
	}
});
const moveLeftIn = new Keyframes_default("antMoveLeftIn", {
	"0%": {
		transform: "translate3d(-100%, 0, 0)",
		transformOrigin: "0 0",
		opacity: 0
	},
	"100%": {
		transform: "translate3d(0, 0, 0)",
		transformOrigin: "0 0",
		opacity: 1
	}
});
const moveLeftOut = new Keyframes_default("antMoveLeftOut", {
	"0%": {
		transform: "translate3d(0, 0, 0)",
		transformOrigin: "0 0",
		opacity: 1
	},
	"100%": {
		transform: "translate3d(-100%, 0, 0)",
		transformOrigin: "0 0",
		opacity: 0
	}
});
const moveRightIn = new Keyframes_default("antMoveRightIn", {
	"0%": {
		transform: "translate3d(100%, 0, 0)",
		transformOrigin: "0 0",
		opacity: 0
	},
	"100%": {
		transform: "translate3d(0, 0, 0)",
		transformOrigin: "0 0",
		opacity: 1
	}
});
const moveRightOut = new Keyframes_default("antMoveRightOut", {
	"0%": {
		transform: "translate3d(0, 0, 0)",
		transformOrigin: "0 0",
		opacity: 1
	},
	"100%": {
		transform: "translate3d(100%, 0, 0)",
		transformOrigin: "0 0",
		opacity: 0
	}
});
const moveUpIn = new Keyframes_default("antMoveUpIn", {
	"0%": {
		transform: "translate3d(0, -100%, 0)",
		transformOrigin: "0 0",
		opacity: 0
	},
	"100%": {
		transform: "translate3d(0, 0, 0)",
		transformOrigin: "0 0",
		opacity: 1
	}
});
const moveUpOut = new Keyframes_default("antMoveUpOut", {
	"0%": {
		transform: "translate3d(0, 0, 0)",
		transformOrigin: "0 0",
		opacity: 1
	},
	"100%": {
		transform: "translate3d(0, -100%, 0)",
		transformOrigin: "0 0",
		opacity: 0
	}
});
var moveMotion = {
	"move-up": {
		inKeyframes: moveUpIn,
		outKeyframes: moveUpOut
	},
	"move-down": {
		inKeyframes: moveDownIn,
		outKeyframes: moveDownOut
	},
	"move-left": {
		inKeyframes: moveLeftIn,
		outKeyframes: moveLeftOut
	},
	"move-right": {
		inKeyframes: moveRightIn,
		outKeyframes: moveRightOut
	}
};
const initMoveMotion = (token$1, motionName) => {
	const { antCls } = token$1;
	const motionCls = `${antCls}-${motionName}`;
	const { inKeyframes, outKeyframes } = moveMotion[motionName];
	return [initMotion(motionCls, inKeyframes, outKeyframes, token$1.motionDurationMid), {
		[`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
			opacity: 0,
			animationTimingFunction: token$1.motionEaseOutCirc
		},
		[`${motionCls}-leave`]: { animationTimingFunction: token$1.motionEaseInOutCirc }
	}];
};

//#endregion
//#region node_modules/antd/es/style/motion/slide.js
const slideUpIn = new Keyframes_default("antSlideUpIn", {
	"0%": {
		transform: "scaleY(0.8)",
		transformOrigin: "0% 0%",
		opacity: 0
	},
	"100%": {
		transform: "scaleY(1)",
		transformOrigin: "0% 0%",
		opacity: 1
	}
});
const slideUpOut = new Keyframes_default("antSlideUpOut", {
	"0%": {
		transform: "scaleY(1)",
		transformOrigin: "0% 0%",
		opacity: 1
	},
	"100%": {
		transform: "scaleY(0.8)",
		transformOrigin: "0% 0%",
		opacity: 0
	}
});
const slideDownIn = new Keyframes_default("antSlideDownIn", {
	"0%": {
		transform: "scaleY(0.8)",
		transformOrigin: "100% 100%",
		opacity: 0
	},
	"100%": {
		transform: "scaleY(1)",
		transformOrigin: "100% 100%",
		opacity: 1
	}
});
const slideDownOut = new Keyframes_default("antSlideDownOut", {
	"0%": {
		transform: "scaleY(1)",
		transformOrigin: "100% 100%",
		opacity: 1
	},
	"100%": {
		transform: "scaleY(0.8)",
		transformOrigin: "100% 100%",
		opacity: 0
	}
});
const slideLeftIn = new Keyframes_default("antSlideLeftIn", {
	"0%": {
		transform: "scaleX(0.8)",
		transformOrigin: "0% 0%",
		opacity: 0
	},
	"100%": {
		transform: "scaleX(1)",
		transformOrigin: "0% 0%",
		opacity: 1
	}
});
const slideLeftOut = new Keyframes_default("antSlideLeftOut", {
	"0%": {
		transform: "scaleX(1)",
		transformOrigin: "0% 0%",
		opacity: 1
	},
	"100%": {
		transform: "scaleX(0.8)",
		transformOrigin: "0% 0%",
		opacity: 0
	}
});
const slideRightIn = new Keyframes_default("antSlideRightIn", {
	"0%": {
		transform: "scaleX(0.8)",
		transformOrigin: "100% 0%",
		opacity: 0
	},
	"100%": {
		transform: "scaleX(1)",
		transformOrigin: "100% 0%",
		opacity: 1
	}
});
const slideRightOut = new Keyframes_default("antSlideRightOut", {
	"0%": {
		transform: "scaleX(1)",
		transformOrigin: "100% 0%",
		opacity: 1
	},
	"100%": {
		transform: "scaleX(0.8)",
		transformOrigin: "100% 0%",
		opacity: 0
	}
});
var slideMotion = {
	"slide-up": {
		inKeyframes: slideUpIn,
		outKeyframes: slideUpOut
	},
	"slide-down": {
		inKeyframes: slideDownIn,
		outKeyframes: slideDownOut
	},
	"slide-left": {
		inKeyframes: slideLeftIn,
		outKeyframes: slideLeftOut
	},
	"slide-right": {
		inKeyframes: slideRightIn,
		outKeyframes: slideRightOut
	}
};
const initSlideMotion = (token$1, motionName) => {
	const { antCls } = token$1;
	const motionCls = `${antCls}-${motionName}`;
	const { inKeyframes, outKeyframes } = slideMotion[motionName];
	return [initMotion(motionCls, inKeyframes, outKeyframes, token$1.motionDurationMid), {
		[`
      ${motionCls}-enter,
      ${motionCls}-appear
    `]: {
			transform: "scale(0)",
			transformOrigin: "0% 0%",
			opacity: 0,
			animationTimingFunction: token$1.motionEaseOutQuint,
			"&-prepare": { transform: "scale(1)" }
		},
		[`${motionCls}-leave`]: { animationTimingFunction: token$1.motionEaseInQuint }
	}];
};

//#endregion
//#region node_modules/antd/es/style/motion/zoom.js
const zoomIn = new Keyframes_default("antZoomIn", {
	"0%": {
		transform: "scale(0.2)",
		opacity: 0
	},
	"100%": {
		transform: "scale(1)",
		opacity: 1
	}
});
const zoomOut = new Keyframes_default("antZoomOut", {
	"0%": { transform: "scale(1)" },
	"100%": {
		transform: "scale(0.2)",
		opacity: 0
	}
});
const zoomBigIn = new Keyframes_default("antZoomBigIn", {
	"0%": {
		transform: "scale(0.8)",
		opacity: 0
	},
	"100%": {
		transform: "scale(1)",
		opacity: 1
	}
});
const zoomBigOut = new Keyframes_default("antZoomBigOut", {
	"0%": { transform: "scale(1)" },
	"100%": {
		transform: "scale(0.8)",
		opacity: 0
	}
});
const zoomUpIn = new Keyframes_default("antZoomUpIn", {
	"0%": {
		transform: "scale(0.8)",
		transformOrigin: "50% 0%",
		opacity: 0
	},
	"100%": {
		transform: "scale(1)",
		transformOrigin: "50% 0%"
	}
});
const zoomUpOut = new Keyframes_default("antZoomUpOut", {
	"0%": {
		transform: "scale(1)",
		transformOrigin: "50% 0%"
	},
	"100%": {
		transform: "scale(0.8)",
		transformOrigin: "50% 0%",
		opacity: 0
	}
});
const zoomLeftIn = new Keyframes_default("antZoomLeftIn", {
	"0%": {
		transform: "scale(0.8)",
		transformOrigin: "0% 50%",
		opacity: 0
	},
	"100%": {
		transform: "scale(1)",
		transformOrigin: "0% 50%"
	}
});
const zoomLeftOut = new Keyframes_default("antZoomLeftOut", {
	"0%": {
		transform: "scale(1)",
		transformOrigin: "0% 50%"
	},
	"100%": {
		transform: "scale(0.8)",
		transformOrigin: "0% 50%",
		opacity: 0
	}
});
const zoomRightIn = new Keyframes_default("antZoomRightIn", {
	"0%": {
		transform: "scale(0.8)",
		transformOrigin: "100% 50%",
		opacity: 0
	},
	"100%": {
		transform: "scale(1)",
		transformOrigin: "100% 50%"
	}
});
const zoomRightOut = new Keyframes_default("antZoomRightOut", {
	"0%": {
		transform: "scale(1)",
		transformOrigin: "100% 50%"
	},
	"100%": {
		transform: "scale(0.8)",
		transformOrigin: "100% 50%",
		opacity: 0
	}
});
const zoomDownIn = new Keyframes_default("antZoomDownIn", {
	"0%": {
		transform: "scale(0.8)",
		transformOrigin: "50% 100%",
		opacity: 0
	},
	"100%": {
		transform: "scale(1)",
		transformOrigin: "50% 100%"
	}
});
const zoomDownOut = new Keyframes_default("antZoomDownOut", {
	"0%": {
		transform: "scale(1)",
		transformOrigin: "50% 100%"
	},
	"100%": {
		transform: "scale(0.8)",
		transformOrigin: "50% 100%",
		opacity: 0
	}
});
var zoomMotion = {
	zoom: {
		inKeyframes: zoomIn,
		outKeyframes: zoomOut
	},
	"zoom-big": {
		inKeyframes: zoomBigIn,
		outKeyframes: zoomBigOut
	},
	"zoom-big-fast": {
		inKeyframes: zoomBigIn,
		outKeyframes: zoomBigOut
	},
	"zoom-left": {
		inKeyframes: zoomLeftIn,
		outKeyframes: zoomLeftOut
	},
	"zoom-right": {
		inKeyframes: zoomRightIn,
		outKeyframes: zoomRightOut
	},
	"zoom-up": {
		inKeyframes: zoomUpIn,
		outKeyframes: zoomUpOut
	},
	"zoom-down": {
		inKeyframes: zoomDownIn,
		outKeyframes: zoomDownOut
	}
};
const initZoomMotion = (token$1, motionName) => {
	const { antCls } = token$1;
	const motionCls = `${antCls}-${motionName}`;
	const { inKeyframes, outKeyframes } = zoomMotion[motionName];
	return [initMotion(motionCls, inKeyframes, outKeyframes, motionName === "zoom-big-fast" ? token$1.motionDurationFast : token$1.motionDurationMid), {
		[`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
			transform: "scale(0)",
			opacity: 0,
			animationTimingFunction: token$1.motionEaseOutCirc,
			"&-prepare": { transform: "none" }
		},
		[`${motionCls}-leave`]: { animationTimingFunction: token$1.motionEaseInOutCirc }
	}];
};

//#endregion
//#region node_modules/antd/es/collapse/style/index.js
const genBaseStyle$17 = (token$1) => {
	const { componentCls, contentBg, padding, headerBg, headerPadding, collapseHeaderPaddingSM, collapseHeaderPaddingLG, collapsePanelBorderRadius, lineWidth, lineType, colorBorder, colorText, colorTextHeading, colorTextDisabled, fontSizeLG, lineHeight, lineHeightLG, marginSM, paddingSM, paddingLG, paddingXS, motionDurationSlow, fontSizeIcon, contentPadding, fontHeight, fontHeightLG } = token$1;
	const borderBase = `${unit(lineWidth)} ${lineType} ${colorBorder}`;
	return { [componentCls]: {
		...resetComponent(token$1),
		backgroundColor: headerBg,
		border: borderBase,
		borderRadius: collapsePanelBorderRadius,
		"&-rtl": { direction: "rtl" },
		[`& > ${componentCls}-item`]: {
			borderBottom: borderBase,
			"&:first-child": { [`
            &,
            & > ${componentCls}-header`]: { borderRadius: `${unit(collapsePanelBorderRadius)} ${unit(collapsePanelBorderRadius)} 0 0` } },
			"&:last-child": { [`
            &,
            & > ${componentCls}-header`]: { borderRadius: `0 0 ${unit(collapsePanelBorderRadius)} ${unit(collapsePanelBorderRadius)}` } },
			[`> ${componentCls}-header`]: {
				position: "relative",
				display: "flex",
				flexWrap: "nowrap",
				alignItems: "flex-start",
				padding: headerPadding,
				color: colorTextHeading,
				lineHeight,
				cursor: "pointer",
				transition: `all ${motionDurationSlow}, visibility 0s`,
				...genFocusStyle(token$1),
				[`> ${componentCls}-title`]: { flex: "auto" },
				[`${componentCls}-expand-icon`]: {
					height: fontHeight,
					display: "flex",
					alignItems: "center",
					marginInlineEnd: marginSM
				},
				[`${componentCls}-arrow`]: {
					...resetIcon(),
					fontSize: fontSizeIcon,
					transition: `transform ${motionDurationSlow}`,
					svg: { transition: `transform ${motionDurationSlow}` }
				},
				[`${componentCls}-title`]: { marginInlineEnd: "auto" }
			},
			[`${componentCls}-collapsible-header`]: {
				cursor: "default",
				[`${componentCls}-title`]: {
					flex: "none",
					cursor: "pointer"
				},
				[`${componentCls}-expand-icon`]: { cursor: "pointer" }
			},
			[`${componentCls}-collapsible-icon`]: {
				cursor: "unset",
				[`${componentCls}-expand-icon`]: { cursor: "pointer" }
			}
		},
		[`${componentCls}-panel`]: {
			color: colorText,
			backgroundColor: contentBg,
			borderTop: borderBase,
			[`& > ${componentCls}-body`]: { padding: contentPadding },
			"&-hidden": { display: "none" }
		},
		"&-small": { [`> ${componentCls}-item`]: {
			[`> ${componentCls}-header`]: {
				padding: collapseHeaderPaddingSM,
				paddingInlineStart: paddingXS,
				[`> ${componentCls}-expand-icon`]: { marginInlineStart: token$1.calc(paddingSM).sub(paddingXS).equal() }
			},
			[`> ${componentCls}-panel > ${componentCls}-body`]: { padding: paddingSM }
		} },
		"&-large": { [`> ${componentCls}-item`]: {
			fontSize: fontSizeLG,
			lineHeight: lineHeightLG,
			[`> ${componentCls}-header`]: {
				padding: collapseHeaderPaddingLG,
				paddingInlineStart: padding,
				[`> ${componentCls}-expand-icon`]: {
					height: fontHeightLG,
					marginInlineStart: token$1.calc(paddingLG).sub(padding).equal()
				}
			},
			[`> ${componentCls}-panel > ${componentCls}-body`]: { padding: paddingLG }
		} },
		[`${componentCls}-item:last-child`]: {
			borderBottom: 0,
			[`> ${componentCls}-panel`]: { borderRadius: `0 0 ${unit(collapsePanelBorderRadius)} ${unit(collapsePanelBorderRadius)}` }
		},
		[`& ${componentCls}-item-disabled > ${componentCls}-header`]: { [`
          &,
          & > .arrow
        `]: {
			color: colorTextDisabled,
			cursor: "not-allowed"
		} },
		[`&${componentCls}-icon-placement-end`]: { [`& > ${componentCls}-item`]: { [`> ${componentCls}-header`]: { [`${componentCls}-expand-icon`]: {
			order: 1,
			marginInlineEnd: 0,
			marginInlineStart: marginSM
		} } } }
	} };
};
var genArrowStyle = (token$1) => {
	const { componentCls } = token$1;
	const fixedSelector = `> ${componentCls}-item > ${componentCls}-header ${componentCls}-arrow`;
	return { [`${componentCls}-rtl`]: { [fixedSelector]: { transform: `rotate(180deg)` } } };
};
var genBorderlessStyle$1 = (token$1) => {
	const { componentCls, headerBg, borderlessContentPadding, borderlessContentBg, colorBorder } = token$1;
	return { [`${componentCls}-borderless`]: {
		backgroundColor: headerBg,
		border: 0,
		[`> ${componentCls}-item`]: { borderBottom: `1px solid ${colorBorder}` },
		[`
        > ${componentCls}-item:last-child,
        > ${componentCls}-item:last-child ${componentCls}-header
      `]: { borderRadius: 0 },
		[`> ${componentCls}-item:last-child`]: { borderBottom: 0 },
		[`> ${componentCls}-item > ${componentCls}-panel`]: {
			backgroundColor: borderlessContentBg,
			borderTop: 0
		},
		[`> ${componentCls}-item > ${componentCls}-panel > ${componentCls}-body`]: { padding: borderlessContentPadding }
	} };
};
var genGhostStyle = (token$1) => {
	const { componentCls, paddingSM } = token$1;
	return { [`${componentCls}-ghost`]: {
		backgroundColor: "transparent",
		border: 0,
		[`> ${componentCls}-item`]: {
			borderBottom: 0,
			[`> ${componentCls}-panel`]: {
				backgroundColor: "transparent",
				border: 0,
				[`> ${componentCls}-body`]: { paddingBlock: paddingSM }
			}
		}
	} };
};
const prepareComponentToken$53 = (token$1) => ({
	headerPadding: `${token$1.paddingSM}px ${token$1.padding}px`,
	headerBg: token$1.colorFillAlter,
	contentPadding: `${token$1.padding}px 16px`,
	contentBg: token$1.colorBgContainer,
	borderlessContentPadding: `${token$1.paddingXXS}px 16px ${token$1.padding}px`,
	borderlessContentBg: "transparent"
});
var style_default$59 = genStyleHooks("Collapse", (token$1) => {
	const collapseToken = merge(token$1, {
		collapseHeaderPaddingSM: `${unit(token$1.paddingXS)} ${unit(token$1.paddingSM)}`,
		collapseHeaderPaddingLG: `${unit(token$1.padding)} ${unit(token$1.paddingLG)}`,
		collapsePanelBorderRadius: token$1.borderRadiusLG
	});
	return [
		genBaseStyle$17(collapseToken),
		genBorderlessStyle$1(collapseToken),
		genGhostStyle(collapseToken),
		genArrowStyle(collapseToken),
		collapse_default$1(collapseToken)
	];
}, prepareComponentToken$53);

//#endregion
//#region node_modules/antd/es/collapse/Collapse.js
var Collapse = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { getPrefixCls, direction, expandIcon: contextExpandIcon, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("collapse");
	const { prefixCls: customizePrefixCls, className, rootClassName, style: style$1, bordered = true, ghost, size: customizeSize, expandIconPlacement, expandIconPosition, children, destroyInactivePanel, destroyOnHidden, expandIcon, classNames, styles } = props;
	const mergedSize = useSize_default((ctx) => customizeSize ?? ctx ?? "middle");
	const prefixCls = getPrefixCls("collapse", customizePrefixCls);
	const rootPrefixCls = getPrefixCls();
	const [hashId, cssVarCls] = style_default$59(prefixCls);
	const mergedPlacement = expandIconPlacement ?? expandIconPosition ?? "start";
	const mergedProps = {
		...props,
		size: mergedSize,
		bordered,
		expandIconPlacement: mergedPlacement
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const mergedExpandIcon = expandIcon ?? contextExpandIcon;
	{
		const warning$3 = devUseWarning("Collapse");
		[["destroyInactivePanel", "destroyOnHidden"], ["expandIconPosition", "expandIconPlacement"]].forEach(([deprecatedName, newName]) => {
			warning$3.deprecated(!(deprecatedName in props), deprecatedName, newName);
		});
	}
	const renderExpandIcon$2 = import_react.useCallback((panelProps = {}) => {
		const icon = typeof mergedExpandIcon === "function" ? mergedExpandIcon(panelProps) : /* @__PURE__ */ import_react.createElement(RightOutlined_default, {
			rotate: panelProps.isActive ? direction === "rtl" ? -90 : 90 : void 0,
			"aria-label": panelProps.isActive ? "expanded" : "collapsed"
		});
		return cloneElement(icon, () => ({ className: clsx(icon?.props?.className, `${prefixCls}-arrow`) }));
	}, [
		mergedExpandIcon,
		prefixCls,
		direction
	]);
	const collapseClassName = clsx(`${prefixCls}-icon-placement-${mergedPlacement}`, {
		[`${prefixCls}-borderless`]: !bordered,
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-ghost`]: !!ghost,
		[`${prefixCls}-${mergedSize}`]: mergedSize !== "middle"
	}, contextClassName, className, rootClassName, hashId, cssVarCls, mergedClassNames.root);
	const openMotion = import_react.useMemo(() => ({
		...motion_default(rootPrefixCls),
		motionAppear: false,
		leavedClassName: `${prefixCls}-panel-hidden`
	}), [rootPrefixCls, prefixCls]);
	const items = import_react.useMemo(() => {
		if (children) return toArray(children).map((child) => child);
		return null;
	}, [children]);
	return /* @__PURE__ */ import_react.createElement(es_default$35, {
		ref,
		openMotion,
		...omit(props, ["rootClassName"]),
		expandIcon: renderExpandIcon$2,
		prefixCls,
		className: collapseClassName,
		style: {
			...mergedStyles.root,
			...contextStyle,
			...style$1
		},
		classNames: mergedClassNames,
		styles: mergedStyles,
		destroyOnHidden: destroyOnHidden ?? destroyInactivePanel
	}, items);
});
Collapse.displayName = "Collapse";
var Collapse_default = Object.assign(Collapse, { Panel: CollapsePanel_default });

//#endregion
//#region node_modules/antd/es/collapse/index.js
var collapse_default = Collapse_default;

//#endregion
//#region node_modules/antd/es/color-picker/util.js
const generateColor = (color) => {
	if (color instanceof AggregationColor) return color;
	return new AggregationColor(color);
};
const getRoundNumber = (value) => Math.round(Number(value || 0));
const getColorAlpha = (color) => getRoundNumber(color.toHsb().a * 100);
/** Return the color whose `alpha` is 1 */
const genAlphaColor = (color, alpha) => {
	const rgba = color.toRgb();
	if (!rgba.r && !rgba.g && !rgba.b) {
		const hsba = color.toHsb();
		hsba.a = alpha || 1;
		return generateColor(hsba);
	}
	rgba.a = alpha || 1;
	return generateColor(rgba);
};
/**
* Get percent position color. e.g. [10%-#fff, 20%-#000], 15% => #888
*/
const getGradientPercentColor = (colors, percent) => {
	const filledColors = [{
		percent: 0,
		color: colors[0].color
	}].concat(_toConsumableArray(colors), [{
		percent: 100,
		color: colors[colors.length - 1].color
	}]);
	for (let i = 0; i < filledColors.length - 1; i += 1) {
		const startPtg = filledColors[i].percent;
		const endPtg = filledColors[i + 1].percent;
		const startColor = filledColors[i].color;
		const endColor = filledColors[i + 1].color;
		if (startPtg <= percent && percent <= endPtg) {
			const dist = endPtg - startPtg;
			if (dist === 0) return startColor;
			const ratio = (percent - startPtg) / dist * 100;
			const startRcColor = new Color(startColor);
			const endRcColor = new Color(endColor);
			return startRcColor.mix(endRcColor, ratio).toRgbString();
		}
	}
	/* istanbul ignore next */
	return "";
};

//#endregion
//#region node_modules/antd/es/color-picker/components/ColorPresets.js
var genPresetColor$1 = (list) => list.map((value) => {
	value.colors = value.colors.map(generateColor);
	return value;
});
const isBright = (value, bgColorToken) => {
	const { r: r$1, g, b, a } = value.toRgb();
	const hsv = new Color(value.toRgbString()).onBackground(bgColorToken).toHsv();
	if (a <= .5) return hsv.v > .5;
	return r$1 * .299 + g * .587 + b * .114 > 192;
};
var genCollapsePanelKey = (preset, index$1) => {
	return `panel-${preset.key ?? index$1}`;
};
var ColorPresets = ({ prefixCls, presets, value: color, onChange }) => {
	const [locale$5] = useLocale_default("ColorPicker");
	const [, token$1] = useToken();
	const presetsValue = (0, import_react.useMemo)(() => genPresetColor$1(presets), [presets]);
	const colorPresetsPrefixCls = `${prefixCls}-presets`;
	const activeKeys = (0, import_react.useMemo)(() => presetsValue.reduce((acc, preset, index$1) => {
		const { defaultOpen = true } = preset;
		if (defaultOpen) acc.push(genCollapsePanelKey(preset, index$1));
		return acc;
	}, []), [presetsValue]);
	const handleClick = (colorValue) => {
		onChange?.(colorValue);
	};
	const items = presetsValue.map((preset, index$1) => ({
		key: genCollapsePanelKey(preset, index$1),
		label: /* @__PURE__ */ import_react.createElement("div", { className: `${colorPresetsPrefixCls}-label` }, preset?.label),
		children: /* @__PURE__ */ import_react.createElement("div", { className: `${colorPresetsPrefixCls}-items` }, Array.isArray(preset?.colors) && preset.colors?.length > 0 ? preset.colors.map((presetColor, index$2) => {
			const colorInst = generateColor(presetColor);
			return /* @__PURE__ */ import_react.createElement(ColorBlock_default, {
				key: `preset-${index$2}-${presetColor.toHexString()}`,
				color: colorInst.toCssString(),
				prefixCls,
				className: clsx(`${colorPresetsPrefixCls}-color`, {
					[`${colorPresetsPrefixCls}-color-checked`]: presetColor.toCssString() === color?.toCssString(),
					[`${colorPresetsPrefixCls}-color-bright`]: isBright(presetColor, token$1.colorBgElevated)
				}),
				onClick: () => handleClick(presetColor)
			});
		}) : /* @__PURE__ */ import_react.createElement("span", { className: `${colorPresetsPrefixCls}-empty` }, locale$5.presetEmpty))
	}));
	return /* @__PURE__ */ import_react.createElement("div", { className: colorPresetsPrefixCls }, /* @__PURE__ */ import_react.createElement(collapse_default, {
		defaultActiveKey: activeKeys,
		ghost: true,
		items
	}));
};
var ColorPresets_default = ColorPresets;

//#endregion
//#region node_modules/antd/es/button/style/token.js
const prepareToken$5 = (token$1) => {
	const { paddingInline, onlyIconSize, borderColorDisabled } = token$1;
	return merge(token$1, {
		buttonPaddingHorizontal: paddingInline,
		buttonPaddingVertical: 0,
		buttonIconOnlyFontSize: onlyIconSize,
		colorBorderDisabled: borderColorDisabled
	});
};
const prepareComponentToken$52 = (token$1) => {
	const contentFontSize = token$1.contentFontSize ?? token$1.fontSize;
	const contentFontSizeSM = token$1.contentFontSizeSM ?? token$1.fontSize;
	const contentFontSizeLG = token$1.contentFontSizeLG ?? token$1.fontSizeLG;
	const contentLineHeight = token$1.contentLineHeight ?? getLineHeight(contentFontSize);
	const contentLineHeightSM = token$1.contentLineHeightSM ?? getLineHeight(contentFontSizeSM);
	const contentLineHeightLG = token$1.contentLineHeightLG ?? getLineHeight(contentFontSizeLG);
	const solidTextColor = isBright(new AggregationColor(token$1.colorBgSolid), "#fff") ? "#000" : "#fff";
	const shadowColorTokens = PresetColors.reduce((prev$1, colorKey) => ({
		...prev$1,
		[`${colorKey}ShadowColor`]: `0 ${unit(token$1.controlOutlineWidth)} 0 ${getAlphaColor_default(token$1[`${colorKey}1`], token$1.colorBgContainer)}`
	}), {});
	const defaultBgDisabled = token$1.colorBgContainerDisabled;
	const dashedBgDisabled = token$1.colorBgContainerDisabled;
	return {
		...shadowColorTokens,
		fontWeight: 400,
		iconGap: token$1.marginXS,
		defaultShadow: `0 ${token$1.controlOutlineWidth}px 0 ${token$1.controlTmpOutline}`,
		primaryShadow: `0 ${token$1.controlOutlineWidth}px 0 ${token$1.controlOutline}`,
		dangerShadow: `0 ${token$1.controlOutlineWidth}px 0 ${token$1.colorErrorOutline}`,
		primaryColor: token$1.colorTextLightSolid,
		dangerColor: token$1.colorTextLightSolid,
		borderColorDisabled: token$1.colorBorderDisabled,
		defaultGhostColor: token$1.colorBgContainer,
		ghostBg: "transparent",
		defaultGhostBorderColor: token$1.colorBgContainer,
		paddingInline: token$1.paddingContentHorizontal - token$1.lineWidth,
		paddingInlineLG: token$1.paddingContentHorizontal - token$1.lineWidth,
		paddingInlineSM: 8 - token$1.lineWidth,
		onlyIconSize: "inherit",
		onlyIconSizeSM: "inherit",
		onlyIconSizeLG: "inherit",
		groupBorderColor: token$1.colorPrimaryHover,
		linkHoverBg: "transparent",
		textTextColor: token$1.colorText,
		textTextHoverColor: token$1.colorText,
		textTextActiveColor: token$1.colorText,
		textHoverBg: token$1.colorFillTertiary,
		defaultColor: token$1.colorText,
		defaultBg: token$1.colorBgContainer,
		defaultBorderColor: token$1.colorBorder,
		defaultBorderColorDisabled: token$1.colorBorder,
		defaultHoverBg: token$1.colorBgContainer,
		defaultHoverColor: token$1.colorPrimaryHover,
		defaultHoverBorderColor: token$1.colorPrimaryHover,
		defaultActiveBg: token$1.colorBgContainer,
		defaultActiveColor: token$1.colorPrimaryActive,
		defaultActiveBorderColor: token$1.colorPrimaryActive,
		solidTextColor,
		contentFontSize,
		contentFontSizeSM,
		contentFontSizeLG,
		contentLineHeight,
		contentLineHeightSM,
		contentLineHeightLG,
		paddingBlock: Math.max((token$1.controlHeight - contentFontSize * contentLineHeight) / 2 - token$1.lineWidth, 0),
		paddingBlockSM: Math.max((token$1.controlHeightSM - contentFontSizeSM * contentLineHeightSM) / 2 - token$1.lineWidth, 0),
		paddingBlockLG: Math.max((token$1.controlHeightLG - contentFontSizeLG * contentLineHeightLG) / 2 - token$1.lineWidth, 0),
		defaultBgDisabled,
		dashedBgDisabled
	};
};

//#endregion
//#region node_modules/antd/es/button/style/variant.js
var genVariantStyle = (token$1) => {
	const { componentCls, antCls } = token$1;
	const getCssVar = genCssVar(antCls, "btn");
	return { [componentCls]: [
		{
			[getCssVar("border-width")]: "1px",
			[getCssVar("border-color")]: "#000",
			[getCssVar("border-color-hover")]: `var(${getCssVar("border-color")})`,
			[getCssVar("border-color-active")]: `var(${getCssVar("border-color")})`,
			[getCssVar("border-color-disabled")]: `var(${getCssVar("border-color")})`,
			[getCssVar("border-style")]: "solid",
			[getCssVar("text-color")]: "#000",
			[getCssVar("text-color-hover")]: `var(${getCssVar("text-color")})`,
			[getCssVar("text-color-active")]: `var(${getCssVar("text-color")})`,
			[getCssVar("text-color-disabled")]: `var(${getCssVar("text-color")})`,
			[getCssVar("bg-color")]: "#ddd",
			[getCssVar("bg-color-hover")]: `var(${getCssVar("bg-color")})`,
			[getCssVar("bg-color-active")]: `var(${getCssVar("bg-color")})`,
			[getCssVar("bg-color-disabled")]: token$1.colorBgContainerDisabled,
			[getCssVar("bg-color-container")]: token$1.colorBgContainer,
			[getCssVar("shadow")]: "none"
		},
		{
			border: `var(${getCssVar("border-width")}) var(${getCssVar("border-style")}) var(${getCssVar("border-color")})`,
			color: `var(${getCssVar("text-color")})`,
			backgroundColor: `var(${getCssVar("bg-color")})`,
			[`&:not(:disabled):not(${componentCls}-disabled)`]: {
				"&:hover": {
					border: `var(${getCssVar("border-width")}) var(${getCssVar("border-style")}) var(${getCssVar("border-color-hover")})`,
					color: `var(${getCssVar("text-color-hover")})`,
					backgroundColor: `var(${getCssVar("bg-color-hover")})`
				},
				"&:active": {
					border: `var(${getCssVar("border-width")}) var(${getCssVar("border-style")}) var(${getCssVar("border-color-active")})`,
					color: `var(${getCssVar("text-color-active")})`,
					backgroundColor: `var(${getCssVar("bg-color-active")})`
				}
			}
		},
		{
			[`&${componentCls}-variant-solid`]: {
				[getCssVar("solid-bg-color")]: `var(${getCssVar("color-base")})`,
				[getCssVar("solid-bg-color-hover")]: `var(${getCssVar("color-hover")})`,
				[getCssVar("solid-bg-color-active")]: `var(${getCssVar("color-active")})`,
				[getCssVar("border-color")]: "transparent",
				[getCssVar("text-color")]: token$1.colorTextLightSolid,
				[getCssVar("bg-color")]: `var(${getCssVar("solid-bg-color")})`,
				[getCssVar("bg-color-hover")]: `var(${getCssVar("solid-bg-color-hover")})`,
				[getCssVar("bg-color-active")]: `var(${getCssVar("solid-bg-color-active")})`,
				boxShadow: `var(${getCssVar("shadow")})`
			},
			[`&${componentCls}-variant-outlined, &${componentCls}-variant-dashed`]: {
				[getCssVar("border-color")]: `var(${getCssVar("color-base")})`,
				[getCssVar("border-color-hover")]: `var(${getCssVar("color-hover")})`,
				[getCssVar("border-color-active")]: `var(${getCssVar("color-active")})`,
				[getCssVar("bg-color")]: `var(${getCssVar("bg-color-container")})`,
				[getCssVar("text-color")]: `var(${getCssVar("color-base")})`,
				[getCssVar("text-color-hover")]: `var(${getCssVar("color-hover")})`,
				[getCssVar("text-color-active")]: `var(${getCssVar("color-active")})`,
				boxShadow: `var(${getCssVar("shadow")})`
			},
			[`&${componentCls}-variant-dashed`]: {
				[getCssVar("border-style")]: "dashed",
				[getCssVar("bg-color-disabled")]: token$1.dashedBgDisabled
			},
			[`&${componentCls}-variant-filled`]: {
				[getCssVar("border-color")]: "transparent",
				[getCssVar("text-color")]: `var(${getCssVar("color-base")})`,
				[getCssVar("bg-color")]: `var(${getCssVar("color-light")})`,
				[getCssVar("bg-color-hover")]: `var(${getCssVar("color-light-hover")})`,
				[getCssVar("bg-color-active")]: `var(${getCssVar("color-light-active")})`
			},
			[`&${componentCls}-variant-text, &${componentCls}-variant-link`]: {
				[getCssVar("border-color")]: "transparent",
				[getCssVar("text-color")]: `var(${getCssVar("color-base")})`,
				[getCssVar("text-color-hover")]: `var(${getCssVar("color-hover")})`,
				[getCssVar("text-color-active")]: `var(${getCssVar("color-active")})`,
				[getCssVar("bg-color")]: "transparent",
				[getCssVar("bg-color-hover")]: "transparent",
				[getCssVar("bg-color-active")]: "transparent",
				[`&:disabled, &${token$1.componentCls}-disabled`]: {
					background: "transparent",
					borderColor: "transparent"
				}
			},
			[`&${componentCls}-variant-text`]: {
				[getCssVar("bg-color-hover")]: `var(${getCssVar("color-light")})`,
				[getCssVar("bg-color-active")]: `var(${getCssVar("color-light-active")})`
			}
		},
		{
			[`&${componentCls}-variant-link`]: {
				[getCssVar("color-base")]: token$1.colorLink,
				[getCssVar("color-hover")]: token$1.colorLinkHover,
				[getCssVar("color-active")]: token$1.colorLinkActive
			},
			[`&${componentCls}-color-primary`]: {
				[getCssVar("color-base")]: token$1.colorPrimary,
				[getCssVar("color-hover")]: token$1.colorPrimaryHover,
				[getCssVar("color-active")]: token$1.colorPrimaryActive,
				[getCssVar("color-light")]: token$1.colorPrimaryBg,
				[getCssVar("color-light-hover")]: token$1.colorPrimaryBgHover,
				[getCssVar("color-light-active")]: token$1.colorPrimaryBorder,
				[getCssVar("shadow")]: token$1.primaryShadow,
				[`&${componentCls}-variant-solid`]: {
					[getCssVar("text-color")]: token$1.primaryColor,
					[getCssVar("text-color-hover")]: `var(${getCssVar("text-color")})`,
					[getCssVar("text-color-active")]: `var(${getCssVar("text-color")})`
				}
			},
			[`&${componentCls}-color-dangerous`]: {
				[getCssVar("color-base")]: token$1.colorError,
				[getCssVar("color-hover")]: token$1.colorErrorHover,
				[getCssVar("color-active")]: token$1.colorErrorActive,
				[getCssVar("color-light")]: token$1.colorErrorBg,
				[getCssVar("color-light-hover")]: token$1.colorErrorBgFilledHover,
				[getCssVar("color-light-active")]: token$1.colorErrorBgActive,
				[getCssVar("shadow")]: token$1.dangerShadow,
				[`&${componentCls}-variant-solid`]: {
					[getCssVar("text-color")]: token$1.dangerColor,
					[getCssVar("text-color-hover")]: `var(${getCssVar("text-color")})`,
					[getCssVar("text-color-active")]: `var(${getCssVar("text-color")})`
				}
			},
			[`&${componentCls}-color-default`]: {
				[getCssVar("solid-bg-color")]: token$1.colorBgSolid,
				[getCssVar("solid-bg-color-hover")]: token$1.colorBgSolidHover,
				[getCssVar("solid-bg-color-active")]: token$1.colorBgSolidActive,
				[getCssVar("color-base")]: token$1.defaultBorderColor,
				[getCssVar("color-hover")]: token$1.defaultHoverBorderColor,
				[getCssVar("color-active")]: token$1.defaultActiveBorderColor,
				[getCssVar("color-light")]: token$1.colorFillTertiary,
				[getCssVar("color-light-hover")]: token$1.colorFillSecondary,
				[getCssVar("color-light-active")]: token$1.colorFill,
				[getCssVar("text-color")]: token$1.colorText,
				[getCssVar("text-color-hover")]: token$1.defaultHoverBorderColor,
				[getCssVar("text-color-active")]: token$1.defaultActiveBorderColor,
				[getCssVar("shadow")]: token$1.defaultShadow,
				[`&${componentCls}-variant-solid`]: {
					[getCssVar("text-color")]: token$1.solidTextColor,
					[getCssVar("text-color-hover")]: `var(${getCssVar("text-color")})`,
					[getCssVar("text-color-active")]: `var(${getCssVar("text-color")})`
				},
				[`&${componentCls}-variant-filled, &${componentCls}-variant-text`]: {
					[getCssVar("text-color-hover")]: `var(${getCssVar("text-color")})`,
					[getCssVar("text-color-active")]: `var(${getCssVar("text-color")})`
				},
				[`&${componentCls}-variant-outlined, &${componentCls}-variant-dashed`]: {
					[getCssVar("bg-color-hover")]: token$1.defaultHoverBg,
					[getCssVar("bg-color-active")]: token$1.defaultActiveBg
				},
				[`&${componentCls}-background-ghost`]: { [`&${componentCls}-variant-outlined, &${componentCls}-variant-dashed`]: {
					[getCssVar("text-color")]: token$1.defaultGhostColor,
					[getCssVar("border-color")]: token$1.defaultGhostBorderColor
				} }
			}
		},
		PresetColors.map((colorKey) => {
			const darkColor = token$1[`${colorKey}6`];
			const lightColor = token$1[`${colorKey}1`];
			const hoverColor = token$1[`${colorKey}5`];
			const lightHoverColor = token$1[`${colorKey}2`];
			const lightActiveColor = token$1[`${colorKey}3`];
			const activeColor = token$1[`${colorKey}7`];
			const shadowColor = token$1[`${colorKey}ShadowColor`];
			return { [`&${componentCls}-color-${colorKey}`]: {
				[getCssVar("color-base")]: darkColor,
				[getCssVar("color-hover")]: hoverColor,
				[getCssVar("color-active")]: activeColor,
				[getCssVar("color-light")]: lightColor,
				[getCssVar("color-light-hover")]: lightHoverColor,
				[getCssVar("color-light-active")]: lightActiveColor,
				[getCssVar("shadow")]: shadowColor
			} };
		}),
		{ [`&:disabled, &${token$1.componentCls}-disabled`]: {
			cursor: "not-allowed",
			borderColor: token$1.colorBorderDisabled,
			background: `var(${getCssVar("bg-color-disabled")})`,
			color: token$1.colorTextDisabled,
			boxShadow: "none"
		} },
		{ [`&${componentCls}-background-ghost`]: {
			[getCssVar("bg-color")]: "transparent",
			[getCssVar("shadow")]: "none"
		} }
	] };
};
var variant_default = genVariantStyle;

//#endregion
//#region node_modules/antd/es/button/style/index.js
var genSharedButtonStyle = (token$1) => {
	const { componentCls, iconCls, fontWeight, opacityLoading, motionDurationSlow, motionEaseInOut, iconGap, calc } = token$1;
	return { [componentCls]: {
		outline: "none",
		position: "relative",
		display: "inline-flex",
		gap: iconGap,
		alignItems: "center",
		justifyContent: "center",
		fontWeight,
		whiteSpace: "nowrap",
		textAlign: "center",
		backgroundImage: "none",
		cursor: "pointer",
		transition: `all ${token$1.motionDurationMid} ${token$1.motionEaseInOut}`,
		userSelect: "none",
		touchAction: "manipulation",
		"&:disabled > *": { pointerEvents: "none" },
		[`${componentCls}-icon > svg`]: resetIcon(),
		"> a": { color: "currentColor" },
		"&:not(:disabled)": genFocusStyle(token$1),
		[`&${componentCls}-two-chinese-chars::first-letter`]: { letterSpacing: "0.34em" },
		[`&${componentCls}-two-chinese-chars > *:not(${iconCls})`]: {
			marginInlineEnd: "-0.34em",
			letterSpacing: "0.34em"
		},
		[`&${componentCls}-icon-only`]: {
			paddingInline: 0,
			[`&${componentCls}-compact-item`]: { flex: "none" }
		},
		[`&${componentCls}-loading`]: {
			opacity: opacityLoading,
			cursor: "default"
		},
		[`${componentCls}-loading-icon`]: { transition: [
			"width",
			"opacity",
			"margin"
		].map((transition) => `${transition} ${motionDurationSlow} ${motionEaseInOut}`).join(",") },
		[`&:not(${componentCls}-icon-end)`]: { [`${componentCls}-loading-icon-motion`]: {
			"&-appear-start, &-enter-start": { marginInlineEnd: calc(iconGap).mul(-1).equal() },
			"&-appear-active, &-enter-active": { marginInlineEnd: 0 },
			"&-leave-start": { marginInlineEnd: 0 },
			"&-leave-active": { marginInlineEnd: calc(iconGap).mul(-1).equal() }
		} },
		"&-icon-end": {
			flexDirection: "row-reverse",
			[`${componentCls}-loading-icon-motion`]: {
				"&-appear-start, &-enter-start": { marginInlineStart: calc(iconGap).mul(-1).equal() },
				"&-appear-active, &-enter-active": { marginInlineStart: 0 },
				"&-leave-start": { marginInlineStart: 0 },
				"&-leave-active": { marginInlineStart: calc(iconGap).mul(-1).equal() }
			}
		}
	} };
};
var genCircleButtonStyle = (token$1) => ({
	minWidth: token$1.controlHeight,
	paddingInline: 0,
	borderRadius: "50%"
});
var genButtonStyle = (token$1, prefixCls = "") => {
	const { componentCls, controlHeight, fontSize, borderRadius, buttonPaddingHorizontal, iconCls, buttonPaddingVertical, buttonIconOnlyFontSize } = token$1;
	return [
		{ [prefixCls]: {
			fontSize,
			height: controlHeight,
			padding: `${unit(buttonPaddingVertical)} ${unit(buttonPaddingHorizontal)}`,
			borderRadius,
			[`&${componentCls}-icon-only`]: {
				width: controlHeight,
				[iconCls]: { fontSize: buttonIconOnlyFontSize }
			}
		} },
		{ [`${componentCls}${componentCls}-circle${prefixCls}`]: genCircleButtonStyle(token$1) },
		{ [`${componentCls}${componentCls}-round${prefixCls}`]: {
			borderRadius: token$1.controlHeight,
			[`&:not(${componentCls}-icon-only)`]: { paddingInline: token$1.buttonPaddingHorizontal }
		} }
	];
};
var genSizeBaseButtonStyle = (token$1) => {
	return genButtonStyle(merge(token$1, { fontSize: token$1.contentFontSize }), token$1.componentCls);
};
var genSizeSmallButtonStyle = (token$1) => {
	return genButtonStyle(merge(token$1, {
		controlHeight: token$1.controlHeightSM,
		fontSize: token$1.contentFontSizeSM,
		padding: token$1.paddingXS,
		buttonPaddingHorizontal: token$1.paddingInlineSM,
		buttonPaddingVertical: 0,
		borderRadius: token$1.borderRadiusSM,
		buttonIconOnlyFontSize: token$1.onlyIconSizeSM
	}), `${token$1.componentCls}-sm`);
};
var genSizeLargeButtonStyle = (token$1) => {
	return genButtonStyle(merge(token$1, {
		controlHeight: token$1.controlHeightLG,
		fontSize: token$1.contentFontSizeLG,
		buttonPaddingHorizontal: token$1.paddingInlineLG,
		buttonPaddingVertical: 0,
		borderRadius: token$1.borderRadiusLG,
		buttonIconOnlyFontSize: token$1.onlyIconSizeLG
	}), `${token$1.componentCls}-lg`);
};
var genBlockButtonStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: { [`&${componentCls}-block`]: { width: "100%" } } };
};
var style_default$58 = genStyleHooks("Button", (token$1) => {
	const buttonToken = prepareToken$5(token$1);
	return [
		genSharedButtonStyle(buttonToken),
		genSizeBaseButtonStyle(buttonToken),
		genSizeSmallButtonStyle(buttonToken),
		genSizeLargeButtonStyle(buttonToken),
		genBlockButtonStyle(buttonToken),
		variant_default(buttonToken),
		group_default$2(buttonToken)
	];
}, prepareComponentToken$52, { unitless: {
	fontWeight: true,
	contentLineHeight: true,
	contentLineHeightSM: true,
	contentLineHeightLG: true
} });

//#endregion
//#region node_modules/antd/es/style/compact-item.js
function compactItemBorder(token$1, parentCls, options, prefixCls) {
	const { focusElCls, focus, borderElCls } = options;
	const childCombinator = borderElCls ? "> *" : "";
	const hoverEffects = [
		"hover",
		focus ? "focus" : null,
		"active"
	].filter(Boolean).map((n$1) => `&:${n$1} ${childCombinator}`).join(",");
	return {
		[`&-item:not(${parentCls}-last-item)`]: { marginInlineEnd: token$1.calc(token$1.lineWidth).mul(-1).equal() },
		[`&-item:not(${prefixCls}-status-success)`]: { zIndex: 2 },
		"&-item": {
			[hoverEffects]: { zIndex: 3 },
			...focusElCls ? { [`&${focusElCls}`]: { zIndex: 3 } } : {},
			[`&[disabled] ${childCombinator}`]: { zIndex: 0 }
		}
	};
}
function compactItemBorderRadius(prefixCls, parentCls, options) {
	const { borderElCls } = options;
	const childCombinator = borderElCls ? `> ${borderElCls}` : "";
	return {
		[`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${childCombinator}`]: { borderRadius: 0 },
		[`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: { [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
			borderStartEndRadius: 0,
			borderEndEndRadius: 0
		} },
		[`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: { [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
			borderStartStartRadius: 0,
			borderEndStartRadius: 0
		} }
	};
}
function genCompactItemStyle(token$1, options = { focus: true }) {
	const { componentCls } = token$1;
	const { componentCls: customizePrefixCls } = options;
	const mergedComponentCls = customizePrefixCls || componentCls;
	const compactCls = `${mergedComponentCls}-compact`;
	return { [compactCls]: {
		...compactItemBorder(token$1, compactCls, options, mergedComponentCls),
		...compactItemBorderRadius(mergedComponentCls, compactCls, options)
	} };
}

//#endregion
//#region node_modules/antd/es/style/compact-item-vertical.js
function compactItemVerticalBorder(token$1, parentCls, prefixCls) {
	return {
		[`&-item:not(${parentCls}-last-item)`]: { marginBottom: token$1.calc(token$1.lineWidth).mul(-1).equal() },
		[`&-item:not(${prefixCls}-status-success)`]: { zIndex: 2 },
		"&-item": {
			"&:hover,&:focus,&:active": { zIndex: 3 },
			"&[disabled]": { zIndex: 0 }
		}
	};
}
function compactItemBorderVerticalRadius(prefixCls, parentCls) {
	return {
		[`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: { borderRadius: 0 },
		[`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: { [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
			borderEndEndRadius: 0,
			borderEndStartRadius: 0
		} },
		[`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: { [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
			borderStartStartRadius: 0,
			borderStartEndRadius: 0
		} }
	};
}
function genCompactItemVerticalStyle(token$1) {
	const compactCls = `${token$1.componentCls}-compact-vertical`;
	return { [compactCls]: {
		...compactItemVerticalBorder(token$1, compactCls, token$1.componentCls),
		...compactItemBorderVerticalRadius(token$1.componentCls, compactCls)
	} };
}

//#endregion
//#region node_modules/antd/es/button/style/compact.js
var genButtonCompactStyle = (token$1) => {
	const { componentCls, colorPrimaryHover, lineWidth, calc } = token$1;
	const insetOffset = calc(lineWidth).mul(-1).equal();
	const getCompactBorderStyle = (vertical) => {
		const itemCls = `${componentCls}-compact${vertical ? "-vertical" : ""}-item`;
		const selector = `${itemCls}${componentCls}-primary:not([disabled])`;
		return {
			[itemCls]: { transition: `none` },
			[`${selector} + ${selector}::before`]: {
				position: "absolute",
				top: vertical ? insetOffset : 0,
				insetInlineStart: vertical ? 0 : insetOffset,
				backgroundColor: colorPrimaryHover,
				content: "\"\"",
				width: vertical ? "100%" : lineWidth,
				height: vertical ? lineWidth : "100%"
			}
		};
	};
	return {
		...getCompactBorderStyle(),
		...getCompactBorderStyle(true)
	};
};
var compact_default$1 = genSubStyleComponent(["Button", "compact"], (token$1) => {
	const buttonToken = prepareToken$5(token$1);
	return [
		genCompactItemStyle(buttonToken),
		genCompactItemVerticalStyle(buttonToken),
		genButtonCompactStyle(buttonToken)
	];
}, prepareComponentToken$52);

//#endregion
//#region node_modules/antd/es/button/Button.js
function getLoadingConfig(loading) {
	if (typeof loading === "object" && loading) {
		let delay = loading?.delay;
		delay = !Number.isNaN(delay) && typeof delay === "number" ? delay : 0;
		return {
			loading: delay <= 0,
			delay
		};
	}
	return {
		loading: !!loading,
		delay: 0
	};
}
var ButtonTypeMap = {
	default: ["default", "outlined"],
	primary: ["primary", "solid"],
	dashed: ["default", "dashed"],
	link: ["link", "link"],
	text: ["default", "text"]
};
var Button = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { _skipSemantic, loading = false, prefixCls: customizePrefixCls, color, variant, type: type$2, danger = false, shape: customizeShape, size: customizeSize, disabled: customDisabled, className, rootClassName, children, icon, iconPosition, iconPlacement, ghost = false, block = false, htmlType = "button", classNames, styles, style: style$1, autoInsertSpace, autoFocus, ...rest } = props;
	const childNodes = toArray(children);
	const mergedType = type$2 || "default";
	const { button } = import_react.useContext(ConfigContext);
	const shape = customizeShape || button?.shape || "default";
	const [parsedColor, parsedVariant] = (0, import_react.useMemo)(() => {
		if (color && variant) return [color, variant];
		if (type$2 || danger) {
			const colorVariantPair = ButtonTypeMap[mergedType] || [];
			if (danger) return ["danger", colorVariantPair[1]];
			return colorVariantPair;
		}
		if (button?.color && button?.variant) return [button.color, button.variant];
		return ["default", "outlined"];
	}, [
		color,
		variant,
		type$2,
		danger,
		button?.color,
		button?.variant,
		mergedType
	]);
	const [mergedColor, mergedVariant] = (0, import_react.useMemo)(() => {
		if (ghost && parsedVariant === "solid") return [parsedColor, "outlined"];
		return [parsedColor, parsedVariant];
	}, [
		parsedColor,
		parsedVariant,
		ghost
	]);
	const isDanger = mergedColor === "danger";
	const mergedColorText = isDanger ? "dangerous" : mergedColor;
	const { getPrefixCls, direction, autoInsertSpace: contextAutoInsertSpace, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("button");
	const mergedInsertSpace = autoInsertSpace ?? contextAutoInsertSpace ?? true;
	const prefixCls = getPrefixCls("btn", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$58(prefixCls);
	const disabled = (0, import_react.useContext)(DisabledContext_default);
	const mergedDisabled = customDisabled ?? disabled;
	const groupSize = (0, import_react.useContext)(GroupSizeContext);
	const loadingOrDelay = (0, import_react.useMemo)(() => getLoadingConfig(loading), [loading]);
	const [innerLoading, setLoading] = (0, import_react.useState)(loadingOrDelay.loading);
	const [hasTwoCNChar, setHasTwoCNChar] = (0, import_react.useState)(false);
	const buttonRef = (0, import_react.useRef)(null);
	const mergedRef = useComposeRef(ref, buttonRef);
	const needInserted = childNodes.length === 1 && !icon && !isUnBorderedButtonVariant(mergedVariant);
	const isMountRef = (0, import_react.useRef)(true);
	import_react.useEffect(() => {
		isMountRef.current = false;
		return () => {
			isMountRef.current = true;
		};
	}, []);
	useLayoutEffect_default(() => {
		let delayTimer = null;
		if (loadingOrDelay.delay > 0) delayTimer = setTimeout(() => {
			delayTimer = null;
			setLoading(true);
		}, loadingOrDelay.delay);
		else setLoading(loadingOrDelay.loading);
		function cleanupTimer() {
			if (delayTimer) {
				clearTimeout(delayTimer);
				delayTimer = null;
			}
		}
		return cleanupTimer;
	}, [loadingOrDelay.delay, loadingOrDelay.loading]);
	(0, import_react.useEffect)(() => {
		if (!buttonRef.current || !mergedInsertSpace) return;
		const buttonText = buttonRef.current.textContent || "";
		if (needInserted && isTwoCNChar(buttonText)) {
			if (!hasTwoCNChar) setHasTwoCNChar(true);
		} else if (hasTwoCNChar) setHasTwoCNChar(false);
	});
	(0, import_react.useEffect)(() => {
		if (autoFocus && buttonRef.current) buttonRef.current.focus();
	}, []);
	const handleClick = import_react.useCallback((e$2) => {
		if (innerLoading || mergedDisabled) {
			e$2.preventDefault();
			return;
		}
		props.onClick?.("href" in props ? e$2 : e$2);
	}, [
		props.onClick,
		innerLoading,
		mergedDisabled
	]);
	{
		const warning$3 = devUseWarning("Button");
		warning$3(!(typeof icon === "string" && icon.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${icon}\` at https://ant.design/components/icon`);
		warning$3(!(ghost && isUnBorderedButtonVariant(mergedVariant)), "usage", "`link` or `text` button can't be a `ghost` button.");
		warning$3.deprecated(!iconPosition, "iconPosition", "iconPlacement");
	}
	const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
	const sizeClassNameMap$1 = {
		large: "lg",
		small: "sm",
		middle: void 0
	};
	const sizeFullName = useSize_default((ctxSize) => customizeSize ?? compactSize ?? groupSize ?? ctxSize);
	const sizeCls = sizeFullName ? sizeClassNameMap$1[sizeFullName] ?? "" : "";
	const iconType = innerLoading ? "loading" : icon;
	const mergedIconPlacement = iconPlacement ?? iconPosition ?? "start";
	const linkButtonRestProps = omit(rest, ["navigate"]);
	const mergedProps = {
		...props,
		type: mergedType,
		color: mergedColor,
		variant: mergedVariant,
		danger: isDanger,
		shape,
		size: sizeFullName,
		disabled: mergedDisabled,
		loading: innerLoading,
		iconPlacement: mergedIconPlacement
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([_skipSemantic ? void 0 : contextClassNames, classNames], [_skipSemantic ? void 0 : contextStyles, styles], { props: mergedProps });
	const classes = clsx(prefixCls, hashId, cssVarCls, {
		[`${prefixCls}-${shape}`]: shape !== "default" && shape !== "square" && shape,
		[`${prefixCls}-${mergedType}`]: mergedType,
		[`${prefixCls}-dangerous`]: danger,
		[`${prefixCls}-color-${mergedColorText}`]: mergedColorText,
		[`${prefixCls}-variant-${mergedVariant}`]: mergedVariant,
		[`${prefixCls}-${sizeCls}`]: sizeCls,
		[`${prefixCls}-icon-only`]: !children && children !== 0 && !!iconType,
		[`${prefixCls}-background-ghost`]: ghost && !isUnBorderedButtonVariant(mergedVariant),
		[`${prefixCls}-loading`]: innerLoading,
		[`${prefixCls}-two-chinese-chars`]: hasTwoCNChar && mergedInsertSpace && !innerLoading,
		[`${prefixCls}-block`]: block,
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-icon-end`]: mergedIconPlacement === "end"
	}, compactItemClassnames, className, rootClassName, contextClassName, mergedClassNames.root);
	const fullStyle = {
		...mergedStyles.root,
		...contextStyle,
		...style$1
	};
	const iconSharedProps = {
		className: mergedClassNames.icon,
		style: mergedStyles.icon
	};
	/**
	* Extract icon node
	* If there is a custom icon and not in loading state: show custom icon
	*/
	const iconWrapperElement = (child) => /* @__PURE__ */ import_react.createElement(IconWrapper_default, {
		prefixCls,
		...iconSharedProps
	}, child);
	const defaultLoadingIconElement = /* @__PURE__ */ import_react.createElement(DefaultLoadingIcon_default, {
		existIcon: !!icon,
		prefixCls,
		loading: innerLoading,
		mount: isMountRef.current,
		...iconSharedProps
	});
	/**
	* Using if-else statements can improve code readability without affecting future expansion.
	*/
	let iconNode;
	if (icon && !innerLoading) iconNode = iconWrapperElement(icon);
	else if (loading && typeof loading === "object" && loading.icon) iconNode = iconWrapperElement(loading.icon);
	else iconNode = defaultLoadingIconElement;
	const contentNode = isNonNullable_default(children) ? spaceChildren(children, needInserted && mergedInsertSpace, mergedStyles.content, mergedClassNames.content) : null;
	if (linkButtonRestProps.href !== void 0) return /* @__PURE__ */ import_react.createElement("a", {
		...linkButtonRestProps,
		className: clsx(classes, { [`${prefixCls}-disabled`]: mergedDisabled }),
		href: mergedDisabled ? void 0 : linkButtonRestProps.href,
		style: fullStyle,
		onClick: handleClick,
		ref: mergedRef,
		tabIndex: mergedDisabled ? -1 : 0,
		"aria-disabled": mergedDisabled
	}, iconNode, contentNode);
	let buttonNode = /* @__PURE__ */ import_react.createElement("button", {
		...rest,
		type: htmlType,
		className: classes,
		style: fullStyle,
		onClick: handleClick,
		disabled: mergedDisabled,
		ref: mergedRef
	}, iconNode, contentNode, compactItemClassnames && /* @__PURE__ */ import_react.createElement(compact_default$1, { prefixCls }));
	if (!isUnBorderedButtonVariant(mergedVariant)) buttonNode = /* @__PURE__ */ import_react.createElement(wave_default, {
		component: "Button",
		disabled: innerLoading
	}, buttonNode);
	return buttonNode;
});
Button.Group = ButtonGroup_default;
Button.__ANT_BUTTON = true;
Button.displayName = "Button";
var Button_default = Button;

//#endregion
//#region node_modules/antd/es/_util/ActionButton.js
var isThenable = (thing) => {
	return typeof thing?.then === "function";
};
var ActionButton = (props) => {
	const { type: type$2, children, prefixCls, buttonProps, close, autoFocus, emitEvent, isSilent, quitOnNullishReturnValue, actionFn } = props;
	const clickedRef = import_react.useRef(false);
	const buttonRef = import_react.useRef(null);
	const [loading, setLoading] = useSafeState(false);
	const onInternalClose = (...args) => {
		close?.(...args);
	};
	import_react.useEffect(() => {
		let timeoutId = null;
		if (autoFocus) timeoutId = setTimeout(() => {
			buttonRef.current?.focus({ preventScroll: true });
		});
		return () => {
			if (timeoutId) clearTimeout(timeoutId);
		};
	}, [autoFocus]);
	const handlePromiseOnOk = (returnValueOfOnOk) => {
		if (!isThenable(returnValueOfOnOk)) return;
		setLoading(true);
		returnValueOfOnOk.then((...args) => {
			setLoading(false, true);
			onInternalClose.apply(void 0, args);
			clickedRef.current = false;
		}, (e$2) => {
			setLoading(false, true);
			clickedRef.current = false;
			if (isSilent?.()) return;
			return Promise.reject(e$2);
		});
	};
	const onClick = (e$2) => {
		if (clickedRef.current) return;
		clickedRef.current = true;
		if (!actionFn) {
			onInternalClose();
			return;
		}
		let returnValueOfOnOk;
		if (emitEvent) {
			returnValueOfOnOk = actionFn(e$2);
			if (quitOnNullishReturnValue && !isThenable(returnValueOfOnOk)) {
				clickedRef.current = false;
				onInternalClose(e$2);
				return;
			}
		} else if (actionFn.length) {
			returnValueOfOnOk = actionFn(close);
			clickedRef.current = false;
		} else {
			returnValueOfOnOk = actionFn();
			if (!isThenable(returnValueOfOnOk)) {
				onInternalClose();
				return;
			}
		}
		handlePromiseOnOk(returnValueOfOnOk);
	};
	return /* @__PURE__ */ import_react.createElement(Button_default, {
		...convertLegacyProps(type$2),
		onClick,
		loading,
		prefixCls,
		...buttonProps,
		ref: buttonRef
	}, children);
};
var ActionButton_default = ActionButton;

//#endregion
//#region node_modules/antd/es/modal/context.js
const ModalContext = /* @__PURE__ */ import_react.createContext({});
const { Provider: ModalContextProvider } = ModalContext;

//#endregion
//#region node_modules/antd/es/modal/components/ConfirmCancelBtn.js
var ConfirmCancelBtn = () => {
	const { autoFocusButton, cancelButtonProps, cancelTextLocale, isSilent, mergedOkCancel, rootPrefixCls, close, onCancel, onConfirm, onClose } = (0, import_react.useContext)(ModalContext);
	return mergedOkCancel ? /* @__PURE__ */ import_react.createElement(ActionButton_default, {
		isSilent,
		actionFn: onCancel,
		close: (...args) => {
			close?.(...args);
			onConfirm?.(false);
			onClose?.();
		},
		autoFocus: autoFocusButton === "cancel",
		buttonProps: cancelButtonProps,
		prefixCls: `${rootPrefixCls}-btn`
	}, cancelTextLocale) : null;
};
var ConfirmCancelBtn_default = ConfirmCancelBtn;

//#endregion
//#region node_modules/antd/es/modal/components/ConfirmOkBtn.js
var ConfirmOkBtn = () => {
	const { autoFocusButton, close, isSilent, okButtonProps, rootPrefixCls, okTextLocale, okType, onConfirm, onOk, onClose } = (0, import_react.useContext)(ModalContext);
	return /* @__PURE__ */ import_react.createElement(ActionButton_default, {
		isSilent,
		type: okType || "primary",
		actionFn: onOk,
		close: (...args) => {
			close?.(...args);
			onConfirm?.(true);
			onClose?.();
		},
		autoFocus: autoFocusButton === "ok",
		buttonProps: okButtonProps,
		prefixCls: `${rootPrefixCls}-btn`
	}, okTextLocale);
};
var ConfirmOkBtn_default = ConfirmOkBtn;

//#endregion
//#region node_modules/@rc-component/dialog/es/context.js
const RefContext$1 = /* @__PURE__ */ import_react.createContext({});

//#endregion
//#region node_modules/@rc-component/dialog/es/util.js
function getMotionName(prefixCls, transitionName, animationName) {
	let motionName = transitionName;
	if (!motionName && animationName) motionName = `${prefixCls}-${animationName}`;
	return motionName;
}
function getScroll$1(w, top) {
	let ret = w[`page${top ? "Y" : "X"}Offset`];
	const method$1 = `scroll${top ? "Top" : "Left"}`;
	if (typeof ret !== "number") {
		const d = w.document;
		ret = d.documentElement[method$1];
		if (typeof ret !== "number") ret = d.body[method$1];
	}
	return ret;
}
function offset$1(el) {
	const rect = el.getBoundingClientRect();
	const pos = {
		left: rect.left,
		top: rect.top
	};
	const doc = el.ownerDocument;
	const w = doc.defaultView || doc.parentWindow;
	pos.left += getScroll$1(w);
	pos.top += getScroll$1(w, true);
	return pos;
}

//#endregion
//#region node_modules/@rc-component/dialog/es/Dialog/Content/MemoChildren.js
var MemoChildren_default = /* @__PURE__ */ import_react.memo(({ children }) => children, (_, { shouldUpdate }) => !shouldUpdate);

//#endregion
//#region node_modules/@rc-component/dialog/es/Dialog/Content/Panel.js
function _extends$91() {
	_extends$91 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$91.apply(this, arguments);
}
var sentinelStyle$1 = {
	width: 0,
	height: 0,
	overflow: "hidden",
	outline: "none"
};
var entityStyle = { outline: "none" };
var Panel$3 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls, className, style: style$1, title, ariaId, footer, closable, closeIcon, onClose, children, bodyStyle, bodyProps, modalRender, onMouseDown, onMouseUp, holderRef, visible, forceRender, width, height, classNames: modalClassNames, styles: modalStyles } = props;
	const { panel: panelRef } = import_react.useContext(RefContext$1);
	const mergedRef = useComposeRef(holderRef, panelRef);
	const sentinelStartRef = (0, import_react.useRef)(null);
	const sentinelEndRef = (0, import_react.useRef)(null);
	import_react.useImperativeHandle(ref, () => ({
		focus: () => {
			sentinelStartRef.current?.focus({ preventScroll: true });
		},
		changeActive: (next$1) => {
			const { activeElement } = document;
			if (next$1 && activeElement === sentinelEndRef.current) sentinelStartRef.current.focus({ preventScroll: true });
			else if (!next$1 && activeElement === sentinelStartRef.current) sentinelEndRef.current.focus({ preventScroll: true });
		}
	}));
	const contentStyle = {};
	if (width !== void 0) contentStyle.width = width;
	if (height !== void 0) contentStyle.height = height;
	const footerNode = footer ? /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-footer`, modalClassNames?.footer),
		style: { ...modalStyles?.footer }
	}, footer) : null;
	const headerNode = title ? /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-header`, modalClassNames?.header),
		style: { ...modalStyles?.header }
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-title`, modalClassNames?.title),
		id: ariaId,
		style: { ...modalStyles?.title }
	}, title)) : null;
	const closableObj = (0, import_react.useMemo)(() => {
		if (typeof closable === "object" && closable !== null) return closable;
		if (closable) return { closeIcon: closeIcon ?? /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-close-x` }) };
		return {};
	}, [
		closable,
		closeIcon,
		prefixCls
	]);
	const ariaProps = pickAttrs(closableObj, true);
	const closeBtnIsDisabled = typeof closable === "object" && closable.disabled;
	const closerNode = closable ? /* @__PURE__ */ import_react.createElement("button", _extends$91({
		type: "button",
		onClick: onClose,
		"aria-label": "Close"
	}, ariaProps, {
		className: `${prefixCls}-close`,
		disabled: closeBtnIsDisabled
	}), closableObj.closeIcon) : null;
	const content = /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-container`, modalClassNames?.container),
		style: modalStyles?.container
	}, closerNode, headerNode, /* @__PURE__ */ import_react.createElement("div", _extends$91({
		className: clsx(`${prefixCls}-body`, modalClassNames?.body),
		style: {
			...bodyStyle,
			...modalStyles?.body
		}
	}, bodyProps), children), footerNode);
	return /* @__PURE__ */ import_react.createElement("div", {
		key: "dialog-element",
		role: "dialog",
		"aria-labelledby": title ? ariaId : null,
		"aria-modal": "true",
		ref: mergedRef,
		style: {
			...style$1,
			...contentStyle
		},
		className: clsx(prefixCls, className),
		onMouseDown,
		onMouseUp
	}, /* @__PURE__ */ import_react.createElement("div", {
		ref: sentinelStartRef,
		tabIndex: 0,
		style: entityStyle
	}, /* @__PURE__ */ import_react.createElement(MemoChildren_default, { shouldUpdate: visible || forceRender }, modalRender ? modalRender(content) : content)), /* @__PURE__ */ import_react.createElement("div", {
		tabIndex: 0,
		ref: sentinelEndRef,
		style: sentinelStyle$1
	}));
});
Panel$3.displayName = "Panel";
var Panel_default$2 = Panel$3;

//#endregion
//#region node_modules/@rc-component/dialog/es/Dialog/Content/index.js
function _extends$90() {
	_extends$90 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$90.apply(this, arguments);
}
var Content$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls, title, style: style$1, className, visible, forceRender, destroyOnHidden, motionName, ariaId, onVisibleChanged, mousePosition: mousePosition$1 } = props;
	const dialogRef = (0, import_react.useRef)(null);
	const panelRef = (0, import_react.useRef)(null);
	import_react.useImperativeHandle(ref, () => ({
		...panelRef.current,
		inMotion: dialogRef.current.inMotion,
		enableMotion: dialogRef.current.enableMotion
	}));
	const [transformOrigin, setTransformOrigin] = import_react.useState();
	const contentStyle = {};
	if (transformOrigin) contentStyle.transformOrigin = transformOrigin;
	function onPrepare() {
		const elementOffset = offset$1(dialogRef.current.nativeElement);
		setTransformOrigin(mousePosition$1 && (mousePosition$1.x || mousePosition$1.y) ? `${mousePosition$1.x - elementOffset.left}px ${mousePosition$1.y - elementOffset.top}px` : "");
	}
	return /* @__PURE__ */ import_react.createElement(es_default$1, {
		visible,
		onVisibleChanged,
		onAppearPrepare: onPrepare,
		onEnterPrepare: onPrepare,
		forceRender,
		motionName,
		removeOnLeave: destroyOnHidden,
		ref: dialogRef
	}, ({ className: motionClassName, style: motionStyle }, motionRef) => /* @__PURE__ */ import_react.createElement(Panel_default$2, _extends$90({}, props, {
		ref: panelRef,
		title,
		ariaId,
		prefixCls,
		holderRef: motionRef,
		style: {
			...motionStyle,
			...style$1,
			...contentStyle
		},
		className: clsx(className, motionClassName)
	})));
});
Content$1.displayName = "Content";
var Content_default$1 = Content$1;

//#endregion
//#region node_modules/@rc-component/dialog/es/Dialog/Mask.js
function _extends$89() {
	_extends$89 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$89.apply(this, arguments);
}
var Mask$1 = (props) => {
	const { prefixCls, style: style$1, visible, maskProps, motionName, className } = props;
	return /* @__PURE__ */ import_react.createElement(es_default$1, {
		key: "mask",
		visible,
		motionName,
		leavedClassName: `${prefixCls}-mask-hidden`
	}, ({ className: motionClassName, style: motionStyle }, ref) => /* @__PURE__ */ import_react.createElement("div", _extends$89({
		ref,
		style: {
			...motionStyle,
			...style$1
		},
		className: clsx(`${prefixCls}-mask`, motionClassName, className)
	}, maskProps)));
};
var Mask_default$1 = Mask$1;

//#endregion
//#region node_modules/@rc-component/dialog/es/Dialog/index.js
function _extends$88() {
	_extends$88 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$88.apply(this, arguments);
}
var Dialog = (props) => {
	const { prefixCls = "rc-dialog", zIndex, visible = false, keyboard = true, focusTriggerAfterClose = true, wrapStyle, wrapClassName, wrapProps, onClose, afterOpenChange, afterClose, transitionName, animation, closable = true, mask = true, maskTransitionName, maskAnimation, maskClosable = true, maskStyle, maskProps, rootClassName, rootStyle, classNames: modalClassNames, styles: modalStyles } = props;
	[
		"wrapStyle",
		"bodyStyle",
		"maskStyle"
	].forEach((prop) => {
		warning(!(prop in props), `${prop} is deprecated, please use styles instead.`);
	});
	if ("wrapClassName" in props) warning(false, `wrapClassName is deprecated, please use classNames instead.`);
	const lastOutSideActiveElementRef = (0, import_react.useRef)(null);
	const wrapperRef = (0, import_react.useRef)(null);
	const contentRef = (0, import_react.useRef)(null);
	const [animatedVisible, setAnimatedVisible] = import_react.useState(visible);
	const ariaId = useId_default();
	function saveLastOutSideActiveElementRef() {
		if (!contains(wrapperRef.current, document.activeElement)) lastOutSideActiveElementRef.current = document.activeElement;
	}
	function focusDialogContent() {
		if (!contains(wrapperRef.current, document.activeElement)) contentRef.current?.focus();
	}
	function doClose() {
		setAnimatedVisible(false);
		if (mask && lastOutSideActiveElementRef.current && focusTriggerAfterClose) {
			try {
				lastOutSideActiveElementRef.current.focus({ preventScroll: true });
			} catch (e$2) {}
			lastOutSideActiveElementRef.current = null;
		}
		if (animatedVisible) afterClose?.();
	}
	function onDialogVisibleChanged(newVisible) {
		if (newVisible) focusDialogContent();
		else doClose();
		afterOpenChange?.(newVisible);
	}
	function onInternalClose(e$2) {
		onClose?.(e$2);
	}
	const contentClickRef = (0, import_react.useRef)(false);
	const contentTimeoutRef = (0, import_react.useRef)(null);
	const onContentMouseDown = () => {
		clearTimeout(contentTimeoutRef.current);
		contentClickRef.current = true;
	};
	const onContentMouseUp = () => {
		contentTimeoutRef.current = setTimeout(() => {
			contentClickRef.current = false;
		});
	};
	let onWrapperClick = null;
	if (maskClosable) onWrapperClick = (e$2) => {
		if (contentClickRef.current) contentClickRef.current = false;
		else if (wrapperRef.current === e$2.target) onInternalClose(e$2);
	};
	function onWrapperKeyDown(e$2) {
		if (keyboard && e$2.keyCode === KeyCode_default.ESC) {
			e$2.stopPropagation();
			onInternalClose(e$2);
			return;
		}
		if (visible && e$2.keyCode === KeyCode_default.TAB) contentRef.current.changeActive(!e$2.shiftKey);
	}
	(0, import_react.useEffect)(() => {
		if (visible) {
			setAnimatedVisible(true);
			saveLastOutSideActiveElementRef();
		} else if (animatedVisible && contentRef.current.enableMotion() && !contentRef.current.inMotion()) doClose();
	}, [visible]);
	(0, import_react.useEffect)(() => () => {
		clearTimeout(contentTimeoutRef.current);
	}, []);
	const mergedStyle = {
		zIndex,
		...wrapStyle,
		...modalStyles?.wrapper,
		display: !animatedVisible ? "none" : null
	};
	return /* @__PURE__ */ import_react.createElement("div", _extends$88({
		className: clsx(`${prefixCls}-root`, rootClassName),
		style: rootStyle
	}, pickAttrs(props, { data: true })), /* @__PURE__ */ import_react.createElement(Mask_default$1, {
		prefixCls,
		visible: mask && visible,
		motionName: getMotionName(prefixCls, maskTransitionName, maskAnimation),
		style: {
			zIndex,
			...maskStyle,
			...modalStyles?.mask
		},
		maskProps,
		className: modalClassNames?.mask
	}), /* @__PURE__ */ import_react.createElement("div", _extends$88({
		tabIndex: -1,
		onKeyDown: onWrapperKeyDown,
		className: clsx(`${prefixCls}-wrap`, wrapClassName, modalClassNames?.wrapper),
		ref: wrapperRef,
		onClick: onWrapperClick,
		style: mergedStyle
	}, wrapProps), /* @__PURE__ */ import_react.createElement(Content_default$1, _extends$88({}, props, {
		onMouseDown: onContentMouseDown,
		onMouseUp: onContentMouseUp,
		ref: contentRef,
		closable,
		ariaId,
		prefixCls,
		visible: visible && animatedVisible,
		onClose: onInternalClose,
		onVisibleChanged: onDialogVisibleChanged,
		motionName: getMotionName(prefixCls, transitionName, animation)
	}))));
};
var Dialog_default = Dialog;

//#endregion
//#region node_modules/@rc-component/dialog/es/DialogWrap.js
function _extends$87() {
	_extends$87 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$87.apply(this, arguments);
}
var DialogWrap = (props) => {
	const { visible, getContainer, forceRender, destroyOnHidden = false, afterClose, closable, panelRef } = props;
	const [animatedVisible, setAnimatedVisible] = import_react.useState(visible);
	const refContext = import_react.useMemo(() => ({ panel: panelRef }), [panelRef]);
	import_react.useEffect(() => {
		if (visible) setAnimatedVisible(true);
	}, [visible]);
	if (!forceRender && destroyOnHidden && !animatedVisible) return null;
	return /* @__PURE__ */ import_react.createElement(RefContext$1.Provider, { value: refContext }, /* @__PURE__ */ import_react.createElement(es_default$7, {
		open: visible || forceRender || animatedVisible,
		autoDestroy: false,
		getContainer,
		autoLock: visible || animatedVisible
	}, /* @__PURE__ */ import_react.createElement(Dialog_default, _extends$87({}, props, {
		destroyOnHidden,
		afterClose: () => {
			const { afterClose: closableAfterClose } = (closable && typeof closable === "object" ? closable : {}) || {};
			closableAfterClose?.();
			afterClose?.();
			setAnimatedVisible(false);
		}
	}))));
};
DialogWrap.displayName = "Dialog";
var DialogWrap_default = DialogWrap;

//#endregion
//#region node_modules/@rc-component/dialog/es/index.js
var es_default$33 = DialogWrap_default;

//#endregion
//#region node_modules/@rc-component/form/es/FieldContext.js
const HOOK_MARK = "RC_FORM_INTERNAL_HOOKS";
var warningFunc = () => {
	warning_default$1(false, "Can not find FormContext. Please make sure you wrap Field under Form.");
};
var Context = /* @__PURE__ */ import_react.createContext({
	getFieldValue: warningFunc,
	getFieldsValue: warningFunc,
	getFieldError: warningFunc,
	getFieldWarning: warningFunc,
	getFieldsError: warningFunc,
	isFieldsTouched: warningFunc,
	isFieldTouched: warningFunc,
	isFieldValidating: warningFunc,
	isFieldsValidating: warningFunc,
	resetFields: warningFunc,
	setFields: warningFunc,
	setFieldValue: warningFunc,
	setFieldsValue: warningFunc,
	validateFields: warningFunc,
	submit: warningFunc,
	getInternalHooks: () => {
		warningFunc();
		return {
			dispatch: warningFunc,
			initEntityValue: warningFunc,
			registerField: warningFunc,
			useSubscribe: warningFunc,
			setInitialValues: warningFunc,
			destroyForm: warningFunc,
			setCallbacks: warningFunc,
			registerWatch: warningFunc,
			getFields: warningFunc,
			setValidateMessages: warningFunc,
			setPreserve: warningFunc,
			getInitialValue: warningFunc
		};
	}
});
var FieldContext_default = Context;

//#endregion
//#region node_modules/@rc-component/form/es/ListContext.js
var ListContext$1 = /* @__PURE__ */ import_react.createContext(null);
var ListContext_default = ListContext$1;

//#endregion
//#region node_modules/@rc-component/form/es/utils/typeUtil.js
function toArray$7(value) {
	if (value === void 0 || value === null) return [];
	return Array.isArray(value) ? value : [value];
}
function isFormInstance(form) {
	return form && !!form._init;
}

//#endregion
//#region node_modules/@rc-component/async-validator/es/messages.js
function newMessages() {
	return {
		default: "Validation error on field %s",
		required: "%s is required",
		enum: "%s must be one of %s",
		whitespace: "%s cannot be empty",
		date: {
			format: "%s date %s is invalid for format %s",
			parse: "%s date could not be parsed, %s is invalid ",
			invalid: "%s date %s is invalid"
		},
		types: {
			string: "%s is not a %s",
			method: "%s is not a %s (function)",
			array: "%s is not an %s",
			object: "%s is not an %s",
			number: "%s is not a %s",
			date: "%s is not a %s",
			boolean: "%s is not a %s",
			integer: "%s is not an %s",
			float: "%s is not a %s",
			regexp: "%s is not a valid %s",
			email: "%s is not a valid %s",
			tel: "%s is not a valid %s",
			url: "%s is not a valid %s",
			hex: "%s is not a valid %s"
		},
		string: {
			len: "%s must be exactly %s characters",
			min: "%s must be at least %s characters",
			max: "%s cannot be longer than %s characters",
			range: "%s must be between %s and %s characters"
		},
		number: {
			len: "%s must equal %s",
			min: "%s cannot be less than %s",
			max: "%s cannot be greater than %s",
			range: "%s must be between %s and %s"
		},
		array: {
			len: "%s must be exactly %s in length",
			min: "%s cannot be less than %s in length",
			max: "%s cannot be greater than %s in length",
			range: "%s must be between %s and %s in length"
		},
		pattern: { mismatch: "%s value %s does not match pattern %s" },
		clone: function clone() {
			var cloned = JSON.parse(JSON.stringify(this));
			cloned.clone = this.clone;
			return cloned;
		}
	};
}
var messages = newMessages();

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
function _isNativeFunction(t$1) {
	try {
		return -1 !== Function.toString.call(t$1).indexOf("[native code]");
	} catch (n$1) {
		return "function" == typeof t$1;
	}
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/construct.js
function _construct(t$1, e$2, r$1) {
	if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
	var o$2 = [null];
	o$2.push.apply(o$2, e$2);
	var p = new (t$1.bind.apply(t$1, o$2))();
	return r$1 && _setPrototypeOf(p, r$1.prototype), p;
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js
function _wrapNativeSuper(t$1) {
	var r$1 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
	return _wrapNativeSuper = function _wrapNativeSuper$1(t$2) {
		if (null === t$2 || !_isNativeFunction(t$2)) return t$2;
		if ("function" != typeof t$2) throw new TypeError("Super expression must either be null or a function");
		if (void 0 !== r$1) {
			if (r$1.has(t$2)) return r$1.get(t$2);
			r$1.set(t$2, Wrapper$2);
		}
		function Wrapper$2() {
			return _construct(t$2, arguments, _getPrototypeOf(this).constructor);
		}
		return Wrapper$2.prototype = Object.create(t$2.prototype, { constructor: {
			value: Wrapper$2,
			enumerable: !1,
			writable: !0,
			configurable: !0
		} }), _setPrototypeOf(Wrapper$2, t$2);
	}, _wrapNativeSuper(t$1);
}

//#endregion
//#region node_modules/@rc-component/async-validator/es/util.js
var formatRegExp = /%[sdj%]/g;
var warning$1 = function warning$3() {};
if (typeof process !== "undefined" && process.env && typeof window !== "undefined" && typeof document !== "undefined") warning$1 = function warning$3(type$2, errors) {
	if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
		if (errors.every(function(e$2) {
			return typeof e$2 === "string";
		})) console.warn(type$2, errors);
	}
};
function convertFieldsError(errors) {
	if (!errors || !errors.length) return null;
	var fields = {};
	errors.forEach(function(error) {
		var field = error.field;
		fields[field] = fields[field] || [];
		fields[field].push(error);
	});
	return fields;
}
function format(template) {
	for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
	var i = 0;
	var len = args.length;
	if (typeof template === "function") return template.apply(null, args);
	if (typeof template === "string") return template.replace(formatRegExp, function(x) {
		if (x === "%%") return "%";
		if (i >= len) return x;
		switch (x) {
			case "%s": return String(args[i++]);
			case "%d": return Number(args[i++]);
			case "%j":
				try {
					return JSON.stringify(args[i++]);
				} catch (_) {
					return "[Circular]";
				}
				break;
			default: return x;
		}
	});
	return template;
}
function isNativeStringType(type$2) {
	return type$2 === "string" || type$2 === "url" || type$2 === "hex" || type$2 === "email" || type$2 === "date" || type$2 === "pattern" || type$2 === "tel";
}
function isEmptyValue(value, type$2) {
	if (value === void 0 || value === null) return true;
	if (type$2 === "array" && Array.isArray(value) && !value.length) return true;
	if (isNativeStringType(type$2) && typeof value === "string" && !value) return true;
	return false;
}
function asyncParallelArray(arr, func, callback) {
	var results = [];
	var total = 0;
	var arrLength = arr.length;
	function count(errors) {
		results.push.apply(results, _toConsumableArray(errors || []));
		total++;
		if (total === arrLength) callback(results);
	}
	arr.forEach(function(a) {
		func(a, count);
	});
}
function asyncSerialArray(arr, func, callback) {
	var index$1 = 0;
	var arrLength = arr.length;
	function next$1(errors) {
		if (errors && errors.length) {
			callback(errors);
			return;
		}
		var original = index$1;
		index$1 = index$1 + 1;
		if (original < arrLength) func(arr[original], next$1);
		else callback([]);
	}
	next$1([]);
}
function flattenObjArr(objArr) {
	var ret = [];
	Object.keys(objArr).forEach(function(k) {
		ret.push.apply(ret, _toConsumableArray(objArr[k] || []));
	});
	return ret;
}
var AsyncValidationError = /* @__PURE__ */ function(_Error) {
	_inherits(AsyncValidationError$1, _Error);
	var _super = _createSuper(AsyncValidationError$1);
	function AsyncValidationError$1(errors, fields) {
		var _this;
		_classCallCheck(this, AsyncValidationError$1);
		_this = _super.call(this, "Async Validation Error");
		_defineProperty(_assertThisInitialized(_this), "errors", void 0);
		_defineProperty(_assertThisInitialized(_this), "fields", void 0);
		_this.errors = errors;
		_this.fields = fields;
		return _this;
	}
	return _createClass(AsyncValidationError$1);
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function asyncMap(objArr, option, func, callback, source) {
	if (option.first) {
		var _pending = new Promise(function(resolve, reject) {
			asyncSerialArray(flattenObjArr(objArr), func, function next$1(errors) {
				callback(errors);
				return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
			});
		});
		_pending.catch(function(e$2) {
			return e$2;
		});
		return _pending;
	}
	var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
	var objArrKeys = Object.keys(objArr);
	var objArrLength = objArrKeys.length;
	var total = 0;
	var results = [];
	var pending = new Promise(function(resolve, reject) {
		var next$1 = function next$2(errors) {
			results.push.apply(results, errors);
			total++;
			if (total === objArrLength) {
				callback(results);
				return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
			}
		};
		if (!objArrKeys.length) {
			callback(results);
			resolve(source);
		}
		objArrKeys.forEach(function(key) {
			var arr = objArr[key];
			if (firstFields.indexOf(key) !== -1) asyncSerialArray(arr, func, next$1);
			else asyncParallelArray(arr, func, next$1);
		});
	});
	pending.catch(function(e$2) {
		return e$2;
	});
	return pending;
}
function isErrorObj(obj) {
	return !!(obj && obj.message !== void 0);
}
function getValue(value, path$1) {
	var v = value;
	for (var i = 0; i < path$1.length; i++) {
		if (v == void 0) return v;
		v = v[path$1[i]];
	}
	return v;
}
function complementError(rule, source) {
	return function(oe) {
		var fieldValue;
		if (rule.fullFields) fieldValue = getValue(source, rule.fullFields);
		else fieldValue = source[oe.field || rule.fullField];
		if (isErrorObj(oe)) {
			oe.field = oe.field || rule.fullField;
			oe.fieldValue = fieldValue;
			return oe;
		}
		return {
			message: typeof oe === "function" ? oe() : oe,
			fieldValue,
			field: oe.field || rule.fullField
		};
	};
}
function deepMerge(target, source) {
	if (source) {
		for (var s in source) if (source.hasOwnProperty(s)) {
			var value = source[s];
			if (_typeof(value) === "object" && _typeof(target[s]) === "object") target[s] = _objectSpread2(_objectSpread2({}, target[s]), value);
			else target[s] = value;
		}
	}
	return target;
}

//#endregion
//#region node_modules/@rc-component/async-validator/es/rule/enum.js
var ENUM$1 = "enum";
var enumerable$1 = function enumerable$2(rule, value, source, errors, options) {
	rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
	if (rule[ENUM$1].indexOf(value) === -1) errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
};
var enum_default$1 = enumerable$1;

//#endregion
//#region node_modules/@rc-component/async-validator/es/rule/pattern.js
var pattern$2 = function pattern$3(rule, value, source, errors, options) {
	if (rule.pattern) {
		if (rule.pattern instanceof RegExp) {
			rule.pattern.lastIndex = 0;
			if (!rule.pattern.test(value)) errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
		} else if (typeof rule.pattern === "string") {
			if (!new RegExp(rule.pattern).test(value)) errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
		}
	}
};
var pattern_default$1 = pattern$2;

//#endregion
//#region node_modules/@rc-component/async-validator/es/rule/range.js
var range = function range$1(rule, value, source, errors, options) {
	var len = typeof rule.len === "number";
	var min = typeof rule.min === "number";
	var max = typeof rule.max === "number";
	var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
	var val = value;
	var key = null;
	var num = typeof value === "number";
	var str = typeof value === "string";
	var arr = Array.isArray(value);
	if (num) key = "number";
	else if (str) key = "string";
	else if (arr) key = "array";
	if (!key) return false;
	if (arr) val = value.length;
	if (str) val = value.replace(spRegexp, "_").length;
	if (len) {
		if (val !== rule.len) errors.push(format(options.messages[key].len, rule.fullField, rule.len));
	} else if (min && !max && val < rule.min) errors.push(format(options.messages[key].min, rule.fullField, rule.min));
	else if (max && !min && val > rule.max) errors.push(format(options.messages[key].max, rule.fullField, rule.max));
	else if (min && max && (val < rule.min || val > rule.max)) errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
};
var range_default = range;

//#endregion
//#region node_modules/@rc-component/async-validator/es/rule/required.js
var required$1 = function required$2(rule, value, source, errors, options, type$2) {
	if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type$2 || rule.type))) errors.push(format(options.messages.required, rule.fullField));
};
var required_default$1 = required$1;

//#endregion
//#region node_modules/@rc-component/async-validator/es/rule/url.js
var urlReg;
var url_default = (function() {
	if (urlReg) return urlReg;
	var word = "[a-fA-F\\d:]";
	var b = function b$1(options) {
		return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=".concat(word, ")|(?<=").concat(word, ")(?=\\s|$))") : "";
	};
	var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
	var v6seg = "[a-fA-F\\d]{1,4}";
	var v6List = [
		"(?:".concat(v6seg, ":){7}(?:").concat(v6seg, "|:)"),
		"(?:".concat(v6seg, ":){6}(?:").concat(v4, "|:").concat(v6seg, "|:)"),
		"(?:".concat(v6seg, ":){5}(?::").concat(v4, "|(?::").concat(v6seg, "){1,2}|:)"),
		"(?:".concat(v6seg, ":){4}(?:(?::").concat(v6seg, "){0,1}:").concat(v4, "|(?::").concat(v6seg, "){1,3}|:)"),
		"(?:".concat(v6seg, ":){3}(?:(?::").concat(v6seg, "){0,2}:").concat(v4, "|(?::").concat(v6seg, "){1,4}|:)"),
		"(?:".concat(v6seg, ":){2}(?:(?::").concat(v6seg, "){0,3}:").concat(v4, "|(?::").concat(v6seg, "){1,5}|:)"),
		"(?:".concat(v6seg, ":){1}(?:(?::").concat(v6seg, "){0,4}:").concat(v4, "|(?::").concat(v6seg, "){1,6}|:)"),
		"(?::(?:(?::".concat(v6seg, "){0,5}:").concat(v4, "|(?::").concat(v6seg, "){1,7}|:))")
	];
	var v6 = "(?:".concat(v6List.join("|"), ")").concat("(?:%[0-9a-zA-Z]{1,})?");
	var v46Exact = new RegExp("(?:^".concat(v4, "$)|(?:^").concat(v6, "$)"));
	var v4exact = new RegExp("^".concat(v4, "$"));
	var v6exact = new RegExp("^".concat(v6, "$"));
	var ip = function ip$1(options) {
		return options && options.exact ? v46Exact : new RegExp("(?:".concat(b(options)).concat(v4).concat(b(options), ")|(?:").concat(b(options)).concat(v6).concat(b(options), ")"), "g");
	};
	ip.v4 = function(options) {
		return options && options.exact ? v4exact : new RegExp("".concat(b(options)).concat(v4).concat(b(options)), "g");
	};
	ip.v6 = function(options) {
		return options && options.exact ? v6exact : new RegExp("".concat(b(options)).concat(v6).concat(b(options)), "g");
	};
	var protocol = "(?:(?:[a-z]+:)?//)";
	var auth = "(?:\\S+(?::\\S*)?@)?";
	var ipv4 = ip.v4().source;
	var ipv6 = ip.v6().source;
	var regex = "(?:".concat(protocol, "|www\\.)").concat(auth, "(?:localhost|").concat(ipv4, "|").concat(ipv6, "|").concat("(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)").concat("(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*").concat("(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", ")").concat("(?::\\d{2,5})?").concat("(?:[/?#][^\\s\"]*)?");
	urlReg = new RegExp("(?:^".concat(regex, "$)"), "i");
	return urlReg;
});

//#endregion
//#region node_modules/@rc-component/async-validator/es/rule/type.js
var pattern$1 = {
	email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
	tel: /^(\+[0-9]{1,3}[-\s\u2011]?)?(\([0-9]{1,4}\)[-\s\u2011]?)?([0-9]+[-\s\u2011]?)*[0-9]+$/,
	hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
	integer: function integer$1(value) {
		return types.number(value) && parseInt(value, 10) === value;
	},
	float: function float(value) {
		return types.number(value) && !types.integer(value);
	},
	array: function array$1(value) {
		return Array.isArray(value);
	},
	regexp: function regexp$3(value) {
		if (value instanceof RegExp) return true;
		try {
			return true;
		} catch (e$2) {
			return false;
		}
	},
	date: function date$1(value) {
		return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
	},
	number: function number$1(value) {
		if (isNaN(value)) return false;
		return typeof value === "number";
	},
	object: function object$1(value) {
		return _typeof(value) === "object" && !types.array(value);
	},
	method: function method$1(value) {
		return typeof value === "function";
	},
	email: function email(value) {
		return typeof value === "string" && value.length <= 320 && !!value.match(pattern$1.email);
	},
	tel: function tel(value) {
		return typeof value === "string" && value.length <= 32 && !!value.match(pattern$1.tel);
	},
	url: function url(value) {
		return typeof value === "string" && value.length <= 2048 && !!value.match(url_default());
	},
	hex: function hex(value) {
		return typeof value === "string" && !!value.match(pattern$1.hex);
	}
};
var type$1 = function type$2(rule, value, source, errors, options) {
	if (rule.required && value === void 0) {
		required_default$1(rule, value, source, errors, options);
		return;
	}
	var custom = [
		"integer",
		"float",
		"array",
		"regexp",
		"object",
		"method",
		"email",
		"tel",
		"number",
		"date",
		"url",
		"hex"
	];
	var ruleType = rule.type;
	if (custom.indexOf(ruleType) > -1) {
		if (!types[ruleType](value)) errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
	} else if (ruleType && _typeof(value) !== rule.type) errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
};
var type_default$1 = type$1;

//#endregion
//#region node_modules/@rc-component/async-validator/es/rule/whitespace.js
/**
*  Rule for validating whitespace.
*
*  @param rule The validation rule.
*  @param value The value of the field on the source object.
*  @param source The source object being validated.
*  @param errors An array of errors that this rule may add
*  validation errors to.
*  @param options The validation options.
*  @param options.messages The validation messages.
*/
var whitespace = function whitespace$2(rule, value, source, errors, options) {
	if (/^\s+$/.test(value) || value === "") errors.push(format(options.messages.whitespace, rule.fullField));
};
var whitespace_default = whitespace;

//#endregion
//#region node_modules/@rc-component/async-validator/es/rule/index.js
var rule_default = {
	required: required_default$1,
	whitespace: whitespace_default,
	type: type_default$1,
	range: range_default,
	enum: enum_default$1,
	pattern: pattern_default$1
};

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/any.js
var any = function any$1(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (isEmptyValue(value) && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options);
	}
	callback(errors);
};
var any_default = any;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/array.js
var array = function array$1(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if ((value === void 0 || value === null) && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options, "array");
		if (value !== void 0 && value !== null) {
			rule_default.type(rule, value, source, errors, options);
			rule_default.range(rule, value, source, errors, options);
		}
	}
	callback(errors);
};
var array_default = array;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/boolean.js
var boolean = function boolean$1(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (isEmptyValue(value) && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options);
		if (value !== void 0) rule_default.type(rule, value, source, errors, options);
	}
	callback(errors);
};
var boolean_default = boolean;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/date.js
var date = function date$1(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (isEmptyValue(value, "date") && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options);
		if (!isEmptyValue(value, "date")) {
			var dateObject;
			if (value instanceof Date) dateObject = value;
			else dateObject = new Date(value);
			rule_default.type(rule, dateObject, source, errors, options);
			if (dateObject) rule_default.range(rule, dateObject.getTime(), source, errors, options);
		}
	}
	callback(errors);
};
var date_default = date;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/enum.js
var ENUM = "enum";
var enumerable = function enumerable$2(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (isEmptyValue(value) && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options);
		if (value !== void 0) rule_default[ENUM](rule, value, source, errors, options);
	}
	callback(errors);
};
var enum_default = enumerable;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/float.js
var floatFn = function floatFn$1(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (isEmptyValue(value) && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options);
		if (value !== void 0) {
			rule_default.type(rule, value, source, errors, options);
			rule_default.range(rule, value, source, errors, options);
		}
	}
	callback(errors);
};
var float_default = floatFn;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/integer.js
var integer = function integer$1(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (isEmptyValue(value) && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options);
		if (value !== void 0) {
			rule_default.type(rule, value, source, errors, options);
			rule_default.range(rule, value, source, errors, options);
		}
	}
	callback(errors);
};
var integer_default = integer;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/method.js
var method = function method$1(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (isEmptyValue(value) && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options);
		if (value !== void 0) rule_default.type(rule, value, source, errors, options);
	}
	callback(errors);
};
var method_default = method;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/number.js
var number = function number$1(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (value === "") value = void 0;
		if (isEmptyValue(value) && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options);
		if (value !== void 0) {
			rule_default.type(rule, value, source, errors, options);
			rule_default.range(rule, value, source, errors, options);
		}
	}
	callback(errors);
};
var number_default = number;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/object.js
var object = function object$1(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (isEmptyValue(value) && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options);
		if (value !== void 0) rule_default.type(rule, value, source, errors, options);
	}
	callback(errors);
};
var object_default = object;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/pattern.js
var pattern = function pattern$3(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (isEmptyValue(value, "string") && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options);
		if (!isEmptyValue(value, "string")) rule_default.pattern(rule, value, source, errors, options);
	}
	callback(errors);
};
var pattern_default = pattern;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/regexp.js
var regexp = function regexp$3(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (isEmptyValue(value) && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options);
		if (!isEmptyValue(value)) rule_default.type(rule, value, source, errors, options);
	}
	callback(errors);
};
var regexp_default = regexp;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/required.js
var required = function required$2(rule, value, callback, source, options) {
	var errors = [];
	var type$2 = Array.isArray(value) ? "array" : _typeof(value);
	rule_default.required(rule, value, source, errors, options, type$2);
	callback(errors);
};
var required_default = required;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/string.js
var string = function string$1(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (isEmptyValue(value, "string") && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options, "string");
		if (!isEmptyValue(value, "string")) {
			rule_default.type(rule, value, source, errors, options);
			rule_default.range(rule, value, source, errors, options);
			rule_default.pattern(rule, value, source, errors, options);
			if (rule.whitespace === true) rule_default.whitespace(rule, value, source, errors, options);
		}
	}
	callback(errors);
};
var string_default = string;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/type.js
var type = function type$2(rule, value, callback, source, options) {
	var ruleType = rule.type;
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (isEmptyValue(value, ruleType) && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options, ruleType);
		if (!isEmptyValue(value, ruleType)) rule_default.type(rule, value, source, errors, options);
	}
	callback(errors);
};
var type_default = type;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/index.js
var validator_default = {
	string: string_default,
	method: method_default,
	number: number_default,
	boolean: boolean_default,
	regexp: regexp_default,
	integer: integer_default,
	float: float_default,
	array: array_default,
	object: object_default,
	enum: enum_default,
	pattern: pattern_default,
	date: date_default,
	url: type_default,
	hex: type_default,
	email: type_default,
	tel: type_default,
	required: required_default,
	any: any_default
};

//#endregion
//#region node_modules/@rc-component/async-validator/es/index.js
/**
*  Encapsulates a validation schema.
*
*  @param descriptor An object declaring validation rules
*  for this schema.
*/
var Schema = /* @__PURE__ */ function() {
	function Schema$1(descriptor) {
		_classCallCheck(this, Schema$1);
		_defineProperty(this, "rules", null);
		_defineProperty(this, "_messages", messages);
		this.define(descriptor);
	}
	_createClass(Schema$1, [
		{
			key: "define",
			value: function define$1(rules) {
				var _this = this;
				if (!rules) throw new Error("Cannot configure a schema with no rules");
				if (_typeof(rules) !== "object" || Array.isArray(rules)) throw new Error("Rules must be an object");
				this.rules = {};
				Object.keys(rules).forEach(function(name) {
					var item = rules[name];
					_this.rules[name] = Array.isArray(item) ? item : [item];
				});
			}
		},
		{
			key: "messages",
			value: function messages$1(_messages) {
				if (_messages) this._messages = deepMerge(newMessages(), _messages);
				return this._messages;
			}
		},
		{
			key: "validate",
			value: function validate(source_) {
				var _this2 = this;
				var o$2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
				var oc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {};
				var source = source_;
				var options = o$2;
				var callback = oc;
				if (typeof options === "function") {
					callback = options;
					options = {};
				}
				if (!this.rules || Object.keys(this.rules).length === 0) {
					if (callback) callback(null, source);
					return Promise.resolve(source);
				}
				function complete(results) {
					var errors = [];
					var fields = {};
					function add(e$2) {
						if (Array.isArray(e$2)) {
							var _errors;
							errors = (_errors = errors).concat.apply(_errors, _toConsumableArray(e$2));
						} else errors.push(e$2);
					}
					for (var i = 0; i < results.length; i++) add(results[i]);
					if (!errors.length) callback(null, source);
					else {
						fields = convertFieldsError(errors);
						callback(errors, fields);
					}
				}
				if (options.messages) {
					var messages$1 = this.messages();
					if (messages$1 === messages) messages$1 = newMessages();
					deepMerge(messages$1, options.messages);
					options.messages = messages$1;
				} else options.messages = this.messages();
				var series = {};
				(options.keys || Object.keys(this.rules)).forEach(function(z) {
					var arr = _this2.rules[z];
					var value = source[z];
					arr.forEach(function(r$1) {
						var rule = r$1;
						if (typeof rule.transform === "function") {
							if (source === source_) source = _objectSpread2({}, source);
							value = source[z] = rule.transform(value);
							if (value !== void 0 && value !== null) rule.type = rule.type || (Array.isArray(value) ? "array" : _typeof(value));
						}
						if (typeof rule === "function") rule = { validator: rule };
						else rule = _objectSpread2({}, rule);
						rule.validator = _this2.getValidationMethod(rule);
						if (!rule.validator) return;
						rule.field = z;
						rule.fullField = rule.fullField || z;
						rule.type = _this2.getType(rule);
						series[z] = series[z] || [];
						series[z].push({
							rule,
							value,
							source,
							field: z
						});
					});
				});
				var errorFields = {};
				return asyncMap(series, options, function(data, doIt) {
					var rule = data.rule;
					var deep = (rule.type === "object" || rule.type === "array") && (_typeof(rule.fields) === "object" || _typeof(rule.defaultField) === "object");
					deep = deep && (rule.required || !rule.required && data.value);
					rule.field = data.field;
					function addFullField(key, schema) {
						return _objectSpread2(_objectSpread2({}, schema), {}, {
							fullField: "".concat(rule.fullField, ".").concat(key),
							fullFields: rule.fullFields ? [].concat(_toConsumableArray(rule.fullFields), [key]) : [key]
						});
					}
					function cb() {
						var e$2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
						var errorList = Array.isArray(e$2) ? e$2 : [e$2];
						if (!options.suppressWarning && errorList.length) Schema$1.warning("async-validator:", errorList);
						if (errorList.length && rule.message !== void 0 && rule.message !== null) errorList = [].concat(rule.message);
						var filledErrors = errorList.map(complementError(rule, source));
						if (options.first && filledErrors.length) {
							errorFields[rule.field] = 1;
							return doIt(filledErrors);
						}
						if (!deep) doIt(filledErrors);
						else {
							if (rule.required && !data.value) {
								if (rule.message !== void 0) filledErrors = [].concat(rule.message).map(complementError(rule, source));
								else if (options.error) filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
								return doIt(filledErrors);
							}
							var fieldsSchema = {};
							if (rule.defaultField) Object.keys(data.value).map(function(key) {
								fieldsSchema[key] = rule.defaultField;
							});
							fieldsSchema = _objectSpread2(_objectSpread2({}, fieldsSchema), data.rule.fields);
							var paredFieldsSchema = {};
							Object.keys(fieldsSchema).forEach(function(field) {
								var fieldSchema = fieldsSchema[field];
								paredFieldsSchema[field] = (Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema]).map(addFullField.bind(null, field));
							});
							var schema = new Schema$1(paredFieldsSchema);
							schema.messages(options.messages);
							if (data.rule.options) {
								data.rule.options.messages = options.messages;
								data.rule.options.error = options.error;
							}
							schema.validate(data.value, data.rule.options || options, function(errs) {
								var finalErrors = [];
								if (filledErrors && filledErrors.length) finalErrors.push.apply(finalErrors, _toConsumableArray(filledErrors));
								if (errs && errs.length) finalErrors.push.apply(finalErrors, _toConsumableArray(errs));
								doIt(finalErrors.length ? finalErrors : null);
							});
						}
					}
					var res;
					if (rule.asyncValidator) res = rule.asyncValidator(rule, data.value, cb, data.source, options);
					else if (rule.validator) {
						try {
							res = rule.validator(rule, data.value, cb, data.source, options);
						} catch (error) {
							var _console$error, _console;
							(_console$error = (_console = console).error) === null || _console$error === void 0 || _console$error.call(_console, error);
							if (!options.suppressValidatorError) setTimeout(function() {
								throw error;
							}, 0);
							cb(error.message);
						}
						if (res === true) cb();
						else if (res === false) cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || "".concat(rule.fullField || rule.field, " fails"));
						else if (res instanceof Array) cb(res);
						else if (res instanceof Error) cb(res.message);
					}
					if (res && res.then) res.then(function() {
						return cb();
					}, function(e$2) {
						return cb(e$2);
					});
				}, function(results) {
					complete(results);
				}, source);
			}
		},
		{
			key: "getType",
			value: function getType(rule) {
				if (rule.type === void 0 && rule.pattern instanceof RegExp) rule.type = "pattern";
				if (typeof rule.validator !== "function" && rule.type && !validator_default.hasOwnProperty(rule.type)) throw new Error(format("Unknown rule type %s", rule.type));
				return rule.type || "string";
			}
		},
		{
			key: "getValidationMethod",
			value: function getValidationMethod(rule) {
				if (typeof rule.validator === "function") return rule.validator;
				var keys$1 = Object.keys(rule);
				var messageIndex = keys$1.indexOf("message");
				if (messageIndex !== -1) keys$1.splice(messageIndex, 1);
				if (keys$1.length === 1 && keys$1[0] === "required") return validator_default.required;
				return validator_default[this.getType(rule)] || void 0;
			}
		}
	]);
	return Schema$1;
}();
_defineProperty(Schema, "register", function register(type$2, validator) {
	if (typeof validator !== "function") throw new Error("Cannot register a validator by type, validator is not a function");
	validator_default[type$2] = validator;
});
_defineProperty(Schema, "warning", warning$1);
_defineProperty(Schema, "messages", messages);
_defineProperty(Schema, "validators", validator_default);
var es_default$34 = Schema;

//#endregion
//#region node_modules/@rc-component/form/es/utils/messages.js
var typeTemplate = "'${name}' is not a valid ${type}";
const defaultValidateMessages = {
	default: "Validation error on field '${name}'",
	required: "'${name}' is required",
	enum: "'${name}' must be one of [${enum}]",
	whitespace: "'${name}' cannot be empty",
	date: {
		format: "'${name}' is invalid for format date",
		parse: "'${name}' could not be parsed as date",
		invalid: "'${name}' is invalid date"
	},
	types: {
		string: typeTemplate,
		method: typeTemplate,
		array: typeTemplate,
		object: typeTemplate,
		number: typeTemplate,
		date: typeTemplate,
		boolean: typeTemplate,
		integer: typeTemplate,
		float: typeTemplate,
		regexp: typeTemplate,
		email: typeTemplate,
		tel: typeTemplate,
		url: typeTemplate,
		hex: typeTemplate
	},
	string: {
		len: "'${name}' must be exactly ${len} characters",
		min: "'${name}' must be at least ${min} characters",
		max: "'${name}' cannot be longer than ${max} characters",
		range: "'${name}' must be between ${min} and ${max} characters"
	},
	number: {
		len: "'${name}' must equal ${len}",
		min: "'${name}' cannot be less than ${min}",
		max: "'${name}' cannot be greater than ${max}",
		range: "'${name}' must be between ${min} and ${max}"
	},
	array: {
		len: "'${name}' must be exactly ${len} in length",
		min: "'${name}' cannot be less than ${min} in length",
		max: "'${name}' cannot be greater than ${max} in length",
		range: "'${name}' must be between ${min} and ${max} in length"
	},
	pattern: { mismatch: "'${name}' does not match pattern ${pattern}" }
};

//#endregion
//#region node_modules/@rc-component/form/es/utils/validateUtil.js
var AsyncValidator = es_default$34;
/**
* Replace with template.
*   `I'm ${name}` + { name: 'bamboo' } = I'm bamboo
*/
function replaceMessage(template, kv) {
	return template.replace(/\\?\$\{\w+\}/g, (str) => {
		if (str.startsWith("\\")) return str.slice(1);
		return kv[str.slice(2, -1)];
	});
}
var CODE_LOGIC_ERROR = "CODE_LOGIC_ERROR";
async function validateRule(name, value, rule, options, messageVariables) {
	const cloneRule = { ...rule };
	delete cloneRule.ruleIndex;
	AsyncValidator.warning = () => void 0;
	if (cloneRule.validator) {
		const originValidator = cloneRule.validator;
		cloneRule.validator = (...args) => {
			try {
				return originValidator(...args);
			} catch (error) {
				console.error(error);
				return Promise.reject(CODE_LOGIC_ERROR);
			}
		};
	}
	let subRuleField = null;
	if (cloneRule && cloneRule.type === "array" && cloneRule.defaultField) {
		subRuleField = cloneRule.defaultField;
		delete cloneRule.defaultField;
	}
	const validator = new AsyncValidator({ [name]: [cloneRule] });
	const messages$1 = merge$1(defaultValidateMessages, options.validateMessages);
	validator.messages(messages$1);
	let result = [];
	try {
		await Promise.resolve(validator.validate({ [name]: value }, { ...options }));
	} catch (errObj) {
		if (errObj.errors) result = errObj.errors.map(({ message: message$1 }, index$1) => {
			const mergedMessage = message$1 === CODE_LOGIC_ERROR ? messages$1.default : message$1;
			return /* @__PURE__ */ import_react.isValidElement(mergedMessage) ? /* @__PURE__ */ import_react.cloneElement(mergedMessage, { key: `error_${index$1}` }) : mergedMessage;
		});
	}
	if (!result.length && subRuleField && Array.isArray(value) && value.length > 0) return (await Promise.all(value.map((subValue, i) => validateRule(`${name}.${i}`, subValue, subRuleField, options, messageVariables)))).reduce((prev$1, errors) => [...prev$1, ...errors], []);
	const kv = {
		...rule,
		name,
		enum: (rule.enum || []).join(", "),
		...messageVariables
	};
	return result.map((error) => {
		if (typeof error === "string") return replaceMessage(error, kv);
		return error;
	});
}
/**
* We use `async-validator` to validate the value.
* But only check one value in a time to avoid namePath validate issue.
*/
function validateRules(namePath, value, rules, options, validateFirst, messageVariables) {
	const name = namePath.join(".");
	const filledRules = rules.map((currentRule, ruleIndex) => {
		const originValidatorFunc = currentRule.validator;
		const cloneRule = {
			...currentRule,
			ruleIndex
		};
		if (originValidatorFunc) cloneRule.validator = (rule, val, callback) => {
			let hasPromise = false;
			const wrappedCallback = (...args) => {
				Promise.resolve().then(() => {
					warning_default$1(!hasPromise, "Your validator function has already return a promise. `callback` will be ignored.");
					if (!hasPromise) callback(...args);
				});
			};
			const promise = originValidatorFunc(rule, val, wrappedCallback);
			hasPromise = promise && typeof promise.then === "function" && typeof promise.catch === "function";
			/**
			* 1. Use promise as the first priority.
			* 2. If promise not exist, use callback with warning instead
			*/
			warning_default$1(hasPromise, "`callback` is deprecated. Please return a promise instead.");
			if (hasPromise) promise.then(() => {
				callback();
			}).catch((err) => {
				callback(err || " ");
			});
		};
		return cloneRule;
	}).sort(({ warningOnly: w1, ruleIndex: i1 }, { warningOnly: w2, ruleIndex: i2 }) => {
		if (!!w1 === !!w2) return i1 - i2;
		if (w1) return 1;
		return -1;
	});
	let summaryPromise;
	if (validateFirst === true) summaryPromise = new Promise(async (resolve, reject) => {
		for (let i = 0; i < filledRules.length; i += 1) {
			const rule = filledRules[i];
			const errors = await validateRule(name, value, rule, options, messageVariables);
			if (errors.length) {
				reject([{
					errors,
					rule
				}]);
				return;
			}
		}
		resolve([]);
	});
	else {
		const rulePromises = filledRules.map((rule) => validateRule(name, value, rule, options, messageVariables).then((errors) => ({
			errors,
			rule
		})));
		summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then((errors) => {
			return Promise.reject(errors);
		});
	}
	summaryPromise.catch((e$2) => e$2);
	return summaryPromise;
}
async function finishOnAllFailed(rulePromises) {
	return Promise.all(rulePromises).then((errorsList) => {
		return [].concat(...errorsList);
	});
}
async function finishOnFirstFailed(rulePromises) {
	let count = 0;
	return new Promise((resolve) => {
		rulePromises.forEach((promise) => {
			promise.then((ruleError) => {
				if (ruleError.errors.length) resolve([ruleError]);
				count += 1;
				if (count === rulePromises.length) resolve([]);
			});
		});
	});
}

//#endregion
//#region node_modules/@rc-component/form/es/utils/valueUtil.js
/**
* Convert name to internal supported format.
* This function should keep since we still thinking if need support like `a.b.c` format.
* 'a' => ['a']
* 123 => [123]
* ['a', 123] => ['a', 123]
*/
function getNamePath(path$1) {
	return toArray$7(path$1);
}
/**
* Create a new store object that contains only the values referenced by
* the provided list of name paths.
*/
function cloneByNamePathList(store, namePathList) {
	let newStore = {};
	namePathList.forEach((namePath) => {
		const value = get(store, namePath);
		newStore = set(newStore, namePath, value);
	});
	return newStore;
}
/**
* Check if `namePathList` includes `namePath`.
* @param namePathList A list of `InternalNamePath[]`
* @param namePath Compare `InternalNamePath`
* @param partialMatch True will make `[a, b]` match `[a, b, c]`
*/
function containsNamePath(namePathList, namePath, partialMatch = false) {
	return namePathList && namePathList.some((path$1) => matchNamePath(namePath, path$1, partialMatch));
}
/**
* Check if `namePath` is super set or equal of `subNamePath`.
* @param namePath A list of `InternalNamePath[]`
* @param subNamePath Compare `InternalNamePath`
* @param partialMatch Default false. True will make `[a, b]` match `[a, b, c]`
*/
function matchNamePath(namePath, subNamePath, partialMatch = false) {
	if (!namePath || !subNamePath) return false;
	if (!partialMatch && namePath.length !== subNamePath.length) return false;
	return subNamePath.every((nameUnit, i) => namePath[i] === nameUnit);
}
function isSimilar(source, target) {
	if (source === target) return true;
	if (!source && target || source && !target) return false;
	if (!source || !target || typeof source !== "object" || typeof target !== "object") return false;
	const sourceKeys = Object.keys(source);
	const targetKeys = Object.keys(target);
	return [...new Set([...sourceKeys, ...targetKeys])].every((key) => {
		const sourceValue = source[key];
		const targetValue = target[key];
		if (typeof sourceValue === "function" && typeof targetValue === "function") return true;
		return sourceValue === targetValue;
	});
}
function defaultGetValueFromEvent(valuePropName, ...args) {
	const event = args[0];
	if (event && event.target && typeof event.target === "object" && valuePropName in event.target) return event.target[valuePropName];
	return event;
}
/**
* Moves an array item from one position in an array to another.
*
* Note: This is a pure function so a new array will be returned, instead
* of altering the array argument.
*
* @param array         Array in which to move an item.         (required)
* @param moveIndex     The index of the item to move.          (required)
* @param toIndex       The index to move item at moveIndex to. (required)
*/
function move(array$1, moveIndex, toIndex) {
	const { length: length$1 } = array$1;
	if (moveIndex < 0 || moveIndex >= length$1 || toIndex < 0 || toIndex >= length$1) return array$1;
	const item = array$1[moveIndex];
	const diff = moveIndex - toIndex;
	if (diff > 0) return [
		...array$1.slice(0, toIndex),
		item,
		...array$1.slice(toIndex, moveIndex),
		...array$1.slice(moveIndex + 1, length$1)
	];
	if (diff < 0) return [
		...array$1.slice(0, moveIndex),
		...array$1.slice(moveIndex + 1, toIndex + 1),
		item,
		...array$1.slice(toIndex + 1, length$1)
	];
	return array$1;
}

//#endregion
//#region node_modules/@rc-component/form/es/Field.js
function _extends$86() {
	_extends$86 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$86.apply(this, arguments);
}
var EMPTY_ERRORS = [];
var EMPTY_WARNINGS = [];
function requireUpdate(shouldUpdate, prev$1, next$1, prevValue, nextValue, info) {
	if (typeof shouldUpdate === "function") return shouldUpdate(prev$1, next$1, "source" in info ? { source: info.source } : {});
	return prevValue !== nextValue;
}
var Field = class extends import_react.Component {
	static contextType = FieldContext_default;
	state = { resetCount: 0 };
	cancelRegisterFunc = null;
	mounted = false;
	/**
	* Follow state should not management in State since it will async update by React.
	* This makes first render of form can not get correct state value.
	*/
	touched = false;
	/**
	* Mark when touched & validated. Currently only used for `dependencies`.
	* Note that we do not think field with `initialValue` is dirty
	* but this will be by `isFieldDirty` func.
	*/
	dirty = false;
	validatePromise;
	prevValidating;
	errors = EMPTY_ERRORS;
	warnings = EMPTY_WARNINGS;
	constructor(props) {
		super(props);
		if (props.fieldContext) {
			const { getInternalHooks } = props.fieldContext;
			const { initEntityValue } = getInternalHooks(HOOK_MARK);
			initEntityValue(this);
		}
	}
	componentDidMount() {
		const { shouldUpdate, fieldContext } = this.props;
		this.mounted = true;
		if (fieldContext) {
			const { getInternalHooks } = fieldContext;
			const { registerField } = getInternalHooks(HOOK_MARK);
			this.cancelRegisterFunc = registerField(this);
		}
		if (shouldUpdate === true) this.reRender();
	}
	componentWillUnmount() {
		this.cancelRegister();
		this.triggerMetaEvent(true);
		this.mounted = false;
	}
	cancelRegister = () => {
		const { preserve: preserve$1, isListField, name } = this.props;
		if (this.cancelRegisterFunc) this.cancelRegisterFunc(isListField, preserve$1, getNamePath(name));
		this.cancelRegisterFunc = null;
	};
	getNamePath = () => {
		const { name, fieldContext } = this.props;
		const { prefixName = [] } = fieldContext;
		return name !== void 0 ? [...prefixName, ...name] : [];
	};
	getRules = () => {
		const { rules = [], fieldContext } = this.props;
		return rules.map((rule) => {
			if (typeof rule === "function") return rule(fieldContext);
			return rule;
		});
	};
	reRender() {
		if (!this.mounted) return;
		this.forceUpdate();
	}
	refresh = () => {
		if (!this.mounted) return;
		/**
		* Clean up current node.
		*/
		this.setState(({ resetCount }) => ({ resetCount: resetCount + 1 }));
	};
	metaCache = null;
	triggerMetaEvent = (destroy$2) => {
		const { onMetaChange } = this.props;
		if (onMetaChange) {
			const meta = {
				...this.getMeta(),
				destroy: destroy$2
			};
			if (!isEqual_default(this.metaCache, meta)) onMetaChange(meta);
			this.metaCache = meta;
		} else this.metaCache = null;
	};
	onStoreChange = (prevStore, namePathList, info) => {
		const { shouldUpdate, dependencies = [], onReset } = this.props;
		const { store } = info;
		const namePath = this.getNamePath();
		const prevValue = this.getValue(prevStore);
		const curValue = this.getValue(store);
		const namePathMatch = namePathList && containsNamePath(namePathList, namePath);
		if (info.type === "valueUpdate" && info.source === "external" && !isEqual_default(prevValue, curValue)) {
			this.touched = true;
			this.dirty = true;
			this.validatePromise = null;
			this.errors = EMPTY_ERRORS;
			this.warnings = EMPTY_WARNINGS;
			this.triggerMetaEvent();
		}
		switch (info.type) {
			case "reset":
				if (!namePathList || namePathMatch) {
					this.touched = false;
					this.dirty = false;
					this.validatePromise = void 0;
					this.errors = EMPTY_ERRORS;
					this.warnings = EMPTY_WARNINGS;
					this.triggerMetaEvent();
					onReset?.();
					this.refresh();
					return;
				}
				break;
			case "remove":
				if (shouldUpdate && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
					this.reRender();
					return;
				}
				break;
			case "setField": {
				const { data } = info;
				if (namePathMatch) {
					if ("touched" in data) this.touched = data.touched;
					if ("validating" in data && !("originRCField" in data)) this.validatePromise = data.validating ? Promise.resolve([]) : null;
					if ("errors" in data) this.errors = data.errors || EMPTY_ERRORS;
					if ("warnings" in data) this.warnings = data.warnings || EMPTY_WARNINGS;
					this.dirty = true;
					this.triggerMetaEvent();
					this.reRender();
					return;
				} else if ("value" in data && containsNamePath(namePathList, namePath, true)) {
					this.reRender();
					return;
				}
				if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
					this.reRender();
					return;
				}
				break;
			}
			case "dependenciesUpdate":
				if (dependencies.map(getNamePath).some((dependency) => containsNamePath(info.relatedFields, dependency))) {
					this.reRender();
					return;
				}
				break;
			default:
				if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
					this.reRender();
					return;
				}
				break;
		}
		if (shouldUpdate === true) this.reRender();
	};
	validateRules = (options) => {
		const namePath = this.getNamePath();
		const currentValue = this.getValue();
		const { triggerName, validateOnly = false } = options || {};
		const rootPromise = Promise.resolve().then(async () => {
			if (!this.mounted) return [];
			const { validateFirst = false, messageVariables, validateDebounce } = this.props;
			let filteredRules = this.getRules();
			if (triggerName) filteredRules = filteredRules.filter((rule) => rule).filter((rule) => {
				const { validateTrigger } = rule;
				if (!validateTrigger) return true;
				return toArray$7(validateTrigger).includes(triggerName);
			});
			if (validateDebounce && triggerName) {
				await new Promise((resolve) => {
					setTimeout(resolve, validateDebounce);
				});
				if (this.validatePromise !== rootPromise) return [];
			}
			const promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);
			promise.catch((e$2) => e$2).then((ruleErrors = EMPTY_ERRORS) => {
				if (this.validatePromise === rootPromise) {
					this.validatePromise = null;
					const nextErrors = [];
					const nextWarnings = [];
					ruleErrors.forEach?.(({ rule: { warningOnly }, errors = EMPTY_ERRORS }) => {
						if (warningOnly) nextWarnings.push(...errors);
						else nextErrors.push(...errors);
					});
					this.errors = nextErrors;
					this.warnings = nextWarnings;
					this.triggerMetaEvent();
					this.reRender();
				}
			});
			return promise;
		});
		if (validateOnly) return rootPromise;
		this.validatePromise = rootPromise;
		this.dirty = true;
		this.errors = EMPTY_ERRORS;
		this.warnings = EMPTY_WARNINGS;
		this.triggerMetaEvent();
		this.reRender();
		return rootPromise;
	};
	isFieldValidating = () => !!this.validatePromise;
	isFieldTouched = () => this.touched;
	isFieldDirty = () => {
		if (this.dirty || this.props.initialValue !== void 0) return true;
		const { fieldContext } = this.props;
		const { getInitialValue } = fieldContext.getInternalHooks(HOOK_MARK);
		if (getInitialValue(this.getNamePath()) !== void 0) return true;
		return false;
	};
	getErrors = () => this.errors;
	getWarnings = () => this.warnings;
	isListField = () => this.props.isListField;
	isList = () => this.props.isList;
	isPreserve = () => this.props.preserve;
	getMeta = () => {
		this.prevValidating = this.isFieldValidating();
		return {
			touched: this.isFieldTouched(),
			validating: this.prevValidating,
			errors: this.errors,
			warnings: this.warnings,
			name: this.getNamePath(),
			validated: this.validatePromise === null
		};
	};
	getOnlyChild = (children) => {
		if (typeof children === "function") {
			const meta = this.getMeta();
			return {
				...this.getOnlyChild(children(this.getControlled(), meta, this.props.fieldContext)),
				isFunction: true
			};
		}
		const childList = toArray(children);
		if (childList.length !== 1 || !/* @__PURE__ */ import_react.isValidElement(childList[0])) return {
			child: childList,
			isFunction: false
		};
		return {
			child: childList[0],
			isFunction: false
		};
	};
	getValue = (store) => {
		const { getFieldsValue } = this.props.fieldContext;
		const namePath = this.getNamePath();
		return get(store || getFieldsValue(true), namePath);
	};
	getControlled = (childProps = {}) => {
		const { name, trigger = "onChange", validateTrigger, getValueFromEvent, normalize: normalize$1, valuePropName = "value", getValueProps, fieldContext } = this.props;
		const mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : fieldContext.validateTrigger;
		const namePath = this.getNamePath();
		const { getInternalHooks, getFieldsValue } = fieldContext;
		const { dispatch } = getInternalHooks(HOOK_MARK);
		const value = this.getValue();
		const mergedGetValueProps = getValueProps || ((val) => ({ [valuePropName]: val }));
		const originTriggerFunc = childProps[trigger];
		const valueProps = name !== void 0 ? mergedGetValueProps(value) : {};
		if (valueProps) Object.keys(valueProps).forEach((key) => {
			warning_default$1(typeof valueProps[key] !== "function", `It's not recommended to generate dynamic function prop by \`getValueProps\`. Please pass it to child component directly (prop: ${key})`);
		});
		const control = {
			...childProps,
			...valueProps
		};
		control[trigger] = (...args) => {
			this.touched = true;
			this.dirty = true;
			this.triggerMetaEvent();
			let newValue;
			if (getValueFromEvent) newValue = getValueFromEvent(...args);
			else newValue = defaultGetValueFromEvent(valuePropName, ...args);
			if (normalize$1) newValue = normalize$1(newValue, value, getFieldsValue(true));
			if (newValue !== value) dispatch({
				type: "updateValue",
				namePath,
				value: newValue
			});
			if (originTriggerFunc) originTriggerFunc(...args);
		};
		toArray$7(mergedValidateTrigger || []).forEach((triggerName) => {
			const originTrigger = control[triggerName];
			control[triggerName] = (...args) => {
				if (originTrigger) originTrigger(...args);
				const { rules } = this.props;
				if (rules && rules.length) dispatch({
					type: "validateField",
					namePath,
					triggerName
				});
			};
		});
		return control;
	};
	render() {
		const { resetCount } = this.state;
		const { children } = this.props;
		const { child, isFunction } = this.getOnlyChild(children);
		let returnChildNode;
		if (isFunction) returnChildNode = child;
		else if (/* @__PURE__ */ import_react.isValidElement(child)) returnChildNode = /* @__PURE__ */ import_react.cloneElement(child, this.getControlled(child.props));
		else {
			warning_default$1(!child, "`children` of Field is not validate ReactElement.");
			returnChildNode = child;
		}
		return /* @__PURE__ */ import_react.createElement(import_react.Fragment, { key: resetCount }, returnChildNode);
	}
};
function WrapperField({ name, ...restProps }) {
	const fieldContext = import_react.useContext(FieldContext_default);
	const listContext = import_react.useContext(ListContext_default);
	const namePath = name !== void 0 ? getNamePath(name) : void 0;
	const isMergedListField = restProps.isListField ?? !!listContext;
	let key = "keep";
	if (!isMergedListField) key = `_${(namePath || []).join("_")}`;
	if (restProps.preserve === false && isMergedListField && namePath.length <= 1) warning_default$1(false, "`preserve` should not apply on Form.List fields.");
	return /* @__PURE__ */ import_react.createElement(Field, _extends$86({
		key,
		name: namePath,
		isListField: isMergedListField
	}, restProps, { fieldContext }));
}
var Field_default = WrapperField;

//#endregion
//#region node_modules/@rc-component/form/es/List.js
function List$2({ name, initialValue, children, rules, validateTrigger, isListField }) {
	const context = import_react.useContext(FieldContext_default);
	const wrapperListContext = import_react.useContext(ListContext_default);
	const keyManager = import_react.useRef({
		keys: [],
		id: 0
	}).current;
	const prefixName = import_react.useMemo(() => {
		return [...getNamePath(context.prefixName) || [], ...getNamePath(name)];
	}, [context.prefixName, name]);
	const fieldContext = import_react.useMemo(() => ({
		...context,
		prefixName
	}), [context, prefixName]);
	const listContext = import_react.useMemo(() => ({ getKey: (namePath) => {
		const len = prefixName.length;
		const pathName = namePath[len];
		return [keyManager.keys[pathName], namePath.slice(len + 1)];
	} }), [keyManager, prefixName]);
	if (typeof children !== "function") {
		warning_default$1(false, "Form.List only accepts function as children.");
		return null;
	}
	const shouldUpdate = (prevValue, nextValue, { source }) => {
		if (source === "internal") return false;
		return prevValue !== nextValue;
	};
	return /* @__PURE__ */ import_react.createElement(ListContext_default.Provider, { value: listContext }, /* @__PURE__ */ import_react.createElement(FieldContext_default.Provider, { value: fieldContext }, /* @__PURE__ */ import_react.createElement(Field_default, {
		name: [],
		shouldUpdate,
		rules,
		validateTrigger,
		initialValue,
		isList: true,
		isListField: isListField ?? !!wrapperListContext
	}, ({ value = [], onChange }, meta) => {
		const { getFieldValue } = context;
		const getNewValue = () => {
			return getFieldValue(prefixName || []) || [];
		};
		/**
		* Always get latest value in case user update fields by `form` api.
		*/
		const operations = {
			add: (defaultValue, index$1) => {
				const newValue = getNewValue();
				if (index$1 >= 0 && index$1 <= newValue.length) {
					keyManager.keys = [
						...keyManager.keys.slice(0, index$1),
						keyManager.id,
						...keyManager.keys.slice(index$1)
					];
					onChange([
						...newValue.slice(0, index$1),
						defaultValue,
						...newValue.slice(index$1)
					]);
				} else {
					if (index$1 < 0 || index$1 > newValue.length) warning_default$1(false, "The second parameter of the add function should be a valid positive number.");
					keyManager.keys = [...keyManager.keys, keyManager.id];
					onChange([...newValue, defaultValue]);
				}
				keyManager.id += 1;
			},
			remove: (index$1) => {
				const newValue = getNewValue();
				const indexSet = new Set(Array.isArray(index$1) ? index$1 : [index$1]);
				if (indexSet.size <= 0) return;
				keyManager.keys = keyManager.keys.filter((_, keysIndex) => !indexSet.has(keysIndex));
				onChange(newValue.filter((_, valueIndex) => !indexSet.has(valueIndex)));
			},
			move(from$1, to) {
				if (from$1 === to) return;
				const newValue = getNewValue();
				if (from$1 < 0 || from$1 >= newValue.length || to < 0 || to >= newValue.length) return;
				keyManager.keys = move(keyManager.keys, from$1, to);
				onChange(move(newValue, from$1, to));
			}
		};
		let listValue = value || [];
		if (!Array.isArray(listValue)) {
			listValue = [];
			warning_default$1(false, `Current value of '${prefixName.join(" > ")}' is not an array type.`);
		}
		return children(listValue.map((__, index$1) => {
			let key = keyManager.keys[index$1];
			if (key === void 0) {
				keyManager.keys[index$1] = keyManager.id;
				key = keyManager.keys[index$1];
				keyManager.id += 1;
			}
			return {
				name: index$1,
				key,
				isListField: true
			};
		}), operations, meta);
	})));
}
var List_default = List$2;

//#endregion
//#region node_modules/@rc-component/form/es/utils/asyncUtil.js
function allPromiseFinish(promiseList) {
	let hasError = false;
	let count = promiseList.length;
	const results = [];
	if (!promiseList.length) return Promise.resolve([]);
	return new Promise((resolve, reject) => {
		promiseList.forEach((promise, index$1) => {
			promise.catch((e$2) => {
				hasError = true;
				return e$2;
			}).then((result) => {
				count -= 1;
				results[index$1] = result;
				if (count > 0) return;
				if (hasError) reject(results);
				resolve(results);
			});
		});
	});
}

//#endregion
//#region node_modules/@rc-component/form/es/utils/NameMap.js
var SPLIT = "__@field_split__";
/**
* Convert name path into string to fast the fetch speed of Map.
*/
function normalize(namePath) {
	return namePath.map((cell) => `${typeof cell}:${cell}`).join(SPLIT);
}
/**
* NameMap like a `Map` but accepts `string[]` as key.
*/
var NameMap = class {
	kvs = /* @__PURE__ */ new Map();
	set(key, value) {
		this.kvs.set(normalize(key), value);
	}
	get(key) {
		return this.kvs.get(normalize(key));
	}
	getAsPrefix(key) {
		const normalizedKey = normalize(key);
		const normalizedPrefix = normalizedKey + SPLIT;
		const results = [];
		const current = this.kvs.get(normalizedKey);
		if (current !== void 0) results.push(current);
		this.kvs.forEach((value, itemNormalizedKey) => {
			if (itemNormalizedKey.startsWith(normalizedPrefix)) results.push(value);
		});
		return results;
	}
	update(key, updater) {
		const next$1 = updater(this.get(key));
		if (!next$1) this.delete(key);
		else this.set(key, next$1);
	}
	delete(key) {
		this.kvs.delete(normalize(key));
	}
	map(callback) {
		return [...this.kvs.entries()].map(([key, value]) => {
			return callback({
				key: key.split(SPLIT).map((cell) => {
					const [, type$2, unit$2] = cell.match(/^([^:]*):(.*)$/);
					return type$2 === "number" ? Number(unit$2) : unit$2;
				}),
				value
			});
		});
	}
	toJSON() {
		const json = {};
		this.map(({ key, value }) => {
			json[key.join(".")] = value;
			return null;
		});
		return json;
	}
};
var NameMap_default = NameMap;

//#endregion
//#region node_modules/@rc-component/form/es/hooks/useNotifyWatch.js
/**
* Call action with delay in macro task.
*/
var macroTask$1 = (fn) => {
	const channel = new MessageChannel();
	channel.port1.onmessage = fn;
	channel.port2.postMessage(null);
};
var WatcherCenter = class {
	namePathList = [];
	taskId = 0;
	watcherList = /* @__PURE__ */ new Set();
	form;
	constructor(form) {
		this.form = form;
	}
	register(callback) {
		this.watcherList.add(callback);
		return () => {
			this.watcherList.delete(callback);
		};
	}
	notify(namePath) {
		namePath.forEach((path$1) => {
			if (this.namePathList.every((exist) => !matchNamePath(exist, path$1))) this.namePathList.push(path$1);
		});
		this.doBatch();
	}
	doBatch() {
		this.taskId += 1;
		const currentId = this.taskId;
		macroTask$1(() => {
			if (currentId === this.taskId && this.watcherList.size) {
				const formInst = this.form.getForm();
				const values = formInst.getFieldsValue();
				const allValues = formInst.getFieldsValue(true);
				this.watcherList.forEach((callback) => {
					callback(values, allValues, this.namePathList);
				});
				this.namePathList = [];
			}
		});
	}
};

//#endregion
//#region node_modules/@rc-component/form/es/hooks/useForm.js
var FormStore = class {
	formHooked = false;
	forceRootUpdate;
	subscribable = true;
	store = {};
	fieldEntities = [];
	initialValues = {};
	callbacks = {};
	validateMessages = null;
	preserve = null;
	lastValidatePromise = null;
	watcherCenter = new WatcherCenter(this);
	constructor(forceRootUpdate) {
		this.forceRootUpdate = forceRootUpdate;
	}
	getForm = () => ({
		getFieldValue: this.getFieldValue,
		getFieldsValue: this.getFieldsValue,
		getFieldError: this.getFieldError,
		getFieldWarning: this.getFieldWarning,
		getFieldsError: this.getFieldsError,
		isFieldsTouched: this.isFieldsTouched,
		isFieldTouched: this.isFieldTouched,
		isFieldValidating: this.isFieldValidating,
		isFieldsValidating: this.isFieldsValidating,
		resetFields: this.resetFields,
		setFields: this.setFields,
		setFieldValue: this.setFieldValue,
		setFieldsValue: this.setFieldsValue,
		validateFields: this.validateFields,
		submit: this.submit,
		_init: true,
		getInternalHooks: this.getInternalHooks
	});
	getInternalHooks = (key) => {
		if (key === HOOK_MARK) {
			this.formHooked = true;
			return {
				dispatch: this.dispatch,
				initEntityValue: this.initEntityValue,
				registerField: this.registerField,
				useSubscribe: this.useSubscribe,
				setInitialValues: this.setInitialValues,
				destroyForm: this.destroyForm,
				setCallbacks: this.setCallbacks,
				setValidateMessages: this.setValidateMessages,
				getFields: this.getFields,
				setPreserve: this.setPreserve,
				getInitialValue: this.getInitialValue,
				registerWatch: this.registerWatch
			};
		}
		warning_default$1(false, "`getInternalHooks` is internal usage. Should not call directly.");
		return null;
	};
	useSubscribe = (subscribable) => {
		this.subscribable = subscribable;
	};
	/**
	* Record prev Form unmount fieldEntities which config preserve false.
	* This need to be refill with initialValues instead of store value.
	*/
	prevWithoutPreserves = null;
	/**
	* First time `setInitialValues` should update store with initial value
	*/
	setInitialValues = (initialValues, init) => {
		this.initialValues = initialValues || {};
		if (init) {
			let nextStore = merge$1(initialValues, this.store);
			this.prevWithoutPreserves?.map(({ key: namePath }) => {
				nextStore = set(nextStore, namePath, get(initialValues, namePath));
			});
			this.prevWithoutPreserves = null;
			this.updateStore(nextStore);
		}
	};
	destroyForm = (clearOnDestroy) => {
		if (clearOnDestroy) this.updateStore({});
		else {
			const prevWithoutPreserves = new NameMap_default();
			this.getFieldEntities(true).forEach((entity) => {
				if (!this.isMergedPreserve(entity.isPreserve())) prevWithoutPreserves.set(entity.getNamePath(), true);
			});
			this.prevWithoutPreserves = prevWithoutPreserves;
		}
	};
	getInitialValue = (namePath) => {
		const initValue = get(this.initialValues, namePath);
		return namePath.length ? merge$1(initValue) : initValue;
	};
	setCallbacks = (callbacks) => {
		this.callbacks = callbacks;
	};
	setValidateMessages = (validateMessages) => {
		this.validateMessages = validateMessages;
	};
	setPreserve = (preserve$1) => {
		this.preserve = preserve$1;
	};
	registerWatch = (callback) => {
		return this.watcherCenter.register(callback);
	};
	notifyWatch = (namePath = []) => {
		this.watcherCenter.notify(namePath);
	};
	timeoutId = null;
	warningUnhooked = () => {
		if (!this.timeoutId && typeof window !== "undefined") this.timeoutId = setTimeout(() => {
			this.timeoutId = null;
			if (!this.formHooked) warning_default$1(false, "Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?");
		});
	};
	updateStore = (nextStore) => {
		this.store = nextStore;
	};
	/**
	* Get registered field entities.
	* @param pure Only return field which has a `name`. Default: false
	*/
	getFieldEntities = (pure = false) => {
		if (!pure) return this.fieldEntities;
		return this.fieldEntities.filter((field) => field.getNamePath().length);
	};
	/**
	* Get a map of registered field entities with their name path as the key.
	* @param pure Only include fields which have a `name`. Default: false
	* @returns A NameMap containing field entities indexed by their name paths
	*/
	getFieldsMap = (pure = false) => {
		const cache = new NameMap_default();
		this.getFieldEntities(pure).forEach((field) => {
			const namePath = field.getNamePath();
			cache.set(namePath, field);
		});
		return cache;
	};
	/**
	* Get field entities based on a list of name paths.
	* @param nameList - Array of name paths to search for. If not provided, returns all field entities with names.
	* @param includesSubNamePath - Whether to include fields that have the given name path as a prefix.
	*/
	getFieldEntitiesForNamePathList = (nameList, includesSubNamePath = false) => {
		if (!nameList) return this.getFieldEntities(true);
		const cache = this.getFieldsMap(true);
		if (!includesSubNamePath) return nameList.map((name) => {
			const namePath = getNamePath(name);
			return cache.get(namePath) || { INVALIDATE_NAME_PATH: getNamePath(name) };
		});
		return nameList.flatMap((name) => {
			const namePath = getNamePath(name);
			const fields = cache.getAsPrefix(namePath);
			if (fields.length) return fields;
			return [{ INVALIDATE_NAME_PATH: namePath }];
		});
	};
	getFieldsValue = (nameList, filterFunc) => {
		this.warningUnhooked();
		let mergedNameList;
		let mergedFilterFunc;
		if (nameList === true || Array.isArray(nameList)) {
			mergedNameList = nameList;
			mergedFilterFunc = filterFunc;
		} else if (nameList && typeof nameList === "object") mergedFilterFunc = nameList.filter;
		if (mergedNameList === true && !mergedFilterFunc) return this.store;
		const fieldEntities = this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null, true);
		const filteredNameList = [];
		const listNamePaths = [];
		fieldEntities.forEach((entity) => {
			const namePath = entity.INVALIDATE_NAME_PATH || entity.getNamePath();
			if (entity.isList?.()) {
				listNamePaths.push(namePath);
				return;
			}
			if (!mergedFilterFunc) filteredNameList.push(namePath);
			else {
				const meta = "getMeta" in entity ? entity.getMeta() : null;
				if (mergedFilterFunc(meta)) filteredNameList.push(namePath);
			}
		});
		let mergedValues = cloneByNamePathList(this.store, filteredNameList.map(getNamePath));
		listNamePaths.forEach((namePath) => {
			if (!get(mergedValues, namePath)) mergedValues = set(mergedValues, namePath, []);
		});
		return mergedValues;
	};
	getFieldValue = (name) => {
		this.warningUnhooked();
		const namePath = getNamePath(name);
		return get(this.store, namePath);
	};
	getFieldsError = (nameList) => {
		this.warningUnhooked();
		return this.getFieldEntitiesForNamePathList(nameList).map((entity, index$1) => {
			if (entity && !entity.INVALIDATE_NAME_PATH) return {
				name: entity.getNamePath(),
				errors: entity.getErrors(),
				warnings: entity.getWarnings()
			};
			return {
				name: getNamePath(nameList[index$1]),
				errors: [],
				warnings: []
			};
		});
	};
	getFieldError = (name) => {
		this.warningUnhooked();
		const namePath = getNamePath(name);
		return this.getFieldsError([namePath])[0].errors;
	};
	getFieldWarning = (name) => {
		this.warningUnhooked();
		const namePath = getNamePath(name);
		return this.getFieldsError([namePath])[0].warnings;
	};
	isFieldsTouched = (...args) => {
		this.warningUnhooked();
		const [arg0, arg1] = args;
		let namePathList;
		let isAllFieldsTouched = false;
		if (args.length === 0) namePathList = null;
		else if (args.length === 1) if (Array.isArray(arg0)) {
			namePathList = arg0.map(getNamePath);
			isAllFieldsTouched = false;
		} else {
			namePathList = null;
			isAllFieldsTouched = arg0;
		}
		else {
			namePathList = arg0.map(getNamePath);
			isAllFieldsTouched = arg1;
		}
		const fieldEntities = this.getFieldEntities(true);
		const isFieldTouched = (field) => field.isFieldTouched();
		if (!namePathList) return isAllFieldsTouched ? fieldEntities.every((entity) => isFieldTouched(entity) || entity.isList()) : fieldEntities.some(isFieldTouched);
		const map = new NameMap_default();
		namePathList.forEach((shortNamePath) => {
			map.set(shortNamePath, []);
		});
		fieldEntities.forEach((field) => {
			const fieldNamePath = field.getNamePath();
			namePathList.forEach((shortNamePath) => {
				if (shortNamePath.every((nameUnit, i) => fieldNamePath[i] === nameUnit)) map.update(shortNamePath, (list) => [...list, field]);
			});
		});
		const isNamePathListTouched = (entities) => entities.some(isFieldTouched);
		const namePathListEntities = map.map(({ value }) => value);
		return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);
	};
	isFieldTouched = (name) => {
		this.warningUnhooked();
		return this.isFieldsTouched([name]);
	};
	isFieldsValidating = (nameList) => {
		this.warningUnhooked();
		const fieldEntities = this.getFieldEntities();
		if (!nameList) return fieldEntities.some((testField) => testField.isFieldValidating());
		const namePathList = nameList.map(getNamePath);
		return fieldEntities.some((testField) => {
			return containsNamePath(namePathList, testField.getNamePath()) && testField.isFieldValidating();
		});
	};
	isFieldValidating = (name) => {
		this.warningUnhooked();
		return this.isFieldsValidating([name]);
	};
	/**
	* Reset Field with field `initialValue` prop.
	* Can pass `entities` or `namePathList` or just nothing.
	*/
	resetWithFieldInitialValue = (info = {}) => {
		const cache = new NameMap_default();
		const fieldEntities = this.getFieldEntities(true);
		fieldEntities.forEach((field) => {
			const { initialValue } = field.props;
			const namePath = field.getNamePath();
			if (initialValue !== void 0) {
				const records = cache.get(namePath) || /* @__PURE__ */ new Set();
				records.add({
					entity: field,
					value: initialValue
				});
				cache.set(namePath, records);
			}
		});
		const resetWithFields = (entities) => {
			entities.forEach((field) => {
				const { initialValue } = field.props;
				if (initialValue !== void 0) {
					const namePath = field.getNamePath();
					if (this.getInitialValue(namePath) !== void 0) warning_default$1(false, `Form already set 'initialValues' with path '${namePath.join(".")}'. Field can not overwrite it.`);
					else {
						const records = cache.get(namePath);
						if (records && records.size > 1) warning_default$1(false, `Multiple Field with path '${namePath.join(".")}' set 'initialValue'. Can not decide which one to pick.`);
						else if (records) {
							const originValue = this.getFieldValue(namePath);
							if (!field.isListField() && (!info.skipExist || originValue === void 0)) this.updateStore(set(this.store, namePath, [...records][0].value));
						}
					}
				}
			});
		};
		let requiredFieldEntities;
		if (info.entities) requiredFieldEntities = info.entities;
		else if (info.namePathList) {
			requiredFieldEntities = [];
			info.namePathList.forEach((namePath) => {
				const records = cache.get(namePath);
				if (records) requiredFieldEntities.push(...[...records].map((r$1) => r$1.entity));
			});
		} else requiredFieldEntities = fieldEntities;
		resetWithFields(requiredFieldEntities);
	};
	resetFields = (nameList) => {
		this.warningUnhooked();
		const prevStore = this.store;
		if (!nameList) {
			this.updateStore(merge$1(this.initialValues));
			this.resetWithFieldInitialValue();
			this.notifyObservers(prevStore, null, { type: "reset" });
			this.notifyWatch();
			return;
		}
		const namePathList = nameList.map(getNamePath);
		namePathList.forEach((namePath) => {
			const initialValue = this.getInitialValue(namePath);
			this.updateStore(set(this.store, namePath, initialValue));
		});
		this.resetWithFieldInitialValue({ namePathList });
		this.notifyObservers(prevStore, namePathList, { type: "reset" });
		this.notifyWatch(namePathList);
	};
	setFields = (fields) => {
		this.warningUnhooked();
		const prevStore = this.store;
		const namePathList = [];
		fields.forEach((fieldData) => {
			const { name, ...data } = fieldData;
			const namePath = getNamePath(name);
			namePathList.push(namePath);
			if ("value" in data) this.updateStore(set(this.store, namePath, data.value));
			this.notifyObservers(prevStore, [namePath], {
				type: "setField",
				data: fieldData
			});
		});
		this.notifyWatch(namePathList);
	};
	getFields = () => {
		return this.getFieldEntities(true).map((field) => {
			const namePath = field.getNamePath();
			const fieldData = {
				...field.getMeta(),
				name: namePath,
				value: this.getFieldValue(namePath)
			};
			Object.defineProperty(fieldData, "originRCField", { value: true });
			return fieldData;
		});
	};
	/**
	* This only trigger when a field is on constructor to avoid we get initialValue too late
	*/
	initEntityValue = (entity) => {
		const { initialValue } = entity.props;
		if (initialValue !== void 0) {
			const namePath = entity.getNamePath();
			if (get(this.store, namePath) === void 0) this.updateStore(set(this.store, namePath, initialValue));
		}
	};
	isMergedPreserve = (fieldPreserve) => {
		return (fieldPreserve !== void 0 ? fieldPreserve : this.preserve) ?? true;
	};
	registerField = (entity) => {
		this.fieldEntities.push(entity);
		const namePath = entity.getNamePath();
		this.notifyWatch([namePath]);
		if (entity.props.initialValue !== void 0) {
			const prevStore = this.store;
			this.resetWithFieldInitialValue({
				entities: [entity],
				skipExist: true
			});
			this.notifyObservers(prevStore, [entity.getNamePath()], {
				type: "valueUpdate",
				source: "internal"
			});
		}
		return (isListField, preserve$1, subNamePath = []) => {
			this.fieldEntities = this.fieldEntities.filter((item) => item !== entity);
			if (!this.isMergedPreserve(preserve$1) && (!isListField || subNamePath.length > 1)) {
				const defaultValue = isListField ? void 0 : this.getInitialValue(namePath);
				if (namePath.length && this.getFieldValue(namePath) !== defaultValue && this.fieldEntities.every((field) => !matchNamePath(field.getNamePath(), namePath))) {
					const prevStore = this.store;
					this.updateStore(set(prevStore, namePath, defaultValue, true));
					this.notifyObservers(prevStore, [namePath], { type: "remove" });
					this.triggerDependenciesUpdate(prevStore, namePath);
				}
			}
			this.notifyWatch([namePath]);
		};
	};
	dispatch = (action) => {
		switch (action.type) {
			case "updateValue": {
				const { namePath, value } = action;
				this.updateValue(namePath, value);
				break;
			}
			case "validateField": {
				const { namePath, triggerName } = action;
				this.validateFields([namePath], { triggerName });
				break;
			}
			default:
		}
	};
	notifyObservers = (prevStore, namePathList, info) => {
		if (this.subscribable) {
			const mergedInfo = {
				...info,
				store: this.getFieldsValue(true)
			};
			this.getFieldEntities().forEach(({ onStoreChange }) => {
				onStoreChange(prevStore, namePathList, mergedInfo);
			});
		} else this.forceRootUpdate();
	};
	/**
	* Notify dependencies children with parent update
	* We need delay to trigger validate in case Field is under render props
	*/
	triggerDependenciesUpdate = (prevStore, namePath) => {
		const childrenFields = this.getDependencyChildrenFields(namePath);
		if (childrenFields.length) this.validateFields(childrenFields);
		this.notifyObservers(prevStore, childrenFields, {
			type: "dependenciesUpdate",
			relatedFields: [namePath, ...childrenFields]
		});
		return childrenFields;
	};
	updateValue = (name, value) => {
		const namePath = getNamePath(name);
		const prevStore = this.store;
		this.updateStore(set(this.store, namePath, value));
		this.notifyObservers(prevStore, [namePath], {
			type: "valueUpdate",
			source: "internal"
		});
		this.notifyWatch([namePath]);
		const childrenFields = this.triggerDependenciesUpdate(prevStore, namePath);
		const { onValuesChange } = this.callbacks;
		if (onValuesChange) {
			const fieldEntity = this.getFieldsMap(true).get(namePath);
			const changedValues = cloneByNamePathList(this.store, [namePath]);
			onValuesChange(changedValues, mergeWith([this.getFieldsValue(), changedValues], { prepareArray: (current) => fieldEntity?.isList() ? [] : [...current || []] }));
		}
		this.triggerOnFieldsChange([namePath, ...childrenFields]);
	};
	setFieldsValue = (store) => {
		this.warningUnhooked();
		const prevStore = this.store;
		if (store) {
			const nextStore = merge$1(this.store, store);
			this.updateStore(nextStore);
		}
		this.notifyObservers(prevStore, null, {
			type: "valueUpdate",
			source: "external"
		});
		this.notifyWatch();
	};
	setFieldValue = (name, value) => {
		this.setFields([{
			name,
			value,
			errors: [],
			warnings: [],
			touched: true
		}]);
	};
	getDependencyChildrenFields = (rootNamePath) => {
		const children = /* @__PURE__ */ new Set();
		const childrenFields = [];
		const dependencies2fields = new NameMap_default();
		/**
		* Generate maps
		* Can use cache to save perf if user report performance issue with this
		*/
		this.getFieldEntities().forEach((field) => {
			const { dependencies } = field.props;
			(dependencies || []).forEach((dependency) => {
				const dependencyNamePath = getNamePath(dependency);
				dependencies2fields.update(dependencyNamePath, (fields = /* @__PURE__ */ new Set()) => {
					fields.add(field);
					return fields;
				});
			});
		});
		const fillChildren = (namePath) => {
			(dependencies2fields.get(namePath) || /* @__PURE__ */ new Set()).forEach((field) => {
				if (!children.has(field)) {
					children.add(field);
					const fieldNamePath = field.getNamePath();
					if (field.isFieldDirty() && fieldNamePath.length) {
						childrenFields.push(fieldNamePath);
						fillChildren(fieldNamePath);
					}
				}
			});
		};
		fillChildren(rootNamePath);
		return childrenFields;
	};
	triggerOnFieldsChange = (namePathList, filedErrors) => {
		const { onFieldsChange } = this.callbacks;
		if (onFieldsChange) {
			const fields = this.getFields();
			/**
			* Fill errors since `fields` may be replaced by controlled fields
			*/
			if (filedErrors) {
				const cache = new NameMap_default();
				filedErrors.forEach(({ name, errors }) => {
					cache.set(name, errors);
				});
				fields.forEach((field) => {
					field.errors = cache.get(field.name) || field.errors;
				});
			}
			const changedFields = fields.filter(({ name: fieldName }) => containsNamePath(namePathList, fieldName));
			if (changedFields.length) onFieldsChange(changedFields, fields);
		}
	};
	validateFields = (arg1, arg2) => {
		this.warningUnhooked();
		let nameList;
		let options;
		if (Array.isArray(arg1) || typeof arg1 === "string" || typeof arg2 === "string") {
			nameList = arg1;
			options = arg2;
		} else options = arg1;
		const provideNameList = !!nameList;
		const namePathList = provideNameList ? nameList.map(getNamePath) : [];
		const finalValueNamePathList = [...namePathList];
		const promiseList = [];
		const TMP_SPLIT = String(Date.now());
		const validateNamePathList = /* @__PURE__ */ new Set();
		const { recursive, dirty } = options || {};
		this.getFieldEntities(true).forEach((field) => {
			const fieldNamePath = field.getNamePath();
			if (!provideNameList) {
				if (!field.isList() || !namePathList.some((name) => matchNamePath(name, fieldNamePath, true))) finalValueNamePathList.push(fieldNamePath);
				namePathList.push(fieldNamePath);
			}
			if (!field.props.rules || !field.props.rules.length) return;
			if (dirty && !field.isFieldDirty()) return;
			validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));
			if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {
				const promise = field.validateRules({
					validateMessages: {
						...defaultValidateMessages,
						...this.validateMessages
					},
					...options
				});
				promiseList.push(promise.then(() => ({
					name: fieldNamePath,
					errors: [],
					warnings: []
				})).catch((ruleErrors) => {
					const mergedErrors = [];
					const mergedWarnings = [];
					ruleErrors.forEach?.(({ rule: { warningOnly }, errors }) => {
						if (warningOnly) mergedWarnings.push(...errors);
						else mergedErrors.push(...errors);
					});
					if (mergedErrors.length) return Promise.reject({
						name: fieldNamePath,
						errors: mergedErrors,
						warnings: mergedWarnings
					});
					return {
						name: fieldNamePath,
						errors: mergedErrors,
						warnings: mergedWarnings
					};
				}));
			}
		});
		const summaryPromise = allPromiseFinish(promiseList);
		this.lastValidatePromise = summaryPromise;
		summaryPromise.catch((results) => results).then((results) => {
			const resultNamePathList = results.map(({ name }) => name);
			this.notifyObservers(this.store, resultNamePathList, { type: "validateFinish" });
			this.triggerOnFieldsChange(resultNamePathList, results);
		});
		const returnPromise = summaryPromise.then(() => {
			if (this.lastValidatePromise === summaryPromise) return Promise.resolve(this.getFieldsValue(finalValueNamePathList));
			return Promise.reject([]);
		}).catch((results) => {
			const errorList = results.filter((result) => result && result.errors.length);
			const errorMessage = errorList[0]?.errors?.[0];
			return Promise.reject({
				message: errorMessage,
				values: this.getFieldsValue(namePathList),
				errorFields: errorList,
				outOfDate: this.lastValidatePromise !== summaryPromise
			});
		});
		returnPromise.catch((e$2) => e$2);
		const triggerNamePathList = namePathList.filter((namePath) => validateNamePathList.has(namePath.join(TMP_SPLIT)));
		this.triggerOnFieldsChange(triggerNamePathList);
		return returnPromise;
	};
	submit = () => {
		this.warningUnhooked();
		this.validateFields().then((values) => {
			const { onFinish } = this.callbacks;
			if (onFinish) try {
				onFinish(values);
			} catch (err) {
				console.error(err);
			}
		}).catch((e$2) => {
			const { onFinishFailed } = this.callbacks;
			if (onFinishFailed) onFinishFailed(e$2);
		});
	};
};
function useForm$1(form) {
	const formRef = import_react.useRef(null);
	const [, forceUpdate] = import_react.useState({});
	if (!formRef.current) if (form) formRef.current = form;
	else {
		const forceReRender = () => {
			forceUpdate({});
		};
		formRef.current = new FormStore(forceReRender).getForm();
	}
	return [formRef.current];
}
var useForm_default = useForm$1;

//#endregion
//#region node_modules/@rc-component/form/es/FormContext.js
var FormContext$1 = /* @__PURE__ */ import_react.createContext({
	triggerFormChange: () => {},
	triggerFormFinish: () => {},
	registerForm: () => {},
	unregisterForm: () => {}
});
var FormProvider$1 = ({ validateMessages, onFormChange, onFormFinish, children }) => {
	const formContext = import_react.useContext(FormContext$1);
	const formsRef = import_react.useRef({});
	return /* @__PURE__ */ import_react.createElement(FormContext$1.Provider, { value: {
		...formContext,
		validateMessages: {
			...formContext.validateMessages,
			...validateMessages
		},
		triggerFormChange: (name, changedFields) => {
			if (onFormChange) onFormChange(name, {
				changedFields,
				forms: formsRef.current
			});
			formContext.triggerFormChange(name, changedFields);
		},
		triggerFormFinish: (name, values) => {
			if (onFormFinish) onFormFinish(name, {
				values,
				forms: formsRef.current
			});
			formContext.triggerFormFinish(name, values);
		},
		registerForm: (name, form) => {
			if (name) formsRef.current = {
				...formsRef.current,
				[name]: form
			};
			formContext.registerForm(name, form);
		},
		unregisterForm: (name) => {
			const newForms = { ...formsRef.current };
			delete newForms[name];
			formsRef.current = newForms;
			formContext.unregisterForm(name);
		}
	} }, children);
};
var FormContext_default = FormContext$1;

//#endregion
//#region node_modules/@rc-component/form/es/Form.js
function _extends$85() {
	_extends$85 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$85.apply(this, arguments);
}
var Form$2 = ({ name, initialValues, fields, form, preserve: preserve$1, children, component: Component$2 = "form", validateMessages, validateTrigger = "onChange", onValuesChange, onFieldsChange, onFinish, onFinishFailed, clearOnDestroy, ...restProps }, ref) => {
	const nativeElementRef = import_react.useRef(null);
	const formContext = import_react.useContext(FormContext_default);
	const [formInstance] = useForm_default(form);
	const { useSubscribe, setInitialValues, setCallbacks, setValidateMessages, setPreserve, destroyForm } = formInstance.getInternalHooks(HOOK_MARK);
	import_react.useImperativeHandle(ref, () => ({
		...formInstance,
		nativeElement: nativeElementRef.current
	}));
	import_react.useEffect(() => {
		formContext.registerForm(name, formInstance);
		return () => {
			formContext.unregisterForm(name);
		};
	}, [
		formContext,
		formInstance,
		name
	]);
	setValidateMessages({
		...formContext.validateMessages,
		...validateMessages
	});
	setCallbacks({
		onValuesChange,
		onFieldsChange: (changedFields, ...rest) => {
			formContext.triggerFormChange(name, changedFields);
			if (onFieldsChange) onFieldsChange(changedFields, ...rest);
		},
		onFinish: (values) => {
			formContext.triggerFormFinish(name, values);
			if (onFinish) onFinish(values);
		},
		onFinishFailed
	});
	setPreserve(preserve$1);
	const mountRef = import_react.useRef(null);
	setInitialValues(initialValues, !mountRef.current);
	if (!mountRef.current) mountRef.current = true;
	import_react.useEffect(() => () => destroyForm(clearOnDestroy), []);
	let childrenNode;
	const childrenRenderProps = typeof children === "function";
	if (childrenRenderProps) childrenNode = children(formInstance.getFieldsValue(true), formInstance);
	else childrenNode = children;
	useSubscribe(!childrenRenderProps);
	const prevFieldsRef = import_react.useRef(null);
	import_react.useEffect(() => {
		if (!isSimilar(prevFieldsRef.current || [], fields || [])) formInstance.setFields(fields || []);
		prevFieldsRef.current = fields;
	}, [fields, formInstance]);
	const formContextValue = import_react.useMemo(() => ({
		...formInstance,
		validateTrigger
	}), [formInstance, validateTrigger]);
	const wrapperNode = /* @__PURE__ */ import_react.createElement(ListContext_default.Provider, { value: null }, /* @__PURE__ */ import_react.createElement(FieldContext_default.Provider, { value: formContextValue }, childrenNode));
	if (Component$2 === false) return wrapperNode;
	return /* @__PURE__ */ import_react.createElement(Component$2, _extends$85({}, restProps, {
		ref: nativeElementRef,
		onSubmit: (event) => {
			event.preventDefault();
			event.stopPropagation();
			formInstance.submit();
		},
		onReset: (event) => {
			event.preventDefault();
			formInstance.resetFields();
			restProps.onReset?.(event);
		}
	}), wrapperNode);
};
var Form_default$1 = Form$2;

//#endregion
//#region node_modules/@rc-component/form/es/hooks/useWatch.js
function stringify$1(value) {
	try {
		return JSON.stringify(value);
	} catch {
		return Math.random();
	}
}
function useWatch(...args) {
	const [dependencies, _form = {}] = args;
	const options = isFormInstance(_form) ? { form: _form } : _form;
	const form = options.form;
	const [value, setValue] = (0, import_react.useState)(() => typeof dependencies === "function" ? dependencies({}) : void 0);
	const valueStr = (0, import_react.useMemo)(() => stringify$1(value), [value]);
	const valueStrRef = (0, import_react.useRef)(valueStr);
	valueStrRef.current = valueStr;
	const fieldContext = (0, import_react.useContext)(FieldContext_default);
	const formInstance = form || fieldContext;
	const isValidForm = formInstance && formInstance._init;
	warning_default$1(args.length === 2 ? form ? isValidForm : true : isValidForm, "useWatch requires a form instance since it can not auto detect from context.");
	const { getFieldsValue, getInternalHooks } = formInstance;
	const { registerWatch } = getInternalHooks(HOOK_MARK);
	const triggerUpdate = useEvent_default((values, allValues) => {
		const watchValue = options.preserve ? allValues ?? getFieldsValue(true) : values ?? getFieldsValue();
		const nextValue = typeof dependencies === "function" ? dependencies(watchValue) : get(watchValue, getNamePath(dependencies));
		if (stringify$1(value) !== stringify$1(nextValue)) setValue(nextValue);
	});
	(0, import_react.useEffect)(() => {
		if (!isValidForm) return;
		triggerUpdate();
	}, [isValidForm, typeof dependencies === "function" ? dependencies : JSON.stringify(dependencies)]);
	(0, import_react.useEffect)(() => {
		if (!isValidForm) return;
		return registerWatch((values, allValues) => {
			triggerUpdate(values, allValues);
		});
	}, [isValidForm]);
	return value;
}
var useWatch_default = useWatch;

//#endregion
//#region node_modules/@rc-component/form/es/index.js
var RefForm = /* @__PURE__ */ import_react.forwardRef(Form_default$1);
RefForm.FormProvider = FormProvider$1;
RefForm.Field = Field_default;
RefForm.List = List_default;
RefForm.useForm = useForm_default;
RefForm.useWatch = useWatch_default;
var es_default$16 = RefForm;

//#endregion
//#region node_modules/antd/es/form/context.js
const FormContext = /* @__PURE__ */ import_react.createContext({
	labelAlign: "right",
	layout: "horizontal",
	itemRef: () => {}
});
const NoStyleItemContext = /* @__PURE__ */ import_react.createContext(null);
const FormProvider = (props) => {
	const providerProps = omit(props, ["prefixCls"]);
	return /* @__PURE__ */ import_react.createElement(FormProvider$1, { ...providerProps });
};
const FormItemPrefixContext = /* @__PURE__ */ import_react.createContext({ prefixCls: "" });
const FormItemInputContext = /* @__PURE__ */ import_react.createContext({});
FormItemInputContext.displayName = "FormItemInputContext";
const NoFormStyle = ({ children, status, override }) => {
	const formItemInputContext = import_react.useContext(FormItemInputContext);
	const newFormItemInputContext = import_react.useMemo(() => {
		const newContext = { ...formItemInputContext };
		if (override) delete newContext.isFormItemInput;
		if (status) {
			delete newContext.status;
			delete newContext.hasFeedback;
			delete newContext.feedbackIcon;
		}
		return newContext;
	}, [
		status,
		override,
		formItemInputContext
	]);
	return /* @__PURE__ */ import_react.createElement(FormItemInputContext.Provider, { value: newFormItemInputContext }, children);
};
const VariantContext = /* @__PURE__ */ import_react.createContext(void 0);

//#endregion
//#region node_modules/antd/es/_util/ContextIsolator.js
var ContextIsolator = (props) => {
	const { space, form, children } = props;
	if (!isNonNullable_default(children)) return null;
	let result = children;
	if (form) result = /* @__PURE__ */ import_react.createElement(NoFormStyle, {
		override: true,
		status: true
	}, result);
	if (space) result = /* @__PURE__ */ import_react.createElement(NoCompactStyle, null, result);
	return result;
};
var ContextIsolator_default = ContextIsolator;

//#endregion
//#region node_modules/@rc-component/util/es/Dom/styleChecker.js
var isStyleNameSupport = (styleName) => {
	if (canUseDom() && window.document.documentElement) {
		const styleNameList = Array.isArray(styleName) ? styleName : [styleName];
		const { documentElement } = window.document;
		return styleNameList.some((name) => name in documentElement.style);
	}
	return false;
};
var isStyleValueSupport = (styleName, value) => {
	if (!isStyleNameSupport(styleName)) return false;
	const ele = document.createElement("div");
	const origin = ele.style[styleName];
	ele.style[styleName] = value;
	return ele.style[styleName] !== origin;
};
function isStyleSupport(styleName, styleValue) {
	if (!Array.isArray(styleName) && styleValue !== void 0) return isStyleValueSupport(styleName, styleValue);
	return isStyleNameSupport(styleName);
}

//#endregion
//#region node_modules/antd/es/_util/styleChecker.js
const canUseDocElement = () => canUseDom() && window.document.documentElement;

//#endregion
//#region node_modules/antd/es/skeleton/Element.js
var Element$1 = (props) => {
	const { prefixCls, className, style: style$1, size, shape } = props;
	const sizeCls = clsx({
		[`${prefixCls}-lg`]: size === "large",
		[`${prefixCls}-sm`]: size === "small"
	});
	const shapeCls = clsx({
		[`${prefixCls}-circle`]: shape === "circle",
		[`${prefixCls}-square`]: shape === "square",
		[`${prefixCls}-round`]: shape === "round"
	});
	const sizeStyle = import_react.useMemo(() => typeof size === "number" ? {
		width: size,
		height: size,
		lineHeight: `${size}px`
	} : {}, [size]);
	return /* @__PURE__ */ import_react.createElement("span", {
		className: clsx(prefixCls, sizeCls, shapeCls, className),
		style: {
			...sizeStyle,
			...style$1
		}
	});
};
var Element_default = Element$1;

//#endregion
//#region node_modules/antd/es/skeleton/style/index.js
var skeletonClsLoading = new Keyframes_default(`ant-skeleton-loading`, {
	"0%": { backgroundPosition: "100% 50%" },
	"100%": { backgroundPosition: "0 50%" }
});
var genSkeletonElementCommonSize = (size) => ({
	height: size,
	lineHeight: unit(size)
});
var genSkeletonElementSize = (size) => ({
	width: size,
	...genSkeletonElementCommonSize(size)
});
var genSkeletonColor = (token$1) => ({
	background: token$1.skeletonLoadingBackground,
	backgroundSize: "400% 100%",
	animationName: skeletonClsLoading,
	animationDuration: token$1.skeletonLoadingMotionDuration,
	animationTimingFunction: "ease",
	animationIterationCount: "infinite"
});
var genSkeletonElementInputSize = (size, calc) => ({
	width: calc(size).mul(5).equal(),
	minWidth: calc(size).mul(5).equal(),
	...genSkeletonElementCommonSize(size)
});
var genSkeletonElementAvatar = (token$1) => {
	const { skeletonAvatarCls, gradientFromColor, controlHeight, controlHeightLG, controlHeightSM } = token$1;
	return {
		[skeletonAvatarCls]: {
			display: "inline-block",
			verticalAlign: "top",
			background: gradientFromColor,
			...genSkeletonElementSize(controlHeight)
		},
		[`${skeletonAvatarCls}${skeletonAvatarCls}-circle`]: { borderRadius: "50%" },
		[`${skeletonAvatarCls}${skeletonAvatarCls}-lg`]: { ...genSkeletonElementSize(controlHeightLG) },
		[`${skeletonAvatarCls}${skeletonAvatarCls}-sm`]: { ...genSkeletonElementSize(controlHeightSM) }
	};
};
var genSkeletonElementInput = (token$1) => {
	const { controlHeight, borderRadiusSM, skeletonInputCls, controlHeightLG, controlHeightSM, gradientFromColor, calc } = token$1;
	return {
		[skeletonInputCls]: {
			display: "inline-block",
			verticalAlign: "top",
			background: gradientFromColor,
			borderRadius: borderRadiusSM,
			...genSkeletonElementInputSize(controlHeight, calc)
		},
		[`${skeletonInputCls}-lg`]: { ...genSkeletonElementInputSize(controlHeightLG, calc) },
		[`${skeletonInputCls}-sm`]: { ...genSkeletonElementInputSize(controlHeightSM, calc) }
	};
};
var genSkeletonElementShape = (token$1) => {
	const { gradientFromColor, borderRadiusSM, imageSizeBase, calc } = token$1;
	return {
		display: "inline-flex",
		alignItems: "center",
		justifyContent: "center",
		verticalAlign: "middle",
		background: gradientFromColor,
		borderRadius: borderRadiusSM,
		...genSkeletonElementSize(calc(imageSizeBase).mul(2).equal())
	};
};
var genSkeletonElementNode = (token$1) => {
	return { [token$1.skeletonNodeCls]: { ...genSkeletonElementShape(token$1) } };
};
var genSkeletonElementImage = (token$1) => {
	const { skeletonImageCls, imageSizeBase, calc } = token$1;
	return {
		[skeletonImageCls]: {
			...genSkeletonElementShape(token$1),
			[`${skeletonImageCls}-path`]: { fill: "#bfbfbf" },
			[`${skeletonImageCls}-svg`]: {
				...genSkeletonElementSize(imageSizeBase),
				maxWidth: calc(imageSizeBase).mul(4).equal(),
				maxHeight: calc(imageSizeBase).mul(4).equal()
			},
			[`${skeletonImageCls}-svg${skeletonImageCls}-svg-circle`]: { borderRadius: "50%" }
		},
		[`${skeletonImageCls}${skeletonImageCls}-circle`]: { borderRadius: "50%" }
	};
};
var genSkeletonElementButtonShape = (token$1, size, buttonCls) => {
	const { skeletonButtonCls } = token$1;
	return {
		[`${buttonCls}${skeletonButtonCls}-circle`]: {
			width: size,
			minWidth: size,
			borderRadius: "50%"
		},
		[`${buttonCls}${skeletonButtonCls}-round`]: { borderRadius: size }
	};
};
var genSkeletonElementButtonSize = (size, calc) => ({
	width: calc(size).mul(2).equal(),
	minWidth: calc(size).mul(2).equal(),
	...genSkeletonElementCommonSize(size)
});
var genSkeletonElementButton = (token$1) => {
	const { borderRadiusSM, skeletonButtonCls, controlHeight, controlHeightLG, controlHeightSM, gradientFromColor, calc } = token$1;
	return {
		[skeletonButtonCls]: {
			display: "inline-block",
			verticalAlign: "top",
			background: gradientFromColor,
			borderRadius: borderRadiusSM,
			width: calc(controlHeight).mul(2).equal(),
			minWidth: calc(controlHeight).mul(2).equal(),
			...genSkeletonElementButtonSize(controlHeight, calc)
		},
		...genSkeletonElementButtonShape(token$1, controlHeight, skeletonButtonCls),
		[`${skeletonButtonCls}-lg`]: { ...genSkeletonElementButtonSize(controlHeightLG, calc) },
		...genSkeletonElementButtonShape(token$1, controlHeightLG, `${skeletonButtonCls}-lg`),
		[`${skeletonButtonCls}-sm`]: { ...genSkeletonElementButtonSize(controlHeightSM, calc) },
		...genSkeletonElementButtonShape(token$1, controlHeightSM, `${skeletonButtonCls}-sm`)
	};
};
var genBaseStyle$16 = (token$1) => {
	const { componentCls, skeletonAvatarCls, skeletonTitleCls, skeletonParagraphCls, skeletonButtonCls, skeletonInputCls, skeletonNodeCls, skeletonImageCls, controlHeight, controlHeightLG, controlHeightSM, gradientFromColor, padding, marginSM, borderRadius, titleHeight, blockRadius, paragraphLiHeight, controlHeightXS, paragraphMarginTop } = token$1;
	return {
		[componentCls]: {
			display: "table",
			width: "100%",
			[`${componentCls}-header`]: {
				display: "table-cell",
				paddingInlineEnd: padding,
				verticalAlign: "top",
				[skeletonAvatarCls]: {
					display: "inline-block",
					verticalAlign: "top",
					background: gradientFromColor,
					...genSkeletonElementSize(controlHeight)
				},
				[`${skeletonAvatarCls}-circle`]: { borderRadius: "50%" },
				[`${skeletonAvatarCls}-lg`]: { ...genSkeletonElementSize(controlHeightLG) },
				[`${skeletonAvatarCls}-sm`]: { ...genSkeletonElementSize(controlHeightSM) }
			},
			[`${componentCls}-section`]: {
				display: "table-cell",
				width: "100%",
				verticalAlign: "top",
				[skeletonTitleCls]: {
					width: "100%",
					height: titleHeight,
					background: gradientFromColor,
					borderRadius: blockRadius,
					[`+ ${skeletonParagraphCls}`]: { marginBlockStart: controlHeightSM }
				},
				[skeletonParagraphCls]: {
					padding: 0,
					"> li": {
						width: "100%",
						height: paragraphLiHeight,
						listStyle: "none",
						background: gradientFromColor,
						borderRadius: blockRadius,
						"+ li": { marginBlockStart: controlHeightXS }
					}
				},
				[`${skeletonParagraphCls}> li:last-child:not(:first-child):not(:nth-child(2))`]: { width: "61%" }
			},
			[`&-round ${componentCls}-section`]: { [`${skeletonTitleCls}, ${skeletonParagraphCls} > li`]: { borderRadius } }
		},
		[`${componentCls}-with-avatar ${componentCls}-section`]: { [skeletonTitleCls]: {
			marginBlockStart: marginSM,
			[`+ ${skeletonParagraphCls}`]: { marginBlockStart: paragraphMarginTop }
		} },
		[`${componentCls}${componentCls}-element`]: {
			display: "inline-block",
			width: "auto",
			...genSkeletonElementButton(token$1),
			...genSkeletonElementAvatar(token$1),
			...genSkeletonElementInput(token$1),
			...genSkeletonElementNode(token$1),
			...genSkeletonElementImage(token$1)
		},
		[`${componentCls}${componentCls}-block`]: {
			width: "100%",
			[skeletonButtonCls]: { width: "100%" },
			[skeletonInputCls]: { width: "100%" }
		},
		[`${componentCls}${componentCls}-active`]: { [`
        ${skeletonTitleCls},
        ${skeletonParagraphCls} > li,
        ${skeletonAvatarCls},
        ${skeletonButtonCls},
        ${skeletonInputCls},
        ${skeletonNodeCls},
        ${skeletonImageCls}
      `]: { ...genSkeletonColor(token$1) } }
	};
};
const prepareComponentToken$51 = (token$1) => {
	const { colorFillContent, colorFill } = token$1;
	const gradientFromColor = colorFillContent;
	const gradientToColor = colorFill;
	return {
		color: gradientFromColor,
		colorGradientEnd: gradientToColor,
		gradientFromColor,
		gradientToColor,
		titleHeight: token$1.controlHeight / 2,
		blockRadius: token$1.borderRadiusSM,
		paragraphMarginTop: token$1.marginLG + token$1.marginXXS,
		paragraphLiHeight: token$1.controlHeight / 2
	};
};
var style_default$57 = genStyleHooks("Skeleton", (token$1) => {
	const { componentCls, calc } = token$1;
	return genBaseStyle$16(merge(token$1, {
		skeletonAvatarCls: `${componentCls}-avatar`,
		skeletonTitleCls: `${componentCls}-title`,
		skeletonParagraphCls: `${componentCls}-paragraph`,
		skeletonButtonCls: `${componentCls}-button`,
		skeletonInputCls: `${componentCls}-input`,
		skeletonNodeCls: `${componentCls}-node`,
		skeletonImageCls: `${componentCls}-image`,
		imageSizeBase: calc(token$1.controlHeight).mul(1.5).equal(),
		borderRadius: 100,
		skeletonLoadingBackground: `linear-gradient(90deg, ${token$1.gradientFromColor} 25%, ${token$1.gradientToColor} 37%, ${token$1.gradientFromColor} 63%)`,
		skeletonLoadingMotionDuration: "1.4s"
	}));
}, prepareComponentToken$51, { deprecatedTokens: [["color", "gradientFromColor"], ["colorGradientEnd", "gradientToColor"]] });

//#endregion
//#region node_modules/antd/es/skeleton/Avatar.js
var SkeletonAvatar = (props) => {
	const { prefixCls: customizePrefixCls, className, classNames, rootClassName, active, style: style$1, styles, shape = "circle", size = "default", ...rest } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$57(prefixCls);
	const cls = clsx(prefixCls, `${prefixCls}-element`, { [`${prefixCls}-active`]: active }, classNames?.root, className, rootClassName, hashId, cssVarCls);
	return /* @__PURE__ */ import_react.createElement("div", {
		className: cls,
		style: styles?.root
	}, /* @__PURE__ */ import_react.createElement(Element_default, {
		prefixCls: `${prefixCls}-avatar`,
		className: classNames?.content,
		style: {
			...styles?.content,
			...style$1
		},
		shape,
		size,
		...rest
	}));
};
var Avatar_default$1 = SkeletonAvatar;

//#endregion
//#region node_modules/antd/es/skeleton/Button.js
var SkeletonButton = (props) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, classNames, active, style: style$1, styles, block = false, size = "default", ...rest } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$57(prefixCls);
	const cls = clsx(prefixCls, `${prefixCls}-element`, {
		[`${prefixCls}-active`]: active,
		[`${prefixCls}-block`]: block
	}, classNames?.root, className, rootClassName, hashId, cssVarCls);
	return /* @__PURE__ */ import_react.createElement("div", {
		className: cls,
		style: styles?.root
	}, /* @__PURE__ */ import_react.createElement(Element_default, {
		prefixCls: `${prefixCls}-button`,
		className: classNames?.content,
		style: {
			...styles?.content,
			...style$1
		},
		size,
		...rest
	}));
};
var Button_default$1 = SkeletonButton;

//#endregion
//#region node_modules/antd/es/skeleton/Node.js
var SkeletonNode = (props) => {
	const { prefixCls: customizePrefixCls, className, classNames, rootClassName, internalClassName, style: style$1, styles, active, children } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$57(prefixCls);
	const cls = clsx(prefixCls, `${prefixCls}-element`, { [`${prefixCls}-active`]: active }, hashId, classNames?.root, className, rootClassName, cssVarCls);
	return /* @__PURE__ */ import_react.createElement("div", {
		className: cls,
		style: styles?.root
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(classNames?.content, internalClassName || `${prefixCls}-node`),
		style: {
			...styles?.content,
			...style$1
		}
	}, children));
};
var Node_default = SkeletonNode;

//#endregion
//#region node_modules/antd/es/skeleton/Image.js
var path = "M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z";
var SkeletonImage = (props) => {
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("skeleton", props.prefixCls);
	return /* @__PURE__ */ import_react.createElement(Node_default, {
		...props,
		internalClassName: `${prefixCls}-image`
	}, /* @__PURE__ */ import_react.createElement("svg", {
		viewBox: "0 0 1098 1024",
		xmlns: "http://www.w3.org/2000/svg",
		className: `${prefixCls}-image-svg`
	}, /* @__PURE__ */ import_react.createElement("title", null, "Image placeholder"), /* @__PURE__ */ import_react.createElement("path", {
		d: path,
		className: `${prefixCls}-image-path`
	})));
};
var Image_default$1 = SkeletonImage;

//#endregion
//#region node_modules/antd/es/skeleton/Input.js
var SkeletonInput = (props) => {
	const { prefixCls: customizePrefixCls, className, classNames, rootClassName, active, block, style: style$1, styles, size = "default", ...rest } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$57(prefixCls);
	const cls = clsx(prefixCls, `${prefixCls}-element`, {
		[`${prefixCls}-active`]: active,
		[`${prefixCls}-block`]: block
	}, classNames?.root, className, rootClassName, hashId, cssVarCls);
	return /* @__PURE__ */ import_react.createElement("div", {
		className: cls,
		style: styles?.root
	}, /* @__PURE__ */ import_react.createElement(Element_default, {
		prefixCls: `${prefixCls}-input`,
		className: classNames?.content,
		style: {
			...styles?.content,
			...style$1
		},
		size,
		...rest
	}));
};
var Input_default$4 = SkeletonInput;

//#endregion
//#region node_modules/antd/es/skeleton/Paragraph.js
var getWidth$1 = (index$1, props) => {
	const { width, rows = 2 } = props;
	if (Array.isArray(width)) return width[index$1];
	if (rows - 1 === index$1) return width;
};
var Paragraph$1 = (props) => {
	const { prefixCls, className, style: style$1, rows = 0 } = props;
	const rowList = Array.from({ length: rows }).map((_, index$1) => /* @__PURE__ */ import_react.createElement("li", {
		key: index$1,
		style: { width: getWidth$1(index$1, props) }
	}));
	return /* @__PURE__ */ import_react.createElement("ul", {
		className: clsx(prefixCls, className),
		style: style$1
	}, rowList);
};
var Paragraph_default$1 = Paragraph$1;

//#endregion
//#region node_modules/antd/es/skeleton/Title.js
var Title$1 = ({ prefixCls, className, width, style: style$1 }) => /* @__PURE__ */ import_react.createElement("h3", {
	className: clsx(prefixCls, className),
	style: {
		width,
		...style$1
	}
});
var Title_default$1 = Title$1;

//#endregion
//#region node_modules/antd/es/skeleton/Skeleton.js
function getComponentProps(prop) {
	if (prop && typeof prop === "object") return prop;
	return {};
}
function getAvatarBasicProps(hasTitle, hasParagraph) {
	if (hasTitle && !hasParagraph) return {
		size: "large",
		shape: "square"
	};
	return {
		size: "large",
		shape: "circle"
	};
}
function getTitleBasicProps(hasAvatar, hasParagraph) {
	if (!hasAvatar && hasParagraph) return { width: "38%" };
	if (hasAvatar && hasParagraph) return { width: "50%" };
	return {};
}
function getParagraphBasicProps(hasAvatar, hasTitle) {
	const basicProps = {};
	if (!hasAvatar || !hasTitle) basicProps.width = "61%";
	if (!hasAvatar && hasTitle) basicProps.rows = 3;
	else basicProps.rows = 2;
	return basicProps;
}
var Skeleton = (props) => {
	const { prefixCls: customizePrefixCls, loading, className, rootClassName, classNames, style: style$1, styles, children, avatar = false, title = true, paragraph = true, active, round } = props;
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("skeleton");
	const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$57(prefixCls);
	const mergedProps = {
		...props,
		avatar,
		title,
		paragraph
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	if (loading || !("loading" in props)) {
		const hasAvatar = !!avatar;
		const hasTitle = !!title;
		const hasParagraph = !!paragraph;
		let avatarNode;
		if (hasAvatar) {
			const avatarProps = {
				className: mergedClassNames.avatar,
				prefixCls: `${prefixCls}-avatar`,
				...getAvatarBasicProps(hasTitle, hasParagraph),
				...getComponentProps(avatar),
				style: mergedStyles.avatar
			};
			avatarNode = /* @__PURE__ */ import_react.createElement("div", {
				className: clsx(mergedClassNames.header, `${prefixCls}-header`),
				style: mergedStyles.header
			}, /* @__PURE__ */ import_react.createElement(Element_default, { ...avatarProps }));
		}
		let contentNode;
		if (hasTitle || hasParagraph) {
			let $title;
			if (hasTitle) {
				const titleProps = {
					className: mergedClassNames.title,
					prefixCls: `${prefixCls}-title`,
					...getTitleBasicProps(hasAvatar, hasParagraph),
					...getComponentProps(title),
					style: mergedStyles.title
				};
				$title = /* @__PURE__ */ import_react.createElement(Title_default$1, { ...titleProps });
			}
			let paragraphNode;
			if (hasParagraph) {
				const paragraphProps = {
					className: mergedClassNames.paragraph,
					prefixCls: `${prefixCls}-paragraph`,
					...getParagraphBasicProps(hasAvatar, hasTitle),
					...getComponentProps(paragraph),
					style: mergedStyles.paragraph
				};
				paragraphNode = /* @__PURE__ */ import_react.createElement(Paragraph_default$1, { ...paragraphProps });
			}
			contentNode = /* @__PURE__ */ import_react.createElement("div", {
				className: clsx(mergedClassNames.section, `${prefixCls}-section`),
				style: mergedStyles.section
			}, $title, paragraphNode);
		}
		const cls = clsx(prefixCls, {
			[`${prefixCls}-with-avatar`]: hasAvatar,
			[`${prefixCls}-active`]: active,
			[`${prefixCls}-rtl`]: direction === "rtl",
			[`${prefixCls}-round`]: round
		}, mergedClassNames.root, contextClassName, className, rootClassName, hashId, cssVarCls);
		return /* @__PURE__ */ import_react.createElement("div", {
			className: cls,
			style: {
				...mergedStyles.root,
				...contextStyle,
				...style$1
			}
		}, avatarNode, contentNode);
	}
	return children ?? null;
};
Skeleton.Button = Button_default$1;
Skeleton.Avatar = Avatar_default$1;
Skeleton.Input = Input_default$4;
Skeleton.Image = Image_default$1;
Skeleton.Node = Node_default;
Skeleton.displayName = "Skeleton";
var Skeleton_default = Skeleton;

//#endregion
//#region node_modules/antd/es/skeleton/index.js
var skeleton_default = Skeleton_default;

//#endregion
//#region node_modules/antd/es/watermark/context.js
function voidFunc() {}
var WatermarkContext = /* @__PURE__ */ import_react.createContext({
	add: voidFunc,
	remove: voidFunc
});
function usePanelRef(panelSelector) {
	const watermark = import_react.useContext(WatermarkContext);
	const panelEleRef = import_react.useRef(null);
	return useEvent_default((ele) => {
		if (ele) {
			const innerContentEle = panelSelector ? ele.querySelector(panelSelector) : ele;
			if (innerContentEle) {
				watermark.add(innerContentEle);
				panelEleRef.current = innerContentEle;
			}
		} else watermark.remove(panelEleRef.current);
	});
}
var context_default = WatermarkContext;

//#endregion
//#region node_modules/antd/es/modal/components/NormalCancelBtn.js
var NormalCancelBtn = () => {
	const { cancelButtonProps, cancelTextLocale, onCancel } = (0, import_react.useContext)(ModalContext);
	return /* @__PURE__ */ import_react.createElement(Button_default, {
		onClick: onCancel,
		...cancelButtonProps
	}, cancelTextLocale);
};
var NormalCancelBtn_default = NormalCancelBtn;

//#endregion
//#region node_modules/antd/es/modal/components/NormalOkBtn.js
var NormalOkBtn = () => {
	const { confirmLoading, okButtonProps, okType, okTextLocale, onOk } = (0, import_react.useContext)(ModalContext);
	return /* @__PURE__ */ import_react.createElement(Button_default, {
		...convertLegacyProps(okType),
		loading: confirmLoading,
		onClick: onOk,
		...okButtonProps
	}, okTextLocale);
};
var NormalOkBtn_default = NormalOkBtn;

//#endregion
//#region node_modules/antd/es/modal/shared.js
function renderCloseIcon(prefixCls, closeIcon) {
	return /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-close-x` }, closeIcon || /* @__PURE__ */ import_react.createElement(CloseOutlined_default, { className: `${prefixCls}-close-icon` }));
}
const Footer$1 = (props) => {
	const { okText, okType = "primary", cancelText, confirmLoading, onOk, onCancel, okButtonProps, cancelButtonProps, footer } = props;
	const [locale$5] = useLocale_default("Modal", getConfirmLocale());
	const okTextLocale = okText || locale$5?.okText;
	const cancelTextLocale = cancelText || locale$5?.cancelText;
	const memoizedValue = import_react.useMemo(() => {
		return {
			confirmLoading,
			okButtonProps,
			cancelButtonProps,
			okTextLocale,
			cancelTextLocale,
			okType,
			onOk,
			onCancel
		};
	}, [
		confirmLoading,
		okButtonProps,
		cancelButtonProps,
		okTextLocale,
		cancelTextLocale,
		okType,
		onOk,
		onCancel
	]);
	let footerNode;
	if (typeof footer === "function" || typeof footer === "undefined") {
		footerNode = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(NormalCancelBtn_default, null), /* @__PURE__ */ import_react.createElement(NormalOkBtn_default, null));
		if (typeof footer === "function") footerNode = footer(footerNode, {
			OkBtn: NormalOkBtn_default,
			CancelBtn: NormalCancelBtn_default
		});
		footerNode = /* @__PURE__ */ import_react.createElement(ModalContextProvider, { value: memoizedValue }, footerNode);
	} else footerNode = footer;
	return /* @__PURE__ */ import_react.createElement(DisabledContextProvider, { disabled: false }, footerNode);
};

//#endregion
//#region node_modules/antd/es/grid/style/index.js
var genGridRowStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: {
		display: "flex",
		flexFlow: "row wrap",
		minWidth: 0,
		"&::before, &::after": { display: "flex" },
		"&-no-wrap": { flexWrap: "nowrap" },
		"&-start": { justifyContent: "flex-start" },
		"&-center": { justifyContent: "center" },
		"&-end": { justifyContent: "flex-end" },
		"&-space-between": { justifyContent: "space-between" },
		"&-space-around": { justifyContent: "space-around" },
		"&-space-evenly": { justifyContent: "space-evenly" },
		"&-top": { alignItems: "flex-start" },
		"&-middle": { alignItems: "center" },
		"&-bottom": { alignItems: "flex-end" }
	} };
};
var genGridColStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: {
		position: "relative",
		maxWidth: "100%",
		minHeight: 1
	} };
};
var genLoopGridColumnsStyle = (token$1, sizeCls) => {
	const { prefixCls, componentCls, gridColumns } = token$1;
	const gridColumnsStyle = {};
	for (let i = gridColumns; i >= 0; i--) if (i === 0) {
		gridColumnsStyle[`${componentCls}${sizeCls}-${i}`] = { display: "none" };
		gridColumnsStyle[`${componentCls}-push-${i}`] = { insetInlineStart: "auto" };
		gridColumnsStyle[`${componentCls}-pull-${i}`] = { insetInlineEnd: "auto" };
		gridColumnsStyle[`${componentCls}${sizeCls}-push-${i}`] = { insetInlineStart: "auto" };
		gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i}`] = { insetInlineEnd: "auto" };
		gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i}`] = { marginInlineStart: 0 };
		gridColumnsStyle[`${componentCls}${sizeCls}-order-${i}`] = { order: 0 };
	} else {
		gridColumnsStyle[`${componentCls}${sizeCls}-${i}`] = [{
			["--ant-display"]: "block",
			display: "block"
		}, {
			display: "var(--ant-display)",
			flex: `0 0 ${i / gridColumns * 100}%`,
			maxWidth: `${i / gridColumns * 100}%`
		}];
		gridColumnsStyle[`${componentCls}${sizeCls}-push-${i}`] = { insetInlineStart: `${i / gridColumns * 100}%` };
		gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i}`] = { insetInlineEnd: `${i / gridColumns * 100}%` };
		gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i}`] = { marginInlineStart: `${i / gridColumns * 100}%` };
		gridColumnsStyle[`${componentCls}${sizeCls}-order-${i}`] = { order: i };
	}
	gridColumnsStyle[`${componentCls}${sizeCls}-flex`] = { flex: `var(--${prefixCls}${sizeCls}-flex)` };
	return gridColumnsStyle;
};
var genGridStyle = (token$1, sizeCls) => genLoopGridColumnsStyle(token$1, sizeCls);
var genGridMediaStyle = (token$1, screenSize, sizeCls) => ({ [`@media (min-width: ${unit(screenSize)})`]: { ...genGridStyle(token$1, sizeCls) } });
const prepareRowComponentToken = () => ({});
const prepareColComponentToken = () => ({});
const useRowStyle = genStyleHooks("Grid", genGridRowStyle, prepareRowComponentToken);
const getMediaSize = (token$1) => {
	return {
		xs: token$1.screenXSMin,
		sm: token$1.screenSMMin,
		md: token$1.screenMDMin,
		lg: token$1.screenLGMin,
		xl: token$1.screenXLMin,
		xxl: token$1.screenXXLMin
	};
};
const useColStyle = genStyleHooks("Grid", (token$1) => {
	const gridToken = merge(token$1, { gridColumns: 24 });
	const gridMediaSizesMap = getMediaSize(gridToken);
	delete gridMediaSizesMap.xs;
	return [
		genGridColStyle(gridToken),
		genGridStyle(gridToken, ""),
		genGridStyle(gridToken, "-xs"),
		Object.keys(gridMediaSizesMap).map((key) => genGridMediaStyle(gridToken, gridMediaSizesMap[key], `-${key}`)).reduce((pre, cur) => ({
			...pre,
			...cur
		}), {})
	];
}, prepareColComponentToken);

//#endregion
//#region node_modules/antd/es/modal/style/index.js
function box(position$2) {
	return {
		position: position$2,
		inset: 0
	};
}
const genModalMaskStyle = (token$1) => {
	const { componentCls, antCls } = token$1;
	return [{ [`${componentCls}-root`]: {
		[`${componentCls}${antCls}-zoom-enter, ${componentCls}${antCls}-zoom-appear`]: {
			transform: "none",
			opacity: 0,
			animationDuration: token$1.motionDurationSlow,
			userSelect: "none"
		},
		[`${componentCls}${antCls}-zoom-leave ${componentCls}-container`]: { pointerEvents: "none" },
		[`${componentCls}-mask`]: {
			...box("fixed"),
			zIndex: token$1.zIndexPopupBase,
			height: "100%",
			backgroundColor: token$1.colorBgMask,
			pointerEvents: "none",
			[`&${componentCls}-mask-blur`]: { backdropFilter: "blur(4px)" },
			[`${componentCls}-hidden`]: { display: "none" }
		},
		[`${componentCls}-wrap`]: {
			...box("fixed"),
			zIndex: token$1.zIndexPopupBase,
			overflow: "auto",
			outline: 0,
			WebkitOverflowScrolling: "touch"
		}
	} }, { [`${componentCls}-root`]: initFadeMotion(token$1) }];
};
var genModalStyle = (token$1) => {
	const { componentCls } = token$1;
	return [
		{ [`${componentCls}-root`]: {
			[`${componentCls}-wrap-rtl`]: { direction: "rtl" },
			[`${componentCls}-centered`]: {
				textAlign: "center",
				"&::before": {
					display: "inline-block",
					width: 0,
					height: "100%",
					verticalAlign: "middle",
					content: "\"\""
				},
				[componentCls]: {
					top: 0,
					display: "inline-block",
					paddingBottom: 0,
					textAlign: "start",
					verticalAlign: "middle"
				}
			},
			[`@media (max-width: ${token$1.screenSMMax}px)`]: {
				[componentCls]: {
					maxWidth: "calc(100vw - 16px)",
					margin: `${unit(token$1.marginXS)} auto`
				},
				[`${componentCls}-centered`]: { [componentCls]: { flex: 1 } }
			}
		} },
		{ [componentCls]: {
			...resetComponent(token$1),
			pointerEvents: "none",
			position: "relative",
			top: 100,
			width: "auto",
			maxWidth: `calc(100vw - ${unit(token$1.calc(token$1.margin).mul(2).equal())})`,
			margin: "0 auto",
			paddingBottom: token$1.paddingLG,
			[`${componentCls}-title`]: {
				margin: 0,
				color: token$1.titleColor,
				fontWeight: token$1.fontWeightStrong,
				fontSize: token$1.titleFontSize,
				lineHeight: token$1.titleLineHeight,
				wordWrap: "break-word"
			},
			[`${componentCls}-container`]: {
				position: "relative",
				backgroundColor: token$1.contentBg,
				backgroundClip: "padding-box",
				border: 0,
				borderRadius: token$1.borderRadiusLG,
				boxShadow: token$1.boxShadow,
				pointerEvents: "auto",
				padding: token$1.contentPadding
			},
			[`${componentCls}-close`]: {
				position: "absolute",
				top: token$1.calc(token$1.modalHeaderHeight).sub(token$1.modalCloseBtnSize).div(2).equal(),
				insetInlineEnd: token$1.calc(token$1.modalHeaderHeight).sub(token$1.modalCloseBtnSize).div(2).equal(),
				zIndex: token$1.calc(token$1.zIndexPopupBase).add(10).equal(),
				padding: 0,
				color: token$1.modalCloseIconColor,
				fontWeight: token$1.fontWeightStrong,
				lineHeight: 1,
				textDecoration: "none",
				background: "transparent",
				borderRadius: token$1.borderRadiusSM,
				width: token$1.modalCloseBtnSize,
				height: token$1.modalCloseBtnSize,
				border: 0,
				outline: 0,
				cursor: "pointer",
				transition: `color ${token$1.motionDurationMid}, background-color ${token$1.motionDurationMid}`,
				"&-x": {
					display: "flex",
					fontSize: token$1.fontSizeLG,
					fontStyle: "normal",
					lineHeight: unit(token$1.modalCloseBtnSize),
					justifyContent: "center",
					textTransform: "none",
					textRendering: "auto"
				},
				"&:disabled": { pointerEvents: "none" },
				"&:hover": {
					color: token$1.modalCloseIconHoverColor,
					backgroundColor: token$1.colorBgTextHover,
					textDecoration: "none"
				},
				"&:active": { backgroundColor: token$1.colorBgTextActive },
				...genFocusStyle(token$1)
			},
			[`${componentCls}-header`]: {
				color: token$1.colorText,
				background: token$1.headerBg,
				borderRadius: `${unit(token$1.borderRadiusLG)} ${unit(token$1.borderRadiusLG)} 0 0`,
				marginBottom: token$1.headerMarginBottom,
				padding: token$1.headerPadding,
				borderBottom: token$1.headerBorderBottom
			},
			[`${componentCls}-body`]: {
				fontSize: token$1.fontSize,
				lineHeight: token$1.lineHeight,
				wordWrap: "break-word",
				padding: token$1.bodyPadding,
				[`${componentCls}-body-skeleton`]: {
					width: "100%",
					height: "100%",
					display: "flex",
					justifyContent: "center",
					alignItems: "center",
					margin: `${unit(token$1.margin)} auto`
				}
			},
			[`${componentCls}-footer`]: {
				textAlign: "end",
				background: token$1.footerBg,
				marginTop: token$1.footerMarginTop,
				padding: token$1.footerPadding,
				borderTop: token$1.footerBorderTop,
				borderRadius: token$1.footerBorderRadius,
				[`> ${token$1.antCls}-btn + ${token$1.antCls}-btn`]: { marginInlineStart: token$1.marginXS }
			},
			[`${componentCls}-open`]: { overflow: "hidden" }
		} },
		{ [`${componentCls}-pure-panel`]: {
			top: "auto",
			padding: 0,
			display: "flex",
			flexDirection: "column",
			[`${componentCls}-container,
          ${componentCls}-body,
          ${componentCls}-confirm-body-wrapper`]: {
				display: "flex",
				flexDirection: "column",
				flex: "auto"
			},
			[`${componentCls}-confirm-body`]: { marginBottom: "auto" }
		} }
	];
};
var genRTLStyle$1 = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-root`]: { [`${componentCls}-wrap-rtl`]: {
		direction: "rtl",
		[`${componentCls}-confirm-body`]: { direction: "rtl" }
	} } };
};
var genResponsiveWidthStyle = (token$1) => {
	const { componentCls } = token$1;
	const oriGridMediaSizesMap = getMediaSize(token$1);
	const gridMediaSizesMap = { ...oriGridMediaSizesMap };
	delete gridMediaSizesMap.xs;
	const cssVarPrefix = `--${componentCls.replace(".", "")}-`;
	const responsiveStyles = Object.keys(gridMediaSizesMap).map((key) => ({ [`@media (min-width: ${unit(gridMediaSizesMap[key])})`]: { width: `var(${cssVarPrefix}${key}-width)` } }));
	return { [`${componentCls}-root`]: { [componentCls]: [].concat(_toConsumableArray(Object.keys(oriGridMediaSizesMap).map((currentKey, index$1) => {
		const previousKey = Object.keys(oriGridMediaSizesMap)[index$1 - 1];
		return previousKey ? { [`${cssVarPrefix}${currentKey}-width`]: `var(${cssVarPrefix}${previousKey}-width)` } : null;
	})), [{ width: `var(${cssVarPrefix}xs-width)` }], _toConsumableArray(responsiveStyles)) } };
};
const prepareToken$4 = (token$1) => {
	const headerPaddingVertical = token$1.padding;
	const headerFontSize = token$1.fontSizeHeading5;
	const headerLineHeight = token$1.lineHeightHeading5;
	return merge(token$1, {
		modalHeaderHeight: token$1.calc(token$1.calc(headerLineHeight).mul(headerFontSize).equal()).add(token$1.calc(headerPaddingVertical).mul(2).equal()).equal(),
		modalFooterBorderColorSplit: token$1.colorSplit,
		modalFooterBorderStyle: token$1.lineType,
		modalFooterBorderWidth: token$1.lineWidth,
		modalCloseIconColor: token$1.colorIcon,
		modalCloseIconHoverColor: token$1.colorIconHover,
		modalCloseBtnSize: token$1.controlHeight,
		modalConfirmIconSize: token$1.fontHeight,
		modalTitleHeight: token$1.calc(token$1.titleFontSize).mul(token$1.titleLineHeight).equal()
	});
};
const prepareComponentToken$50 = (token$1) => ({
	footerBg: "transparent",
	headerBg: "transparent",
	titleLineHeight: token$1.lineHeightHeading5,
	titleFontSize: token$1.fontSizeHeading5,
	contentBg: token$1.colorBgElevated,
	titleColor: token$1.colorTextHeading,
	contentPadding: token$1.wireframe ? 0 : `${unit(token$1.paddingMD)} ${unit(token$1.paddingContentHorizontalLG)}`,
	headerPadding: token$1.wireframe ? `${unit(token$1.padding)} ${unit(token$1.paddingLG)}` : 0,
	headerBorderBottom: token$1.wireframe ? `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}` : "none",
	headerMarginBottom: token$1.wireframe ? 0 : token$1.marginXS,
	bodyPadding: token$1.wireframe ? token$1.paddingLG : 0,
	footerPadding: token$1.wireframe ? `${unit(token$1.paddingXS)} ${unit(token$1.padding)}` : 0,
	footerBorderTop: token$1.wireframe ? `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}` : "none",
	footerBorderRadius: token$1.wireframe ? `0 0 ${unit(token$1.borderRadiusLG)} ${unit(token$1.borderRadiusLG)}` : 0,
	footerMarginTop: token$1.wireframe ? 0 : token$1.marginSM,
	confirmBodyPadding: token$1.wireframe ? `${unit(token$1.padding * 2)} ${unit(token$1.padding * 2)} ${unit(token$1.paddingLG)}` : 0,
	confirmIconMarginInlineEnd: token$1.wireframe ? token$1.margin : token$1.marginSM,
	confirmBtnsMarginTop: token$1.wireframe ? token$1.marginLG : token$1.marginSM,
	mask: true
});
var style_default$18 = genStyleHooks("Modal", (token$1) => {
	const modalToken = prepareToken$4(token$1);
	return [
		genModalStyle(modalToken),
		genRTLStyle$1(modalToken),
		genModalMaskStyle(modalToken),
		initZoomMotion(modalToken, "zoom"),
		genResponsiveWidthStyle(modalToken)
	];
}, prepareComponentToken$50, { unitless: { titleLineHeight: true } });

//#endregion
//#region node_modules/antd/es/modal/Modal.js
var mousePosition;
var getClickPosition = (e$2) => {
	mousePosition = {
		x: e$2.pageX,
		y: e$2.pageY
	};
	setTimeout(() => {
		mousePosition = null;
	}, 100);
};
if (canUseDocElement()) document.documentElement.addEventListener("click", getClickPosition, true);
var Modal$1 = (props) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, open: open$2, wrapClassName, centered, getContainer, focusTriggerAfterClose = true, style: style$1, width = 520, footer, classNames, styles, children, loading, confirmLoading, zIndex: customizeZIndex, mousePosition: customizeMousePosition, onOk, onCancel, okButtonProps, cancelButtonProps, destroyOnHidden, destroyOnClose, panelRef = null, closable, mask: modalMask, modalRender, ...restProps } = props;
	const { getPopupContainer: getContextPopupContainer, getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles, centered: contextCentered, cancelButtonProps: contextCancelButtonProps, okButtonProps: contextOkButtonProps, mask: contextMask } = useComponentConfig("modal");
	const { modal: modalContext } = import_react.useContext(ConfigContext);
	const [closableAfterclose, onClose] = import_react.useMemo(() => {
		if (typeof closable === "boolean") return [void 0, void 0];
		return [closable?.afterClose, closable?.onClose];
	}, [closable]);
	const prefixCls = getPrefixCls("modal", customizePrefixCls);
	const rootPrefixCls = getPrefixCls();
	const [mergedMask, maskBlurClassName] = useMergedMask(modalMask, contextMask, prefixCls);
	const handleCancel = (e$2) => {
		if (confirmLoading) return;
		onCancel?.(e$2);
		onClose?.();
	};
	const handleOk = (e$2) => {
		onOk?.(e$2);
		onClose?.();
	};
	{
		const warning$3 = devUseWarning("Modal");
		[
			["bodyStyle", "styles.body"],
			["maskStyle", "styles.mask"],
			["destroyOnClose", "destroyOnHidden"]
		].forEach(([deprecatedName, newName]) => {
			warning$3.deprecated(!(deprecatedName in props), deprecatedName, newName);
		});
	}
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$18(prefixCls, rootCls);
	const wrapClassNameExtended = clsx(wrapClassName, {
		[`${prefixCls}-centered`]: centered ?? contextCentered,
		[`${prefixCls}-wrap-rtl`]: direction === "rtl"
	});
	const dialogFooter = footer !== null && !loading ? /* @__PURE__ */ import_react.createElement(Footer$1, {
		...props,
		okButtonProps: {
			...contextOkButtonProps,
			...okButtonProps
		},
		onOk: handleOk,
		cancelButtonProps: {
			...contextCancelButtonProps,
			...cancelButtonProps
		},
		onCancel: handleCancel
	}) : null;
	const [rawClosable, mergedCloseIcon, closeBtnIsDisabled, ariaProps] = useClosable(pickClosable(props), pickClosable(modalContext), {
		closable: true,
		closeIcon: /* @__PURE__ */ import_react.createElement(CloseOutlined_default, { className: `${prefixCls}-close-icon` }),
		closeIconRender: (icon) => renderCloseIcon(prefixCls, icon)
	});
	const mergedClosable = rawClosable ? {
		disabled: closeBtnIsDisabled,
		closeIcon: mergedCloseIcon,
		afterClose: closableAfterclose,
		...ariaProps
	} : false;
	const mergedModalRender = modalRender ? (node$1) => /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-render` }, modalRender(node$1)) : void 0;
	const mergedPanelRef = composeRef(panelRef, usePanelRef(`.${prefixCls}-${modalRender ? "render" : "container"}`));
	const [zIndex, contextZIndex] = useZIndex("Modal", customizeZIndex);
	const mergedProps = {
		...props,
		width,
		panelRef,
		focusTriggerAfterClose,
		mask: mergedMask,
		zIndex
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([
		contextClassNames,
		classNames,
		maskBlurClassName
	], [contextStyles, styles], { props: mergedProps });
	const [numWidth, responsiveWidth] = import_react.useMemo(() => {
		if (width && typeof width === "object") return [void 0, width];
		return [width, void 0];
	}, [width]);
	const responsiveWidthVars = import_react.useMemo(() => {
		const vars = {};
		if (responsiveWidth) Object.keys(responsiveWidth).forEach((breakpoint) => {
			const breakpointWidth = responsiveWidth[breakpoint];
			if (breakpointWidth !== void 0) vars[`--${prefixCls}-${breakpoint}-width`] = typeof breakpointWidth === "number" ? `${breakpointWidth}px` : breakpointWidth;
		});
		return vars;
	}, [prefixCls, responsiveWidth]);
	return /* @__PURE__ */ import_react.createElement(ContextIsolator_default, {
		form: true,
		space: true
	}, /* @__PURE__ */ import_react.createElement(zindexContext_default.Provider, { value: contextZIndex }, /* @__PURE__ */ import_react.createElement(es_default$33, {
		width: numWidth,
		...restProps,
		zIndex,
		getContainer: getContainer === void 0 ? getContextPopupContainer : getContainer,
		prefixCls,
		rootClassName: clsx(hashId, rootClassName, cssVarCls, rootCls, mergedClassNames.root),
		rootStyle: mergedStyles.root,
		footer: dialogFooter,
		visible: open$2,
		mousePosition: customizeMousePosition ?? mousePosition,
		onClose: handleCancel,
		closable: mergedClosable,
		closeIcon: mergedCloseIcon,
		focusTriggerAfterClose,
		transitionName: getTransitionName(rootPrefixCls, "zoom", props.transitionName),
		maskTransitionName: getTransitionName(rootPrefixCls, "fade", props.maskTransitionName),
		mask: mergedMask,
		className: clsx(hashId, className, contextClassName),
		style: {
			...contextStyle,
			...style$1,
			...responsiveWidthVars
		},
		classNames: {
			...mergedClassNames,
			wrapper: clsx(mergedClassNames.wrapper, wrapClassNameExtended)
		},
		styles: mergedStyles,
		panelRef: mergedPanelRef,
		destroyOnHidden: destroyOnHidden ?? destroyOnClose,
		modalRender: mergedModalRender
	}, loading ? /* @__PURE__ */ import_react.createElement(skeleton_default, {
		active: true,
		title: false,
		paragraph: { rows: 4 },
		className: `${prefixCls}-body-skeleton`
	}) : children)));
};
var Modal_default = Modal$1;

//#endregion
//#region node_modules/antd/es/modal/style/confirm.js
var genModalConfirmStyle = (token$1) => {
	const { componentCls, titleFontSize, titleLineHeight, modalConfirmIconSize, fontSize, lineHeight, modalTitleHeight, fontHeight, confirmBodyPadding } = token$1;
	const confirmComponentCls = `${componentCls}-confirm`;
	return {
		[confirmComponentCls]: {
			"&-rtl": { direction: "rtl" },
			[`${token$1.antCls}-modal-header`]: { display: "none" },
			[`${confirmComponentCls}-body-wrapper`]: { ...clearFix() },
			[`&${componentCls} ${componentCls}-body`]: { padding: confirmBodyPadding },
			[`${confirmComponentCls}-body`]: {
				display: "flex",
				flexWrap: "nowrap",
				alignItems: "start",
				[`> ${token$1.iconCls}`]: {
					flex: "none",
					fontSize: modalConfirmIconSize,
					marginInlineEnd: token$1.confirmIconMarginInlineEnd,
					marginTop: token$1.calc(token$1.calc(fontHeight).sub(modalConfirmIconSize).equal()).div(2).equal()
				},
				[`&-has-title > ${token$1.iconCls}`]: { marginTop: token$1.calc(token$1.calc(modalTitleHeight).sub(modalConfirmIconSize).equal()).div(2).equal() }
			},
			[`${confirmComponentCls}-paragraph`]: {
				display: "flex",
				flexDirection: "column",
				flex: "auto",
				rowGap: token$1.marginXS,
				maxWidth: `calc(100% - ${unit(token$1.marginSM)})`
			},
			[`${token$1.iconCls} + ${confirmComponentCls}-paragraph`]: { maxWidth: `calc(100% - ${unit(token$1.calc(token$1.modalConfirmIconSize).add(token$1.marginSM).equal())})` },
			[`${confirmComponentCls}-title`]: {
				color: token$1.colorTextHeading,
				fontWeight: token$1.fontWeightStrong,
				fontSize: titleFontSize,
				lineHeight: titleLineHeight
			},
			[`${confirmComponentCls}-container`]: {
				color: token$1.colorText,
				fontSize,
				lineHeight
			},
			[`${confirmComponentCls}-btns`]: {
				textAlign: "end",
				marginTop: token$1.confirmBtnsMarginTop,
				[`${token$1.antCls}-btn + ${token$1.antCls}-btn`]: {
					marginBottom: 0,
					marginInlineStart: token$1.marginXS
				}
			}
		},
		[`${confirmComponentCls}-error ${confirmComponentCls}-body > ${token$1.iconCls}`]: { color: token$1.colorError },
		[`${confirmComponentCls}-warning ${confirmComponentCls}-body > ${token$1.iconCls},
        ${confirmComponentCls}-confirm ${confirmComponentCls}-body > ${token$1.iconCls}`]: { color: token$1.colorWarning },
		[`${confirmComponentCls}-info ${confirmComponentCls}-body > ${token$1.iconCls}`]: { color: token$1.colorInfo },
		[`${confirmComponentCls}-success ${confirmComponentCls}-body > ${token$1.iconCls}`]: { color: token$1.colorSuccess }
	};
};
var confirm_default = genSubStyleComponent(["Modal", "confirm"], (token$1) => {
	return genModalConfirmStyle(prepareToken$4(token$1));
}, prepareComponentToken$50, { order: -1e3 });

//#endregion
//#region node_modules/antd/es/modal/ConfirmDialog.js
const ConfirmContent = (props) => {
	const { prefixCls, icon, okText, cancelText, confirmPrefixCls, type: type$2, okCancel, footer, locale: staticLocale, ...restProps } = props;
	devUseWarning("Modal")(!(typeof icon === "string" && icon.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${icon}\` at https://ant.design/components/icon`);
	let mergedIcon = icon;
	if (!icon && icon !== null) switch (type$2) {
		case "info":
			mergedIcon = /* @__PURE__ */ import_react.createElement(InfoCircleFilled_default, null);
			break;
		case "success":
			mergedIcon = /* @__PURE__ */ import_react.createElement(CheckCircleFilled_default, null);
			break;
		case "error":
			mergedIcon = /* @__PURE__ */ import_react.createElement(CloseCircleFilled_default, null);
			break;
		default: mergedIcon = /* @__PURE__ */ import_react.createElement(ExclamationCircleFilled_default, null);
	}
	const mergedOkCancel = okCancel ?? type$2 === "confirm";
	const autoFocusButton = props.autoFocusButton === null ? false : props.autoFocusButton || "ok";
	const [locale$5] = useLocale_default("Modal");
	const mergedLocale = staticLocale || locale$5;
	const okTextLocale = okText || (mergedOkCancel ? mergedLocale?.okText : mergedLocale?.justOkText);
	const cancelTextLocale = cancelText || mergedLocale?.cancelText;
	const { closable } = restProps;
	const { onClose } = closable && typeof closable === "object" ? closable : {};
	const memoizedValue = import_react.useMemo(() => {
		return {
			autoFocusButton,
			cancelTextLocale,
			okTextLocale,
			mergedOkCancel,
			onClose,
			...restProps
		};
	}, [
		autoFocusButton,
		cancelTextLocale,
		okTextLocale,
		mergedOkCancel,
		onClose,
		restProps
	]);
	const footerOriginNode = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(ConfirmCancelBtn_default, null), /* @__PURE__ */ import_react.createElement(ConfirmOkBtn_default, null));
	const hasTitle = props.title !== void 0 && props.title !== null;
	const bodyCls = `${confirmPrefixCls}-body`;
	return /* @__PURE__ */ import_react.createElement("div", { className: `${confirmPrefixCls}-body-wrapper` }, /* @__PURE__ */ import_react.createElement("div", { className: clsx(bodyCls, { [`${bodyCls}-has-title`]: hasTitle }) }, mergedIcon, /* @__PURE__ */ import_react.createElement("div", { className: `${confirmPrefixCls}-paragraph` }, hasTitle && /* @__PURE__ */ import_react.createElement("span", { className: `${confirmPrefixCls}-title` }, props.title), /* @__PURE__ */ import_react.createElement("div", { className: `${confirmPrefixCls}-content` }, props.content))), footer === void 0 || typeof footer === "function" ? /* @__PURE__ */ import_react.createElement(ModalContextProvider, { value: memoizedValue }, /* @__PURE__ */ import_react.createElement("div", { className: `${confirmPrefixCls}-btns` }, typeof footer === "function" ? footer(footerOriginNode, {
		OkBtn: ConfirmOkBtn_default,
		CancelBtn: ConfirmCancelBtn_default
	}) : footerOriginNode)) : footer, /* @__PURE__ */ import_react.createElement(confirm_default, { prefixCls }));
};
var ConfirmDialog = (props) => {
	const { close, zIndex, maskStyle, direction, prefixCls, wrapClassName, rootPrefixCls, bodyStyle, closable = false, onConfirm, styles, title, okButtonProps, cancelButtonProps } = props;
	const { cancelButtonProps: contextCancelButtonProps, okButtonProps: contextOkButtonProps } = useComponentConfig("modal");
	{
		const warning$3 = devUseWarning("Modal");
		[["bodyStyle", "styles.body"], ["maskStyle", "styles.mask"]].forEach(([deprecatedName, newName]) => {
			warning$3.deprecated(!(deprecatedName in props), deprecatedName, newName);
		});
	}
	const confirmPrefixCls = `${prefixCls}-confirm`;
	const width = props.width || 416;
	const style$1 = props.style || {};
	const maskClosable = props.maskClosable === void 0 ? false : props.maskClosable;
	const classString = clsx(confirmPrefixCls, `${confirmPrefixCls}-${props.type}`, { [`${confirmPrefixCls}-rtl`]: direction === "rtl" }, props.className);
	const [, token$1] = useToken();
	const mergedZIndex = import_react.useMemo(() => {
		if (zIndex !== void 0) return zIndex;
		return token$1.zIndexPopupBase + CONTAINER_MAX_OFFSET;
	}, [zIndex, token$1]);
	return /* @__PURE__ */ import_react.createElement(Modal_default, {
		...props,
		className: classString,
		wrapClassName: clsx({ [`${confirmPrefixCls}-centered`]: !!props.centered }, wrapClassName),
		onCancel: () => {
			close?.({ triggerCancel: true });
			onConfirm?.(false);
		},
		title,
		footer: null,
		transitionName: getTransitionName(rootPrefixCls || "", "zoom", props.transitionName),
		maskTransitionName: getTransitionName(rootPrefixCls || "", "fade", props.maskTransitionName),
		maskClosable,
		style: style$1,
		styles: {
			body: bodyStyle,
			mask: maskStyle,
			...styles
		},
		width,
		zIndex: mergedZIndex,
		closable
	}, /* @__PURE__ */ import_react.createElement(ConfirmContent, {
		...props,
		confirmPrefixCls,
		okButtonProps: {
			...contextOkButtonProps,
			...okButtonProps
		},
		cancelButtonProps: {
			...contextCancelButtonProps,
			...cancelButtonProps
		}
	}));
};
var ConfirmDialogWrapper$1 = (props) => {
	const { rootPrefixCls, iconPrefixCls, direction, theme } = props;
	return /* @__PURE__ */ import_react.createElement(config_provider_default, {
		prefixCls: rootPrefixCls,
		iconPrefixCls,
		direction,
		theme
	}, /* @__PURE__ */ import_react.createElement(ConfirmDialog, { ...props }));
};
ConfirmDialog.displayName = "ConfirmDialog";
ConfirmDialogWrapper$1.displayName = "ConfirmDialogWrapper";
var ConfirmDialog_default = ConfirmDialogWrapper$1;

//#endregion
//#region node_modules/antd/es/modal/destroyFns.js
var destroyFns = [];
var destroyFns_default = destroyFns;

//#endregion
//#region node_modules/antd/es/modal/confirm.js
var defaultRootPrefixCls = "";
function getRootPrefixCls() {
	return defaultRootPrefixCls;
}
var ConfirmDialogWrapper = (props) => {
	const { prefixCls: customizePrefixCls, getContainer, direction } = props;
	const runtimeLocale$1 = getConfirmLocale();
	const config = (0, import_react.useContext)(ConfigContext);
	const rootPrefixCls = getRootPrefixCls() || config.getPrefixCls();
	const prefixCls = customizePrefixCls || `${rootPrefixCls}-modal`;
	let mergedGetContainer = getContainer;
	if (mergedGetContainer === false) {
		mergedGetContainer = void 0;
		warning_default(false, "Modal", "Static method not support `getContainer` to be `false` since it do not have context env.");
	}
	return /* @__PURE__ */ import_react.createElement(ConfirmDialog_default, {
		...props,
		rootPrefixCls,
		prefixCls,
		iconPrefixCls: config.iconPrefixCls,
		theme: config.theme,
		direction: direction ?? config.direction,
		locale: config.locale?.Modal ?? runtimeLocale$1,
		getContainer: mergedGetContainer
	});
};
function confirm(config) {
	const global = globalConfig();
	if (!global.holderRender) warnContext("Modal");
	const container = document.createDocumentFragment();
	let currentConfig = {
		...config,
		close,
		open: true
	};
	let timeoutId;
	function destroy$2(...args) {
		if (args.some((param) => param?.triggerCancel)) config.onCancel?.(() => {}, ...args.slice(1));
		for (let i = 0; i < destroyFns_default.length; i++) if (destroyFns_default[i] === close) {
			destroyFns_default.splice(i, 1);
			break;
		}
		unmount(container).then(() => {});
	}
	const scheduleRender = (props) => {
		clearTimeout(timeoutId);
		/**
		* https://github.com/ant-design/ant-design/issues/23623
		*
		* Sync render blocks React event. Let's make this async.
		*/
		timeoutId = setTimeout(() => {
			const rootPrefixCls = global.getPrefixCls(void 0, getRootPrefixCls());
			const iconPrefixCls = global.getIconPrefixCls();
			const theme = global.getTheme();
			const dom = /* @__PURE__ */ import_react.createElement(ConfirmDialogWrapper, { ...props });
			render(/* @__PURE__ */ import_react.createElement(config_provider_default, {
				prefixCls: rootPrefixCls,
				iconPrefixCls,
				theme
			}, typeof global.holderRender === "function" ? global.holderRender(dom) : dom), container);
		});
	};
	function close(...args) {
		currentConfig = {
			...currentConfig,
			open: false,
			afterClose: () => {
				if (typeof config.afterClose === "function") config.afterClose();
				destroy$2.apply(this, args);
			}
		};
		scheduleRender(currentConfig);
	}
	function update(configUpdate) {
		if (typeof configUpdate === "function") currentConfig = configUpdate(currentConfig);
		else currentConfig = {
			...currentConfig,
			...configUpdate
		};
		scheduleRender(currentConfig);
	}
	scheduleRender(currentConfig);
	destroyFns_default.push(close);
	return {
		destroy: close,
		update
	};
}
function withWarn(props) {
	return {
		...props,
		type: "warning"
	};
}
function withInfo(props) {
	return {
		...props,
		type: "info"
	};
}
function withSuccess(props) {
	return {
		...props,
		type: "success"
	};
}
function withError(props) {
	return {
		...props,
		type: "error"
	};
}
function withConfirm(props) {
	return {
		...props,
		type: "confirm"
	};
}
function modalGlobalConfig({ rootPrefixCls }) {
	warning_default(false, "Modal", "Modal.config is deprecated. Please use ConfigProvider.config instead.");
	defaultRootPrefixCls = rootPrefixCls;
}

//#endregion
//#region node_modules/antd/es/modal/useModal/HookModal.js
var HookModal = ({ afterClose: hookAfterClose, config, ...restProps }, ref) => {
	const [open$2, setOpen] = import_react.useState(true);
	const [innerConfig, setInnerConfig] = import_react.useState(config);
	const { direction, getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("modal");
	const rootPrefixCls = getPrefixCls();
	const afterClose = () => {
		hookAfterClose();
		innerConfig.afterClose?.();
	};
	const close = (...args) => {
		setOpen(false);
		if (args.some((param) => param?.triggerCancel)) innerConfig.onCancel?.(() => {}, ...args.slice(1));
	};
	import_react.useImperativeHandle(ref, () => ({
		destroy: close,
		update: (newConfig) => {
			setInnerConfig((originConfig) => {
				const nextConfig = typeof newConfig === "function" ? newConfig(originConfig) : newConfig;
				return {
					...originConfig,
					...nextConfig
				};
			});
		}
	}));
	const mergedOkCancel = innerConfig.okCancel ?? innerConfig.type === "confirm";
	const [contextLocale] = useLocale_default("Modal", en_US_default.Modal);
	return /* @__PURE__ */ import_react.createElement(ConfirmDialog_default, {
		prefixCls,
		rootPrefixCls,
		...innerConfig,
		close,
		open: open$2,
		afterClose,
		okText: innerConfig.okText || (mergedOkCancel ? contextLocale?.okText : contextLocale?.justOkText),
		direction: innerConfig.direction || direction,
		cancelText: innerConfig.cancelText || contextLocale?.cancelText,
		...restProps
	});
};
var HookModal_default = /* @__PURE__ */ import_react.forwardRef(HookModal);

//#endregion
//#region node_modules/antd/es/modal/useModal/index.js
var uuid$1 = 0;
var ElementsHolder = /* @__PURE__ */ import_react.memo(/* @__PURE__ */ import_react.forwardRef((_props, ref) => {
	const [elements, patchElement] = usePatchElement();
	import_react.useImperativeHandle(ref, () => ({ patchElement }), [patchElement]);
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, elements);
}));
function useModal() {
	const holderRef = import_react.useRef(null);
	const [actionQueue, setActionQueue] = import_react.useState([]);
	import_react.useEffect(() => {
		if (actionQueue.length) {
			_toConsumableArray(actionQueue).forEach((action) => {
				action();
			});
			setActionQueue([]);
		}
	}, [actionQueue]);
	const getConfirmFunc = import_react.useCallback((withFunc) => function hookConfirm(config) {
		uuid$1 += 1;
		const modalRef = /* @__PURE__ */ import_react.createRef();
		let resolvePromise;
		const promise = new Promise((resolve) => {
			resolvePromise = resolve;
		});
		let silent = false;
		let closeFunc;
		const modal = /* @__PURE__ */ import_react.createElement(HookModal_default, {
			key: `modal-${uuid$1}`,
			config: withFunc(config),
			ref: modalRef,
			afterClose: () => {
				closeFunc?.();
			},
			isSilent: () => silent,
			onConfirm: (confirmed) => {
				resolvePromise(confirmed);
			}
		});
		closeFunc = holderRef.current?.patchElement(modal);
		if (closeFunc) destroyFns_default.push(closeFunc);
		return {
			destroy: () => {
				function destroyAction() {
					modalRef.current?.destroy();
				}
				if (modalRef.current) destroyAction();
				else setActionQueue((prev$1) => [].concat(_toConsumableArray(prev$1), [destroyAction]));
			},
			update: (newConfig) => {
				function updateAction() {
					modalRef.current?.update(newConfig);
				}
				if (modalRef.current) updateAction();
				else setActionQueue((prev$1) => [].concat(_toConsumableArray(prev$1), [updateAction]));
			},
			then: (resolve) => {
				silent = true;
				return promise.then(resolve);
			}
		};
	}, []);
	return [import_react.useMemo(() => ({
		info: getConfirmFunc(withInfo),
		success: getConfirmFunc(withSuccess),
		error: getConfirmFunc(withError),
		warning: getConfirmFunc(withWarn),
		confirm: getConfirmFunc(withConfirm)
	}), [getConfirmFunc]), /* @__PURE__ */ import_react.createElement(ElementsHolder, {
		key: "modal-holder",
		ref: holderRef
	})];
}
var useModal_default = useModal;

//#endregion
//#region node_modules/antd/es/notification/style/placement.js
var genNotificationPlacementStyle = (token$1) => {
	const { componentCls, notificationMarginEdge, animationMaxHeight } = token$1;
	const noticeCls = `${componentCls}-notice`;
	const rightFadeIn = new Keyframes_default("antNotificationFadeIn", {
		"0%": {
			transform: `translate3d(100%, 0, 0)`,
			opacity: 0
		},
		"100%": {
			transform: `translate3d(0, 0, 0)`,
			opacity: 1
		}
	});
	const topFadeIn = new Keyframes_default("antNotificationTopFadeIn", {
		"0%": {
			top: -animationMaxHeight,
			opacity: 0
		},
		"100%": {
			top: 0,
			opacity: 1
		}
	});
	const bottomFadeIn = new Keyframes_default("antNotificationBottomFadeIn", {
		"0%": {
			bottom: token$1.calc(animationMaxHeight).mul(-1).equal(),
			opacity: 0
		},
		"100%": {
			bottom: 0,
			opacity: 1
		}
	});
	const leftFadeIn = new Keyframes_default("antNotificationLeftFadeIn", {
		"0%": {
			transform: `translate3d(-100%, 0, 0)`,
			opacity: 0
		},
		"100%": {
			transform: `translate3d(0, 0, 0)`,
			opacity: 1
		}
	});
	return { [componentCls]: {
		[`&${componentCls}-top, &${componentCls}-bottom`]: {
			marginInline: 0,
			[noticeCls]: { marginInline: "auto auto" }
		},
		[`&${componentCls}-top`]: { [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: { animationName: topFadeIn } },
		[`&${componentCls}-bottom`]: { [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: { animationName: bottomFadeIn } },
		[`&${componentCls}-topRight, &${componentCls}-bottomRight`]: { [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: { animationName: rightFadeIn } },
		[`&${componentCls}-topLeft, &${componentCls}-bottomLeft`]: {
			marginRight: {
				value: 0,
				_skip_check_: true
			},
			marginLeft: {
				value: notificationMarginEdge,
				_skip_check_: true
			},
			[noticeCls]: {
				marginInlineEnd: "auto",
				marginInlineStart: 0
			},
			[`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: { animationName: leftFadeIn }
		}
	} };
};
var placement_default = genNotificationPlacementStyle;

//#endregion
//#region node_modules/antd/es/notification/interface.js
const NotificationPlacements = [
	"top",
	"topLeft",
	"topRight",
	"bottom",
	"bottomLeft",
	"bottomRight"
];

//#endregion
//#region node_modules/antd/es/notification/style/stack.js
var placementAlignProperty = {
	topLeft: "left",
	topRight: "right",
	bottomLeft: "left",
	bottomRight: "right",
	top: "left",
	bottom: "left"
};
var genPlacementStackStyle = (token$1, placement) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-${placement}`]: { [`&${componentCls}-stack > ${componentCls}-notice-wrapper`]: {
		[placement.startsWith("top") ? "top" : "bottom"]: 0,
		[placementAlignProperty[placement]]: {
			value: 0,
			_skip_check_: true
		}
	} } };
};
var genStackChildrenStyle = (token$1) => {
	const childrenStyle = {};
	for (let i = 1; i < token$1.notificationStackLayer; i++) childrenStyle[`&:nth-last-child(${i + 1})`] = {
		overflow: "hidden",
		[`& > ${token$1.componentCls}-notice`]: {
			opacity: 0,
			transition: `opacity ${token$1.motionDurationMid}`
		}
	};
	return {
		[`&:not(:nth-last-child(-n+${token$1.notificationStackLayer}))`]: {
			opacity: 0,
			overflow: "hidden",
			color: "transparent",
			pointerEvents: "none"
		},
		...childrenStyle
	};
};
var genStackedNoticeStyle = (token$1) => {
	const childrenStyle = {};
	for (let i = 1; i < token$1.notificationStackLayer; i++) childrenStyle[`&:nth-last-child(${i + 1})`] = {
		background: token$1.colorBgBlur,
		backdropFilter: "blur(10px)",
		"-webkit-backdrop-filter": "blur(10px)"
	};
	return { ...childrenStyle };
};
var genStackStyle = (token$1) => {
	const { componentCls } = token$1;
	return {
		[`${componentCls}-stack`]: { [`& > ${componentCls}-notice-wrapper`]: {
			transition: `transform ${token$1.motionDurationSlow}, backdrop-filter 0s`,
			willChange: "transform, opacity",
			position: "absolute",
			...genStackChildrenStyle(token$1)
		} },
		[`${componentCls}-stack:not(${componentCls}-stack-expanded)`]: { [`& > ${componentCls}-notice-wrapper`]: { ...genStackedNoticeStyle(token$1) } },
		[`${componentCls}-stack${componentCls}-stack-expanded`]: { [`& > ${componentCls}-notice-wrapper`]: {
			"&:not(:nth-last-child(-n + 1))": {
				opacity: 1,
				overflow: "unset",
				color: "inherit",
				pointerEvents: "auto",
				[`& > ${token$1.componentCls}-notice`]: { opacity: 1 }
			},
			"&:after": {
				content: "\"\"",
				position: "absolute",
				height: token$1.margin,
				width: "100%",
				insetInline: 0,
				bottom: token$1.calc(token$1.margin).mul(-1).equal(),
				background: "transparent",
				pointerEvents: "auto"
			}
		} },
		...NotificationPlacements.map((placement) => genPlacementStackStyle(token$1, placement)).reduce((acc, cur) => ({
			...acc,
			...cur
		}), {})
	};
};
var stack_default = genStackStyle;

//#endregion
//#region node_modules/antd/es/notification/style/index.js
const genNoticeStyle = (token$1) => {
	const { iconCls, componentCls, boxShadow, fontSizeLG, notificationMarginBottom, borderRadiusLG, colorSuccess, colorInfo, colorWarning, colorError, colorTextHeading, notificationBg, notificationPadding, notificationMarginEdge, progressBg, notificationProgressHeight, fontSize, lineHeight, width, notificationIconSize, colorText, colorSuccessBg, colorErrorBg, colorInfoBg, colorWarningBg } = token$1;
	const noticeCls = `${componentCls}-notice`;
	return {
		position: "relative",
		marginBottom: notificationMarginBottom,
		marginInlineStart: "auto",
		background: notificationBg,
		borderRadius: borderRadiusLG,
		boxShadow,
		[noticeCls]: {
			padding: notificationPadding,
			width,
			maxWidth: `calc(100vw - ${unit(token$1.calc(notificationMarginEdge).mul(2).equal())})`,
			lineHeight,
			wordWrap: "break-word",
			borderRadius: borderRadiusLG,
			overflow: "hidden",
			"&-success": colorSuccessBg ? { background: colorSuccessBg } : {},
			"&-error": colorErrorBg ? { background: colorErrorBg } : {},
			"&-info": colorInfoBg ? { background: colorInfoBg } : {},
			"&-warning": colorWarningBg ? { background: colorWarningBg } : {}
		},
		[`${noticeCls}-title`]: {
			marginBottom: token$1.marginXS,
			color: colorTextHeading,
			fontSize: fontSizeLG,
			lineHeight: token$1.lineHeightLG
		},
		[`${noticeCls}-description`]: {
			fontSize,
			color: colorText,
			marginTop: token$1.marginXS
		},
		[`${noticeCls}-closable ${noticeCls}-title`]: { paddingInlineEnd: token$1.paddingLG },
		[`${noticeCls}-with-icon ${noticeCls}-title`]: {
			marginBottom: token$1.marginXS,
			marginInlineStart: token$1.calc(token$1.marginSM).add(notificationIconSize).equal(),
			fontSize: fontSizeLG
		},
		[`${noticeCls}-with-icon ${noticeCls}-description`]: {
			marginInlineStart: token$1.calc(token$1.marginSM).add(notificationIconSize).equal(),
			fontSize
		},
		[`${noticeCls}-icon`]: {
			position: "absolute",
			fontSize: notificationIconSize,
			lineHeight: 1,
			[`&-success${iconCls}`]: { color: colorSuccess },
			[`&-info${iconCls}`]: { color: colorInfo },
			[`&-warning${iconCls}`]: { color: colorWarning },
			[`&-error${iconCls}`]: { color: colorError }
		},
		[`${noticeCls}-close`]: {
			position: "absolute",
			top: token$1.notificationPaddingVertical,
			insetInlineEnd: token$1.notificationPaddingHorizontal,
			color: token$1.colorIcon,
			outline: "none",
			width: token$1.notificationCloseButtonSize,
			height: token$1.notificationCloseButtonSize,
			borderRadius: token$1.borderRadiusSM,
			transition: `background-color ${token$1.motionDurationMid}, color ${token$1.motionDurationMid}`,
			display: "flex",
			alignItems: "center",
			justifyContent: "center",
			background: "none",
			border: "none",
			"&:hover": {
				color: token$1.colorIconHover,
				backgroundColor: token$1.colorBgTextHover
			},
			"&:active": { backgroundColor: token$1.colorBgTextActive },
			...genFocusStyle(token$1)
		},
		[`${noticeCls}-progress`]: {
			position: "absolute",
			display: "block",
			appearance: "none",
			inlineSize: `calc(100% - ${unit(borderRadiusLG)} * 2)`,
			left: {
				_skip_check_: true,
				value: borderRadiusLG
			},
			right: {
				_skip_check_: true,
				value: borderRadiusLG
			},
			bottom: 0,
			blockSize: notificationProgressHeight,
			border: 0,
			"&, &::-webkit-progress-bar": {
				borderRadius: borderRadiusLG,
				backgroundColor: `rgba(0, 0, 0, 0.04)`
			},
			"&::-moz-progress-bar": { background: progressBg },
			"&::-webkit-progress-value": {
				borderRadius: borderRadiusLG,
				background: progressBg
			}
		},
		[`${noticeCls}-actions`]: {
			float: "right",
			marginTop: token$1.marginSM
		}
	};
};
var genNotificationStyle = (token$1) => {
	const { componentCls, notificationMarginBottom, notificationMarginEdge, motionDurationMid, motionEaseInOut } = token$1;
	const noticeCls = `${componentCls}-notice`;
	const fadeOut$1 = new Keyframes_default("antNotificationFadeOut", {
		"0%": {
			maxHeight: token$1.animationMaxHeight,
			marginBottom: notificationMarginBottom
		},
		"100%": {
			maxHeight: 0,
			marginBottom: 0,
			paddingTop: 0,
			paddingBottom: 0,
			opacity: 0
		}
	});
	return [{ [componentCls]: {
		...resetComponent(token$1),
		position: "fixed",
		zIndex: token$1.zIndexPopup,
		marginRight: {
			value: notificationMarginEdge,
			_skip_check_: true
		},
		[`${componentCls}-hook-holder`]: { position: "relative" },
		[`${componentCls}-fade-appear-prepare`]: { opacity: "0 !important" },
		[`${componentCls}-fade-enter, ${componentCls}-fade-appear`]: {
			animationDuration: token$1.motionDurationMid,
			animationTimingFunction: motionEaseInOut,
			animationFillMode: "both",
			opacity: 0,
			animationPlayState: "paused"
		},
		[`${componentCls}-fade-leave`]: {
			animationTimingFunction: motionEaseInOut,
			animationFillMode: "both",
			animationDuration: motionDurationMid,
			animationPlayState: "paused"
		},
		[`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: { animationPlayState: "running" },
		[`${componentCls}-fade-leave${componentCls}-fade-leave-active`]: {
			animationName: fadeOut$1,
			animationPlayState: "running"
		},
		"&-rtl": {
			direction: "rtl",
			[`${noticeCls}-actions`]: { float: "left" }
		}
	} }, { [componentCls]: { [`${noticeCls}-wrapper`]: genNoticeStyle(token$1) } }];
};
const prepareComponentToken$49 = (token$1) => ({
	zIndexPopup: token$1.zIndexPopupBase + CONTAINER_MAX_OFFSET + 50,
	width: 384,
	progressBg: `linear-gradient(90deg, ${token$1.colorPrimaryBorderHover}, ${token$1.colorPrimary})`,
	colorSuccessBg: void 0,
	colorErrorBg: void 0,
	colorInfoBg: void 0,
	colorWarningBg: void 0
});
const prepareNotificationToken = (token$1) => {
	const notificationPaddingVertical = token$1.paddingMD;
	const notificationPaddingHorizontal = token$1.paddingLG;
	return merge(token$1, {
		notificationBg: token$1.colorBgElevated,
		notificationPaddingVertical,
		notificationPaddingHorizontal,
		notificationIconSize: token$1.calc(token$1.fontSizeLG).mul(token$1.lineHeightLG).equal(),
		notificationCloseButtonSize: token$1.calc(token$1.controlHeightLG).mul(.55).equal(),
		notificationMarginBottom: token$1.margin,
		notificationPadding: `${unit(token$1.paddingMD)} ${unit(token$1.paddingContentHorizontalLG)}`,
		notificationMarginEdge: token$1.marginLG,
		animationMaxHeight: 150,
		notificationStackLayer: 3,
		notificationProgressHeight: 2
	});
};
var style_default$56 = genStyleHooks("Notification", (token$1) => {
	const notificationToken = prepareNotificationToken(token$1);
	return [
		genNotificationStyle(notificationToken),
		placement_default(notificationToken),
		stack_default(notificationToken)
	];
}, prepareComponentToken$49);

//#endregion
//#region node_modules/antd/es/notification/style/pure-panel.js
var pure_panel_default = genSubStyleComponent(["Notification", "PurePanel"], (token$1) => {
	const noticeCls = `${token$1.componentCls}-notice`;
	const notificationToken = prepareNotificationToken(token$1);
	return { [`${noticeCls}-pure-panel`]: {
		...genNoticeStyle(notificationToken),
		width: notificationToken.width,
		maxWidth: `calc(100vw - ${unit(token$1.calc(notificationToken.notificationMarginEdge).mul(2).equal())})`,
		margin: 0
	} };
}, prepareComponentToken$49);

//#endregion
//#region node_modules/antd/es/notification/PurePanel.js
function getCloseIcon(prefixCls, closeIcon) {
	if (closeIcon === null || closeIcon === false) return null;
	return closeIcon || /* @__PURE__ */ import_react.createElement(CloseOutlined_default, { className: `${prefixCls}-close-icon` });
}
var typeToIcon = {
	success: CheckCircleFilled_default,
	info: InfoCircleFilled_default,
	error: CloseCircleFilled_default,
	warning: ExclamationCircleFilled_default
};
const PureContent = (props) => {
	const { prefixCls, icon, type: type$2, title, description, actions, role = "alert", styles, classNames: pureContentCls } = props;
	let iconNode = null;
	if (icon) iconNode = /* @__PURE__ */ import_react.createElement("span", {
		className: clsx(`${prefixCls}-icon`, pureContentCls.icon),
		style: styles.icon
	}, icon);
	else if (type$2) iconNode = /* @__PURE__ */ import_react.createElement(typeToIcon[type$2] || null, {
		className: clsx(`${prefixCls}-icon`, pureContentCls.icon, `${prefixCls}-icon-${type$2}`),
		style: styles.icon
	});
	return /* @__PURE__ */ import_react.createElement("div", {
		className: clsx({ [`${prefixCls}-with-icon`]: iconNode }),
		role
	}, iconNode, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-title`, pureContentCls.title),
		style: styles.title
	}, title), description && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-description`, pureContentCls.description),
		style: styles.description
	}, description), actions && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-actions`, pureContentCls.actions),
		style: styles.actions
	}, actions));
};
/** @private Internal Component. Do not use in your production. */
var PurePanel$13 = (props) => {
	const { prefixCls: staticPrefixCls, icon, type: type$2, message: message$1, title, description, btn, actions, closeIcon: _closeIcon, className: notificationClassName, style: style$1, styles, classNames: notificationClassNames, closable, ...restProps } = props;
	const { getPrefixCls, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("notification");
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, notificationClassNames], [contextStyles, styles], { props });
	const { notification: notificationContext } = import_react.useContext(ConfigContext);
	const mergedActions = actions ?? btn;
	{
		const warning$3 = devUseWarning("Notification");
		[["btn", "actions"], ["message", "title"]].forEach(([deprecatedName, newName]) => {
			warning$3.deprecated(!(deprecatedName in props), deprecatedName, newName);
		});
	}
	const mergedTitle = title ?? message$1;
	const prefixCls = staticPrefixCls || getPrefixCls("notification");
	const noticePrefixCls = `${prefixCls}-notice`;
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$56(prefixCls, rootCls);
	const [rawClosable, mergedCloseIcon, , ariaProps] = useClosable(pickClosable(props), pickClosable(notificationContext), {
		closable: true,
		closeIcon: /* @__PURE__ */ import_react.createElement(CloseOutlined_default, { className: `${prefixCls}-close-icon` }),
		closeIconRender: (icon$1) => getCloseIcon(prefixCls, icon$1)
	});
	const mergedClosable = rawClosable ? {
		onClose: closable && typeof closable === "object" ? closable?.onClose : void 0,
		closeIcon: mergedCloseIcon,
		...ariaProps
	} : false;
	return /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${noticePrefixCls}-pure-panel`, hashId, notificationClassName, cssVarCls, rootCls, mergedClassNames.root),
		style: mergedStyles.root
	}, /* @__PURE__ */ import_react.createElement(pure_panel_default, { prefixCls }), /* @__PURE__ */ import_react.createElement(Notice_default, {
		style: {
			...contextStyle,
			...style$1
		},
		...restProps,
		prefixCls,
		eventKey: "pure",
		duration: null,
		closable: mergedClosable,
		className: clsx(notificationClassName, contextClassName),
		content: /* @__PURE__ */ import_react.createElement(PureContent, {
			classNames: mergedClassNames,
			styles: mergedStyles,
			prefixCls: noticePrefixCls,
			icon,
			type: type$2,
			title: mergedTitle,
			description,
			actions: mergedActions
		})
	}));
};
var PurePanel_default$4 = PurePanel$13;

//#endregion
//#region node_modules/antd/es/notification/util.js
function getPlacementStyle(placement, top, bottom) {
	let style$1;
	switch (placement) {
		case "top":
			style$1 = {
				left: "50%",
				transform: "translateX(-50%)",
				right: "auto",
				top,
				bottom: "auto"
			};
			break;
		case "topLeft":
			style$1 = {
				left: 0,
				top,
				bottom: "auto"
			};
			break;
		case "topRight":
			style$1 = {
				right: 0,
				top,
				bottom: "auto"
			};
			break;
		case "bottom":
			style$1 = {
				left: "50%",
				transform: "translateX(-50%)",
				right: "auto",
				top: "auto",
				bottom
			};
			break;
		case "bottomLeft":
			style$1 = {
				left: 0,
				top: "auto",
				bottom
			};
			break;
		default:
			style$1 = {
				right: 0,
				top: "auto",
				bottom
			};
			break;
	}
	return style$1;
}
function getMotion$1(prefixCls) {
	return { motionName: `${prefixCls}-fade` };
}
function getCloseIconConfig(closeIcon, notificationConfig, notification$1) {
	if (typeof closeIcon !== "undefined") return closeIcon;
	if (typeof notificationConfig?.closeIcon !== "undefined") return notificationConfig.closeIcon;
	return notification$1?.closeIcon;
}

//#endregion
//#region node_modules/antd/es/notification/useNotification.js
var DEFAULT_OFFSET = 24;
var DEFAULT_DURATION = 4.5;
var DEFAULT_PLACEMENT = "topRight";
var Wrapper = ({ children, prefixCls }) => {
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$56(prefixCls, rootCls);
	return /* @__PURE__ */ import_react.createElement(NotificationProvider_default, { classNames: { list: clsx(hashId, cssVarCls, rootCls) } }, children);
};
var renderNotifications = (node$1, { prefixCls, key }) => /* @__PURE__ */ import_react.createElement(Wrapper, {
	prefixCls,
	key
}, node$1);
var Holder = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { top, bottom, prefixCls: staticPrefixCls, getContainer: staticGetContainer, maxCount, rtl, onAllRemoved, stack: stack$1, duration = DEFAULT_DURATION, pauseOnHover = true, showProgress } = props;
	const { getPrefixCls, getPopupContainer, direction } = useComponentConfig("notification");
	const { notification: notification$1 } = (0, import_react.useContext)(ConfigContext);
	const [, token$1] = useToken();
	const prefixCls = staticPrefixCls || getPrefixCls("notification");
	const mergedDuration = (0, import_react.useMemo)(() => typeof duration === "number" && duration > 0 ? duration : false, [duration]);
	const getStyle$2 = (placement) => getPlacementStyle(placement, top ?? DEFAULT_OFFSET, bottom ?? DEFAULT_OFFSET);
	const getClassName = () => clsx({ [`${prefixCls}-rtl`]: rtl ?? direction === "rtl" });
	const getNotificationMotion = () => getMotion$1(prefixCls);
	const [api, holder] = useNotification$1({
		prefixCls,
		style: getStyle$2,
		className: getClassName,
		motion: getNotificationMotion,
		closable: { closeIcon: getCloseIcon(prefixCls) },
		duration: mergedDuration,
		getContainer: () => staticGetContainer?.() || getPopupContainer?.() || document.body,
		maxCount,
		pauseOnHover,
		showProgress,
		onAllRemoved,
		renderNotifications,
		stack: stack$1 === false ? false : {
			threshold: typeof stack$1 === "object" ? stack$1?.threshold : void 0,
			offset: 8,
			gap: token$1.margin
		}
	});
	const [mergedClassNames, mergedStyles] = useMergeSemantic([notification$1?.classNames, props?.classNames], [notification$1?.styles, props?.styles], { props });
	import_react.useImperativeHandle(ref, () => ({
		...api,
		prefixCls,
		notification: notification$1,
		classNames: mergedClassNames,
		styles: mergedStyles
	}));
	return holder;
});
function useInternalNotification(notificationConfig) {
	const holderRef = import_react.useRef(null);
	const warning$3 = devUseWarning("Notification");
	const { notification: notificationContext } = import_react.useContext(ConfigContext);
	return [import_react.useMemo(() => {
		const open$2 = (config) => {
			if (!holderRef.current) {
				warning$3(false, "usage", "You are calling notice in render which will break in React 18 concurrent mode. Please trigger in effect instead.");
				return;
			}
			const { open: originOpen, prefixCls, notification: notification$1, classNames: originClassNames, styles: originStyles } = holderRef.current;
			const contextClassName = notification$1?.className || {};
			const contextStyle = notification$1?.style || {};
			const noticePrefixCls = `${prefixCls}-notice`;
			const { title, message: message$1, description, icon, type: type$2, btn, actions, className, style: style$1, role = "alert", closeIcon, closable, classNames: configClassNames = {}, styles = {}, ...restConfig } = config;
			[["btn", "actions"], ["message", "title"]].forEach(([deprecatedName, newName]) => {
				warning$3.deprecated(!(deprecatedName in config), deprecatedName, newName);
			});
			const mergedTitle = title ?? message$1;
			const mergedActions = actions ?? btn;
			const realCloseIcon = getCloseIcon(noticePrefixCls, getCloseIconConfig(closeIcon, notificationConfig, notification$1));
			const [rawClosable, mergedCloseIcon, , ariaProps] = computeClosable(pickClosable({
				...notificationConfig || {},
				...config
			}), pickClosable(notificationContext), {
				closable: true,
				closeIcon: realCloseIcon
			});
			const mergedClosable = rawClosable ? {
				onClose: closable && typeof closable === "object" ? closable.onClose : void 0,
				closeIcon: mergedCloseIcon,
				...ariaProps
			} : false;
			const semanticClassNames = resolveStyleOrClass(configClassNames, { props: config });
			const semanticStyles = resolveStyleOrClass(styles, { props: config });
			const mergedClassNames = mergeClassNames(void 0, originClassNames, semanticClassNames);
			const mergedStyles = mergeStyles(originStyles, semanticStyles);
			return originOpen({
				placement: notificationConfig?.placement ?? DEFAULT_PLACEMENT,
				...restConfig,
				content: /* @__PURE__ */ import_react.createElement(PureContent, {
					prefixCls: noticePrefixCls,
					icon,
					type: type$2,
					title: mergedTitle,
					description,
					actions: mergedActions,
					role,
					classNames: mergedClassNames,
					styles: mergedStyles
				}),
				className: clsx({ [`${noticePrefixCls}-${type$2}`]: type$2 }, className, contextClassName, mergedClassNames.root),
				style: {
					...contextStyle,
					...mergedStyles.root,
					...style$1
				},
				closable: mergedClosable
			});
		};
		const destroy$2 = (key) => {
			if (key !== void 0) holderRef.current?.close(key);
			else holderRef.current?.destroy();
		};
		const clone = {
			open: open$2,
			destroy: destroy$2
		};
		[
			"success",
			"info",
			"warning",
			"error"
		].forEach((type$2) => {
			clone[type$2] = (config) => open$2({
				...config,
				type: type$2
			});
		});
		return clone;
	}, [notificationConfig, notificationContext]), /* @__PURE__ */ import_react.createElement(Holder, {
		key: "notification-holder",
		...notificationConfig,
		ref: holderRef
	})];
}
function useNotification(notificationConfig) {
	return useInternalNotification(notificationConfig);
}

//#endregion
//#region node_modules/antd/es/app/context.js
const AppConfigContext = /* @__PURE__ */ import_react.createContext({});
var AppContext = /* @__PURE__ */ import_react.createContext({
	message: {},
	notification: {},
	modal: {}
});
var context_default$7 = AppContext;

//#endregion
//#region node_modules/antd/es/app/style/index.js
var genBaseStyle$15 = (token$1) => {
	const { componentCls, colorText, fontSize, lineHeight, fontFamily } = token$1;
	return { [componentCls]: {
		color: colorText,
		fontSize,
		lineHeight,
		fontFamily,
		[`&${componentCls}-rtl`]: { direction: "rtl" }
	} };
};
const prepareComponentToken$48 = () => ({});
var style_default$55 = genStyleHooks("App", genBaseStyle$15, prepareComponentToken$48);

//#endregion
//#region node_modules/antd/es/app/App.js
var App$1 = (props) => {
	const { prefixCls: customizePrefixCls, children, className, rootClassName, message: message$1, notification: notification$1, style: style$1, component = "div" } = props;
	const { direction, getPrefixCls } = (0, import_react.useContext)(ConfigContext);
	const prefixCls = getPrefixCls("app", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$55(prefixCls);
	const customClassName = clsx(hashId, prefixCls, className, rootClassName, cssVarCls, { [`${prefixCls}-rtl`]: direction === "rtl" });
	const appConfig = (0, import_react.useContext)(AppConfigContext);
	const mergedAppConfig = import_react.useMemo(() => ({
		message: {
			...appConfig.message,
			...message$1
		},
		notification: {
			...appConfig.notification,
			...notification$1
		}
	}), [
		message$1,
		notification$1,
		appConfig.message,
		appConfig.notification
	]);
	const [messageApi, messageContextHolder] = useMessage(mergedAppConfig.message);
	const [notificationApi, notificationContextHolder] = useNotification(mergedAppConfig.notification);
	const [ModalApi, ModalContextHolder] = useModal_default();
	const memoizedContextValue = import_react.useMemo(() => ({
		message: messageApi,
		notification: notificationApi,
		modal: ModalApi
	}), [
		messageApi,
		notificationApi,
		ModalApi
	]);
	devUseWarning("App")(!(cssVarCls && component === false), "usage", "When using cssVar, ensure `component` is assigned a valid React component string.");
	const Component$2 = component === false ? import_react.Fragment : component;
	const rootProps = {
		className: customClassName,
		style: style$1
	};
	return /* @__PURE__ */ import_react.createElement(context_default$7.Provider, { value: memoizedContextValue }, /* @__PURE__ */ import_react.createElement(AppConfigContext.Provider, { value: mergedAppConfig }, /* @__PURE__ */ import_react.createElement(Component$2, { ...component === false ? void 0 : rootProps }, ModalContextHolder, messageContextHolder, notificationContextHolder, children)));
};
App$1.displayName = "App";
var App_default = App$1;

//#endregion
//#region node_modules/antd/es/app/useApp.js
var useApp = () => import_react.useContext(context_default$7);
var useApp_default = useApp;

//#endregion
//#region node_modules/antd/es/app/index.js
var App = App_default;
App.useApp = useApp_default;
var app_default = App;

//#endregion
//#region node_modules/antd/es/_util/PurePanel.js
function withPureRenderTheme(Component$2) {
	return (props) => /* @__PURE__ */ import_react.createElement(config_provider_default, { theme: { token: {
		motion: false,
		zIndexPopupBase: 0
	} } }, /* @__PURE__ */ import_react.createElement(Component$2, { ...props }));
}
/* istanbul ignore next */
var genPurePanel = (Component$2, alignPropName, postProps, defaultPrefixCls$1, getDropdownCls) => {
	const PurePanel$15 = (props) => {
		const { prefixCls: customizePrefixCls, style: style$1 } = props;
		const holderRef = import_react.useRef(null);
		const [popupHeight, setPopupHeight] = import_react.useState(0);
		const [popupWidth, setPopupWidth] = import_react.useState(0);
		const [open$2, setOpen] = useControlledState(false, props.open);
		const { getPrefixCls } = import_react.useContext(ConfigContext);
		const prefixCls = getPrefixCls(defaultPrefixCls$1 || "select", customizePrefixCls);
		import_react.useEffect(() => {
			setOpen(true);
			if (typeof ResizeObserver !== "undefined") {
				const resizeObserver = new ResizeObserver((entries) => {
					const element = entries[0].target;
					setPopupHeight(element.offsetHeight + 8);
					setPopupWidth(element.offsetWidth);
				});
				const interval = setInterval(() => {
					const dropdownCls = getDropdownCls ? `.${getDropdownCls(prefixCls)}` : `.${prefixCls}-dropdown`;
					const popup = holderRef.current?.querySelector(dropdownCls);
					if (popup) {
						clearInterval(interval);
						resizeObserver.observe(popup);
					}
				}, 10);
				return () => {
					clearInterval(interval);
					resizeObserver.disconnect();
				};
			}
		}, [prefixCls]);
		let mergedProps = {
			...props,
			style: {
				...style$1,
				margin: 0
			},
			open: open$2,
			getPopupContainer: () => holderRef.current
		};
		if (postProps) mergedProps = postProps(mergedProps);
		if (alignPropName) Object.assign(mergedProps, { [alignPropName]: { overflow: {
			adjustX: false,
			adjustY: false
		} } });
		const mergedStyle = {
			paddingBottom: popupHeight,
			position: "relative",
			minWidth: popupWidth
		};
		return /* @__PURE__ */ import_react.createElement("div", {
			ref: holderRef,
			style: mergedStyle
		}, /* @__PURE__ */ import_react.createElement(Component$2, { ...mergedProps }));
	};
	return withPureRenderTheme(PurePanel$15);
};
var PurePanel_default = genPurePanel;

//#endregion
//#region node_modules/@rc-component/select/es/hooks/useAllowClear.js
const useAllowClear = (prefixCls, displayValues, allowClear, clearIcon, disabled = false, mergedSearchValue, mode) => {
	const allowClearConfig = (0, import_react.useMemo)(() => {
		if (typeof allowClear === "boolean") return { allowClear };
		if (allowClear && typeof allowClear === "object") return allowClear;
		return { allowClear: false };
	}, [allowClear]);
	return (0, import_react.useMemo)(() => {
		const mergedAllowClear = !disabled && allowClearConfig.allowClear !== false && (displayValues.length || mergedSearchValue) && !(mode === "combobox" && mergedSearchValue === "");
		return {
			allowClear: mergedAllowClear,
			clearIcon: mergedAllowClear ? allowClearConfig.clearIcon || clearIcon || "" : null
		};
	}, [
		allowClearConfig,
		clearIcon,
		disabled,
		displayValues.length,
		mergedSearchValue,
		mode
	]);
};

//#endregion
//#region node_modules/@rc-component/select/es/hooks/useBaseProps.js
/**
* BaseSelect provide some parsed data into context.
* You can use this hooks to get them.
*/
const BaseSelectContext = /* @__PURE__ */ import_react.createContext(null);
function useBaseProps() {
	return import_react.useContext(BaseSelectContext);
}

//#endregion
//#region node_modules/@rc-component/select/es/hooks/useLock.js
/**
* Locker return cached mark.
* If set to `true`, will return `true` in a short time even if set `false`.
* If set to `false` and then set to `true`, will change to `true`.
* And after time duration, it will back to `null` automatically.
*/
function useLock(duration = 250) {
	const lockRef = import_react.useRef(null);
	const timeoutRef = import_react.useRef(null);
	import_react.useEffect(() => () => {
		window.clearTimeout(timeoutRef.current);
	}, []);
	function doLock(locked) {
		if (locked || lockRef.current === null) lockRef.current = locked;
		window.clearTimeout(timeoutRef.current);
		timeoutRef.current = window.setTimeout(() => {
			lockRef.current = null;
		}, duration);
	}
	return [() => lockRef.current, doLock];
}

//#endregion
//#region node_modules/@rc-component/select/es/hooks/useSelectTriggerControl.js
function isInside(elements, target) {
	return elements.filter((element) => element).some((element) => element.contains(target) || element === target);
}
function useSelectTriggerControl(elements, open$2, triggerOpen, customizedTrigger) {
	const onGlobalMouseDown = useEvent_default((event) => {
		if (customizedTrigger) return;
		let target = event.target;
		if (target.shadowRoot && event.composed) target = event.composedPath()[0] || target;
		if (event._ori_target) target = event._ori_target;
		if (open$2 && !isInside(elements(), target)) triggerOpen(false);
	});
	import_react.useEffect(() => {
		window.addEventListener("mousedown", onGlobalMouseDown);
		return () => window.removeEventListener("mousedown", onGlobalMouseDown);
	}, [onGlobalMouseDown]);
}

//#endregion
//#region node_modules/@rc-component/select/es/SelectTrigger.js
function _extends$84() {
	_extends$84 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$84.apply(this, arguments);
}
var getBuiltInPlacements$1 = (popupMatchSelectWidth) => {
	const adjustX = popupMatchSelectWidth === true ? 0 : 1;
	return {
		bottomLeft: {
			points: ["tl", "bl"],
			offset: [0, 4],
			overflow: {
				adjustX,
				adjustY: 1
			},
			htmlRegion: "scroll"
		},
		bottomRight: {
			points: ["tr", "br"],
			offset: [0, 4],
			overflow: {
				adjustX,
				adjustY: 1
			},
			htmlRegion: "scroll"
		},
		topLeft: {
			points: ["bl", "tl"],
			offset: [0, -4],
			overflow: {
				adjustX,
				adjustY: 1
			},
			htmlRegion: "scroll"
		},
		topRight: {
			points: ["br", "tr"],
			offset: [0, -4],
			overflow: {
				adjustX,
				adjustY: 1
			},
			htmlRegion: "scroll"
		}
	};
};
var SelectTrigger = (props, ref) => {
	const { prefixCls, disabled, visible, children, popupElement, animation, transitionName, popupStyle, popupClassName, direction = "ltr", placement, builtinPlacements, popupMatchSelectWidth, popupRender, popupAlign, getPopupContainer, empty: empty$1, onPopupVisibleChange, onPopupMouseEnter, onPopupMouseDown, onPopupBlur, ...restProps } = props;
	const popupPrefixCls = `${prefixCls}-dropdown`;
	let popupNode = popupElement;
	if (popupRender) popupNode = popupRender(popupElement);
	const mergedBuiltinPlacements$1 = import_react.useMemo(() => builtinPlacements || getBuiltInPlacements$1(popupMatchSelectWidth), [builtinPlacements, popupMatchSelectWidth]);
	const mergedTransitionName = animation ? `${popupPrefixCls}-${animation}` : transitionName;
	const isNumberPopupWidth = typeof popupMatchSelectWidth === "number";
	const stretch = import_react.useMemo(() => {
		if (isNumberPopupWidth) return null;
		return popupMatchSelectWidth === false ? "minWidth" : "width";
	}, [popupMatchSelectWidth, isNumberPopupWidth]);
	let mergedPopupStyle = popupStyle;
	if (isNumberPopupWidth) mergedPopupStyle = {
		...popupStyle,
		width: popupMatchSelectWidth
	};
	const triggerPopupRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => ({ getPopupElement: () => triggerPopupRef.current?.popupElement }));
	return /* @__PURE__ */ import_react.createElement(es_default$6, _extends$84({}, restProps, {
		showAction: onPopupVisibleChange ? ["click"] : [],
		hideAction: onPopupVisibleChange ? ["click"] : [],
		popupPlacement: placement || (direction === "rtl" ? "bottomRight" : "bottomLeft"),
		builtinPlacements: mergedBuiltinPlacements$1,
		prefixCls: popupPrefixCls,
		popupMotion: { motionName: mergedTransitionName },
		popup: /* @__PURE__ */ import_react.createElement("div", {
			onMouseEnter: onPopupMouseEnter,
			onMouseDown: onPopupMouseDown,
			onBlur: onPopupBlur
		}, popupNode),
		ref: triggerPopupRef,
		stretch,
		popupAlign,
		popupVisible: visible,
		getPopupContainer,
		popupClassName: clsx(popupClassName, { [`${popupPrefixCls}-empty`]: empty$1 }),
		popupStyle: mergedPopupStyle,
		onPopupVisibleChange
	}), children);
};
var RefSelectTrigger = /* @__PURE__ */ import_react.forwardRef(SelectTrigger);
RefSelectTrigger.displayName = "SelectTrigger";
var SelectTrigger_default = RefSelectTrigger;

//#endregion
//#region node_modules/@rc-component/select/es/utils/valueUtil.js
function getKey$2(data, index$1) {
	const { key } = data;
	let value;
	if ("value" in data) ({value} = data);
	if (key !== null && key !== void 0) return key;
	if (value !== void 0) return value;
	return `rc-index-key-${index$1}`;
}
function isValidCount(value) {
	return typeof value !== "undefined" && !Number.isNaN(value);
}
function fillFieldNames$3(fieldNames, childrenAsData) {
	const { label, value, options, groupLabel } = fieldNames || {};
	const mergedLabel = label || (childrenAsData ? "children" : "label");
	return {
		label: mergedLabel,
		value: value || "value",
		options: options || "options",
		groupLabel: groupLabel || mergedLabel
	};
}
/**
* Flat options into flatten list.
* We use `optionOnly` here is aim to avoid user use nested option group.
* Here is simply set `key` to the index if not provided.
*/
function flattenOptions(options, { fieldNames, childrenAsData } = {}) {
	const flattenList = [];
	const { label: fieldLabel, value: fieldValue, options: fieldOptions, groupLabel } = fillFieldNames$3(fieldNames, false);
	function dig(list, isGroupOption) {
		if (!Array.isArray(list)) return;
		list.forEach((data) => {
			if (isGroupOption || !(fieldOptions in data)) {
				const value = data[fieldValue];
				flattenList.push({
					key: getKey$2(data, flattenList.length),
					groupOption: isGroupOption,
					data,
					label: data[fieldLabel],
					value
				});
			} else {
				let grpLabel = data[groupLabel];
				if (grpLabel === void 0 && childrenAsData) grpLabel = data.label;
				flattenList.push({
					key: getKey$2(data, flattenList.length),
					group: true,
					data,
					label: grpLabel
				});
				dig(data[fieldOptions], true);
			}
		});
	}
	dig(options, false);
	return flattenList;
}
/**
* Inject `props` into `option` for legacy usage
*/
function injectPropsWithOption(option) {
	const newOption = { ...option };
	if (!("props" in newOption)) Object.defineProperty(newOption, "props", { get() {
		warning_default$1(false, "Return type is option instead of Option instance. Please read value directly instead of reading from `props`.");
		return newOption;
	} });
	return newOption;
}
const getSeparatedContent = (text, tokens, end) => {
	if (!tokens || !tokens.length) return null;
	let match$2 = false;
	const separate = (str, [token$1, ...restTokens]) => {
		if (!token$1) return [str];
		const list$1 = str.split(token$1);
		match$2 = match$2 || list$1.length > 1;
		return list$1.reduce((prevList, unitStr) => [...prevList, ...separate(unitStr, restTokens)], []).filter(Boolean);
	};
	const list = separate(text, tokens);
	if (match$2) return typeof end !== "undefined" ? list.slice(0, end) : list;
	else return null;
};

//#endregion
//#region node_modules/@rc-component/select/es/BaseSelect/Polite.js
function Polite(props) {
	const { visible, values } = props;
	if (!visible) return null;
	const MAX_COUNT = 50;
	return /* @__PURE__ */ import_react.createElement("span", {
		"aria-live": "polite",
		style: {
			width: 0,
			height: 0,
			position: "absolute",
			overflow: "hidden",
			opacity: 0
		}
	}, `${values.slice(0, MAX_COUNT).map(({ label, value }) => ["number", "string"].includes(typeof label) ? label : value).join(", ")}`, values.length > MAX_COUNT ? ", ..." : null);
}

//#endregion
//#region node_modules/@rc-component/select/es/hooks/useOpen.js
var internalMacroTask = (fn) => {
	const channel = new MessageChannel();
	channel.port1.onmessage = fn;
	channel.port2.postMessage(null);
};
const macroTask = (fn, times = 1) => {
	if (times <= 0) {
		fn();
		return;
	}
	internalMacroTask(() => {
		macroTask(fn, times - 1);
	});
};
/**
* Trigger by latest open call, if nextOpen is undefined, means toggle.
* `weak` means this call can be ignored if previous call exists.
*/
/**
* When `open` is controlled, follow the controlled value;
* Otherwise use uncontrolled logic.
* Setting `open` takes effect immediately,
* but setting it to `false` is delayed via MessageChannel.
*
* SSR handling: During SSR, `open` is always false to avoid Portal issues.
* On client-side hydration, it syncs with the actual open state.
*/
function useOpen$1(defaultOpen, propOpen, onOpen, postOpen) {
	const [rendered, setRendered] = (0, import_react.useState)(false);
	(0, import_react.useEffect)(() => {
		setRendered(true);
	}, []);
	const [stateOpen, internalSetOpen] = useControlledState(defaultOpen, propOpen);
	const mergedOpen = postOpen(rendered ? stateOpen : false);
	const taskIdRef = (0, import_react.useRef)(0);
	const triggerEvent = useEvent_default((nextOpen) => {
		if (onOpen && mergedOpen !== nextOpen) onOpen(nextOpen);
		internalSetOpen(nextOpen);
	});
	return [mergedOpen, useEvent_default((nextOpen, config = {}) => {
		const { cancelFun } = config;
		taskIdRef.current += 1;
		const id = taskIdRef.current;
		const nextOpenVal = typeof nextOpen === "boolean" ? nextOpen : !mergedOpen;
		function triggerUpdate() {
			if (id === taskIdRef.current && !cancelFun?.()) triggerEvent(nextOpenVal);
		}
		if (nextOpenVal) triggerUpdate();
		else macroTask(() => {
			triggerUpdate();
		});
	})];
}

//#endregion
//#region node_modules/@rc-component/select/es/SelectInput/Affix.js
function Affix(props) {
	const { children, ...restProps } = props;
	if (!children) return null;
	return /* @__PURE__ */ import_react.createElement("div", restProps, children);
}

//#endregion
//#region node_modules/@rc-component/select/es/SelectInput/context.js
var SelectInputContext = /* @__PURE__ */ import_react.createContext(null);
function useSelectInputContext() {
	return import_react.useContext(SelectInputContext);
}
var context_default$6 = SelectInputContext;

//#endregion
//#region node_modules/@rc-component/select/es/SelectInput/Input.js
var Input$4 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { onChange, onKeyDown: onKeyDown$1, onBlur, style: style$1, syncWidth, value, className, autoComplete, ...restProps } = props;
	const { prefixCls, mode, onSearch, onSearchSubmit, onInputBlur, autoFocus, tokenWithEnter, placeholder, components: { input: InputComponent = "input" } } = useSelectInputContext();
	const { id, classNames, styles, open: open$2, activeDescendantId, role, disabled } = useBaseProps() || {};
	const inputCls = clsx(`${prefixCls}-input`, classNames?.input, className);
	const compositionStatusRef = import_react.useRef(false);
	const pastedTextRef = import_react.useRef(null);
	const inputRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => inputRef.current);
	const handleChange = (event) => {
		let { value: nextVal } = event.target;
		if (tokenWithEnter && pastedTextRef.current && /[\r\n]/.test(pastedTextRef.current)) {
			const replacedText = pastedTextRef.current.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
			nextVal = nextVal.replace(replacedText, pastedTextRef.current);
		}
		pastedTextRef.current = null;
		if (onSearch) onSearch(nextVal, true, compositionStatusRef.current);
		onChange?.(event);
	};
	const handleKeyDown = (event) => {
		const { key } = event;
		const { value: nextVal } = event.currentTarget;
		if (key === "Enter" && mode === "tags" && !compositionStatusRef.current && onSearchSubmit) onSearchSubmit(nextVal);
		onKeyDown$1?.(event);
	};
	const handleBlur = (event) => {
		onInputBlur?.();
		onBlur?.(event);
	};
	const handleCompositionStart = () => {
		compositionStatusRef.current = true;
	};
	const handleCompositionEnd = (event) => {
		compositionStatusRef.current = false;
		if (mode !== "combobox") {
			const { value: nextVal } = event.currentTarget;
			onSearch?.(nextVal, true, false);
		}
	};
	const handlePaste = (event) => {
		const { clipboardData } = event;
		pastedTextRef.current = clipboardData?.getData("text") || "";
	};
	const [widthCssVar, setWidthCssVar] = import_react.useState(void 0);
	useLayoutEffect_default(() => {
		const input = inputRef.current;
		if (syncWidth && input) {
			input.style.width = "0px";
			const scrollWidth = input.scrollWidth;
			setWidthCssVar(scrollWidth);
			input.style.width = "";
		}
	}, [syncWidth, value]);
	const sharedInputProps = {
		id,
		type: mode === "combobox" ? "text" : "search",
		...restProps,
		ref: inputRef,
		style: {
			...styles?.input,
			...style$1,
			"--select-input-width": widthCssVar
		},
		autoFocus,
		autoComplete: autoComplete || "off",
		className: inputCls,
		disabled,
		value: value || "",
		onChange: handleChange,
		onKeyDown: handleKeyDown,
		onBlur: handleBlur,
		onPaste: handlePaste,
		onCompositionStart: handleCompositionStart,
		onCompositionEnd: handleCompositionEnd,
		role: role || "combobox",
		"aria-expanded": open$2 || false,
		"aria-haspopup": "listbox",
		"aria-owns": open$2 ? `${id}_list` : void 0,
		"aria-autocomplete": "list",
		"aria-controls": open$2 ? `${id}_list` : void 0,
		"aria-activedescendant": open$2 ? activeDescendantId : void 0
	};
	if (/* @__PURE__ */ import_react.isValidElement(InputComponent)) {
		const existingProps = InputComponent.props || {};
		const mergedProps = {
			placeholder: props.placeholder || placeholder,
			...sharedInputProps,
			...existingProps
		};
		Object.keys(existingProps).forEach((key) => {
			const existingValue = existingProps[key];
			if (typeof existingValue === "function") mergedProps[key] = (...args) => {
				existingValue(...args);
				sharedInputProps[key]?.(...args);
			};
		});
		mergedProps.ref = composeRef(InputComponent.ref, sharedInputProps.ref);
		return /* @__PURE__ */ import_react.cloneElement(InputComponent, mergedProps);
	}
	const Component$2 = InputComponent;
	return /* @__PURE__ */ import_react.createElement(Component$2, sharedInputProps);
});
var Input_default$3 = Input$4;

//#endregion
//#region node_modules/@rc-component/select/es/SelectInput/Content/Placeholder.js
function Placeholder$1(props) {
	const { prefixCls, placeholder, displayValues } = useSelectInputContext();
	const { classNames, styles } = useBaseProps();
	const { show = true } = props;
	if (displayValues.length) return null;
	return /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-placeholder`, classNames?.placeholder),
		style: {
			visibility: show ? "visible" : "hidden",
			...styles?.placeholder
		}
	}, placeholder);
}

//#endregion
//#region node_modules/@rc-component/select/es/SelectContext.js
/**
* SelectContext is only used for Select. BaseSelect should not consume this context.
*/
var SelectContext = /* @__PURE__ */ import_react.createContext(null);
var SelectContext_default = SelectContext;

//#endregion
//#region node_modules/@rc-component/select/es/utils/commonUtil.js
function toArray$6(value) {
	if (Array.isArray(value)) return value;
	return value !== void 0 ? [value] : [];
}
const isClient = typeof window !== "undefined" && window.document && window.document.documentElement;
function hasValue(value) {
	return value !== void 0 && value !== null;
}
/** combo mode no value judgment function */
function isComboNoValue(value) {
	return !value && value !== 0;
}
function isTitleType$1(title) {
	return ["string", "number"].includes(typeof title);
}
function getTitle(item) {
	let title = void 0;
	if (item) {
		if (isTitleType$1(item.title)) title = item.title.toString();
		else if (isTitleType$1(item.label)) title = item.label.toString();
	}
	return title;
}

//#endregion
//#region node_modules/@rc-component/select/es/SelectInput/Content/SingleContent.js
function _extends$83() {
	_extends$83 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$83.apply(this, arguments);
}
var SingleContent = /* @__PURE__ */ import_react.forwardRef(({ inputProps }, ref) => {
	const { prefixCls, searchValue, activeValue, displayValues, maxLength, mode } = useSelectInputContext();
	const { triggerOpen, title: rootTitle, showSearch, classNames, styles } = useBaseProps();
	const selectContext = import_react.useContext(SelectContext_default);
	const [inputChanged, setInputChanged] = import_react.useState(false);
	const combobox = mode === "combobox";
	const displayValue = displayValues[0];
	const mergedSearchValue = import_react.useMemo(() => {
		if (combobox && activeValue && !inputChanged && triggerOpen) return activeValue;
		return showSearch ? searchValue : "";
	}, [
		combobox,
		activeValue,
		inputChanged,
		triggerOpen,
		searchValue,
		showSearch
	]);
	const optionProps = import_react.useMemo(() => {
		const restProps = {
			className: `${prefixCls}-content-value`,
			style: { visibility: mergedSearchValue ? "hidden" : "visible" }
		};
		if (displayValue && selectContext?.flattenOptions) {
			const option = selectContext.flattenOptions.find((opt) => opt.value === displayValue.value);
			if (option?.data) {
				const { className, style: style$1 } = option.data;
				Object.assign(restProps, {
					title: getTitle(option.data),
					className: clsx(restProps.className, className),
					style: {
						...restProps.style,
						...style$1
					}
				});
			}
		}
		if (displayValue && !restProps.title) restProps.title = getTitle(displayValue);
		if (rootTitle !== void 0) restProps.title = rootTitle;
		return restProps;
	}, [
		displayValue,
		selectContext?.flattenOptions,
		prefixCls,
		mergedSearchValue,
		rootTitle
	]);
	import_react.useEffect(() => {
		if (combobox) setInputChanged(false);
	}, [combobox, activeValue]);
	return /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-content`, classNames?.content),
		style: styles?.content
	}, displayValue ? /* @__PURE__ */ import_react.createElement("div", optionProps, displayValue.label) : /* @__PURE__ */ import_react.createElement(Placeholder$1, { show: !mergedSearchValue }), /* @__PURE__ */ import_react.createElement(Input_default$3, _extends$83({ ref }, inputProps, {
		value: mergedSearchValue,
		maxLength: mode === "combobox" ? maxLength : void 0,
		onChange: (e$2) => {
			setInputChanged(true);
			inputProps.onChange?.(e$2);
		}
	})));
});
var SingleContent_default = SingleContent;

//#endregion
//#region node_modules/@rc-component/overflow/es/Item.js
var UNDEFINED = void 0;
function InternalItem(props, ref) {
	const { prefixCls, invalidate, item, renderItem: renderItem$1, responsive, responsiveDisabled, registerSize, itemKey: itemKey$2, className, style: style$1, children, display, order, component: Component$2 = "div", ...restProps } = props;
	const mergedHidden = responsive && !display;
	function internalRegisterSize(width) {
		registerSize(itemKey$2, width);
	}
	import_react.useEffect(() => () => {
		internalRegisterSize(null);
	}, []);
	const childNode = renderItem$1 && item !== UNDEFINED ? renderItem$1(item, { index: order }) : children;
	let overflowStyle;
	if (!invalidate) overflowStyle = {
		opacity: mergedHidden ? 0 : 1,
		height: mergedHidden ? 0 : UNDEFINED,
		overflowY: mergedHidden ? "hidden" : UNDEFINED,
		order: responsive ? order : UNDEFINED,
		pointerEvents: mergedHidden ? "none" : UNDEFINED,
		position: mergedHidden ? "absolute" : UNDEFINED
	};
	const overflowProps = {};
	if (mergedHidden) overflowProps["aria-hidden"] = true;
	let itemNode = /* @__PURE__ */ import_react.createElement(Component$2, _extends$26({
		className: clsx(!invalidate && prefixCls, className),
		style: {
			...overflowStyle,
			...style$1
		}
	}, overflowProps, restProps, { ref }), childNode);
	if (responsive) itemNode = /* @__PURE__ */ import_react.createElement(es_default$2, {
		onResize: ({ offsetWidth }) => {
			internalRegisterSize(offsetWidth);
		},
		disabled: responsiveDisabled
	}, itemNode);
	return itemNode;
}
var Item$3 = /* @__PURE__ */ import_react.forwardRef(InternalItem);
Item$3.displayName = "Item";
var Item_default$3 = Item$3;

//#endregion
//#region node_modules/@rc-component/overflow/es/hooks/channelUpdate.js
function channelUpdate(callback) {
	if (typeof MessageChannel === "undefined") raf_default(callback);
	else {
		const channel = new MessageChannel();
		channel.port1.onmessage = () => callback();
		channel.port2.postMessage(void 0);
	}
}

//#endregion
//#region node_modules/@rc-component/overflow/es/hooks/useEffectState.js
var import_react_dom$5 = require_react_dom();
/**
* Batcher for record any `useEffectState` need update.
*/
function useBatcher() {
	const updateFuncRef = import_react.useRef(null);
	const notifyEffectUpdate = (callback) => {
		if (!updateFuncRef.current) {
			updateFuncRef.current = [];
			channelUpdate(() => {
				(0, import_react_dom$5.unstable_batchedUpdates)(() => {
					updateFuncRef.current.forEach((fn) => {
						fn();
					});
					updateFuncRef.current = null;
				});
			});
		}
		updateFuncRef.current.push(callback);
	};
	return notifyEffectUpdate;
}
/**
* Trigger state update by `useLayoutEffect` to save perf.
*/
function useEffectState$1(notifyEffectUpdate, defaultValue) {
	const [stateValue, setStateValue] = import_react.useState(defaultValue);
	return [stateValue, useEvent_default((nextValue) => {
		notifyEffectUpdate(() => {
			setStateValue(nextValue);
		});
	})];
}

//#endregion
//#region node_modules/@rc-component/overflow/es/context.js
const OverflowContext = /* @__PURE__ */ import_react.createContext(null);

//#endregion
//#region node_modules/@rc-component/overflow/es/RawItem.js
var InternalRawItem = (props, ref) => {
	const context = import_react.useContext(OverflowContext);
	if (!context) {
		const { component: Component$2 = "div", ...restProps$1 } = props;
		return /* @__PURE__ */ import_react.createElement(Component$2, _extends$26({}, restProps$1, { ref }));
	}
	const { className: contextClassName, ...restContext } = context;
	const { className, ...restProps } = props;
	return /* @__PURE__ */ import_react.createElement(OverflowContext.Provider, { value: null }, /* @__PURE__ */ import_react.createElement(Item_default$3, _extends$26({
		ref,
		className: clsx(contextClassName, className)
	}, restContext, restProps)));
};
var RawItem = /* @__PURE__ */ import_react.forwardRef(InternalRawItem);
RawItem.displayName = "RawItem";
var RawItem_default = RawItem;

//#endregion
//#region node_modules/@rc-component/overflow/es/Overflow.js
var RESPONSIVE = "responsive";
var INVALIDATE = "invalidate";
function defaultRenderRest(omittedItems) {
	return `+ ${omittedItems.length} ...`;
}
function Overflow(props, ref) {
	const { prefixCls = "rc-overflow", data = [], renderItem: renderItem$1, renderRawItem, itemKey: itemKey$2, itemWidth = 10, ssr, style: style$1, className, maxCount, renderRest, renderRawRest, prefix: prefix$1, suffix, component: Component$2 = "div", itemComponent, onVisibleChange, ...restProps } = props;
	const fullySSR = ssr === "full";
	const notifyEffectUpdate = useBatcher();
	const [containerWidth, setContainerWidth] = useEffectState$1(notifyEffectUpdate, null);
	const mergedContainerWidth = containerWidth || 0;
	const [itemWidths, setItemWidths] = useEffectState$1(notifyEffectUpdate, /* @__PURE__ */ new Map());
	const [prevRestWidth, setPrevRestWidth] = useEffectState$1(notifyEffectUpdate, 0);
	const [restWidth, setRestWidth] = useEffectState$1(notifyEffectUpdate, 0);
	const [prefixWidth, setPrefixWidth] = useEffectState$1(notifyEffectUpdate, 0);
	const [suffixWidth, setSuffixWidth] = useEffectState$1(notifyEffectUpdate, 0);
	const [suffixFixedStart, setSuffixFixedStart] = (0, import_react.useState)(null);
	const [displayCount, setDisplayCount] = (0, import_react.useState)(null);
	const mergedDisplayCount = import_react.useMemo(() => {
		if (displayCount === null && fullySSR) return Number.MAX_SAFE_INTEGER;
		return displayCount || 0;
	}, [displayCount, containerWidth]);
	const [restReady, setRestReady] = (0, import_react.useState)(false);
	const itemPrefixCls = `${prefixCls}-item`;
	const mergedRestWidth = Math.max(prevRestWidth, restWidth);
	const isResponsive = maxCount === RESPONSIVE;
	const shouldResponsive = data.length && isResponsive;
	const invalidate = maxCount === INVALIDATE;
	/**
	* When is `responsive`, we will always render rest node to get the real width of it for calculation
	*/
	const showRest = shouldResponsive || typeof maxCount === "number" && data.length > maxCount;
	const mergedData = (0, import_react.useMemo)(() => {
		let items = data;
		if (shouldResponsive) if (containerWidth === null && fullySSR) items = data;
		else items = data.slice(0, Math.min(data.length, mergedContainerWidth / itemWidth));
		else if (typeof maxCount === "number") items = data.slice(0, maxCount);
		return items;
	}, [
		data,
		itemWidth,
		containerWidth,
		maxCount,
		shouldResponsive
	]);
	const omittedItems = (0, import_react.useMemo)(() => {
		if (shouldResponsive) return data.slice(mergedDisplayCount + 1);
		return data.slice(mergedData.length);
	}, [
		data,
		mergedData,
		shouldResponsive,
		mergedDisplayCount
	]);
	const getKey$3 = (0, import_react.useCallback)((item, index$1) => {
		if (typeof itemKey$2 === "function") return itemKey$2(item);
		return (itemKey$2 && item?.[itemKey$2]) ?? index$1;
	}, [itemKey$2]);
	const mergedRenderItem = (0, import_react.useCallback)(renderItem$1 || ((item) => item), [renderItem$1]);
	function updateDisplayCount(count, suffixFixedStartVal, notReady) {
		if (displayCount === count && (suffixFixedStartVal === void 0 || suffixFixedStartVal === suffixFixedStart)) return;
		setDisplayCount(count);
		if (!notReady) {
			setRestReady(count < data.length - 1);
			onVisibleChange?.(count);
		}
		if (suffixFixedStartVal !== void 0) setSuffixFixedStart(suffixFixedStartVal);
	}
	function onOverflowResize(_, element) {
		setContainerWidth(element.clientWidth);
	}
	function registerSize(key, width) {
		setItemWidths((origin) => {
			const clone = new Map(origin);
			if (width === null) clone.delete(key);
			else clone.set(key, width);
			return clone;
		});
	}
	function registerOverflowSize(_, width) {
		setRestWidth(width);
		setPrevRestWidth(restWidth);
	}
	function registerPrefixSize(_, width) {
		setPrefixWidth(width);
	}
	function registerSuffixSize(_, width) {
		setSuffixWidth(width);
	}
	function getItemWidth(index$1) {
		return itemWidths.get(getKey$3(mergedData[index$1], index$1));
	}
	useLayoutEffect_default(() => {
		if (mergedContainerWidth && typeof mergedRestWidth === "number" && mergedData) {
			let totalWidth = prefixWidth + suffixWidth;
			const len = mergedData.length;
			const lastIndex = len - 1;
			if (!len) {
				updateDisplayCount(0, null);
				return;
			}
			for (let i = 0; i < len; i += 1) {
				let currentItemWidth = getItemWidth(i);
				if (fullySSR) currentItemWidth = currentItemWidth || 0;
				if (currentItemWidth === void 0) {
					updateDisplayCount(i - 1, void 0, true);
					break;
				}
				totalWidth += currentItemWidth;
				if (lastIndex === 0 && totalWidth <= mergedContainerWidth || i === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth) {
					updateDisplayCount(lastIndex, null);
					break;
				} else if (totalWidth + mergedRestWidth > mergedContainerWidth) {
					updateDisplayCount(i - 1, totalWidth - currentItemWidth - suffixWidth + restWidth);
					break;
				}
			}
			if (suffix && getItemWidth(0) + suffixWidth > mergedContainerWidth) setSuffixFixedStart(null);
		}
	}, [
		mergedContainerWidth,
		itemWidths,
		restWidth,
		prefixWidth,
		suffixWidth,
		getKey$3,
		mergedData
	]);
	const displayRest = restReady && !!omittedItems.length;
	let suffixStyle = {};
	if (suffixFixedStart !== null && shouldResponsive) suffixStyle = {
		position: "absolute",
		left: suffixFixedStart,
		top: 0
	};
	const itemSharedProps = {
		prefixCls: itemPrefixCls,
		responsive: shouldResponsive,
		component: itemComponent,
		invalidate
	};
	const internalRenderItemNode = renderRawItem ? (item, index$1) => {
		const key = getKey$3(item, index$1);
		return /* @__PURE__ */ import_react.createElement(OverflowContext.Provider, {
			key,
			value: {
				...itemSharedProps,
				order: index$1,
				item,
				itemKey: key,
				registerSize,
				display: index$1 <= mergedDisplayCount
			}
		}, renderRawItem(item, index$1));
	} : (item, index$1) => {
		const key = getKey$3(item, index$1);
		return /* @__PURE__ */ import_react.createElement(Item_default$3, _extends$26({}, itemSharedProps, {
			order: index$1,
			key,
			item,
			renderItem: mergedRenderItem,
			itemKey: key,
			registerSize,
			display: index$1 <= mergedDisplayCount
		}));
	};
	const restContextProps = {
		order: displayRest ? mergedDisplayCount : Number.MAX_SAFE_INTEGER,
		className: `${itemPrefixCls}-rest`,
		registerSize: registerOverflowSize,
		display: displayRest
	};
	const mergedRenderRest = renderRest || defaultRenderRest;
	const restNode = renderRawRest ? /* @__PURE__ */ import_react.createElement(OverflowContext.Provider, { value: {
		...itemSharedProps,
		...restContextProps
	} }, renderRawRest(omittedItems)) : /* @__PURE__ */ import_react.createElement(Item_default$3, _extends$26({}, itemSharedProps, restContextProps), typeof mergedRenderRest === "function" ? mergedRenderRest(omittedItems) : mergedRenderRest);
	const overflowNode = /* @__PURE__ */ import_react.createElement(Component$2, _extends$26({
		className: clsx(!invalidate && prefixCls, className),
		style: style$1,
		ref
	}, restProps), prefix$1 && /* @__PURE__ */ import_react.createElement(Item_default$3, _extends$26({}, itemSharedProps, {
		responsive: isResponsive,
		responsiveDisabled: !shouldResponsive,
		order: -1,
		className: `${itemPrefixCls}-prefix`,
		registerSize: registerPrefixSize,
		display: true
	}), prefix$1), mergedData.map(internalRenderItemNode), showRest ? restNode : null, suffix && /* @__PURE__ */ import_react.createElement(Item_default$3, _extends$26({}, itemSharedProps, {
		responsive: isResponsive,
		responsiveDisabled: !shouldResponsive,
		order: mergedDisplayCount,
		className: `${itemPrefixCls}-suffix`,
		registerSize: registerSuffixSize,
		display: true,
		style: suffixStyle
	}), suffix));
	return isResponsive ? /* @__PURE__ */ import_react.createElement(es_default$2, {
		onResize: onOverflowResize,
		disabled: !shouldResponsive
	}, overflowNode) : overflowNode;
}
var ForwardOverflow = /* @__PURE__ */ import_react.forwardRef(Overflow);
ForwardOverflow.Item = RawItem_default;
ForwardOverflow.RESPONSIVE = RESPONSIVE;
ForwardOverflow.INVALIDATE = INVALIDATE;
ForwardOverflow.displayName = "Overflow";
var Overflow_default = ForwardOverflow;

//#endregion
//#region node_modules/@rc-component/overflow/es/index.js
var es_default$30 = Overflow_default;

//#endregion
//#region node_modules/@rc-component/select/es/TransBtn.js
/**
* Small wrapper for Select icons (clear/arrow/etc.).
* Prevents default mousedown to avoid blurring or caret moves, and
* renders a custom icon or a fallback icon span.
*
* DOM structure:
* <span className={className} ...>
*   { icon || <span className={`${className}-icon`}>{children}</span> }
* </span>
*/
var TransBtn = (props) => {
	const { className, style: style$1, customizeIcon, customizeIconProps, children, onMouseDown, onClick } = props;
	const icon = typeof customizeIcon === "function" ? customizeIcon(customizeIconProps) : customizeIcon;
	return /* @__PURE__ */ import_react.createElement("span", {
		className,
		onMouseDown: (event) => {
			event.preventDefault();
			onMouseDown?.(event);
		},
		style: {
			userSelect: "none",
			WebkitUserSelect: "none",
			...style$1
		},
		unselectable: "on",
		onClick,
		"aria-hidden": true
	}, icon !== void 0 ? icon : /* @__PURE__ */ import_react.createElement("span", { className: clsx(className.split(/\s+/).map((cls) => `${cls}-icon`)) }, children));
};
var TransBtn_default = TransBtn;

//#endregion
//#region node_modules/@rc-component/select/es/SelectInput/Content/MultipleContent.js
function _extends$82() {
	_extends$82 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$82.apply(this, arguments);
}
function itemKey$1(value) {
	return value.key ?? value.value;
}
var onPreventMouseDown = (event) => {
	event.preventDefault();
	event.stopPropagation();
};
var MultipleContent_default = /* @__PURE__ */ import_react.forwardRef(function MultipleContent({ inputProps }, ref) {
	const { prefixCls, displayValues, searchValue, mode, onSelectorRemove, removeIcon: removeIconFromContext } = useSelectInputContext();
	const { disabled, showSearch, triggerOpen, toggleOpen, autoClearSearchValue, tagRender: tagRenderFromContext, maxTagPlaceholder: maxTagPlaceholderFromContext, maxTagTextLength, maxTagCount, classNames, styles } = useBaseProps();
	const selectionItemPrefixCls = `${prefixCls}-selection-item`;
	let computedSearchValue = searchValue;
	if (!triggerOpen && mode === "multiple" && autoClearSearchValue !== false) computedSearchValue = "";
	const inputValue = showSearch ? computedSearchValue || "" : "";
	const inputEditable = showSearch && !disabled;
	const removeIcon = removeIconFromContext ?? "";
	const maxTagPlaceholder = maxTagPlaceholderFromContext ?? ((omittedValues) => `+ ${omittedValues.length} ...`);
	const tagRender = tagRenderFromContext;
	const onToggleOpen = (newOpen) => {
		toggleOpen(newOpen);
	};
	const onRemove = (value) => {
		onSelectorRemove?.(value);
	};
	const defaultRenderSelector = (item, content, itemDisabled, closable, onClose) => /* @__PURE__ */ import_react.createElement("span", {
		title: getTitle(item),
		className: clsx(selectionItemPrefixCls, { [`${selectionItemPrefixCls}-disabled`]: itemDisabled }, classNames?.item),
		style: styles?.item
	}, /* @__PURE__ */ import_react.createElement("span", {
		className: clsx(`${selectionItemPrefixCls}-content`, classNames?.itemContent),
		style: styles?.itemContent
	}, content), closable && /* @__PURE__ */ import_react.createElement(TransBtn_default, {
		className: clsx(`${selectionItemPrefixCls}-remove`, classNames?.itemRemove),
		style: styles?.itemRemove,
		onMouseDown: onPreventMouseDown,
		onClick: onClose,
		customizeIcon: removeIcon
	}, ""));
	const customizeRenderSelector = (value, content, itemDisabled, closable, onClose, isMaxTag, info) => {
		const onMouseDown = (e$2) => {
			onPreventMouseDown(e$2);
			onToggleOpen(!triggerOpen);
		};
		return /* @__PURE__ */ import_react.createElement("span", { onMouseDown }, tagRender({
			label: content,
			value,
			index: info?.index,
			disabled: itemDisabled,
			closable,
			onClose,
			isMaxTag: !!isMaxTag
		}));
	};
	const renderItem$1 = (valueItem, info) => {
		const { disabled: itemDisabled, label, value } = valueItem;
		const closable = !disabled && !itemDisabled;
		let displayLabel = label;
		if (typeof maxTagTextLength === "number") {
			if (typeof label === "string" || typeof label === "number") {
				const strLabel = String(displayLabel);
				if (strLabel.length > maxTagTextLength) displayLabel = `${strLabel.slice(0, maxTagTextLength)}...`;
			}
		}
		const onClose = (event) => {
			if (event) event.stopPropagation();
			onRemove(valueItem);
		};
		return typeof tagRender === "function" ? customizeRenderSelector(value, displayLabel, itemDisabled, closable, onClose, void 0, info) : defaultRenderSelector(valueItem, displayLabel, itemDisabled, closable, onClose);
	};
	const renderRest = (omittedValues) => {
		if (!displayValues.length) return null;
		const content = typeof maxTagPlaceholder === "function" ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
		return typeof tagRender === "function" ? customizeRenderSelector(void 0, content, false, false, void 0, true) : defaultRenderSelector({ title: content }, content, false);
	};
	return /* @__PURE__ */ import_react.createElement(es_default$30, {
		prefixCls: `${prefixCls}-content`,
		className: classNames?.content,
		style: styles?.content,
		prefix: !displayValues.length && (!searchValue || !triggerOpen) ? /* @__PURE__ */ import_react.createElement(Placeholder$1, null) : null,
		data: displayValues,
		renderItem: renderItem$1,
		renderRest,
		suffix: /* @__PURE__ */ import_react.createElement(Input_default$3, _extends$82({
			ref,
			disabled,
			readOnly: !inputEditable
		}, inputProps, {
			value: inputValue || "",
			syncWidth: true
		})),
		itemKey: itemKey$1,
		maxCount: maxTagCount
	});
});

//#endregion
//#region node_modules/@rc-component/select/es/SelectInput/Content/index.js
var SelectContent = /* @__PURE__ */ import_react.forwardRef(function SelectContent$1(_, ref) {
	const { multiple, onInputKeyDown, tabIndex } = useSelectInputContext();
	const baseProps = useBaseProps();
	const { showSearch } = baseProps;
	const sharedInputProps = {
		...pickAttrs(baseProps, { aria: true }),
		onKeyDown: onInputKeyDown,
		readOnly: !showSearch,
		tabIndex
	};
	if (multiple) return /* @__PURE__ */ import_react.createElement(MultipleContent_default, {
		ref,
		inputProps: sharedInputProps
	});
	return /* @__PURE__ */ import_react.createElement(SingleContent_default, {
		ref,
		inputProps: sharedInputProps
	});
});
var Content_default = SelectContent;

//#endregion
//#region node_modules/@rc-component/select/es/utils/keyUtil.js
/** keyCode Judgment function */
function isValidateOpenKey(currentKeyCode) {
	return currentKeyCode && ![
		KeyCode_default.ESC,
		KeyCode_default.SHIFT,
		KeyCode_default.BACKSPACE,
		KeyCode_default.TAB,
		KeyCode_default.WIN_KEY,
		KeyCode_default.ALT,
		KeyCode_default.META,
		KeyCode_default.WIN_KEY_RIGHT,
		KeyCode_default.CTRL,
		KeyCode_default.SEMICOLON,
		KeyCode_default.EQUALS,
		KeyCode_default.CAPS_LOCK,
		KeyCode_default.CONTEXT_MENU,
		KeyCode_default.UP,
		KeyCode_default.LEFT,
		KeyCode_default.RIGHT,
		KeyCode_default.F1,
		KeyCode_default.F2,
		KeyCode_default.F3,
		KeyCode_default.F4,
		KeyCode_default.F5,
		KeyCode_default.F6,
		KeyCode_default.F7,
		KeyCode_default.F8,
		KeyCode_default.F9,
		KeyCode_default.F10,
		KeyCode_default.F11,
		KeyCode_default.F12
	].includes(currentKeyCode);
}

//#endregion
//#region node_modules/@rc-component/select/es/SelectInput/index.js
function _extends$81() {
	_extends$81 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$81.apply(this, arguments);
}
var DEFAULT_OMIT_PROPS = [
	"value",
	"onChange",
	"removeIcon",
	"placeholder",
	"maxTagCount",
	"maxTagTextLength",
	"maxTagPlaceholder",
	"choiceTransitionName",
	"onInputKeyDown",
	"onPopupScroll",
	"tabIndex",
	"activeValue",
	"onSelectorRemove",
	"focused"
];
var SelectInput_default = /* @__PURE__ */ import_react.forwardRef(function SelectInput(props, ref) {
	const { prefixCls, className, style: style$1, prefix: prefix$1, suffix, clearIcon, children, multiple, displayValues, placeholder, mode, searchValue, onSearch, onSearchSubmit, onInputBlur, maxLength, autoFocus, onMouseDown, onClearMouseDown, onInputKeyDown, onSelectorRemove, tokenWithEnter, components: components$1, ...restProps } = props;
	const { triggerOpen, toggleOpen, showSearch, disabled, loading, classNames, styles } = useBaseProps();
	const rootRef = import_react.useRef(null);
	const inputRef = import_react.useRef(null);
	const onInternalInputKeyDown = useEvent_default((event) => {
		const { which } = event;
		const isTextAreaElement = inputRef.current instanceof HTMLTextAreaElement;
		if (!isTextAreaElement && triggerOpen && (which === KeyCode_default.UP || which === KeyCode_default.DOWN)) event.preventDefault();
		if (onInputKeyDown) onInputKeyDown(event);
		if (isTextAreaElement && !triggerOpen && ~[
			KeyCode_default.UP,
			KeyCode_default.DOWN,
			KeyCode_default.LEFT,
			KeyCode_default.RIGHT
		].indexOf(which)) return;
		if (!(event.ctrlKey || event.altKey || event.metaKey) && isValidateOpenKey(which)) toggleOpen(true);
	});
	import_react.useImperativeHandle(ref, () => {
		return {
			focus: (options) => {
				(inputRef.current || rootRef.current).focus?.(options);
			},
			blur: () => {
				(inputRef.current || rootRef.current).blur?.();
			},
			nativeElement: rootRef.current
		};
	});
	const onInternalMouseDown = useEvent_default((event) => {
		if (!disabled) {
			const inputDOM = getDOM(inputRef.current);
			event.nativeEvent._ori_target = inputDOM;
			if (inputDOM && event.target !== inputDOM && !inputDOM.contains(event.target)) event.preventDefault();
			const shouldPreventClose = triggerOpen && !multiple && (mode === "combobox" || showSearch);
			if (!event.nativeEvent._select_lazy) {
				inputRef.current?.focus();
				if (!shouldPreventClose) toggleOpen();
			} else if (triggerOpen) toggleOpen(false);
		}
		onMouseDown?.(event);
	});
	const { root: RootComponent } = components$1;
	const domProps = omit(restProps, DEFAULT_OMIT_PROPS);
	const ariaProps = pickAttrs(domProps, { aria: true });
	const ariaKeys = Object.keys(ariaProps);
	const contextValue = {
		...props,
		onInputKeyDown: onInternalInputKeyDown
	};
	if (RootComponent) {
		if (/* @__PURE__ */ import_react.isValidElement(RootComponent)) return /* @__PURE__ */ import_react.cloneElement(RootComponent, {
			...domProps,
			ref: composeRef(RootComponent.ref, rootRef)
		});
		return /* @__PURE__ */ import_react.createElement(RootComponent, _extends$81({}, domProps, { ref: rootRef }));
	}
	return /* @__PURE__ */ import_react.createElement(context_default$6.Provider, { value: contextValue }, /* @__PURE__ */ import_react.createElement("div", _extends$81({}, omit(domProps, ariaKeys), {
		ref: rootRef,
		className,
		style: style$1,
		onMouseDown: onInternalMouseDown
	}), /* @__PURE__ */ import_react.createElement(Affix, {
		className: clsx(`${prefixCls}-prefix`, classNames?.prefix),
		style: styles?.prefix
	}, prefix$1), /* @__PURE__ */ import_react.createElement(Content_default, { ref: inputRef }), /* @__PURE__ */ import_react.createElement(Affix, {
		className: clsx(`${prefixCls}-suffix`, { [`${prefixCls}-suffix-loading`]: loading }, classNames?.suffix),
		style: styles?.suffix
	}, suffix), clearIcon && /* @__PURE__ */ import_react.createElement(Affix, {
		className: clsx(`${prefixCls}-clear`, classNames?.clear),
		style: styles?.clear,
		onMouseDown: (e$2) => {
			e$2.nativeEvent._select_lazy = true;
			onClearMouseDown?.(e$2);
		}
	}, clearIcon), children));
});

//#endregion
//#region node_modules/@rc-component/select/es/hooks/useComponents.js
function useComponents$1(components$1, getInputElement, getRawInputElement) {
	return import_react.useMemo(() => {
		let { root, input } = components$1 || {};
		if (getRawInputElement) root = getRawInputElement();
		if (getInputElement) input = getInputElement();
		return {
			root,
			input
		};
	}, [
		components$1,
		getInputElement,
		getRawInputElement
	]);
}

//#endregion
//#region node_modules/@rc-component/select/es/BaseSelect/index.js
function _extends$80() {
	_extends$80 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$80.apply(this, arguments);
}
/**
* ZombieJ:
* We are currently refactoring the semantic structure of the component. Changelog:
* - Remove `suffixIcon` and change to `suffix`.
* - Add `components.root` for replacing response element.
*   - Remove `getInputElement` and `getRawInputElement` since we can use `components.input` instead.
*/
const isMultiple = (mode) => mode === "tags" || mode === "multiple";
var BaseSelect = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { id, prefixCls, className, styles, classNames, showSearch, tagRender, showScrollBar = "optional", direction, omitDomProps, displayValues, onDisplayValuesChange, emptyOptions, notFoundContent = "Not Found", onClear, maxCount, placeholder, mode, disabled, loading, getInputElement, getRawInputElement, open: open$2, defaultOpen, onPopupVisibleChange, activeValue, onActiveValueChange, activeDescendantId, searchValue, autoClearSearchValue, onSearch, onSearchSplit, tokenSeparators, allowClear, prefix: prefix$1, suffix, suffixIcon, clearIcon, OptionList: OptionList$2, animation, transitionName, popupStyle, popupClassName, popupMatchSelectWidth, popupRender, popupAlign, placement, builtinPlacements, getPopupContainer, showAction = [], onFocus, onBlur, onKeyUp, onKeyDown: onKeyDown$1, onMouseDown, components: components$1, ...restProps } = props;
	const multiple = isMultiple(mode);
	const containerRef = import_react.useRef(null);
	const triggerRef = import_react.useRef(null);
	const listRef = import_react.useRef(null);
	/** Used for component focused management */
	const [focused, setFocused] = import_react.useState(false);
	import_react.useImperativeHandle(ref, () => ({
		focus: containerRef.current?.focus,
		blur: containerRef.current?.blur,
		scrollTo: (arg) => listRef.current?.scrollTo(arg),
		nativeElement: getDOM(containerRef.current)
	}));
	const mergedComponents = useComponents$1(components$1, getInputElement, getRawInputElement);
	const mergedSearchValue = import_react.useMemo(() => {
		if (mode !== "combobox") return searchValue;
		const val = displayValues[0]?.value;
		return typeof val === "string" || typeof val === "number" ? String(val) : "";
	}, [
		searchValue,
		mode,
		displayValues
	]);
	const customizeInputElement = mode === "combobox" && typeof getInputElement === "function" && getInputElement() || null;
	const emptyListContent = !notFoundContent && emptyOptions;
	const [mergedOpen, triggerOpen] = useOpen$1(defaultOpen || false, open$2, onPopupVisibleChange, (nextOpen) => disabled || emptyListContent ? false : nextOpen);
	const tokenWithEnter = import_react.useMemo(() => (tokenSeparators || []).some((tokenSeparator) => ["\n", "\r\n"].includes(tokenSeparator)), [tokenSeparators]);
	const onInternalSearch = (searchText, fromTyping, isCompositing) => {
		if (multiple && isValidCount(maxCount) && displayValues.length >= maxCount) return;
		let ret = true;
		let newSearchText = searchText;
		onActiveValueChange?.(null);
		const separatedList = getSeparatedContent(searchText, tokenSeparators, isValidCount(maxCount) ? maxCount - displayValues.length : void 0);
		const patchLabels = isCompositing ? null : separatedList;
		if (mode !== "combobox" && patchLabels) {
			newSearchText = "";
			onSearchSplit?.(patchLabels);
			triggerOpen(false);
			ret = false;
		}
		if (onSearch && mergedSearchValue !== newSearchText) onSearch(newSearchText, { source: fromTyping ? "typing" : "effect" });
		if (searchText && fromTyping && ret) triggerOpen(true);
		return ret;
	};
	const onInternalSearchSubmit = (searchText) => {
		if (!searchText || !searchText.trim()) return;
		onSearch(searchText, { source: "submit" });
	};
	import_react.useEffect(() => {
		if (!mergedOpen && !multiple && mode !== "combobox") onInternalSearch("", false, false);
	}, [mergedOpen]);
	import_react.useEffect(() => {
		if (disabled) {
			triggerOpen(false);
			setFocused(false);
		}
	}, [disabled, mergedOpen]);
	/**
	* We record input value here to check if can press to clean up by backspace
	* - null: Key is not down, this is reset by key up
	* - true: Search text is empty when first time backspace down
	* - false: Search text is not empty when first time backspace down
	*/
	const [getClearLock, setClearLock] = useLock();
	const keyLockRef = import_react.useRef(false);
	const onInternalKeyDown = (event) => {
		const clearLock = getClearLock();
		const { key } = event;
		const isEnterKey = key === "Enter";
		if (isEnterKey) {
			if (mode !== "combobox") event.preventDefault();
			if (!mergedOpen) triggerOpen(true);
		}
		setClearLock(!!mergedSearchValue);
		if (key === "Backspace" && !clearLock && multiple && !mergedSearchValue && displayValues.length) {
			const cloneDisplayValues = [...displayValues];
			let removedDisplayValue = null;
			for (let i = cloneDisplayValues.length - 1; i >= 0; i -= 1) {
				const current = cloneDisplayValues[i];
				if (!current.disabled) {
					cloneDisplayValues.splice(i, 1);
					removedDisplayValue = current;
					break;
				}
			}
			if (removedDisplayValue) onDisplayValuesChange(cloneDisplayValues, {
				type: "remove",
				values: [removedDisplayValue]
			});
		}
		if (mergedOpen && (!isEnterKey || !keyLockRef.current)) {
			if (isEnterKey) keyLockRef.current = true;
			listRef.current?.onKeyDown(event);
		}
		onKeyDown$1?.(event);
	};
	const onInternalKeyUp = (event, ...rest) => {
		if (mergedOpen) listRef.current?.onKeyUp(event, ...rest);
		if (event.key === "Enter") keyLockRef.current = false;
		onKeyUp?.(event, ...rest);
	};
	const onSelectorRemove = useEvent_default((val) => {
		onDisplayValuesChange(displayValues.filter((i) => i !== val), {
			type: "remove",
			values: [val]
		});
	});
	const onInputBlur = () => {
		keyLockRef.current = false;
	};
	const getSelectElements = () => [getDOM(containerRef.current), triggerRef.current?.getPopupElement()];
	useSelectTriggerControl(getSelectElements, mergedOpen, triggerOpen, !!mergedComponents.root);
	const internalMouseDownRef = import_react.useRef(false);
	const onInternalFocus = (event) => {
		setFocused(true);
		if (!disabled) {
			if (showAction.includes("focus")) triggerOpen(true);
			onFocus?.(event);
		}
	};
	const onRootBlur = () => {
		if (mergedOpen && !internalMouseDownRef.current) triggerOpen(false, { cancelFun: () => isInside(getSelectElements(), document.activeElement) });
	};
	const onInternalBlur = (event) => {
		setFocused(false);
		if (mergedSearchValue) {
			if (mode === "tags") onSearch(mergedSearchValue, { source: "submit" });
			else if (mode === "multiple") onSearch("", { source: "blur" });
		}
		onRootBlur();
		if (!disabled) onBlur?.(event);
	};
	const onRootMouseDown = (event, ...restArgs) => {
		const { target } = event;
		if ((triggerRef.current?.getPopupElement())?.contains(target) && triggerOpen) triggerOpen(true);
		onMouseDown?.(event, ...restArgs);
		internalMouseDownRef.current = true;
		macroTask(() => {
			internalMouseDownRef.current = false;
		});
	};
	const [, forceUpdate] = import_react.useState({});
	function onPopupMouseEnter() {
		forceUpdate({});
	}
	let onTriggerVisibleChange;
	if (!!mergedComponents.root) onTriggerVisibleChange = (newOpen) => {
		triggerOpen(newOpen);
	};
	const baseSelectContext = import_react.useMemo(() => ({
		...props,
		notFoundContent,
		open: mergedOpen,
		triggerOpen: mergedOpen,
		id,
		showSearch,
		multiple,
		toggleOpen: triggerOpen,
		showScrollBar,
		styles,
		classNames
	}), [
		props,
		notFoundContent,
		triggerOpen,
		id,
		showSearch,
		multiple,
		mergedOpen,
		showScrollBar,
		styles,
		classNames
	]);
	const mergedSuffixIcon = import_react.useMemo(() => {
		const nextSuffix = suffix ?? suffixIcon;
		if (typeof nextSuffix === "function") return nextSuffix({
			searchValue: mergedSearchValue,
			open: mergedOpen,
			focused,
			showSearch,
			loading
		});
		return nextSuffix;
	}, [
		suffix,
		suffixIcon,
		mergedSearchValue,
		mergedOpen,
		focused,
		showSearch,
		loading
	]);
	const onClearMouseDown = () => {
		onClear?.();
		containerRef.current?.focus();
		onDisplayValuesChange([], {
			type: "clear",
			values: displayValues
		});
		onInternalSearch("", false, false);
	};
	const { allowClear: mergedAllowClear, clearIcon: clearNode } = useAllowClear(prefixCls, displayValues, allowClear, clearIcon, disabled, mergedSearchValue, mode);
	const optionList = /* @__PURE__ */ import_react.createElement(OptionList$2, { ref: listRef });
	const mergedClassName = clsx(prefixCls, className, {
		[`${prefixCls}-focused`]: focused,
		[`${prefixCls}-multiple`]: multiple,
		[`${prefixCls}-single`]: !multiple,
		[`${prefixCls}-allow-clear`]: mergedAllowClear,
		[`${prefixCls}-show-arrow`]: mergedSuffixIcon !== void 0 && mergedSuffixIcon !== null,
		[`${prefixCls}-disabled`]: disabled,
		[`${prefixCls}-loading`]: loading,
		[`${prefixCls}-open`]: mergedOpen,
		[`${prefixCls}-customize-input`]: customizeInputElement,
		[`${prefixCls}-show-search`]: showSearch
	});
	let renderNode = /* @__PURE__ */ import_react.createElement(SelectInput_default, _extends$80({}, restProps, {
		ref: containerRef,
		prefixCls,
		className: mergedClassName,
		focused,
		prefix: prefix$1,
		suffix: mergedSuffixIcon,
		clearIcon: clearNode,
		multiple,
		mode,
		displayValues,
		placeholder,
		searchValue: mergedSearchValue,
		activeValue,
		onSearch: onInternalSearch,
		onSearchSubmit: onInternalSearchSubmit,
		onInputBlur,
		onFocus: onInternalFocus,
		onBlur: onInternalBlur,
		onClearMouseDown,
		onKeyDown: onInternalKeyDown,
		onKeyUp: onInternalKeyUp,
		onSelectorRemove,
		tokenWithEnter,
		onMouseDown: onRootMouseDown,
		components: mergedComponents
	}));
	renderNode = /* @__PURE__ */ import_react.createElement(SelectTrigger_default, {
		ref: triggerRef,
		disabled,
		prefixCls,
		visible: mergedOpen,
		popupElement: optionList,
		animation,
		transitionName,
		popupStyle,
		popupClassName,
		direction,
		popupMatchSelectWidth,
		popupRender,
		popupAlign,
		placement,
		builtinPlacements,
		getPopupContainer,
		empty: emptyOptions,
		onPopupVisibleChange: onTriggerVisibleChange,
		onPopupMouseEnter,
		onPopupMouseDown: onRootMouseDown,
		onPopupBlur: onRootBlur
	}, renderNode);
	return /* @__PURE__ */ import_react.createElement(BaseSelectContext.Provider, { value: baseSelectContext }, /* @__PURE__ */ import_react.createElement(Polite, {
		visible: focused && !mergedOpen,
		values: displayValues
	}), renderNode);
});
BaseSelect.displayName = "BaseSelect";
var BaseSelect_default = BaseSelect;

//#endregion
//#region node_modules/@rc-component/select/es/OptGroup.js
/* istanbul ignore file */
/** This is a placeholder, not real render in dom */
var OptGroup = () => null;
OptGroup.isSelectOptGroup = true;
var OptGroup_default = OptGroup;

//#endregion
//#region node_modules/@rc-component/select/es/Option.js
/* istanbul ignore file */
/** This is a placeholder, not real render in dom */
var Option$4 = () => null;
Option$4.isSelectOption = true;
var Option_default$1 = Option$4;

//#endregion
//#region node_modules/@rc-component/virtual-list/es/Filler.js
/**
* Fill component to provided the scroll content real height.
*/
var Filler = /* @__PURE__ */ import_react.forwardRef(({ height, offsetY, offsetX, children, prefixCls, onInnerResize, innerProps, rtl, extra }, ref) => {
	let outerStyle = {};
	let innerStyle = {
		display: "flex",
		flexDirection: "column"
	};
	if (offsetY !== void 0) {
		outerStyle = {
			height,
			position: "relative",
			overflow: "hidden"
		};
		innerStyle = {
			...innerStyle,
			transform: `translateY(${offsetY}px)`,
			[rtl ? "marginRight" : "marginLeft"]: -offsetX,
			position: "absolute",
			left: 0,
			right: 0,
			top: 0
		};
	}
	return /* @__PURE__ */ import_react.createElement("div", { style: outerStyle }, /* @__PURE__ */ import_react.createElement(es_default$2, { onResize: ({ offsetHeight }) => {
		if (offsetHeight && onInnerResize) onInnerResize();
	} }, /* @__PURE__ */ import_react.createElement("div", _extends$26({
		style: innerStyle,
		className: clsx({ [`${prefixCls}-holder-inner`]: prefixCls }),
		ref
	}, innerProps), children, extra)));
});
Filler.displayName = "Filler";
var Filler_default = Filler;

//#endregion
//#region node_modules/@rc-component/virtual-list/es/Item.js
function Item$2({ children, setRef }) {
	const refFunc = import_react.useCallback((node$1) => {
		setRef(node$1);
	}, []);
	return /* @__PURE__ */ import_react.cloneElement(children, { ref: refFunc });
}

//#endregion
//#region node_modules/@rc-component/virtual-list/es/hooks/useChildren.js
function useChildren$1(list, startIndex, endIndex, scrollWidth, offsetX, setNodeRef, renderFunc, { getKey: getKey$3 }) {
	return list.slice(startIndex, endIndex + 1).map((item, index$1) => {
		const node$1 = renderFunc(item, startIndex + index$1, {
			style: { width: scrollWidth },
			offsetX
		});
		const key = getKey$3(item);
		return /* @__PURE__ */ import_react.createElement(Item$2, {
			key,
			setRef: (ele) => setNodeRef(item, ele)
		}, node$1);
	});
}

//#endregion
//#region node_modules/@rc-component/virtual-list/es/utils/algorithmUtil.js
/**
* We assume that 2 list has only 1 item diff and others keeping the order.
* So we can use dichotomy algorithm to find changed one.
*/
function findListDiffIndex(originList, targetList, getKey$3) {
	const originLen = originList.length;
	const targetLen = targetList.length;
	let shortList;
	let longList;
	if (originLen === 0 && targetLen === 0) return null;
	if (originLen < targetLen) {
		shortList = originList;
		longList = targetList;
	} else {
		shortList = targetList;
		longList = originList;
	}
	const notExistKey = { __EMPTY_ITEM__: true };
	function getItemKey(item) {
		if (item !== void 0) return getKey$3(item);
		return notExistKey;
	}
	let diffIndex = null;
	let multiple = Math.abs(originLen - targetLen) !== 1;
	for (let i = 0; i < longList.length; i += 1) {
		const shortKey = getItemKey(shortList[i]);
		if (shortKey !== getItemKey(longList[i])) {
			diffIndex = i;
			multiple = multiple || shortKey !== getItemKey(longList[i + 1]);
			break;
		}
	}
	return diffIndex === null ? null : {
		index: diffIndex,
		multiple
	};
}

//#endregion
//#region node_modules/@rc-component/virtual-list/es/hooks/useDiffItem.js
function useDiffItem(data, getKey$3, onDiff) {
	const [prevData, setPrevData] = import_react.useState(data);
	const [diffItem, setDiffItem] = import_react.useState(null);
	import_react.useEffect(() => {
		const diff = findListDiffIndex(prevData || [], data || [], getKey$3);
		if (diff?.index !== void 0) {
			onDiff?.(diff.index);
			setDiffItem(data[diff.index]);
		}
		setPrevData(data);
	}, [data]);
	return [diffItem];
}

//#endregion
//#region node_modules/@rc-component/virtual-list/es/utils/isFirefox.js
var isFF = typeof navigator === "object" && /Firefox/i.test(navigator.userAgent);
var isFirefox_default = isFF;

//#endregion
//#region node_modules/@rc-component/virtual-list/es/hooks/useOriginScroll.js
var useOriginScroll_default = ((isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight) => {
	const lockRef = (0, import_react.useRef)(false);
	const lockTimeoutRef = (0, import_react.useRef)(null);
	function lockScroll() {
		clearTimeout(lockTimeoutRef.current);
		lockRef.current = true;
		lockTimeoutRef.current = setTimeout(() => {
			lockRef.current = false;
		}, 50);
	}
	const scrollPingRef = (0, import_react.useRef)({
		top: isScrollAtTop,
		bottom: isScrollAtBottom,
		left: isScrollAtLeft,
		right: isScrollAtRight
	});
	scrollPingRef.current.top = isScrollAtTop;
	scrollPingRef.current.bottom = isScrollAtBottom;
	scrollPingRef.current.left = isScrollAtLeft;
	scrollPingRef.current.right = isScrollAtRight;
	return (isHorizontal, delta, smoothOffset = false) => {
		const originScroll = isHorizontal ? delta < 0 && scrollPingRef.current.left || delta > 0 && scrollPingRef.current.right : delta < 0 && scrollPingRef.current.top || delta > 0 && scrollPingRef.current.bottom;
		if (smoothOffset && originScroll) {
			clearTimeout(lockTimeoutRef.current);
			lockRef.current = false;
		} else if (!originScroll || lockRef.current) lockScroll();
		return !lockRef.current && originScroll;
	};
});

//#endregion
//#region node_modules/@rc-component/virtual-list/es/hooks/useFrameWheel.js
function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight, horizontalScroll, onWheelDelta) {
	const offsetRef = (0, import_react.useRef)(0);
	const nextFrameRef = (0, import_react.useRef)(null);
	const wheelValueRef = (0, import_react.useRef)(null);
	const isMouseScrollRef = (0, import_react.useRef)(false);
	const originScroll = useOriginScroll_default(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight);
	function onWheelY(e$2, deltaY) {
		raf_default.cancel(nextFrameRef.current);
		if (originScroll(false, deltaY)) return;
		const event = e$2;
		if (!event._virtualHandled) event._virtualHandled = true;
		else return;
		offsetRef.current += deltaY;
		wheelValueRef.current = deltaY;
		if (!isFirefox_default) event.preventDefault();
		nextFrameRef.current = raf_default(() => {
			const patchMultiple = isMouseScrollRef.current ? 10 : 1;
			onWheelDelta(offsetRef.current * patchMultiple, false);
			offsetRef.current = 0;
		});
	}
	function onWheelX(event, deltaX) {
		onWheelDelta(deltaX, true);
		if (!isFirefox_default) event.preventDefault();
	}
	const wheelDirectionRef = (0, import_react.useRef)(null);
	const wheelDirectionCleanRef = (0, import_react.useRef)(null);
	function onWheel(event) {
		if (!inVirtual) return;
		raf_default.cancel(wheelDirectionCleanRef.current);
		wheelDirectionCleanRef.current = raf_default(() => {
			wheelDirectionRef.current = null;
		}, 2);
		const { deltaX, deltaY, shiftKey } = event;
		let mergedDeltaX = deltaX;
		let mergedDeltaY = deltaY;
		if (wheelDirectionRef.current === "sx" || !wheelDirectionRef.current && (shiftKey || false) && deltaY && !deltaX) {
			mergedDeltaX = deltaY;
			mergedDeltaY = 0;
			wheelDirectionRef.current = "sx";
		}
		const absX = Math.abs(mergedDeltaX);
		const absY = Math.abs(mergedDeltaY);
		if (wheelDirectionRef.current === null) wheelDirectionRef.current = horizontalScroll && absX > absY ? "x" : "y";
		if (wheelDirectionRef.current === "y") onWheelY(event, mergedDeltaY);
		else onWheelX(event, mergedDeltaX);
	}
	function onFireFoxScroll(event) {
		if (!inVirtual) return;
		isMouseScrollRef.current = event.detail === wheelValueRef.current;
	}
	return [onWheel, onFireFoxScroll];
}

//#endregion
//#region node_modules/@rc-component/virtual-list/es/hooks/useGetSize.js
/**
* Size info need loop query for the `heights` which will has the perf issue.
* Let cache result for each render phase.
*/
function useGetSize(mergedData, getKey$3, heights, itemHeight) {
	const [key2Index, bottomList] = import_react.useMemo(() => [/* @__PURE__ */ new Map(), []], [
		mergedData,
		heights.id,
		itemHeight
	]);
	const getSize$2 = (startKey, endKey = startKey) => {
		let startIndex = key2Index.get(startKey);
		let endIndex = key2Index.get(endKey);
		if (startIndex === void 0 || endIndex === void 0) {
			const dataLen = mergedData.length;
			for (let i = bottomList.length; i < dataLen; i += 1) {
				const item = mergedData[i];
				const key = getKey$3(item);
				key2Index.set(key, i);
				const cacheHeight = heights.get(key) ?? itemHeight;
				bottomList[i] = (bottomList[i - 1] || 0) + cacheHeight;
				if (key === startKey) startIndex = i;
				if (key === endKey) endIndex = i;
				if (startIndex !== void 0 && endIndex !== void 0) break;
			}
		}
		return {
			top: bottomList[startIndex - 1] || 0,
			bottom: bottomList[endIndex]
		};
	};
	return getSize$2;
}

//#endregion
//#region node_modules/@rc-component/virtual-list/es/utils/CacheMap.js
var CacheMap = class {
	maps;
	id = 0;
	diffRecords = /* @__PURE__ */ new Map();
	constructor() {
		this.maps = Object.create(null);
	}
	set(key, value) {
		this.diffRecords.set(key, this.maps[key]);
		this.maps[key] = value;
		this.id += 1;
	}
	get(key) {
		return this.maps[key];
	}
	/**
	* CacheMap will record the key changed.
	* To help to know what's update in the next render.
	*/
	resetRecord() {
		this.diffRecords.clear();
	}
	getRecord() {
		return this.diffRecords;
	}
};
var CacheMap_default = CacheMap;

//#endregion
//#region node_modules/@rc-component/virtual-list/es/hooks/useHeights.js
function parseNumber(value) {
	const num = parseFloat(value);
	return isNaN(num) ? 0 : num;
}
function useHeights(getKey$3, onItemAdd, onItemRemove) {
	const [updatedMark, setUpdatedMark] = import_react.useState(0);
	const instanceRef = (0, import_react.useRef)(/* @__PURE__ */ new Map());
	const heightsRef = (0, import_react.useRef)(new CacheMap_default());
	const promiseIdRef = (0, import_react.useRef)(0);
	function cancelRaf() {
		promiseIdRef.current += 1;
	}
	function collectHeight(sync = false) {
		cancelRaf();
		const doCollect = () => {
			let changed = false;
			instanceRef.current.forEach((element, key) => {
				if (element && element.offsetParent) {
					const { offsetHeight } = element;
					const { marginTop, marginBottom } = getComputedStyle(element);
					const marginTopNum = parseNumber(marginTop);
					const marginBottomNum = parseNumber(marginBottom);
					const totalHeight = offsetHeight + marginTopNum + marginBottomNum;
					if (heightsRef.current.get(key) !== totalHeight) {
						heightsRef.current.set(key, totalHeight);
						changed = true;
					}
				}
			});
			if (changed) setUpdatedMark((c) => c + 1);
		};
		if (sync) doCollect();
		else {
			promiseIdRef.current += 1;
			const id = promiseIdRef.current;
			Promise.resolve().then(() => {
				if (id === promiseIdRef.current) doCollect();
			});
		}
	}
	function setInstanceRef(item, instance) {
		const key = getKey$3(item);
		const origin = instanceRef.current.get(key);
		if (instance) {
			instanceRef.current.set(key, instance);
			collectHeight();
		} else instanceRef.current.delete(key);
		if (!origin !== !instance) if (instance) onItemAdd?.(item);
		else onItemRemove?.(item);
	}
	(0, import_react.useEffect)(() => {
		return cancelRaf;
	}, []);
	return [
		setInstanceRef,
		collectHeight,
		heightsRef.current,
		updatedMark
	];
}

//#endregion
//#region node_modules/@rc-component/virtual-list/es/hooks/useMobileTouchMove.js
var SMOOTH_PTG = 14 / 15;
function useMobileTouchMove(inVirtual, listRef, callback) {
	const touchedRef = (0, import_react.useRef)(false);
	const touchXRef = (0, import_react.useRef)(0);
	const touchYRef = (0, import_react.useRef)(0);
	const elementRef = (0, import_react.useRef)(null);
	const intervalRef = (0, import_react.useRef)(null);
	let cleanUpEvents;
	const onTouchMove = (e$2) => {
		if (touchedRef.current) {
			const currentX = Math.ceil(e$2.touches[0].pageX);
			const currentY = Math.ceil(e$2.touches[0].pageY);
			let offsetX = touchXRef.current - currentX;
			let offsetY = touchYRef.current - currentY;
			const isHorizontal = Math.abs(offsetX) > Math.abs(offsetY);
			if (isHorizontal) touchXRef.current = currentX;
			else touchYRef.current = currentY;
			const scrollHandled = callback(isHorizontal, isHorizontal ? offsetX : offsetY, false, e$2);
			if (scrollHandled) e$2.preventDefault();
			clearInterval(intervalRef.current);
			if (scrollHandled) intervalRef.current = setInterval(() => {
				if (isHorizontal) offsetX *= SMOOTH_PTG;
				else offsetY *= SMOOTH_PTG;
				const offset$2 = Math.floor(isHorizontal ? offsetX : offsetY);
				if (!callback(isHorizontal, offset$2, true) || Math.abs(offset$2) <= .1) clearInterval(intervalRef.current);
			}, 16);
		}
	};
	const onTouchEnd = () => {
		touchedRef.current = false;
		cleanUpEvents();
	};
	const onTouchStart = (e$2) => {
		cleanUpEvents();
		if (e$2.touches.length === 1 && !touchedRef.current) {
			touchedRef.current = true;
			touchXRef.current = Math.ceil(e$2.touches[0].pageX);
			touchYRef.current = Math.ceil(e$2.touches[0].pageY);
			elementRef.current = e$2.target;
			elementRef.current.addEventListener("touchmove", onTouchMove, { passive: false });
			elementRef.current.addEventListener("touchend", onTouchEnd, { passive: true });
		}
	};
	cleanUpEvents = () => {
		if (elementRef.current) {
			elementRef.current.removeEventListener("touchmove", onTouchMove);
			elementRef.current.removeEventListener("touchend", onTouchEnd);
		}
	};
	useLayoutEffect_default(() => {
		if (inVirtual) listRef.current.addEventListener("touchstart", onTouchStart, { passive: true });
		return () => {
			listRef.current?.removeEventListener("touchstart", onTouchStart);
			cleanUpEvents();
			clearInterval(intervalRef.current);
		};
	}, [inVirtual]);
}

//#endregion
//#region node_modules/@rc-component/virtual-list/es/hooks/useScrollDrag.js
function smoothScrollOffset(offset$2) {
	return Math.floor(offset$2 ** .5);
}
function getPageXY(e$2, horizontal) {
	return ("touches" in e$2 ? e$2.touches[0] : e$2)[horizontal ? "pageX" : "pageY"] - window[horizontal ? "scrollX" : "scrollY"];
}
function useScrollDrag(inVirtual, componentRef, onScrollOffset) {
	import_react.useEffect(() => {
		const ele = componentRef.current;
		if (inVirtual && ele) {
			let mouseDownLock = false;
			let rafId;
			let offset$2;
			const stopScroll = () => {
				raf_default.cancel(rafId);
			};
			const continueScroll = () => {
				stopScroll();
				rafId = raf_default(() => {
					onScrollOffset(offset$2);
					continueScroll();
				});
			};
			const clearDragState = () => {
				mouseDownLock = false;
				stopScroll();
			};
			const onMouseDown = (e$2) => {
				if (e$2.target.draggable || e$2.button !== 0) return;
				const event = e$2;
				if (!event._virtualHandled) {
					event._virtualHandled = true;
					mouseDownLock = true;
				}
			};
			const onMouseMove = (e$2) => {
				if (mouseDownLock) {
					const mouseY = getPageXY(e$2, false);
					const { top, bottom } = ele.getBoundingClientRect();
					if (mouseY <= top) {
						offset$2 = -smoothScrollOffset(top - mouseY);
						continueScroll();
					} else if (mouseY >= bottom) {
						offset$2 = smoothScrollOffset(mouseY - bottom);
						continueScroll();
					} else stopScroll();
				}
			};
			ele.addEventListener("mousedown", onMouseDown);
			ele.ownerDocument.addEventListener("mouseup", clearDragState);
			ele.ownerDocument.addEventListener("mousemove", onMouseMove);
			ele.ownerDocument.addEventListener("dragend", clearDragState);
			return () => {
				ele.removeEventListener("mousedown", onMouseDown);
				ele.ownerDocument.removeEventListener("mouseup", clearDragState);
				ele.ownerDocument.removeEventListener("mousemove", onMouseMove);
				ele.ownerDocument.removeEventListener("dragend", clearDragState);
				stopScroll();
			};
		}
	}, [inVirtual]);
}

//#endregion
//#region node_modules/@rc-component/virtual-list/es/hooks/useScrollTo.js
var MAX_TIMES = 10;
function useScrollTo$1(containerRef, data, heights, itemHeight, getKey$3, collectHeight, syncScrollTop, triggerFlash) {
	const scrollRef = import_react.useRef();
	const [syncState, setSyncState] = import_react.useState(null);
	useLayoutEffect_default(() => {
		if (syncState && syncState.times < MAX_TIMES) {
			if (!containerRef.current) {
				setSyncState((ori) => ({ ...ori }));
				return;
			}
			collectHeight();
			const { targetAlign, originAlign, index: index$1, offset: offset$2 } = syncState;
			const height = containerRef.current.clientHeight;
			let needCollectHeight = false;
			let newTargetAlign = targetAlign;
			let targetTop = null;
			if (height) {
				const mergedAlign = targetAlign || originAlign;
				let stackTop = 0;
				let itemTop = 0;
				let itemBottom = 0;
				const maxLen = Math.min(data.length - 1, index$1);
				for (let i = 0; i <= maxLen; i += 1) {
					const key = getKey$3(data[i]);
					itemTop = stackTop;
					const cacheHeight = heights.get(key);
					itemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
					stackTop = itemBottom;
				}
				let leftHeight = mergedAlign === "top" ? offset$2 : height - offset$2;
				for (let i = maxLen; i >= 0; i -= 1) {
					const key = getKey$3(data[i]);
					const cacheHeight = heights.get(key);
					if (cacheHeight === void 0) {
						needCollectHeight = true;
						break;
					}
					leftHeight -= cacheHeight;
					if (leftHeight <= 0) break;
				}
				switch (mergedAlign) {
					case "top":
						targetTop = itemTop - offset$2;
						break;
					case "bottom":
						targetTop = itemBottom - height + offset$2;
						break;
					default: {
						const { scrollTop } = containerRef.current;
						const scrollBottom = scrollTop + height;
						if (itemTop < scrollTop) newTargetAlign = "top";
						else if (itemBottom > scrollBottom) newTargetAlign = "bottom";
					}
				}
				if (targetTop !== null) syncScrollTop(targetTop);
				if (targetTop !== syncState.lastTop) needCollectHeight = true;
			}
			if (needCollectHeight) setSyncState({
				...syncState,
				times: syncState.times + 1,
				targetAlign: newTargetAlign,
				lastTop: targetTop
			});
		} else if (syncState?.times === MAX_TIMES) warning_default$1(false, "Seems `scrollTo` with `rc-virtual-list` reach the max limitation. Please fire issue for us. Thanks.");
	}, [syncState, containerRef.current]);
	return (arg) => {
		if (arg === null || arg === void 0) {
			triggerFlash();
			return;
		}
		raf_default.cancel(scrollRef.current);
		if (typeof arg === "number") syncScrollTop(arg);
		else if (arg && typeof arg === "object") {
			let index$1;
			const { align } = arg;
			if ("index" in arg) ({index: index$1} = arg);
			else index$1 = data.findIndex((item) => getKey$3(item) === arg.key);
			const { offset: offset$2 = 0 } = arg;
			setSyncState({
				times: 0,
				index: index$1,
				offset: offset$2,
				originAlign: align
			});
		}
	};
}

//#endregion
//#region node_modules/@rc-component/virtual-list/es/ScrollBar.js
var ScrollBar = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls, rtl, scrollOffset, scrollRange, onStartMove, onStopMove, onScroll, horizontal, spinSize, containerSize, style: style$1, thumbStyle: propsThumbStyle, showScrollBar } = props;
	const [dragging, setDragging] = import_react.useState(false);
	const [pageXY, setPageXY] = import_react.useState(null);
	const [startTop, setStartTop] = import_react.useState(null);
	const isLTR = !rtl;
	const scrollbarRef = import_react.useRef();
	const thumbRef = import_react.useRef();
	const [visible, setVisible] = import_react.useState(showScrollBar);
	const visibleTimeoutRef = import_react.useRef();
	const delayHidden = () => {
		if (showScrollBar === true || showScrollBar === false) return;
		clearTimeout(visibleTimeoutRef.current);
		setVisible(true);
		visibleTimeoutRef.current = setTimeout(() => {
			setVisible(false);
		}, 3e3);
	};
	const enableScrollRange = scrollRange - containerSize || 0;
	const enableOffsetRange = containerSize - spinSize || 0;
	const top = import_react.useMemo(() => {
		if (scrollOffset === 0 || enableScrollRange === 0) return 0;
		return scrollOffset / enableScrollRange * enableOffsetRange;
	}, [
		scrollOffset,
		enableScrollRange,
		enableOffsetRange
	]);
	const onContainerMouseDown = (e$2) => {
		e$2.stopPropagation();
		e$2.preventDefault();
	};
	const stateRef = import_react.useRef({
		top,
		dragging,
		pageY: pageXY,
		startTop
	});
	stateRef.current = {
		top,
		dragging,
		pageY: pageXY,
		startTop
	};
	const onThumbMouseDown = (e$2) => {
		setDragging(true);
		setPageXY(getPageXY(e$2, horizontal));
		setStartTop(stateRef.current.top);
		onStartMove();
		e$2.stopPropagation();
		e$2.preventDefault();
	};
	import_react.useEffect(() => {
		const onScrollbarTouchStart = (e$2) => {
			e$2.preventDefault();
		};
		const scrollbarEle = scrollbarRef.current;
		const thumbEle = thumbRef.current;
		scrollbarEle.addEventListener("touchstart", onScrollbarTouchStart, { passive: false });
		thumbEle.addEventListener("touchstart", onThumbMouseDown, { passive: false });
		return () => {
			scrollbarEle.removeEventListener("touchstart", onScrollbarTouchStart);
			thumbEle.removeEventListener("touchstart", onThumbMouseDown);
		};
	}, []);
	const enableScrollRangeRef = import_react.useRef();
	enableScrollRangeRef.current = enableScrollRange;
	const enableOffsetRangeRef = import_react.useRef();
	enableOffsetRangeRef.current = enableOffsetRange;
	import_react.useEffect(() => {
		if (dragging) {
			let moveRafId;
			const onMouseMove = (e$2) => {
				const { dragging: stateDragging, pageY: statePageY, startTop: stateStartTop } = stateRef.current;
				raf_default.cancel(moveRafId);
				const rect = scrollbarRef.current.getBoundingClientRect();
				const scale = containerSize / (horizontal ? rect.width : rect.height);
				if (stateDragging) {
					const offset$2 = (getPageXY(e$2, horizontal) - statePageY) * scale;
					let newTop = stateStartTop;
					if (!isLTR && horizontal) newTop -= offset$2;
					else newTop += offset$2;
					const tmpEnableScrollRange = enableScrollRangeRef.current;
					const tmpEnableOffsetRange = enableOffsetRangeRef.current;
					const ptg = tmpEnableOffsetRange ? newTop / tmpEnableOffsetRange : 0;
					let newScrollTop = Math.ceil(ptg * tmpEnableScrollRange);
					newScrollTop = Math.max(newScrollTop, 0);
					newScrollTop = Math.min(newScrollTop, tmpEnableScrollRange);
					moveRafId = raf_default(() => {
						onScroll(newScrollTop, horizontal);
					});
				}
			};
			const onMouseUp = () => {
				setDragging(false);
				onStopMove();
			};
			window.addEventListener("mousemove", onMouseMove, { passive: true });
			window.addEventListener("touchmove", onMouseMove, { passive: true });
			window.addEventListener("mouseup", onMouseUp, { passive: true });
			window.addEventListener("touchend", onMouseUp, { passive: true });
			return () => {
				window.removeEventListener("mousemove", onMouseMove);
				window.removeEventListener("touchmove", onMouseMove);
				window.removeEventListener("mouseup", onMouseUp);
				window.removeEventListener("touchend", onMouseUp);
				raf_default.cancel(moveRafId);
			};
		}
	}, [dragging]);
	import_react.useEffect(() => {
		delayHidden();
		return () => {
			clearTimeout(visibleTimeoutRef.current);
		};
	}, [scrollOffset]);
	import_react.useImperativeHandle(ref, () => ({ delayHidden }));
	const scrollbarPrefixCls = `${prefixCls}-scrollbar`;
	const containerStyle = {
		position: "absolute",
		visibility: visible ? null : "hidden"
	};
	const thumbStyle = {
		position: "absolute",
		borderRadius: 99,
		background: "var(--rc-virtual-list-scrollbar-bg, rgba(0, 0, 0, 0.5))",
		cursor: "pointer",
		userSelect: "none"
	};
	if (horizontal) {
		Object.assign(containerStyle, {
			height: 8,
			left: 0,
			right: 0,
			bottom: 0
		});
		Object.assign(thumbStyle, {
			height: "100%",
			width: spinSize,
			[isLTR ? "left" : "right"]: top
		});
	} else {
		Object.assign(containerStyle, {
			width: 8,
			top: 0,
			bottom: 0,
			[isLTR ? "right" : "left"]: 0
		});
		Object.assign(thumbStyle, {
			width: "100%",
			height: spinSize,
			top
		});
	}
	return /* @__PURE__ */ import_react.createElement("div", {
		ref: scrollbarRef,
		className: clsx(scrollbarPrefixCls, {
			[`${scrollbarPrefixCls}-horizontal`]: horizontal,
			[`${scrollbarPrefixCls}-vertical`]: !horizontal,
			[`${scrollbarPrefixCls}-visible`]: visible
		}),
		style: {
			...containerStyle,
			...style$1
		},
		onMouseDown: onContainerMouseDown,
		onMouseMove: delayHidden
	}, /* @__PURE__ */ import_react.createElement("div", {
		ref: thumbRef,
		className: clsx(`${scrollbarPrefixCls}-thumb`, { [`${scrollbarPrefixCls}-thumb-moving`]: dragging }),
		style: {
			...thumbStyle,
			...propsThumbStyle
		},
		onMouseDown: onThumbMouseDown
	}));
});
ScrollBar.displayName = "ScrollBar";
var ScrollBar_default = ScrollBar;

//#endregion
//#region node_modules/@rc-component/virtual-list/es/utils/scrollbarUtil.js
var MIN_SIZE = 20;
function getSpinSize(containerSize = 0, scrollRange = 0) {
	let baseSize = containerSize / scrollRange * containerSize;
	if (isNaN(baseSize)) baseSize = 0;
	baseSize = Math.max(baseSize, MIN_SIZE);
	return Math.floor(baseSize);
}

//#endregion
//#region node_modules/@rc-component/virtual-list/es/List.js
var import_react_dom$4 = require_react_dom();
var EMPTY_DATA$1 = [];
var ScrollStyle = {
	overflowY: "auto",
	overflowAnchor: "none"
};
function RawList(props, ref) {
	const { prefixCls = "rc-virtual-list", className, height, itemHeight, fullHeight = true, style: style$1, data, children, itemKey: itemKey$2, virtual, direction, scrollWidth, component: Component$2 = "div", onScroll, onVirtualScroll, onVisibleChange, innerProps, extraRender, styles, showScrollBar = "optional", ...restProps } = props;
	const getKey$3 = import_react.useCallback((item) => {
		if (typeof itemKey$2 === "function") return itemKey$2(item);
		return item?.[itemKey$2];
	}, [itemKey$2]);
	const [setInstanceRef, collectHeight, heights, heightUpdatedMark] = useHeights(getKey$3, null, null);
	const useVirtual = !!(virtual !== false && height && itemHeight);
	const containerHeight = import_react.useMemo(() => Object.values(heights.maps).reduce((total, curr) => total + curr, 0), [heights.id, heights.maps]);
	const inVirtual = useVirtual && data && (Math.max(itemHeight * data.length, containerHeight) > height || !!scrollWidth);
	const isRTL = direction === "rtl";
	const mergedClassName = clsx(prefixCls, { [`${prefixCls}-rtl`]: isRTL }, className);
	const mergedData = data || EMPTY_DATA$1;
	const componentRef = (0, import_react.useRef)();
	const fillerInnerRef = (0, import_react.useRef)();
	const containerRef = (0, import_react.useRef)();
	const [offsetTop, setOffsetTop] = (0, import_react.useState)(0);
	const [offsetLeft, setOffsetLeft] = (0, import_react.useState)(0);
	const [scrollMoving, setScrollMoving] = (0, import_react.useState)(false);
	const onScrollbarStartMove = () => {
		setScrollMoving(true);
	};
	const onScrollbarStopMove = () => {
		setScrollMoving(false);
	};
	const sharedConfig = { getKey: getKey$3 };
	function syncScrollTop(newTop) {
		setOffsetTop((origin) => {
			let value;
			if (typeof newTop === "function") value = newTop(origin);
			else value = newTop;
			const alignedTop = keepInRange(value);
			componentRef.current.scrollTop = alignedTop;
			return alignedTop;
		});
	}
	const rangeRef = (0, import_react.useRef)({
		start: 0,
		end: mergedData.length
	});
	const diffItemRef = (0, import_react.useRef)();
	const [diffItem] = useDiffItem(mergedData, getKey$3);
	diffItemRef.current = diffItem;
	const { scrollHeight, start, end, offset: fillerOffset } = import_react.useMemo(() => {
		if (!useVirtual) return {
			scrollHeight: void 0,
			start: 0,
			end: mergedData.length - 1,
			offset: void 0
		};
		if (!inVirtual) return {
			scrollHeight: fillerInnerRef.current?.offsetHeight || 0,
			start: 0,
			end: mergedData.length - 1,
			offset: void 0
		};
		let itemTop = 0;
		let startIndex;
		let startOffset;
		let endIndex;
		const dataLen = mergedData.length;
		for (let i = 0; i < dataLen; i += 1) {
			const item = mergedData[i];
			const key = getKey$3(item);
			const cacheHeight = heights.get(key);
			const currentItemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
			if (currentItemBottom >= offsetTop && startIndex === void 0) {
				startIndex = i;
				startOffset = itemTop;
			}
			if (currentItemBottom > offsetTop + height && endIndex === void 0) endIndex = i;
			itemTop = currentItemBottom;
		}
		if (startIndex === void 0) {
			startIndex = 0;
			startOffset = 0;
			endIndex = Math.ceil(height / itemHeight);
		}
		if (endIndex === void 0) endIndex = mergedData.length - 1;
		endIndex = Math.min(endIndex + 1, mergedData.length - 1);
		return {
			scrollHeight: itemTop,
			start: startIndex,
			end: endIndex,
			offset: startOffset
		};
	}, [
		inVirtual,
		useVirtual,
		offsetTop,
		mergedData,
		heightUpdatedMark,
		height
	]);
	rangeRef.current.start = start;
	rangeRef.current.end = end;
	import_react.useLayoutEffect(() => {
		const changedRecord = heights.getRecord();
		if (changedRecord.size === 1) {
			const recordKey = Array.from(changedRecord.keys())[0];
			const prevCacheHeight = changedRecord.get(recordKey);
			const startItem = mergedData[start];
			if (startItem && prevCacheHeight === void 0) {
				if (getKey$3(startItem) === recordKey) {
					const diffHeight = heights.get(recordKey) - itemHeight;
					syncScrollTop((ori) => {
						return ori + diffHeight;
					});
				}
			}
		}
		heights.resetRecord();
	}, [scrollHeight]);
	const [size, setSize] = import_react.useState({
		width: 0,
		height
	});
	const onHolderResize = (sizeInfo) => {
		setSize({
			width: sizeInfo.offsetWidth,
			height: sizeInfo.offsetHeight
		});
	};
	const verticalScrollBarRef = (0, import_react.useRef)();
	const horizontalScrollBarRef = (0, import_react.useRef)();
	const horizontalScrollBarSpinSize = import_react.useMemo(() => getSpinSize(size.width, scrollWidth), [size.width, scrollWidth]);
	const verticalScrollBarSpinSize = import_react.useMemo(() => getSpinSize(size.height, scrollHeight), [size.height, scrollHeight]);
	const maxScrollHeight = scrollHeight - height;
	const maxScrollHeightRef = (0, import_react.useRef)(maxScrollHeight);
	maxScrollHeightRef.current = maxScrollHeight;
	function keepInRange(newScrollTop) {
		let newTop = newScrollTop;
		if (!Number.isNaN(maxScrollHeightRef.current)) newTop = Math.min(newTop, maxScrollHeightRef.current);
		newTop = Math.max(newTop, 0);
		return newTop;
	}
	const isScrollAtTop = offsetTop <= 0;
	const isScrollAtBottom = offsetTop >= maxScrollHeight;
	const isScrollAtLeft = offsetLeft <= 0;
	const isScrollAtRight = offsetLeft >= scrollWidth;
	const originScroll = useOriginScroll_default(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight);
	const getVirtualScrollInfo = () => ({
		x: isRTL ? -offsetLeft : offsetLeft,
		y: offsetTop
	});
	const lastVirtualScrollInfoRef = (0, import_react.useRef)(getVirtualScrollInfo());
	const triggerScroll = useEvent_default((params) => {
		if (onVirtualScroll) {
			const nextInfo = {
				...getVirtualScrollInfo(),
				...params
			};
			if (lastVirtualScrollInfoRef.current.x !== nextInfo.x || lastVirtualScrollInfoRef.current.y !== nextInfo.y) {
				onVirtualScroll(nextInfo);
				lastVirtualScrollInfoRef.current = nextInfo;
			}
		}
	});
	function onScrollBar(newScrollOffset, horizontal) {
		const newOffset = newScrollOffset;
		if (horizontal) {
			(0, import_react_dom$4.flushSync)(() => {
				setOffsetLeft(newOffset);
			});
			triggerScroll();
		} else syncScrollTop(newOffset);
	}
	function onFallbackScroll(e$2) {
		const { scrollTop: newScrollTop } = e$2.currentTarget;
		if (newScrollTop !== offsetTop) syncScrollTop(newScrollTop);
		onScroll?.(e$2);
		triggerScroll();
	}
	const keepInHorizontalRange = (nextOffsetLeft) => {
		let tmpOffsetLeft = nextOffsetLeft;
		const max = !!scrollWidth ? scrollWidth - size.width : 0;
		tmpOffsetLeft = Math.max(tmpOffsetLeft, 0);
		tmpOffsetLeft = Math.min(tmpOffsetLeft, max);
		return tmpOffsetLeft;
	};
	const onWheelDelta = useEvent_default((offsetXY, fromHorizontal) => {
		if (fromHorizontal) {
			(0, import_react_dom$4.flushSync)(() => {
				setOffsetLeft((left) => {
					return keepInHorizontalRange(left + (isRTL ? -offsetXY : offsetXY));
				});
			});
			triggerScroll();
		} else syncScrollTop((top) => {
			return top + offsetXY;
		});
	});
	const [onRawWheel, onFireFoxScroll] = useFrameWheel(useVirtual, isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight, !!scrollWidth, onWheelDelta);
	useMobileTouchMove(useVirtual, componentRef, (isHorizontal, delta, smoothOffset, e$2) => {
		const event = e$2;
		if (originScroll(isHorizontal, delta, smoothOffset)) return false;
		if (!event || !event._virtualHandled) {
			if (event) event._virtualHandled = true;
			onRawWheel({
				preventDefault() {},
				deltaX: isHorizontal ? delta : 0,
				deltaY: isHorizontal ? 0 : delta
			});
			return true;
		}
		return false;
	});
	useScrollDrag(inVirtual, componentRef, (offset$2) => {
		syncScrollTop((top) => top + offset$2);
	});
	useLayoutEffect_default(() => {
		function onMozMousePixelScroll(e$2) {
			const scrollingUpAtTop = isScrollAtTop && e$2.detail < 0;
			const scrollingDownAtBottom = isScrollAtBottom && e$2.detail > 0;
			if (useVirtual && !scrollingUpAtTop && !scrollingDownAtBottom) e$2.preventDefault();
		}
		const componentEle = componentRef.current;
		componentEle.addEventListener("wheel", onRawWheel, { passive: false });
		componentEle.addEventListener("DOMMouseScroll", onFireFoxScroll, { passive: true });
		componentEle.addEventListener("MozMousePixelScroll", onMozMousePixelScroll, { passive: false });
		return () => {
			componentEle.removeEventListener("wheel", onRawWheel);
			componentEle.removeEventListener("DOMMouseScroll", onFireFoxScroll);
			componentEle.removeEventListener("MozMousePixelScroll", onMozMousePixelScroll);
		};
	}, [
		useVirtual,
		isScrollAtTop,
		isScrollAtBottom
	]);
	useLayoutEffect_default(() => {
		if (scrollWidth) {
			const newOffsetLeft = keepInHorizontalRange(offsetLeft);
			setOffsetLeft(newOffsetLeft);
			triggerScroll({ x: newOffsetLeft });
		}
	}, [size.width, scrollWidth]);
	const delayHideScrollBar = () => {
		verticalScrollBarRef.current?.delayHidden();
		horizontalScrollBarRef.current?.delayHidden();
	};
	const scrollTo$1 = useScrollTo$1(componentRef, mergedData, heights, itemHeight, getKey$3, () => collectHeight(true), syncScrollTop, delayHideScrollBar);
	import_react.useImperativeHandle(ref, () => ({
		nativeElement: containerRef.current,
		getScrollInfo: getVirtualScrollInfo,
		scrollTo: (config) => {
			function isPosScroll(arg) {
				return arg && typeof arg === "object" && ("left" in arg || "top" in arg);
			}
			if (isPosScroll(config)) {
				if (config.left !== void 0) setOffsetLeft(keepInHorizontalRange(config.left));
				scrollTo$1(config.top);
			} else scrollTo$1(config);
		}
	}));
	/** We need told outside that some list not rendered */
	useLayoutEffect_default(() => {
		if (onVisibleChange) onVisibleChange(mergedData.slice(start, end + 1), mergedData);
	}, [
		start,
		end,
		mergedData
	]);
	const getSize$2 = useGetSize(mergedData, getKey$3, heights, itemHeight);
	const extraContent = extraRender?.({
		start,
		end,
		virtual: inVirtual,
		offsetX: offsetLeft,
		offsetY: fillerOffset,
		rtl: isRTL,
		getSize: getSize$2
	});
	const listChildren = useChildren$1(mergedData, start, end, scrollWidth, offsetLeft, setInstanceRef, children, sharedConfig);
	let componentStyle = null;
	if (height) {
		componentStyle = {
			[fullHeight ? "height" : "maxHeight"]: height,
			...ScrollStyle
		};
		if (useVirtual) {
			componentStyle.overflowY = "hidden";
			if (scrollWidth) componentStyle.overflowX = "hidden";
			if (scrollMoving) componentStyle.pointerEvents = "none";
		}
	}
	const containerProps = {};
	if (isRTL) containerProps.dir = "rtl";
	return /* @__PURE__ */ import_react.createElement("div", _extends$26({
		ref: containerRef,
		style: {
			...style$1,
			position: "relative"
		},
		className: mergedClassName
	}, containerProps, restProps), /* @__PURE__ */ import_react.createElement(es_default$2, { onResize: onHolderResize }, /* @__PURE__ */ import_react.createElement(Component$2, {
		className: `${prefixCls}-holder`,
		style: componentStyle,
		ref: componentRef,
		onScroll: onFallbackScroll,
		onMouseEnter: delayHideScrollBar
	}, /* @__PURE__ */ import_react.createElement(Filler_default, {
		prefixCls,
		height: scrollHeight,
		offsetX: offsetLeft,
		offsetY: fillerOffset,
		scrollWidth,
		onInnerResize: collectHeight,
		ref: fillerInnerRef,
		innerProps,
		rtl: isRTL,
		extra: extraContent
	}, listChildren))), inVirtual && scrollHeight > height && /* @__PURE__ */ import_react.createElement(ScrollBar_default, {
		ref: verticalScrollBarRef,
		prefixCls,
		scrollOffset: offsetTop,
		scrollRange: scrollHeight,
		rtl: isRTL,
		onScroll: onScrollBar,
		onStartMove: onScrollbarStartMove,
		onStopMove: onScrollbarStopMove,
		spinSize: verticalScrollBarSpinSize,
		containerSize: size.height,
		style: styles?.verticalScrollBar,
		thumbStyle: styles?.verticalScrollBarThumb,
		showScrollBar
	}), inVirtual && scrollWidth > size.width && /* @__PURE__ */ import_react.createElement(ScrollBar_default, {
		ref: horizontalScrollBarRef,
		prefixCls,
		scrollOffset: offsetLeft,
		scrollRange: scrollWidth,
		rtl: isRTL,
		onScroll: onScrollBar,
		onStartMove: onScrollbarStartMove,
		onStopMove: onScrollbarStopMove,
		spinSize: horizontalScrollBarSpinSize,
		containerSize: size.width,
		horizontal: true,
		style: styles?.horizontalScrollBar,
		thumbStyle: styles?.horizontalScrollBarThumb,
		showScrollBar
	}));
}
var List$1 = /* @__PURE__ */ import_react.forwardRef(RawList);
List$1.displayName = "List";
var List_default$2 = List$1;

//#endregion
//#region node_modules/@rc-component/virtual-list/es/index.js
var es_default$8 = List_default$2;

//#endregion
//#region node_modules/@rc-component/select/es/utils/platformUtil.js
/* istanbul ignore file */
function isPlatformMac() {
	return /(mac\sos|macintosh)/i.test(navigator.appVersion);
}

//#endregion
//#region node_modules/@rc-component/select/es/OptionList.js
function _extends$79() {
	_extends$79 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$79.apply(this, arguments);
}
function isTitleType(content) {
	return typeof content === "string" || typeof content === "number";
}
/**
* Using virtual list of option display.
* Will fallback to dom if use customize render.
*/
var OptionList$1 = (_, ref) => {
	const { prefixCls, id, open: open$2, multiple, mode, searchValue, toggleOpen, notFoundContent, onPopupScroll, showScrollBar } = useBaseProps();
	const { maxCount, flattenOptions: flattenOptions$1, onActiveValue, defaultActiveFirstOption, onSelect, menuItemSelectedIcon, rawValues, fieldNames, virtual, direction, listHeight, listItemHeight, optionRender, classNames: contextClassNames, styles: contextStyles } = import_react.useContext(SelectContext_default);
	const itemPrefixCls = `${prefixCls}-item`;
	const memoFlattenOptions = useMemo$1(() => flattenOptions$1, [open$2, flattenOptions$1], (prev$1, next$1) => next$1[0] && prev$1[1] !== next$1[1]);
	const listRef = import_react.useRef(null);
	const overMaxCount = import_react.useMemo(() => multiple && isValidCount(maxCount) && rawValues?.size >= maxCount, [
		multiple,
		maxCount,
		rawValues?.size
	]);
	const onListMouseDown = (event) => {
		event.preventDefault();
	};
	const scrollIntoView = (args) => {
		listRef.current?.scrollTo(typeof args === "number" ? { index: args } : args);
	};
	const isSelected = import_react.useCallback((value) => {
		if (mode === "combobox") return false;
		return rawValues.has(value);
	}, [
		mode,
		[...rawValues].toString(),
		rawValues.size
	]);
	const getEnabledActiveIndex = (index$1, offset$2 = 1) => {
		const len = memoFlattenOptions.length;
		for (let i = 0; i < len; i += 1) {
			const current = (index$1 + i * offset$2 + len) % len;
			const { group, data } = memoFlattenOptions[current] || {};
			if (!group && !data?.disabled && (isSelected(data.value) || !overMaxCount)) return current;
		}
		return -1;
	};
	const [activeIndex, setActiveIndex] = import_react.useState(() => getEnabledActiveIndex(0));
	const setActive = (index$1, fromKeyboard = false) => {
		setActiveIndex(index$1);
		const info = { source: fromKeyboard ? "keyboard" : "mouse" };
		const flattenItem = memoFlattenOptions[index$1];
		if (!flattenItem) {
			onActiveValue(null, -1, info);
			return;
		}
		onActiveValue(flattenItem.value, index$1, info);
	};
	(0, import_react.useEffect)(() => {
		setActive(defaultActiveFirstOption !== false ? getEnabledActiveIndex(0) : -1);
	}, [memoFlattenOptions.length, searchValue]);
	const isAriaSelected = import_react.useCallback((value) => {
		if (mode === "combobox") return String(value).toLowerCase() === searchValue.toLowerCase();
		return rawValues.has(value);
	}, [
		mode,
		searchValue,
		[...rawValues].toString(),
		rawValues.size
	]);
	(0, import_react.useEffect)(() => {
		/**
		* React will skip `onChange` when component update.
		* `setActive` function will call root accessibility state update which makes re-render.
		* So we need to delay to let Input component trigger onChange first.
		*/
		let timeoutId;
		if (!multiple && open$2 && rawValues.size === 1) {
			const value = Array.from(rawValues)[0];
			const index$1 = memoFlattenOptions.findIndex(({ data }) => searchValue ? String(data.value).startsWith(searchValue) : data.value === value);
			if (index$1 !== -1) {
				setActive(index$1);
				timeoutId = setTimeout(() => {
					scrollIntoView(index$1);
				});
			}
		}
		if (open$2) listRef.current?.scrollTo(void 0);
		return () => clearTimeout(timeoutId);
	}, [open$2, searchValue]);
	const onSelectValue = (value) => {
		if (value !== void 0) onSelect(value, { selected: !rawValues.has(value) });
		if (!multiple) toggleOpen(false);
	};
	import_react.useImperativeHandle(ref, () => ({
		onKeyDown: (event) => {
			const { which, ctrlKey } = event;
			switch (which) {
				case KeyCode_default.N:
				case KeyCode_default.P:
				case KeyCode_default.UP:
				case KeyCode_default.DOWN: {
					let offset$2 = 0;
					if (which === KeyCode_default.UP) offset$2 = -1;
					else if (which === KeyCode_default.DOWN) offset$2 = 1;
					else if (isPlatformMac() && ctrlKey) {
						if (which === KeyCode_default.N) offset$2 = 1;
						else if (which === KeyCode_default.P) offset$2 = -1;
					}
					if (offset$2 !== 0) {
						const nextActiveIndex = getEnabledActiveIndex(activeIndex + offset$2, offset$2);
						scrollIntoView(nextActiveIndex);
						setActive(nextActiveIndex, true);
					}
					break;
				}
				case KeyCode_default.TAB:
				case KeyCode_default.ENTER: {
					const item = memoFlattenOptions[activeIndex];
					if (!item || item.data.disabled) return onSelectValue(void 0);
					if (!overMaxCount || rawValues.has(item.value)) onSelectValue(item.value);
					else onSelectValue(void 0);
					if (open$2) event.preventDefault();
					break;
				}
				case KeyCode_default.ESC:
					toggleOpen(false);
					if (open$2) event.stopPropagation();
			}
		},
		onKeyUp: () => {},
		scrollTo: (index$1) => {
			scrollIntoView(index$1);
		}
	}));
	if (memoFlattenOptions.length === 0) return /* @__PURE__ */ import_react.createElement("div", {
		role: "listbox",
		id: `${id}_list`,
		className: `${itemPrefixCls}-empty`,
		onMouseDown: onListMouseDown
	}, notFoundContent);
	const omitFieldNameList = Object.keys(fieldNames).map((key) => fieldNames[key]);
	const getLabel = (item) => item.label;
	function getItemAriaProps(item, index$1) {
		const { group } = item;
		return {
			role: group ? "presentation" : "option",
			id: `${id}_list_${index$1}`
		};
	}
	const renderItem$1 = (index$1) => {
		const item = memoFlattenOptions[index$1];
		if (!item) return null;
		const itemData = item.data || {};
		const { value } = itemData;
		const { group } = item;
		const attrs = pickAttrs(itemData, true);
		const mergedLabel = getLabel(item);
		return item ? /* @__PURE__ */ import_react.createElement("div", _extends$79({ "aria-label": typeof mergedLabel === "string" && !group ? mergedLabel : null }, attrs, { key: index$1 }, getItemAriaProps(item, index$1), { "aria-selected": isAriaSelected(value) }), value) : null;
	};
	const a11yProps = {
		role: "listbox",
		id: `${id}_list`
	};
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, virtual && /* @__PURE__ */ import_react.createElement("div", _extends$79({}, a11yProps, { style: {
		height: 0,
		width: 0,
		overflow: "hidden"
	} }), renderItem$1(activeIndex - 1), renderItem$1(activeIndex), renderItem$1(activeIndex + 1)), /* @__PURE__ */ import_react.createElement(es_default$8, {
		itemKey: "key",
		ref: listRef,
		data: memoFlattenOptions,
		height: listHeight,
		itemHeight: listItemHeight,
		fullHeight: false,
		onMouseDown: onListMouseDown,
		onScroll: onPopupScroll,
		virtual,
		direction,
		innerProps: virtual ? null : a11yProps,
		showScrollBar,
		className: contextClassNames?.popup?.list,
		style: contextStyles?.popup?.list
	}, (item, itemIndex) => {
		const { group, groupOption, data, label, value } = item;
		const { key } = data;
		if (group) {
			const groupTitle = data.title ?? (isTitleType(label) ? label.toString() : void 0);
			return /* @__PURE__ */ import_react.createElement("div", {
				className: clsx(itemPrefixCls, `${itemPrefixCls}-group`, data.className),
				title: groupTitle
			}, label !== void 0 ? label : key);
		}
		const { disabled, title, children, style: style$1, className, ...otherProps } = data;
		const passedProps = omit(otherProps, omitFieldNameList);
		const selected = isSelected(value);
		const mergedDisabled = disabled || !selected && overMaxCount;
		const optionPrefixCls = `${itemPrefixCls}-option`;
		const optionClassName = clsx(itemPrefixCls, optionPrefixCls, className, contextClassNames?.popup?.listItem, {
			[`${optionPrefixCls}-grouped`]: groupOption,
			[`${optionPrefixCls}-active`]: activeIndex === itemIndex && !mergedDisabled,
			[`${optionPrefixCls}-disabled`]: mergedDisabled,
			[`${optionPrefixCls}-selected`]: selected
		});
		const mergedLabel = getLabel(item);
		const iconVisible = !menuItemSelectedIcon || typeof menuItemSelectedIcon === "function" || selected;
		const content = typeof mergedLabel === "number" ? mergedLabel : mergedLabel || value;
		let optionTitle = isTitleType(content) ? content.toString() : void 0;
		if (title !== void 0) optionTitle = title;
		return /* @__PURE__ */ import_react.createElement("div", _extends$79({}, pickAttrs(passedProps), !virtual ? getItemAriaProps(item, itemIndex) : {}, {
			"aria-selected": virtual ? void 0 : isAriaSelected(value),
			className: optionClassName,
			title: optionTitle,
			onMouseMove: () => {
				if (activeIndex === itemIndex || mergedDisabled) return;
				setActive(itemIndex);
			},
			onClick: () => {
				if (!mergedDisabled) onSelectValue(value);
			},
			style: {
				...contextStyles?.popup?.listItem,
				...style$1
			}
		}), /* @__PURE__ */ import_react.createElement("div", { className: `${optionPrefixCls}-content` }, typeof optionRender === "function" ? optionRender(item, { index: itemIndex }) : content), /* @__PURE__ */ import_react.isValidElement(menuItemSelectedIcon) || selected, iconVisible && /* @__PURE__ */ import_react.createElement(TransBtn_default, {
			className: `${itemPrefixCls}-option-state`,
			customizeIcon: menuItemSelectedIcon,
			customizeIconProps: {
				value,
				disabled: mergedDisabled,
				isSelected: selected
			}
		}, selected ? "" : null));
	}));
};
var RefOptionList$2 = /* @__PURE__ */ import_react.forwardRef(OptionList$1);
RefOptionList$2.displayName = "OptionList";
var OptionList_default$2 = RefOptionList$2;

//#endregion
//#region node_modules/@rc-component/select/es/hooks/useCache.js
/**
* Cache `value` related LabeledValue & options.
*/
var useCache_default$1 = ((labeledValues, valueOptions) => {
	const cacheRef = import_react.useRef({
		values: /* @__PURE__ */ new Map(),
		options: /* @__PURE__ */ new Map()
	});
	return [import_react.useMemo(() => {
		const { values: prevValueCache, options: prevOptionCache } = cacheRef.current;
		const patchedValues = labeledValues.map((item) => {
			if (item.label === void 0) return {
				...item,
				label: prevValueCache.get(item.value)?.label
			};
			return item;
		});
		const valueCache = /* @__PURE__ */ new Map();
		const optionCache = /* @__PURE__ */ new Map();
		patchedValues.forEach((item) => {
			valueCache.set(item.value, item);
			optionCache.set(item.value, valueOptions.get(item.value) || prevOptionCache.get(item.value));
		});
		cacheRef.current.values = valueCache;
		cacheRef.current.options = optionCache;
		return patchedValues;
	}, [labeledValues, valueOptions]), import_react.useCallback((val) => valueOptions.get(val) || cacheRef.current.options.get(val), [valueOptions])];
});

//#endregion
//#region node_modules/@rc-component/select/es/hooks/useFilterOptions.js
function includes(test, search) {
	return toArray$6(test).join("").toUpperCase().includes(search);
}
var useFilterOptions_default = ((options, fieldNames, searchValue, filterOption$1, optionFilterProp) => {
	return import_react.useMemo(() => {
		if (!searchValue || filterOption$1 === false) return options;
		const { options: fieldOptions, label: fieldLabel, value: fieldValue } = fieldNames;
		const filteredOptions = [];
		const customizeFilter = typeof filterOption$1 === "function";
		const upperSearch = searchValue.toUpperCase();
		const filterFunc = customizeFilter ? filterOption$1 : (_, option) => {
			if (optionFilterProp && optionFilterProp.length) return optionFilterProp.some((prop) => includes(option[prop], upperSearch));
			if (option[fieldOptions]) return includes(option[fieldLabel !== "children" ? fieldLabel : "label"], upperSearch);
			return includes(option[fieldValue], upperSearch);
		};
		const wrapOption = customizeFilter ? (opt) => injectPropsWithOption(opt) : (opt) => opt;
		options.forEach((item) => {
			if (item[fieldOptions]) {
				if (filterFunc(searchValue, wrapOption(item))) filteredOptions.push(item);
				else {
					const subOptions = item[fieldOptions].filter((subItem) => filterFunc(searchValue, wrapOption(subItem)));
					if (subOptions.length) filteredOptions.push({
						...item,
						[fieldOptions]: subOptions
					});
				}
				return;
			}
			if (filterFunc(searchValue, wrapOption(item))) filteredOptions.push(item);
		});
		return filteredOptions;
	}, [
		options,
		filterOption$1,
		optionFilterProp,
		searchValue,
		fieldNames
	]);
});

//#endregion
//#region node_modules/@rc-component/select/es/utils/legacyUtil.js
function convertNodeToOption(node$1) {
	const { key, props: { children, value, ...restProps } } = node$1;
	return {
		key,
		value: value !== void 0 ? value : key,
		children,
		...restProps
	};
}
function convertChildrenToData$1(nodes, optionOnly = false) {
	return toArray(nodes).map((node$1, index$1) => {
		if (!/* @__PURE__ */ import_react.isValidElement(node$1) || !node$1.type) return null;
		const { type: { isSelectOptGroup }, key, props: { children, ...restProps } } = node$1;
		if (optionOnly || !isSelectOptGroup) return convertNodeToOption(node$1);
		return {
			key: `__RC_SELECT_GRP__${key === null ? index$1 : key}__`,
			label: key,
			...restProps,
			options: convertChildrenToData$1(children)
		};
	}).filter((data) => data);
}

//#endregion
//#region node_modules/@rc-component/select/es/hooks/useOptions.js
/**
* Parse `children` to `options` if `options` is not provided.
* Then flatten the `options`.
*/
var useOptions$1 = (options, children, fieldNames, optionFilterProp, optionLabelProp) => {
	return import_react.useMemo(() => {
		let mergedOptions = options;
		if (!options) mergedOptions = convertChildrenToData$1(children);
		const valueOptions = /* @__PURE__ */ new Map();
		const labelOptions = /* @__PURE__ */ new Map();
		const setLabelOptions = (labelOptionsMap, option, key) => {
			if (key && typeof key === "string") labelOptionsMap.set(option[key], option);
		};
		const dig = (optionList, isChildren = false) => {
			for (let i = 0; i < optionList.length; i += 1) {
				const option = optionList[i];
				if (!option[fieldNames.options] || isChildren) {
					valueOptions.set(option[fieldNames.value], option);
					setLabelOptions(labelOptions, option, fieldNames.label);
					optionFilterProp.forEach((prop) => {
						setLabelOptions(labelOptions, option, prop);
					});
					setLabelOptions(labelOptions, option, optionLabelProp);
				} else dig(option[fieldNames.options], true);
			}
		};
		dig(mergedOptions);
		return {
			options: mergedOptions,
			valueOptions,
			labelOptions
		};
	}, [
		options,
		children,
		fieldNames,
		optionFilterProp,
		optionLabelProp
	]);
};
var useOptions_default = useOptions$1;

//#endregion
//#region node_modules/@rc-component/select/es/hooks/useRefFunc.js
/**
* Same as `React.useCallback` but always return a memoized function
* but redirect to real function.
*/
function useRefFunc$1(callback) {
	const funcRef = import_react.useRef();
	funcRef.current = callback;
	return import_react.useCallback((...args) => {
		return funcRef.current(...args);
	}, []);
}

//#endregion
//#region node_modules/@rc-component/select/es/utils/warningPropsUtil.js
function warningProps$1(props) {
	const { mode, options, children, backfill, allowClear, placeholder, getInputElement, showSearch, onSearch, defaultOpen, autoFocus, labelInValue, value, optionLabelProp } = props;
	const multiple = isMultiple(mode);
	const mergedShowSearch = showSearch !== void 0 ? showSearch : multiple || mode === "combobox";
	const mergedOptions = options || convertChildrenToData$1(children);
	warning_default$1(mode !== "tags" || mergedOptions.every((opt) => !opt.disabled), "Please avoid setting option to disabled in tags mode since user can always type text as tag.");
	if (mode === "tags" || mode === "combobox") warning_default$1(!mergedOptions.some((item) => {
		if (item.options) return item.options.some((opt) => typeof ("value" in opt ? opt.value : opt.key) === "number");
		return typeof ("value" in item ? item.value : item.key) === "number";
	}), "`value` of Option should not use number type when `mode` is `tags` or `combobox`.");
	warning_default$1(mode !== "combobox" || !optionLabelProp, "`combobox` mode not support `optionLabelProp`. Please set `value` on Option directly.");
	warning_default$1(mode === "combobox" || !backfill, "`backfill` only works with `combobox` mode.");
	warning_default$1(mode === "combobox" || !getInputElement, "`getInputElement` only work with `combobox` mode.");
	noteOnce(mode !== "combobox" || !getInputElement || !allowClear || !placeholder, "Customize `getInputElement` should customize clear and placeholder logic instead of configuring `allowClear` and `placeholder`.");
	if (onSearch && !mergedShowSearch && mode !== "combobox" && mode !== "tags") warning_default$1(false, "`onSearch` should work with `showSearch` instead of use alone.");
	noteOnce(!defaultOpen || autoFocus, "`defaultOpen` makes Select open without focus which means it will not close by click outside. You can set `autoFocus` if needed.");
	if (value !== void 0 && value !== null) {
		const values = toArray$6(value);
		warning_default$1(!labelInValue || values.every((val) => typeof val === "object" && ("key" in val || "value" in val)), "`value` should in shape of `{ value: string | number, label?: ReactNode }` when you set `labelInValue` to `true`");
		warning_default$1(!multiple || Array.isArray(value), "`value` should be array when `mode` is `multiple` or `tags`");
	}
	if (children) {
		let invalidateChildType = null;
		toArray(children).some((node$1) => {
			if (!/* @__PURE__ */ import_react.isValidElement(node$1) || !node$1.type) return false;
			const { type: type$2 } = node$1;
			if (type$2.isSelectOption) return false;
			if (type$2.isSelectOptGroup) {
				if (toArray(node$1.props.children).every((subNode) => {
					if (!/* @__PURE__ */ import_react.isValidElement(subNode) || !node$1.type || subNode.type.isSelectOption) return true;
					invalidateChildType = subNode.type;
					return false;
				})) return false;
				return true;
			}
			invalidateChildType = type$2;
			return true;
		});
		if (invalidateChildType) warning_default$1(false, `\`children\` should be \`Select.Option\` or \`Select.OptGroup\` instead of \`${invalidateChildType.displayName || invalidateChildType.name || invalidateChildType}\`.`);
	}
}
function warningNullOptions$1(options, fieldNames) {
	if (options) {
		const recursiveOptions = (optionsList, inGroup = false) => {
			for (let i = 0; i < optionsList.length; i++) {
				const option = optionsList[i];
				if (option[fieldNames?.value] === null) {
					warning_default$1(false, "`value` in Select options should not be `null`.");
					return true;
				}
				if (!inGroup && Array.isArray(option[fieldNames?.options]) && recursiveOptions(option[fieldNames?.options], true)) break;
			}
		};
		recursiveOptions(options);
	}
}
var warningPropsUtil_default$1 = warningProps$1;

//#endregion
//#region node_modules/@rc-component/select/es/hooks/useSearchConfig.js
function useSearchConfig$2(showSearch, props, mode) {
	const { filterOption: filterOption$1, searchValue, optionFilterProp, filterSort, onSearch, autoClearSearchValue } = props;
	return import_react.useMemo(() => {
		const isObject$1 = typeof showSearch === "object";
		const searchConfig = {
			filterOption: filterOption$1,
			searchValue,
			optionFilterProp,
			filterSort,
			onSearch,
			autoClearSearchValue,
			...isObject$1 ? showSearch : {}
		};
		return [isObject$1 || mode === "combobox" || mode === "tags" || mode === "multiple" && showSearch === void 0 ? true : showSearch, searchConfig];
	}, [
		mode,
		showSearch,
		filterOption$1,
		searchValue,
		optionFilterProp,
		filterSort,
		onSearch,
		autoClearSearchValue
	]);
}

//#endregion
//#region node_modules/@rc-component/select/es/Select.js
/**
* To match accessibility requirement, we always provide an input in the component.
* Other element will not set `tabIndex` to avoid `onBlur` sequence problem.
* For focused select, we set `aria-live="polite"` to update the accessibility content.
*
* ref:
* - keyboard: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/listbox_role#Keyboard_interactions
*
* New api:
* - listHeight
* - listItemHeight
* - component
*
* Remove deprecated api:
* - multiple
* - tags
* - combobox
* - firstActiveValue
* - dropdownMenuStyle
* - openClassName (Not list in api)
*
* Update:
* - `backfill` only support `combobox` mode
* - `combobox` mode not support `labelInValue` since it's meaningless
* - `getInputElement` only support `combobox` mode
* - `onChange` return OptionData instead of ReactNode
* - `filterOption` `onChange` `onSelect` accept OptionData instead of ReactNode
* - `combobox` mode trigger `onChange` will get `undefined` if no `value` match in Option
* - `combobox` mode not support `optionLabelProp`
*/
function _extends$78() {
	_extends$78 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$78.apply(this, arguments);
}
var OMIT_DOM_PROPS = ["inputValue"];
function isRawValue$1(value) {
	return !value || typeof value !== "object";
}
var Select$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { id, mode, prefixCls = "rc-select", backfill, fieldNames, showSearch, searchValue: legacySearchValue, onSearch: legacyOnSearch, autoClearSearchValue: legacyAutoClearSearchValue, filterOption: legacyFilterOption, optionFilterProp: legacyOptionFilterProp, filterSort: legacyFilterSort, onSelect, onDeselect, onActive, popupMatchSelectWidth = true, optionLabelProp, options, optionRender, children, defaultActiveFirstOption, menuItemSelectedIcon, virtual, direction, listHeight = 200, listItemHeight = 20, labelRender, value, defaultValue, labelInValue, onChange, maxCount, classNames, styles, ...restProps } = props;
	const [mergedShowSearch, searchConfig] = useSearchConfig$2(showSearch, {
		searchValue: legacySearchValue,
		onSearch: legacyOnSearch,
		autoClearSearchValue: legacyAutoClearSearchValue,
		filterOption: legacyFilterOption,
		optionFilterProp: legacyOptionFilterProp,
		filterSort: legacyFilterSort
	}, mode);
	const { filterOption: filterOption$1, searchValue, optionFilterProp, filterSort, onSearch, autoClearSearchValue = true } = searchConfig;
	const normalizedOptionFilterProp = import_react.useMemo(() => {
		if (!optionFilterProp) return [];
		return Array.isArray(optionFilterProp) ? optionFilterProp : [optionFilterProp];
	}, [optionFilterProp]);
	const mergedId = useId_default(id);
	const multiple = isMultiple(mode);
	const childrenAsData = !!(!options && children);
	const mergedFilterOption = import_react.useMemo(() => {
		if (filterOption$1 === void 0 && mode === "combobox") return false;
		return filterOption$1;
	}, [filterOption$1, mode]);
	const mergedFieldNames = import_react.useMemo(() => fillFieldNames$3(fieldNames, childrenAsData), [JSON.stringify(fieldNames), childrenAsData]);
	const [internalSearchValue, setSearchValue] = useControlledState("", searchValue);
	const mergedSearchValue = internalSearchValue || "";
	const parsedOptions = useOptions_default(options, children, mergedFieldNames, normalizedOptionFilterProp, optionLabelProp);
	const { valueOptions, labelOptions, options: mergedOptions } = parsedOptions;
	const convert2LabelValues = import_react.useCallback((draftValues) => {
		return toArray$6(draftValues).map((val) => {
			let rawValue;
			let rawLabel;
			let rawDisabled;
			let rawTitle;
			if (isRawValue$1(val)) rawValue = val;
			else {
				rawLabel = val.label;
				rawValue = val.value;
			}
			const option = valueOptions.get(rawValue);
			if (option) {
				if (rawLabel === void 0) rawLabel = option?.[optionLabelProp || mergedFieldNames.label];
				rawDisabled = option?.disabled;
				rawTitle = option?.title;
				if (!optionLabelProp) {
					const optionLabel = option?.[mergedFieldNames.label];
					if (optionLabel !== void 0 && !/* @__PURE__ */ import_react.isValidElement(optionLabel) && !/* @__PURE__ */ import_react.isValidElement(rawLabel) && optionLabel !== rawLabel) warning_default$1(false, "`label` of `value` is not same as `label` in Select options.");
				}
			}
			return {
				label: rawLabel,
				value: rawValue,
				key: rawValue,
				disabled: rawDisabled,
				title: rawTitle
			};
		});
	}, [
		mergedFieldNames,
		optionLabelProp,
		valueOptions
	]);
	const [internalValue, setInternalValue] = useControlledState(defaultValue, value);
	const [mergedValues, getMixedOption] = useCache_default$1(import_react.useMemo(() => {
		const values = convert2LabelValues(multiple && internalValue === null ? [] : internalValue);
		if (mode === "combobox" && isComboNoValue(values[0]?.value)) return [];
		return values;
	}, [
		internalValue,
		convert2LabelValues,
		mode,
		multiple
	]), valueOptions);
	const displayValues = import_react.useMemo(() => {
		if (!mode && mergedValues.length === 1) {
			const firstValue = mergedValues[0];
			if (firstValue.value === null && (firstValue.label === null || firstValue.label === void 0)) return [];
		}
		return mergedValues.map((item) => ({
			...item,
			label: (typeof labelRender === "function" ? labelRender(item) : item.label) ?? item.value
		}));
	}, [
		mode,
		mergedValues,
		labelRender
	]);
	/** Convert `displayValues` to raw value type set */
	const rawValues = import_react.useMemo(() => new Set(mergedValues.map((val) => val.value)), [mergedValues]);
	import_react.useEffect(() => {
		if (mode === "combobox") {
			const strValue = mergedValues[0]?.value;
			setSearchValue(hasValue(strValue) ? String(strValue) : "");
		}
	}, [mergedValues]);
	const createTagOption = useRefFunc$1((val, label) => {
		const mergedLabel = label ?? val;
		return {
			[mergedFieldNames.value]: val,
			[mergedFieldNames.label]: mergedLabel
		};
	});
	const filteredOptions = useFilterOptions_default(import_react.useMemo(() => {
		if (mode !== "tags") return mergedOptions;
		const cloneOptions = [...mergedOptions];
		const existOptions = (val) => valueOptions.has(val);
		[...mergedValues].sort((a, b) => a.value < b.value ? -1 : 1).forEach((item) => {
			const val = item.value;
			if (!existOptions(val)) cloneOptions.push(createTagOption(val, item.label));
		});
		return cloneOptions;
	}, [
		createTagOption,
		mergedOptions,
		valueOptions,
		mergedValues,
		mode
	]), mergedFieldNames, mergedSearchValue, mergedFilterOption, normalizedOptionFilterProp);
	const filledSearchOptions = import_react.useMemo(() => {
		const hasItemMatchingSearch = (item) => {
			if (normalizedOptionFilterProp.length) return normalizedOptionFilterProp.some((prop) => item?.[prop] === mergedSearchValue);
			return item?.value === mergedSearchValue;
		};
		if (mode !== "tags" || !mergedSearchValue || filteredOptions.some((item) => hasItemMatchingSearch(item))) return filteredOptions;
		if (filteredOptions.some((item) => item[mergedFieldNames.value] === mergedSearchValue)) return filteredOptions;
		return [createTagOption(mergedSearchValue), ...filteredOptions];
	}, [
		createTagOption,
		normalizedOptionFilterProp,
		mode,
		filteredOptions,
		mergedSearchValue,
		mergedFieldNames
	]);
	const sorter = (inputOptions) => {
		return [...inputOptions].sort((a, b) => filterSort(a, b, { searchValue: mergedSearchValue })).map((item) => {
			if (Array.isArray(item.options)) return {
				...item,
				options: item.options.length > 0 ? sorter(item.options) : item.options
			};
			return item;
		});
	};
	const orderedFilteredOptions = import_react.useMemo(() => {
		if (!filterSort) return filledSearchOptions;
		return sorter(filledSearchOptions);
	}, [
		filledSearchOptions,
		filterSort,
		mergedSearchValue
	]);
	const displayOptions = import_react.useMemo(() => flattenOptions(orderedFilteredOptions, {
		fieldNames: mergedFieldNames,
		childrenAsData
	}), [
		orderedFilteredOptions,
		mergedFieldNames,
		childrenAsData
	]);
	const triggerChange = (values) => {
		const labeledValues = convert2LabelValues(values);
		setInternalValue(labeledValues);
		if (onChange && (labeledValues.length !== mergedValues.length || labeledValues.some((newVal, index$1) => mergedValues[index$1]?.value !== newVal?.value))) {
			const returnValues = labelInValue ? labeledValues.map(({ label: l$1, value: v }) => ({
				label: l$1,
				value: v
			})) : labeledValues.map((v) => v.value);
			const returnOptions = labeledValues.map((v) => injectPropsWithOption(getMixedOption(v.value)));
			onChange(multiple ? returnValues : returnValues[0], multiple ? returnOptions : returnOptions[0]);
		}
	};
	const [activeValue, setActiveValue] = import_react.useState(null);
	const [accessibilityIndex, setAccessibilityIndex] = import_react.useState(0);
	const mergedDefaultActiveFirstOption = defaultActiveFirstOption !== void 0 ? defaultActiveFirstOption : mode !== "combobox";
	const activeEventRef = import_react.useRef();
	const onActiveValue = import_react.useCallback((active, index$1, { source = "keyboard" } = {}) => {
		setAccessibilityIndex(index$1);
		if (backfill && mode === "combobox" && active !== null && source === "keyboard") setActiveValue(String(active));
		const promise = Promise.resolve().then(() => {
			if (activeEventRef.current === promise) onActive?.(active);
		});
		activeEventRef.current = promise;
	}, [
		backfill,
		mode,
		onActive
	]);
	const triggerSelect = (val, selected, type$2) => {
		const getSelectEnt = () => {
			const option = getMixedOption(val);
			return [labelInValue ? {
				label: option?.[mergedFieldNames.label],
				value: val
			} : val, injectPropsWithOption(option)];
		};
		if (selected && onSelect) {
			const [wrappedValue, option] = getSelectEnt();
			onSelect(wrappedValue, option);
		} else if (!selected && onDeselect && type$2 !== "clear") {
			const [wrappedValue, option] = getSelectEnt();
			onDeselect(wrappedValue, option);
		}
	};
	const onInternalSelect = useRefFunc$1((val, info) => {
		let cloneValues;
		const mergedSelect = multiple ? info.selected : true;
		if (mergedSelect) cloneValues = multiple ? [...mergedValues, val] : [val];
		else cloneValues = mergedValues.filter((v) => v.value !== val);
		triggerChange(cloneValues);
		triggerSelect(val, mergedSelect);
		if (mode === "combobox") setActiveValue("");
		else if (!isMultiple || autoClearSearchValue) {
			setSearchValue("");
			setActiveValue("");
		}
	});
	const onDisplayValuesChange = (nextValues, info) => {
		triggerChange(nextValues);
		const { type: type$2, values } = info;
		if (type$2 === "remove" || type$2 === "clear") values.forEach((item) => {
			triggerSelect(item.value, false, type$2);
		});
	};
	const onInternalSearch = (searchText, info) => {
		setSearchValue(searchText);
		setActiveValue(null);
		if (info.source === "submit") {
			const formatted = (searchText || "").trim();
			if (formatted) {
				triggerChange(Array.from(new Set([...rawValues, formatted])));
				triggerSelect(formatted, true);
				setSearchValue("");
			}
			return;
		}
		if (info.source !== "blur") {
			if (mode === "combobox") triggerChange(searchText);
			onSearch?.(searchText);
		}
	};
	const onInternalSearchSplit = (words) => {
		let patchValues = words;
		if (mode !== "tags") patchValues = words.map((word) => {
			return labelOptions.get(word)?.value;
		}).filter((val) => val !== void 0);
		const newRawValues = Array.from(new Set([...rawValues, ...patchValues]));
		triggerChange(newRawValues);
		newRawValues.forEach((newRawValue) => {
			triggerSelect(newRawValue, true);
		});
	};
	const selectContext = import_react.useMemo(() => {
		const realVirtual = virtual !== false && popupMatchSelectWidth !== false;
		return {
			...parsedOptions,
			flattenOptions: displayOptions,
			onActiveValue,
			defaultActiveFirstOption: mergedDefaultActiveFirstOption,
			onSelect: onInternalSelect,
			menuItemSelectedIcon,
			rawValues,
			fieldNames: mergedFieldNames,
			virtual: realVirtual,
			direction,
			listHeight,
			listItemHeight,
			childrenAsData,
			maxCount,
			optionRender,
			classNames,
			styles
		};
	}, [
		maxCount,
		parsedOptions,
		displayOptions,
		onActiveValue,
		mergedDefaultActiveFirstOption,
		onInternalSelect,
		menuItemSelectedIcon,
		rawValues,
		mergedFieldNames,
		virtual,
		popupMatchSelectWidth,
		direction,
		listHeight,
		listItemHeight,
		childrenAsData,
		optionRender,
		classNames,
		styles
	]);
	warningPropsUtil_default$1(props);
	warningNullOptions$1(mergedOptions, mergedFieldNames);
	return /* @__PURE__ */ import_react.createElement(SelectContext_default.Provider, { value: selectContext }, /* @__PURE__ */ import_react.createElement(BaseSelect_default, _extends$78({}, restProps, {
		id: mergedId,
		prefixCls,
		ref,
		omitDomProps: OMIT_DOM_PROPS,
		mode,
		classNames,
		styles,
		displayValues,
		onDisplayValuesChange,
		maxCount,
		direction,
		showSearch: mergedShowSearch,
		searchValue: mergedSearchValue,
		onSearch: onInternalSearch,
		autoClearSearchValue,
		onSearchSplit: onInternalSearchSplit,
		popupMatchSelectWidth,
		OptionList: OptionList_default$2,
		emptyOptions: !displayOptions.length,
		activeValue,
		activeDescendantId: `${mergedId}_list_${accessibilityIndex}`
	})));
});
Select$1.displayName = "Select";
var TypedSelect = Select$1;
TypedSelect.Option = Option_default$1;
TypedSelect.OptGroup = OptGroup_default;
var Select_default = TypedSelect;

//#endregion
//#region node_modules/@rc-component/select/es/index.js
var es_default$32 = Select_default;

//#endregion
//#region node_modules/antd/es/_util/statusUtils.js
const getStatusClassNames = (prefixCls, status, hasFeedback) => {
	return clsx({
		[`${prefixCls}-status-success`]: status === "success",
		[`${prefixCls}-status-warning`]: status === "warning",
		[`${prefixCls}-status-error`]: status === "error",
		[`${prefixCls}-status-validating`]: status === "validating",
		[`${prefixCls}-has-feedback`]: hasFeedback
	});
};
const getMergedStatus = (contextStatus, customStatus) => customStatus || contextStatus;

//#endregion
//#region node_modules/antd/es/empty/empty.js
var Empty$1 = () => {
	const [, token$1] = useToken();
	const [locale$5] = useLocale_default("Empty");
	const themeStyle = new FastColor(token$1.colorBgBase).toHsl().l < .5 ? { opacity: .65 } : {};
	return /* @__PURE__ */ import_react.createElement("svg", {
		style: themeStyle,
		width: "184",
		height: "152",
		viewBox: "0 0 184 152",
		xmlns: "http://www.w3.org/2000/svg"
	}, /* @__PURE__ */ import_react.createElement("title", null, locale$5?.description || "Empty"), /* @__PURE__ */ import_react.createElement("g", {
		fill: "none",
		fillRule: "evenodd"
	}, /* @__PURE__ */ import_react.createElement("g", { transform: "translate(24 31.67)" }, /* @__PURE__ */ import_react.createElement("ellipse", {
		fillOpacity: ".8",
		fill: "#F5F5F7",
		cx: "67.797",
		cy: "106.89",
		rx: "67.797",
		ry: "12.668"
	}), /* @__PURE__ */ import_react.createElement("path", {
		d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
		fill: "#AEB8C2"
	}), /* @__PURE__ */ import_react.createElement("path", {
		d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
		fill: "url(#linearGradient-1)",
		transform: "translate(13.56)"
	}), /* @__PURE__ */ import_react.createElement("path", {
		d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
		fill: "#F5F5F7"
	}), /* @__PURE__ */ import_react.createElement("path", {
		d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
		fill: "#DCE0E6"
	})), /* @__PURE__ */ import_react.createElement("path", {
		d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
		fill: "#DCE0E6"
	}), /* @__PURE__ */ import_react.createElement("g", {
		transform: "translate(149.65 15.383)",
		fill: "#FFF"
	}, /* @__PURE__ */ import_react.createElement("ellipse", {
		cx: "20.654",
		cy: "3.167",
		rx: "2.849",
		ry: "2.815"
	}), /* @__PURE__ */ import_react.createElement("path", { d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z" }))));
};
Empty$1.displayName = "EmptyImage";
var empty_default$2 = Empty$1;

//#endregion
//#region node_modules/antd/es/empty/simple.js
var Simple = () => {
	const [, token$1] = useToken();
	const [locale$5] = useLocale_default("Empty");
	const { colorFill, colorFillTertiary, colorFillQuaternary, colorBgContainer } = token$1;
	const { borderColor, shadowColor, contentColor } = (0, import_react.useMemo)(() => ({
		borderColor: new FastColor(colorFill).onBackground(colorBgContainer).toHexString(),
		shadowColor: new FastColor(colorFillTertiary).onBackground(colorBgContainer).toHexString(),
		contentColor: new FastColor(colorFillQuaternary).onBackground(colorBgContainer).toHexString()
	}), [
		colorFill,
		colorFillTertiary,
		colorFillQuaternary,
		colorBgContainer
	]);
	return /* @__PURE__ */ import_react.createElement("svg", {
		width: "64",
		height: "41",
		viewBox: "0 0 64 41",
		xmlns: "http://www.w3.org/2000/svg"
	}, /* @__PURE__ */ import_react.createElement("title", null, locale$5?.description || "Empty"), /* @__PURE__ */ import_react.createElement("g", {
		transform: "translate(0 1)",
		fill: "none",
		fillRule: "evenodd"
	}, /* @__PURE__ */ import_react.createElement("ellipse", {
		fill: shadowColor,
		cx: "32",
		cy: "33",
		rx: "32",
		ry: "7"
	}), /* @__PURE__ */ import_react.createElement("g", {
		fillRule: "nonzero",
		stroke: borderColor
	}, /* @__PURE__ */ import_react.createElement("path", { d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z" }), /* @__PURE__ */ import_react.createElement("path", {
		d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
		fill: contentColor
	}))));
};
Simple.displayName = "SimpleImage";
var simple_default = Simple;

//#endregion
//#region node_modules/antd/es/empty/style/index.js
var genSharedEmptyStyle = (token$1) => {
	const { componentCls, margin, marginXS, marginXL, fontSize, lineHeight } = token$1;
	return { [componentCls]: {
		marginInline: marginXS,
		fontSize,
		lineHeight,
		textAlign: "center",
		[`${componentCls}-image`]: {
			height: token$1.emptyImgHeight,
			marginBottom: marginXS,
			opacity: token$1.opacityImage,
			img: { height: "100%" },
			svg: {
				maxWidth: "100%",
				height: "100%",
				margin: "auto"
			}
		},
		[`${componentCls}-description`]: { color: token$1.colorTextDescription },
		[`${componentCls}-footer`]: { marginTop: margin },
		"&-normal": {
			marginBlock: marginXL,
			color: token$1.colorTextDescription,
			[`${componentCls}-description`]: { color: token$1.colorTextDescription },
			[`${componentCls}-image`]: { height: token$1.emptyImgHeightMD }
		},
		"&-small": {
			marginBlock: marginXS,
			color: token$1.colorTextDescription,
			[`${componentCls}-image`]: { height: token$1.emptyImgHeightSM }
		}
	} };
};
var style_default$54 = genStyleHooks("Empty", (token$1) => {
	const { componentCls, controlHeightLG, calc } = token$1;
	return genSharedEmptyStyle(merge(token$1, {
		emptyImgCls: `${componentCls}-img`,
		emptyImgHeight: calc(controlHeightLG).mul(2.5).equal(),
		emptyImgHeightMD: controlHeightLG,
		emptyImgHeightSM: calc(controlHeightLG).mul(.875).equal()
	}));
});

//#endregion
//#region node_modules/antd/es/empty/index.js
var defaultEmptyImg = /* @__PURE__ */ import_react.createElement(empty_default$2, null);
var simpleEmptyImg = /* @__PURE__ */ import_react.createElement(simple_default, null);
var Empty = (props) => {
	const { className, rootClassName, prefixCls: customizePrefixCls, image, description, children, imageStyle, style: style$1, classNames, styles, ...restProps } = props;
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles, image: contextImage } = useComponentConfig("empty");
	const prefixCls = getPrefixCls("empty", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$54(prefixCls);
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props });
	const [locale$5] = useLocale_default("Empty");
	const des = typeof description !== "undefined" ? description : locale$5?.description;
	const alt = typeof des === "string" ? des : "empty";
	const mergedImage = image ?? contextImage ?? defaultEmptyImg;
	let imageNode = null;
	if (typeof mergedImage === "string") imageNode = /* @__PURE__ */ import_react.createElement("img", {
		draggable: false,
		alt,
		src: mergedImage
	});
	else imageNode = mergedImage;
	{
		const warning$3 = devUseWarning("Empty");
		[["imageStyle", "styles.image"]].forEach(([deprecatedName, newName]) => {
			warning$3.deprecated(!(deprecatedName in props), deprecatedName, newName);
		});
	}
	return /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(hashId, cssVarCls, prefixCls, contextClassName, {
			[`${prefixCls}-normal`]: mergedImage === simpleEmptyImg,
			[`${prefixCls}-rtl`]: direction === "rtl"
		}, className, rootClassName, mergedClassNames.root),
		style: {
			...mergedStyles.root,
			...contextStyle,
			...style$1
		},
		...restProps
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-image`, mergedClassNames.image),
		style: {
			...imageStyle,
			...mergedStyles.image
		}
	}, imageNode), des && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-description`, mergedClassNames.description),
		style: mergedStyles.description
	}, des), children && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-footer`, mergedClassNames.footer),
		style: mergedStyles.footer
	}, children));
};
Empty.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
Empty.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
Empty.displayName = "Empty";
var empty_default = Empty;

//#endregion
//#region node_modules/antd/es/config-provider/defaultRenderEmpty.js
var DefaultRenderEmpty = (props) => {
	const { componentName } = props;
	const { getPrefixCls } = (0, import_react.useContext)(ConfigContext);
	const prefix$1 = getPrefixCls("empty");
	switch (componentName) {
		case "Table":
		case "List": return /* @__PURE__ */ import_react.createElement(empty_default, { image: empty_default.PRESENTED_IMAGE_SIMPLE });
		case "Select":
		case "TreeSelect":
		case "Cascader":
		case "Transfer":
		case "Mentions": return /* @__PURE__ */ import_react.createElement(empty_default, {
			image: empty_default.PRESENTED_IMAGE_SIMPLE,
			className: `${prefix$1}-small`
		});
		case "Table.filter": return null;
		default: return /* @__PURE__ */ import_react.createElement(empty_default, null);
	}
};
var defaultRenderEmpty_default = DefaultRenderEmpty;

//#endregion
//#region node_modules/antd/es/form/hooks/useVariants.js
/**
* Compatible for legacy `bordered` prop.
*/
var useVariant = (component, variant, legacyBordered) => {
	const { variant: configVariant, [component]: componentConfig } = import_react.useContext(ConfigContext);
	const ctxVariant = import_react.useContext(VariantContext);
	const configComponentVariant = componentConfig?.variant;
	let mergedVariant;
	if (typeof variant !== "undefined") mergedVariant = variant;
	else if (legacyBordered === false) mergedVariant = "borderless";
	else mergedVariant = ctxVariant ?? configComponentVariant ?? configVariant ?? "outlined";
	const enableVariantCls = Variants.includes(mergedVariant);
	return [mergedVariant, enableVariantCls];
};
var useVariants_default = useVariant;

//#endregion
//#region node_modules/antd/es/select/mergedBuiltinPlacements.js
var getBuiltInPlacements = (popupOverflow) => {
	const sharedConfig = {
		overflow: {
			adjustX: true,
			adjustY: true,
			shiftY: true
		},
		htmlRegion: popupOverflow === "scroll" ? "scroll" : "visible",
		dynamicInset: true
	};
	return {
		bottomLeft: {
			...sharedConfig,
			points: ["tl", "bl"],
			offset: [0, 4]
		},
		bottomRight: {
			...sharedConfig,
			points: ["tr", "br"],
			offset: [0, 4]
		},
		topLeft: {
			...sharedConfig,
			points: ["bl", "tl"],
			offset: [0, -4]
		},
		topRight: {
			...sharedConfig,
			points: ["br", "tr"],
			offset: [0, -4]
		}
	};
};
function mergedBuiltinPlacements(buildInPlacements, popupOverflow) {
	return buildInPlacements || getBuiltInPlacements(popupOverflow);
}
var mergedBuiltinPlacements_default = mergedBuiltinPlacements;

//#endregion
//#region node_modules/antd/es/select/style/dropdown.js
var genItemStyle = (token$1) => {
	const { optionHeight, optionFontSize, optionLineHeight, optionPadding } = token$1;
	return {
		position: "relative",
		display: "block",
		minHeight: optionHeight,
		padding: optionPadding,
		color: token$1.colorText,
		fontWeight: "normal",
		fontSize: optionFontSize,
		lineHeight: optionLineHeight,
		boxSizing: "border-box"
	};
};
var genSingleStyle = (token$1) => {
	const { antCls, componentCls } = token$1;
	const selectItemCls = `${componentCls}-item`;
	const slideUpEnterActive = `&${antCls}-slide-up-enter${antCls}-slide-up-enter-active`;
	const slideUpAppearActive = `&${antCls}-slide-up-appear${antCls}-slide-up-appear-active`;
	const slideUpLeaveActive = `&${antCls}-slide-up-leave${antCls}-slide-up-leave-active`;
	const dropdownPlacementCls = `${componentCls}-dropdown-placement-`;
	const selectedItemCls = `${selectItemCls}-option-selected`;
	return [
		{ [`${componentCls}-dropdown`]: {
			...resetComponent(token$1),
			position: "absolute",
			top: -9999,
			zIndex: token$1.zIndexPopup,
			boxSizing: "border-box",
			padding: token$1.paddingXXS,
			overflow: "hidden",
			fontSize: token$1.fontSize,
			fontVariant: "initial",
			backgroundColor: token$1.colorBgElevated,
			borderRadius: token$1.borderRadiusLG,
			outline: "none",
			boxShadow: token$1.boxShadowSecondary,
			[`
          ${slideUpEnterActive}${dropdownPlacementCls}bottomLeft,
          ${slideUpAppearActive}${dropdownPlacementCls}bottomLeft
        `]: { animationName: slideUpIn },
			[`
          ${slideUpEnterActive}${dropdownPlacementCls}topLeft,
          ${slideUpAppearActive}${dropdownPlacementCls}topLeft,
          ${slideUpEnterActive}${dropdownPlacementCls}topRight,
          ${slideUpAppearActive}${dropdownPlacementCls}topRight
        `]: { animationName: slideDownIn },
			[`${slideUpLeaveActive}${dropdownPlacementCls}bottomLeft`]: { animationName: slideUpOut },
			[`
          ${slideUpLeaveActive}${dropdownPlacementCls}topLeft,
          ${slideUpLeaveActive}${dropdownPlacementCls}topRight
        `]: { animationName: slideDownOut },
			"&-hidden": { display: "none" },
			[selectItemCls]: {
				...genItemStyle(token$1),
				cursor: "pointer",
				transition: `background ${token$1.motionDurationSlow} ease`,
				borderRadius: token$1.borderRadiusSM,
				"&-group": {
					color: token$1.colorTextDescription,
					fontSize: token$1.fontSizeSM,
					cursor: "default"
				},
				"&-option": {
					display: "flex",
					"&-content": {
						flex: "auto",
						...textEllipsis
					},
					"&-state": {
						flex: "none",
						display: "flex",
						alignItems: "center"
					},
					[`&-active:not(${selectItemCls}-option-disabled)`]: { backgroundColor: token$1.optionActiveBg },
					[`&-selected:not(${selectItemCls}-option-disabled)`]: {
						color: token$1.optionSelectedColor,
						fontWeight: token$1.optionSelectedFontWeight,
						backgroundColor: token$1.optionSelectedBg,
						[`${selectItemCls}-option-state`]: { color: token$1.colorPrimary }
					},
					"&-disabled": {
						[`&${selectItemCls}-option-selected`]: { backgroundColor: token$1.colorBgContainerDisabled },
						color: token$1.colorTextDisabled,
						cursor: "not-allowed"
					},
					"&-grouped": { paddingInlineStart: token$1.calc(token$1.controlPaddingHorizontal).mul(2).equal() }
				},
				"&-empty": {
					...genItemStyle(token$1),
					color: token$1.colorTextDisabled
				}
			},
			[`${selectedItemCls}:has(+ ${selectedItemCls})`]: {
				borderEndStartRadius: 0,
				borderEndEndRadius: 0,
				[`& + ${selectedItemCls}`]: {
					borderStartStartRadius: 0,
					borderStartEndRadius: 0
				}
			},
			"&-rtl": { direction: "rtl" }
		} },
		initSlideMotion(token$1, "slide-up"),
		initSlideMotion(token$1, "slide-down"),
		initMoveMotion(token$1, "move-up"),
		initMoveMotion(token$1, "move-down")
	];
};
var dropdown_default$2 = genSingleStyle;

//#endregion
//#region node_modules/antd/es/select/style/select-input-customize.js
var genSelectInputCustomizeStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`&${componentCls}-customize`]: {
		border: 0,
		padding: 0,
		fontSize: "inherit",
		lineHeight: "inherit",
		[`${componentCls}-placeholder`]: { display: "none" },
		[`${componentCls}-content`]: {
			margin: 0,
			padding: 0,
			"&-value": { display: "none" }
		}
	} };
};
var select_input_customize_default = genSelectInputCustomizeStyle;

//#endregion
//#region node_modules/antd/es/select/style/select-input-multiple.js
var FIXED_INPUT_MIN_WIDTH = 4;
var genSelectInputMultipleStyle = (token$1) => {
	const { componentCls, calc, iconCls, paddingXS, paddingXXS, INTERNAL_FIXED_ITEM_MARGIN, lineWidth, colorIcon, colorIconHover, inputPaddingHorizontalBase } = token$1;
	return { "&-multiple": {
		"--select-multi-item-background": token$1.multipleItemBg,
		"--select-multi-item-border-color": "transparent",
		"--select-multi-item-border-radius": token$1.borderRadiusSM,
		"--select-multi-item-height": token$1.multipleItemHeight,
		"--select-multi-padding-base": `calc((var(--select-height) - var(--select-multi-item-height)) / 2)`,
		"--select-multi-padding-vertical": `calc(var(--select-multi-padding-base) - ${INTERNAL_FIXED_ITEM_MARGIN} - ${lineWidth})`,
		"--select-multi-item-padding-horizontal": `calc(${inputPaddingHorizontalBase} - var(--select-multi-padding-vertical) - ${lineWidth} * 2)`,
		paddingBlock: `var(--select-multi-padding-vertical)`,
		paddingInlineStart: `calc(var(--select-multi-padding-base) - ${lineWidth})`,
		[`${componentCls}-prefix`]: { marginInlineStart: "var(--select-multi-item-padding-horizontal)" },
		[`${componentCls}-prefix + ${componentCls}-content`]: {
			[`${componentCls}-placeholder`]: { insetInlineStart: 0 },
			[`${componentCls}-content-item${componentCls}-content-item-suffix`]: { marginInlineStart: 0 }
		},
		[`${componentCls}-placeholder`]: {
			position: "absolute",
			lineHeight: "var(--select-line-height)",
			insetInlineStart: "var(--select-multi-item-padding-horizontal)",
			width: "calc(100% - var(--select-multi-item-padding-horizontal))",
			top: "50%",
			transform: "translateY(-50%)"
		},
		[`${componentCls}-content`]: {
			flexWrap: "wrap",
			alignItems: "center",
			lineHeight: 1,
			"&-item-prefix": { height: "var(--select-font-size)" },
			"&-item": {
				lineHeight: 1,
				maxWidth: `calc(100% - ${FIXED_INPUT_MIN_WIDTH}px)`
			},
			[`${componentCls}-content-item-prefix + ${componentCls}-content-item-suffix,
          ${componentCls}-content-item-suffix:first-child`]: { marginInlineStart: "var(--select-multi-item-padding-horizontal)" },
			[`${componentCls}-selection-item`]: {
				lineHeight: `calc(var(--select-multi-item-height) - ${lineWidth} * 2)`,
				border: `${lineWidth} solid var(--select-multi-item-border-color)`,
				display: "flex",
				marginBlock: INTERNAL_FIXED_ITEM_MARGIN,
				marginInlineEnd: calc(INTERNAL_FIXED_ITEM_MARGIN).mul(2).equal(),
				background: `var(--select-multi-item-background)`,
				borderRadius: `var(--select-multi-item-border-radius)`,
				paddingInlineStart: paddingXS,
				paddingInlineEnd: paddingXXS,
				transition: [
					"height",
					"line-height",
					"padding"
				].map((key) => `${key} ${token$1.motionDurationSlow}`).join(","),
				"&-content": {
					...textEllipsis,
					marginInlineEnd: paddingXXS
				},
				"&-remove": {
					...resetIcon(),
					display: "inline-flex",
					alignItems: "center",
					color: colorIcon,
					fontWeight: "bold",
					fontSize: 10,
					lineHeight: "inherit",
					cursor: "pointer",
					[`> ${iconCls}`]: { verticalAlign: "-0.2em" },
					"&:hover": { color: colorIconHover }
				}
			},
			[`${componentCls}-input`]: {
				lineHeight: calc(INTERNAL_FIXED_ITEM_MARGIN).mul(2).add("var(--select-multi-item-height)").equal(),
				width: "calc(var(--select-input-width, 0) * 1px)",
				minWidth: FIXED_INPUT_MIN_WIDTH,
				maxWidth: "100%",
				transition: `line-height ${token$1.motionDurationSlow}`
			}
		},
		[`&${componentCls}-sm`]: {
			"--select-multi-item-height": token$1.multipleItemHeightSM,
			"--select-multi-item-border-radius": token$1.borderRadiusXS
		},
		[`&${componentCls}-lg`]: {
			"--select-multi-item-height": token$1.multipleItemHeightLG,
			"--select-multi-item-border-radius": token$1.borderRadius
		},
		[`&${componentCls}-filled`]: {
			"--select-multi-item-border-color": token$1.colorSplit,
			"--select-multi-item-background": token$1.colorBgContainer,
			[`&${componentCls}-disabled`]: { "--select-multi-item-border-color": "transparent" }
		}
	} };
};
var select_input_multiple_default = genSelectInputMultipleStyle;

//#endregion
//#region node_modules/antd/es/select/style/select-input.js
/** Set CSS variables and hover/focus styles for a Select input based on provided colors. */
var genSelectInputVariableStyle = (token$1, colors) => {
	const { componentCls } = token$1;
	const { border, borderHover, borderActive, borderOutline } = colors;
	const baseBG = colors.background || token$1.selectorBg || token$1.colorBgContainer;
	return {
		"--select-border-color": border,
		"--select-background": baseBG,
		"--select-color": colors.color || token$1.colorText,
		[`&:not(${componentCls}-disabled)`]: {
			"&:hover": {
				"--select-border-color": borderHover,
				"--select-background": colors.backgroundHover || baseBG
			},
			[`&${componentCls}-focused`]: {
				"--select-border-color": borderActive,
				"--select-background": colors.backgroundActive || baseBG,
				boxShadow: `0 0 0 ${unit(token$1.controlOutlineWidth)} ${borderOutline}`
			}
		},
		[`&${componentCls}-disabled`]: {
			"--select-border-color": colors.borderDisabled || colors.border,
			"--select-background": colors.backgroundDisabled || colors.background
		}
	};
};
/** Generate variant-scoped variable styles and status overrides for a Select input. */
var genSelectInputVariantStyle = (token$1, variant, colors, errorColors = {}, warningColors = {}, patchStyle) => {
	const { componentCls } = token$1;
	return { [`&${componentCls}-${variant}`]: [
		genSelectInputVariableStyle(token$1, colors),
		{
			[`&${componentCls}-status-error`]: genSelectInputVariableStyle(token$1, {
				...colors,
				color: errorColors.color || token$1.colorError,
				...errorColors
			}),
			[`&${componentCls}-status-warning`]: genSelectInputVariableStyle(token$1, {
				...colors,
				color: warningColors.color || token$1.colorWarning,
				...warningColors
			})
		},
		patchStyle
	] };
};
var genSelectInputStyle = (token$1) => {
	const { componentCls, calc, fontHeight, controlHeight, iconCls } = token$1;
	return { [componentCls]: [
		{
			"--select-border-radius": token$1.borderRadius,
			"--select-border-color": "#000",
			"--select-border-size": token$1.lineWidth,
			"--select-background": token$1.colorBgContainer,
			"--select-font-size": token$1.fontSize,
			"--select-line-height": token$1.lineHeight,
			"--select-font-height": fontHeight,
			"--select-color": token$1.colorText,
			"--select-height": controlHeight,
			"--select-padding-horizontal": calc(token$1.paddingSM).sub(token$1.lineWidth).equal(),
			"--select-padding-vertical": "calc((var(--select-height) - var(--select-font-height)) / 2 - var(--select-border-size))",
			...resetComponent(token$1, true),
			display: "inline-flex",
			flexWrap: "nowrap",
			position: "relative",
			transition: `all ${token$1.motionDurationSlow}`,
			alignItems: "flex-start",
			outline: 0,
			cursor: "pointer",
			borderRadius: "var(--select-border-radius)",
			borderWidth: "var(--select-border-size)",
			borderStyle: token$1.lineType,
			borderColor: "var(--select-border-color)",
			background: "var(--select-background)",
			fontSize: "var(--select-font-size)",
			lineHeight: "var(--select-line-height)",
			color: "var(--select-color)",
			paddingInline: "var(--select-padding-horizontal)",
			paddingBlock: "var(--select-padding-vertical)",
			[`${componentCls}-prefix`]: {
				flex: "none",
				lineHeight: 1
			},
			[`${componentCls}-placeholder`]: {
				...textEllipsis,
				color: token$1.colorTextPlaceholder,
				pointerEvents: "none",
				zIndex: 1
			},
			[`${componentCls}-content`]: {
				flex: "auto",
				minWidth: 0,
				position: "relative",
				display: "flex",
				marginInlineEnd: calc(token$1.paddingXXS).mul(1.5).equal(),
				"&:before": {
					content: "\"\\a0\"",
					width: 0,
					overflow: "hidden"
				},
				"&-value": {
					...textEllipsis,
					transition: `all ${token$1.motionDurationMid} ${token$1.motionEaseInOut}`,
					zIndex: 1
				},
				"input[readonly]": {
					cursor: "inherit",
					caretColor: "transparent"
				}
			},
			[`&-open ${componentCls}-content-value`]: { color: token$1.colorTextPlaceholder },
			[`${componentCls}-suffix`]: {
				flex: "none",
				color: token$1.colorTextQuaternary,
				fontSize: token$1.fontSizeIcon,
				lineHeight: 1,
				"> :not(:last-child)": { marginInlineEnd: token$1.marginXS }
			},
			[`${componentCls}-prefix, ${componentCls}-suffix`]: {
				alignSelf: "center",
				[iconCls]: { verticalAlign: "top" }
			},
			"&-disabled": {
				background: token$1.colorBgContainerDisabled,
				color: token$1.colorTextDisabled,
				cursor: "not-allowed",
				input: { cursor: "not-allowed" }
			},
			"&-sm": {
				"--select-height": token$1.controlHeightSM,
				"--select-padding-horizontal": calc(token$1.paddingXS).sub(token$1.lineWidth).equal(),
				"--select-border-radius": token$1.borderRadiusSM
			},
			"&-lg": {
				"--select-height": token$1.controlHeightLG,
				"--select-font-size": token$1.fontSizeLG,
				"--select-line-height": token$1.lineHeightLG,
				"--select-font-height": token$1.fontHeightLG,
				"--select-border-radius": token$1.borderRadiusLG
			}
		},
		{ [`&:not(${componentCls}-customize)`]: { [`${componentCls}-input`]: {
			outline: "none",
			background: "transparent",
			appearance: "none",
			border: 0,
			margin: 0,
			padding: 0,
			color: "inherit",
			"&::-webkit-search-cancel-button": {
				display: "none",
				appearance: "none"
			}
		} } },
		{ [`&-single:not(${componentCls}-customize)`]: {
			[`${componentCls}-input`]: {
				position: "absolute",
				insetInline: 0,
				insetBlock: "calc(var(--select-padding-vertical) * -1)",
				lineHeight: "calc(var(--select-font-height) + var(--select-padding-vertical) * 2)"
			},
			[`${componentCls}-content`]: { alignSelf: "center" }
		} },
		{ [`&-show-search:not(${componentCls}-customize-input):not(${componentCls}-disabled)`]: { cursor: "text" } },
		select_input_multiple_default(token$1),
		genSelectInputVariantStyle(token$1, "outlined", {
			border: token$1.colorBorder,
			borderHover: token$1.hoverBorderColor,
			borderActive: token$1.activeBorderColor,
			borderOutline: token$1.activeOutlineColor,
			borderDisabled: token$1.colorBorderDisabled
		}, {
			border: token$1.colorError,
			borderHover: token$1.colorErrorHover,
			borderActive: token$1.colorError,
			borderOutline: token$1.colorErrorOutline
		}, {
			border: token$1.colorWarning,
			borderHover: token$1.colorWarningHover,
			borderActive: token$1.colorWarning,
			borderOutline: token$1.colorWarningOutline
		}),
		genSelectInputVariantStyle(token$1, "filled", {
			border: "transparent",
			borderHover: "transparent",
			borderActive: token$1.activeBorderColor,
			borderOutline: "transparent",
			borderDisabled: token$1.colorBorderDisabled,
			background: token$1.colorFillTertiary,
			backgroundHover: token$1.colorFillSecondary,
			backgroundActive: token$1.colorBgContainer
		}, {
			background: token$1.colorErrorBg,
			backgroundHover: token$1.colorErrorBgHover,
			borderActive: token$1.colorError
		}, {
			background: token$1.colorWarningBg,
			backgroundHover: token$1.colorWarningBgHover,
			borderActive: token$1.colorWarning
		}),
		genSelectInputVariantStyle(token$1, "borderless", {
			border: "transparent",
			borderHover: "transparent",
			borderActive: "transparent",
			borderOutline: "transparent",
			background: "transparent"
		}),
		genSelectInputVariantStyle(token$1, "underlined", {
			border: token$1.colorBorder,
			borderHover: token$1.hoverBorderColor,
			borderActive: token$1.activeBorderColor,
			borderOutline: "transparent"
		}, {
			border: token$1.colorError,
			borderHover: token$1.colorErrorHover,
			borderActive: token$1.colorError
		}, {
			border: token$1.colorWarning,
			borderHover: token$1.colorWarningHover,
			borderActive: token$1.colorWarning
		}, {
			borderRadius: 0,
			borderTopColor: "transparent",
			borderRightColor: "transparent",
			borderLeftColor: "transparent"
		}),
		select_input_customize_default(token$1)
	] };
};
var select_input_default = genSelectInputStyle;

//#endregion
//#region node_modules/antd/es/select/style/token.js
const prepareComponentToken$47 = (token$1) => {
	const { fontSize, lineHeight, lineWidth, controlHeight, controlHeightSM, controlHeightLG, paddingXXS, controlPaddingHorizontal, zIndexPopupBase, colorText, fontWeightStrong, controlItemBgActive, controlItemBgHover, colorBgContainer, colorFillSecondary, colorBgContainerDisabled, colorTextDisabled, colorPrimaryHover, colorPrimary, controlOutline } = token$1;
	const dblPaddingXXS = paddingXXS * 2;
	const dblLineWidth = lineWidth * 2;
	const multipleItemHeight = Math.min(controlHeight - dblPaddingXXS, controlHeight - dblLineWidth);
	const multipleItemHeightSM = Math.min(controlHeightSM - dblPaddingXXS, controlHeightSM - dblLineWidth);
	const multipleItemHeightLG = Math.min(controlHeightLG - dblPaddingXXS, controlHeightLG - dblLineWidth);
	return {
		INTERNAL_FIXED_ITEM_MARGIN: Math.floor(paddingXXS / 2),
		zIndexPopup: zIndexPopupBase + 50,
		optionSelectedColor: colorText,
		optionSelectedFontWeight: fontWeightStrong,
		optionSelectedBg: controlItemBgActive,
		optionActiveBg: controlItemBgHover,
		optionPadding: `${(controlHeight - fontSize * lineHeight) / 2}px ${controlPaddingHorizontal}px`,
		optionFontSize: fontSize,
		optionLineHeight: lineHeight,
		optionHeight: controlHeight,
		selectorBg: colorBgContainer,
		clearBg: colorBgContainer,
		singleItemHeightLG: controlHeightLG,
		multipleItemBg: colorFillSecondary,
		multipleItemBorderColor: "transparent",
		multipleItemHeight,
		multipleItemHeightSM,
		multipleItemHeightLG,
		multipleSelectorBgDisabled: colorBgContainerDisabled,
		multipleItemColorDisabled: colorTextDisabled,
		multipleItemBorderColorDisabled: "transparent",
		showArrowPaddingInlineEnd: Math.ceil(token$1.fontSize * 1.25),
		hoverBorderColor: colorPrimaryHover,
		activeBorderColor: colorPrimary,
		activeOutlineColor: controlOutline,
		selectAffixPadding: paddingXXS
	};
};

//#endregion
//#region node_modules/antd/es/select/style/index.js
var genBaseStyle$14 = (token$1) => {
	const { antCls, componentCls, inputPaddingHorizontalBase } = token$1;
	const hoverShowClearStyle = { [`${componentCls}-clear`]: {
		opacity: 1,
		background: token$1.colorBgBase,
		borderRadius: "50%"
	} };
	return {
		[componentCls]: {
			...resetComponent(token$1),
			[`${componentCls}-selection-item`]: {
				flex: 1,
				fontWeight: "normal",
				position: "relative",
				userSelect: "none",
				...textEllipsis,
				[`> ${antCls}-typography`]: { display: "inline" }
			},
			[`${componentCls}-prefix`]: {
				flex: "none",
				marginInlineEnd: token$1.selectAffixPadding
			},
			[`${componentCls}-clear`]: {
				position: "absolute",
				top: "50%",
				insetInlineStart: "auto",
				insetInlineEnd: inputPaddingHorizontalBase,
				zIndex: 1,
				display: "inline-block",
				width: token$1.fontSizeIcon,
				height: token$1.fontSizeIcon,
				marginTop: token$1.calc(token$1.fontSizeIcon).mul(-1).div(2).equal(),
				color: token$1.colorTextQuaternary,
				fontSize: token$1.fontSizeIcon,
				fontStyle: "normal",
				lineHeight: 1,
				textAlign: "center",
				textTransform: "none",
				cursor: "pointer",
				opacity: 0,
				transition: `color ${token$1.motionDurationMid} ease, opacity ${token$1.motionDurationSlow} ease`,
				textRendering: "auto",
				transform: "translateZ(0)",
				"&:before": { display: "block" },
				"&:hover": { color: token$1.colorIcon }
			},
			"@media(hover:none)": hoverShowClearStyle,
			"&:hover": hoverShowClearStyle
		},
		[`${componentCls}-status`]: { "&-error, &-warning, &-success, &-validating": { [`&${componentCls}-has-feedback`]: { [`${componentCls}-clear`]: { insetInlineEnd: token$1.calc(inputPaddingHorizontalBase).add(token$1.fontSize).add(token$1.paddingXS).equal() } } } }
	};
};
var genSelectStyle = (token$1) => {
	const { componentCls } = token$1;
	return [
		{ [componentCls]: { [`&${componentCls}-in-form-item`]: { width: "100%" } } },
		genBaseStyle$14(token$1),
		dropdown_default$2(token$1),
		{ [`${componentCls}-rtl`]: { direction: "rtl" } },
		genCompactItemStyle(token$1, { focusElCls: `${componentCls}-focused` })
	];
};
var style_default$2 = genStyleHooks("Select", (token$1, { rootPrefixCls }) => {
	const selectToken = merge(token$1, {
		rootPrefixCls,
		inputPaddingHorizontalBase: token$1.calc(token$1.paddingSM).sub(token$1.lineWidth).equal(),
		multipleSelectItemHeight: token$1.multipleItemHeight,
		selectHeight: token$1.controlHeight
	});
	return [genSelectStyle(selectToken), select_input_default(selectToken)];
}, prepareComponentToken$47, { unitless: {
	optionLineHeight: true,
	optionSelectedFontWeight: true
} });

//#endregion
//#region node_modules/antd/es/select/useIcons.js
function useIcons({ suffixIcon, clearIcon, menuItemSelectedIcon, removeIcon, loading, multiple, hasFeedback, showSuffixIcon, feedbackIcon, showArrow, componentName }) {
	devUseWarning(componentName).deprecated(!clearIcon, "clearIcon", "allowClear={{ clearIcon: React.ReactNode }}");
	const mergedClearIcon = clearIcon ?? /* @__PURE__ */ import_react.createElement(CloseCircleFilled_default, null);
	const getSuffixIconNode = (arrowIcon) => {
		if (suffixIcon === null && !hasFeedback && !showArrow) return null;
		return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, showSuffixIcon !== false && arrowIcon, hasFeedback && feedbackIcon);
	};
	let mergedSuffixIcon = null;
	if (suffixIcon !== void 0) mergedSuffixIcon = getSuffixIconNode(suffixIcon);
	else if (loading) mergedSuffixIcon = getSuffixIconNode(/* @__PURE__ */ import_react.createElement(LoadingOutlined_default, { spin: true }));
	else mergedSuffixIcon = ({ open: open$2, showSearch }) => {
		if (open$2 && showSearch) return getSuffixIconNode(/* @__PURE__ */ import_react.createElement(SearchOutlined_default, null));
		return getSuffixIconNode(/* @__PURE__ */ import_react.createElement(DownOutlined_default, null));
	};
	let mergedItemIcon = null;
	if (menuItemSelectedIcon !== void 0) mergedItemIcon = menuItemSelectedIcon;
	else if (multiple) mergedItemIcon = /* @__PURE__ */ import_react.createElement(CheckOutlined_default, null);
	else mergedItemIcon = null;
	let mergedRemoveIcon = null;
	if (removeIcon !== void 0) mergedRemoveIcon = removeIcon;
	else mergedRemoveIcon = /* @__PURE__ */ import_react.createElement(CloseOutlined_default, null);
	return {
		clearIcon: mergedClearIcon,
		suffixIcon: mergedSuffixIcon,
		itemIcon: mergedItemIcon,
		removeIcon: mergedRemoveIcon
	};
}

//#endregion
//#region node_modules/antd/es/select/usePopupRender.js
function usePopupRender(renderFn) {
	return import_react.useMemo(() => {
		if (!renderFn) return;
		return (...args) => /* @__PURE__ */ import_react.createElement(ContextIsolator_default, { space: true }, renderFn.apply(void 0, args));
	}, [renderFn]);
}
var usePopupRender_default = usePopupRender;

//#endregion
//#region node_modules/antd/es/select/useShowArrow.js
/**
* Since Select, TreeSelect, Cascader is same Select like component.
* We just use same hook to handle this logic.
*
* If `suffixIcon` is not equal to `null`, always show it.
*/
function useShowArrow(suffixIcon, showArrow) {
	return showArrow !== void 0 ? showArrow : suffixIcon !== null;
}

//#endregion
//#region node_modules/antd/es/select/index.js
var SECRET_COMBOBOX_MODE_DO_NOT_USE = "SECRET_COMBOBOX_MODE_DO_NOT_USE";
var InternalSelect = (props, ref) => {
	const { prefixCls: customizePrefixCls, bordered, className, rootClassName, getPopupContainer, popupClassName, dropdownClassName, listHeight = 256, placement, listItemHeight: customListItemHeight, size: customizeSize, disabled: customDisabled, notFoundContent, status: customStatus, builtinPlacements, dropdownMatchSelectWidth, popupMatchSelectWidth, direction: propDirection, style: style$1, allowClear, variant: customizeVariant, popupStyle, dropdownStyle, transitionName, tagRender, maxCount, prefix: prefix$1, dropdownRender, popupRender, onDropdownVisibleChange, onOpenChange, styles, classNames, ...rest } = props;
	const { getPopupContainer: getContextPopupContainer, getPrefixCls, renderEmpty, direction: contextDirection, virtual, popupMatchSelectWidth: contextPopupMatchSelectWidth, popupOverflow } = import_react.useContext(ConfigContext);
	const { showSearch, style: contextStyle, styles: contextStyles, className: contextClassName, classNames: contextClassNames } = useComponentConfig("select");
	const [, token$1] = useToken();
	const listItemHeight = customListItemHeight ?? token$1?.controlHeight;
	const prefixCls = getPrefixCls("select", customizePrefixCls);
	const rootPrefixCls = getPrefixCls();
	const direction = propDirection ?? contextDirection;
	const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
	const [variant, enableVariantCls] = useVariants_default("select", customizeVariant, bordered);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$2(prefixCls, rootCls);
	const mode = import_react.useMemo(() => {
		const { mode: m } = props;
		if (m === "combobox") return;
		if (m === SECRET_COMBOBOX_MODE_DO_NOT_USE) return "combobox";
		return m;
	}, [props.mode]);
	const isMultiple$1 = mode === "multiple" || mode === "tags";
	const showSuffixIcon = useShowArrow(props.suffixIcon, props.showArrow);
	const mergedPopupMatchSelectWidth = popupMatchSelectWidth ?? dropdownMatchSelectWidth ?? contextPopupMatchSelectWidth;
	const mergedPopupRender = usePopupRender_default(popupRender || dropdownRender);
	const mergedOnOpenChange = onOpenChange || onDropdownVisibleChange;
	const { status: contextStatus, hasFeedback, isFormItemInput, feedbackIcon } = import_react.useContext(FormItemInputContext);
	const mergedStatus = getMergedStatus(contextStatus, customStatus);
	let mergedNotFound;
	if (notFoundContent !== void 0) mergedNotFound = notFoundContent;
	else if (mode === "combobox") mergedNotFound = null;
	else mergedNotFound = renderEmpty?.("Select") || /* @__PURE__ */ import_react.createElement(defaultRenderEmpty_default, { componentName: "Select" });
	const { suffixIcon, itemIcon, removeIcon, clearIcon } = useIcons({
		...rest,
		multiple: isMultiple$1,
		hasFeedback,
		feedbackIcon,
		showSuffixIcon,
		prefixCls,
		componentName: "Select"
	});
	const mergedAllowClear = allowClear === true ? { clearIcon } : allowClear;
	const selectProps = omit(rest, ["suffixIcon", "itemIcon"]);
	const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
	const disabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = customDisabled ?? disabled;
	const mergedProps = {
		...props,
		variant,
		status: mergedStatus,
		disabled: mergedDisabled,
		size: mergedSize
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps }, { popup: { _default: "root" } });
	const mergedPopupClassName = clsx(mergedClassNames.popup?.root, popupClassName, dropdownClassName, { [`${prefixCls}-dropdown-${direction}`]: direction === "rtl" }, rootClassName, cssVarCls, rootCls, hashId);
	const mergedPopupStyle = {
		...mergedStyles.popup?.root,
		...popupStyle ?? dropdownStyle
	};
	const mergedClassName = clsx({
		[`${prefixCls}-lg`]: mergedSize === "large",
		[`${prefixCls}-sm`]: mergedSize === "small",
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-${variant}`]: enableVariantCls,
		[`${prefixCls}-in-form-item`]: isFormItemInput
	}, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), compactItemClassnames, contextClassName, className, mergedClassNames.root, rootClassName, cssVarCls, rootCls, hashId);
	const memoPlacement = import_react.useMemo(() => {
		if (placement !== void 0) return placement;
		return direction === "rtl" ? "bottomRight" : "bottomLeft";
	}, [placement, direction]);
	{
		const warning$3 = devUseWarning("Select");
		Object.entries({
			dropdownMatchSelectWidth: "popupMatchSelectWidth",
			dropdownStyle: "styles.popup.root",
			dropdownClassName: "classNames.popup.root",
			popupClassName: "classNames.popup.root",
			dropdownRender: "popupRender",
			onDropdownVisibleChange: "onOpenChange",
			bordered: "variant"
		}).forEach(([oldProp, newProp]) => {
			warning$3.deprecated(!(oldProp in props), oldProp, newProp);
		});
		warning$3(!("showArrow" in props), "deprecated", "`showArrow` is deprecated which will be removed in next major version. It will be a default behavior, you can hide it by setting `suffixIcon` to null.");
		warning$3(!(typeof maxCount !== "undefined" && !isMultiple$1), "usage", "`maxCount` only works with mode `multiple` or `tags`");
	}
	const [zIndex] = useZIndex("SelectLike", mergedStyles.popup?.root?.zIndex ?? mergedPopupStyle?.zIndex);
	return /* @__PURE__ */ import_react.createElement(es_default$32, {
		ref,
		virtual,
		classNames: mergedClassNames,
		styles: mergedStyles,
		showSearch,
		...selectProps,
		style: {
			...mergedStyles.root,
			...contextStyle,
			...style$1
		},
		popupMatchSelectWidth: mergedPopupMatchSelectWidth,
		transitionName: getTransitionName(rootPrefixCls, "slide-up", transitionName),
		builtinPlacements: mergedBuiltinPlacements_default(builtinPlacements, popupOverflow),
		listHeight,
		listItemHeight,
		mode,
		prefixCls,
		placement: memoPlacement,
		direction,
		prefix: prefix$1,
		suffixIcon,
		menuItemSelectedIcon: itemIcon,
		removeIcon,
		allowClear: mergedAllowClear,
		notFoundContent: mergedNotFound,
		className: mergedClassName,
		getPopupContainer: getPopupContainer || getContextPopupContainer,
		popupClassName: mergedPopupClassName,
		disabled: mergedDisabled,
		popupStyle: {
			...mergedStyles.popup?.root,
			...mergedPopupStyle,
			zIndex
		},
		maxCount: isMultiple$1 ? maxCount : void 0,
		tagRender: isMultiple$1 ? tagRender : void 0,
		popupRender: mergedPopupRender,
		onPopupVisibleChange: mergedOnOpenChange
	});
};
InternalSelect.displayName = "Select";
var Select = /* @__PURE__ */ import_react.forwardRef(InternalSelect);
/* istanbul ignore next */
var PurePanel$12 = PurePanel_default(Select, "popupAlign");
Select.SECRET_COMBOBOX_MODE_DO_NOT_USE = SECRET_COMBOBOX_MODE_DO_NOT_USE;
Select.Option = Option_default$1;
Select.OptGroup = OptGroup_default;
Select._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$12;
Select.displayName = "Select";
var select_default = Select;

//#endregion
//#region node_modules/antd/es/auto-complete/AutoComplete.js
var { Option: Option$3 } = select_default;
function isSelectOptionOrSelectOptGroup(child) {
	return child?.type && (child.type.isSelectOption || child.type.isSelectOptGroup);
}
var AutoComplete$1 = (props, ref) => {
	const { prefixCls: customizePrefixCls, className, style: style$1, popupClassName, dropdownClassName, children, dataSource, rootClassName, dropdownStyle, dropdownRender, popupRender, onDropdownVisibleChange, onOpenChange, styles, classNames } = props;
	const childNodes = toArray(children);
	const mergedPopupRender = popupRender || dropdownRender;
	const mergedOnOpenChange = onOpenChange || onDropdownVisibleChange;
	let customizeInput;
	if (childNodes.length === 1 && /* @__PURE__ */ import_react.isValidElement(childNodes[0]) && !isSelectOptionOrSelectOptGroup(childNodes[0])) [customizeInput] = childNodes;
	const getInputElement = customizeInput ? () => customizeInput : void 0;
	let optionChildren;
	if (childNodes.length && isSelectOptionOrSelectOptGroup(childNodes[0])) optionChildren = children;
	else optionChildren = dataSource ? dataSource.map((item) => {
		if (/* @__PURE__ */ import_react.isValidElement(item)) return item;
		switch (typeof item) {
			case "string": return /* @__PURE__ */ import_react.createElement(Option$3, {
				key: item,
				value: item
			}, item);
			case "object": {
				const { value: optionValue } = item;
				return /* @__PURE__ */ import_react.createElement(Option$3, {
					key: optionValue,
					value: optionValue
				}, item.text);
			}
			default: return;
		}
	}) : [];
	{
		const warning$3 = devUseWarning("AutoComplete");
		warning$3(!customizeInput || !("size" in props), "usage", "You need to control style self instead of setting `size` when using customize input.");
		Object.entries({
			dropdownMatchSelectWidth: "popupMatchSelectWidth",
			dropdownStyle: "styles.popup.root",
			dropdownClassName: "classNames.popup.root",
			popupClassName: "classNames.popup.root",
			dropdownRender: "popupRender",
			onDropdownVisibleChange: "onOpenChange",
			dataSource: "options"
		}).forEach(([oldProp, newProp]) => {
			warning$3.deprecated(!(oldProp in props), oldProp, newProp);
		});
	}
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("select", customizePrefixCls);
	const mergedProps = {
		...props,
		dataSource,
		status: props.status,
		popupMatchSelectWidth: props.popupMatchSelectWidth || props.dropdownMatchSelectWidth,
		popupRender: mergedPopupRender,
		onOpenChange: mergedOnOpenChange
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([classNames], [styles], { props: mergedProps }, { popup: { _default: "root" } });
	const finalClassNames = import_react.useMemo(() => ({
		root: clsx(`${prefixCls}-auto-complete`, className, rootClassName, mergedClassNames.root, { [`${prefixCls}-customize`]: customizeInput }),
		prefix: mergedClassNames.prefix,
		input: mergedClassNames.input,
		placeholder: mergedClassNames.placeholder,
		content: mergedClassNames.content,
		popup: {
			root: clsx(popupClassName, dropdownClassName, mergedClassNames.popup?.root),
			list: mergedClassNames.popup?.list,
			listItem: mergedClassNames.popup?.listItem
		}
	}), [
		prefixCls,
		className,
		rootClassName,
		mergedClassNames,
		popupClassName,
		dropdownClassName
	]);
	const finalStyles = import_react.useMemo(() => ({
		root: {
			...mergedStyles.root,
			...style$1
		},
		input: mergedStyles.input,
		prefix: mergedStyles.prefix,
		placeholder: mergedStyles.placeholder,
		content: mergedStyles.content,
		popup: {
			root: {
				...dropdownStyle,
				...mergedStyles.popup?.root
			},
			list: mergedStyles.popup?.list,
			listItem: mergedStyles.popup?.listItem
		}
	}), [
		mergedStyles,
		style$1,
		dropdownStyle
	]);
	return /* @__PURE__ */ import_react.createElement(select_default, {
		ref,
		suffixIcon: null,
		...omit(props, [
			"dataSource",
			"dropdownClassName",
			"popupClassName"
		]),
		prefixCls,
		classNames: finalClassNames,
		styles: finalStyles,
		mode: select_default.SECRET_COMBOBOX_MODE_DO_NOT_USE,
		popupRender: mergedPopupRender,
		onPopupVisibleChange: mergedOnOpenChange,
		getInputElement
	}, optionChildren);
};
var RefAutoComplete = /* @__PURE__ */ import_react.forwardRef(AutoComplete$1);
RefAutoComplete.displayName = "AutoComplete";
var AutoComplete_default = RefAutoComplete;

//#endregion
//#region node_modules/antd/es/auto-complete/index.js
var { Option: Option$2 } = select_default;
/* istanbul ignore next */
var PurePanel$11 = PurePanel_default(AutoComplete_default, "popupAlign", (props) => omit(props, ["visible"]));
var AutoComplete = AutoComplete_default;
AutoComplete.Option = Option$2;
AutoComplete._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$11;
var auto_complete_default = AutoComplete;

//#endregion
//#region node_modules/antd/es/_util/responsiveObserver.js
const responsiveArray = [
	"xxl",
	"xl",
	"lg",
	"md",
	"sm",
	"xs"
];
var getResponsiveMap = (token$1) => ({
	xs: `(max-width: ${token$1.screenXSMax}px)`,
	sm: `(min-width: ${token$1.screenSM}px)`,
	md: `(min-width: ${token$1.screenMD}px)`,
	lg: `(min-width: ${token$1.screenLG}px)`,
	xl: `(min-width: ${token$1.screenXL}px)`,
	xxl: `(min-width: ${token$1.screenXXL}px)`
});
/**
* Ensures that the breakpoints token are valid, in good order
* For each breakpoint : screenMin <= screen <= screenMax and screenMax <= nextScreenMin
*/
var validateBreakpoints = (token$1) => {
	const indexableToken = token$1;
	const revBreakpoints = [].concat(responsiveArray).reverse();
	revBreakpoints.forEach((breakpoint, i) => {
		const breakpointUpper = breakpoint.toUpperCase();
		const screenMin = `screen${breakpointUpper}Min`;
		const screen = `screen${breakpointUpper}`;
		if (!(indexableToken[screenMin] <= indexableToken[screen])) throw new Error(`${screenMin}<=${screen} fails : !(${indexableToken[screenMin]}<=${indexableToken[screen]})`);
		if (i < revBreakpoints.length - 1) {
			const screenMax = `screen${breakpointUpper}Max`;
			if (!(indexableToken[screen] <= indexableToken[screenMax])) throw new Error(`${screen}<=${screenMax} fails : !(${indexableToken[screen]}<=${indexableToken[screenMax]})`);
			const nextScreenMin = `screen${revBreakpoints[i + 1].toUpperCase()}Min`;
			if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) throw new Error(`${screenMax}<=${nextScreenMin} fails : !(${indexableToken[screenMax]}<=${indexableToken[nextScreenMin]})`);
		}
	});
	return token$1;
};
const matchScreen = (screens, screenSizes) => {
	if (!screenSizes) return;
	for (const breakpoint of responsiveArray) if (screens[breakpoint] && screenSizes?.[breakpoint] !== void 0) return screenSizes[breakpoint];
};
var useResponsiveObserver = () => {
	const [, token$1] = useToken();
	const responsiveMap = getResponsiveMap(validateBreakpoints(token$1));
	return import_react.useMemo(() => {
		const subscribers = /* @__PURE__ */ new Map();
		let subUid = -1;
		let screens = {};
		return {
			responsiveMap,
			matchHandlers: {},
			dispatch(pointMap) {
				screens = pointMap;
				subscribers.forEach((func) => func(screens));
				return subscribers.size >= 1;
			},
			subscribe(func) {
				if (!subscribers.size) this.register();
				subUid += 1;
				subscribers.set(subUid, func);
				func(screens);
				return subUid;
			},
			unsubscribe(paramToken) {
				subscribers.delete(paramToken);
				if (!subscribers.size) this.unregister();
			},
			register() {
				Object.entries(responsiveMap).forEach(([screen, mediaQuery]) => {
					const listener = ({ matches }) => {
						this.dispatch({
							...screens,
							[screen]: matches
						});
					};
					const mql = window.matchMedia(mediaQuery);
					if (typeof mql?.addEventListener === "function") mql.addEventListener("change", listener);
					this.matchHandlers[mediaQuery] = {
						mql,
						listener
					};
					listener(mql);
				});
			},
			unregister() {
				Object.values(responsiveMap).forEach((mediaQuery) => {
					const handler = this.matchHandlers[mediaQuery];
					if (typeof handler?.mql?.removeEventListener === "function") handler.mql.removeEventListener("change", handler?.listener);
				});
				subscribers.clear();
			}
		};
	}, [responsiveMap]);
};
var responsiveObserver_default = useResponsiveObserver;

//#endregion
//#region node_modules/antd/es/grid/hooks/useBreakpoint.js
function useBreakpoint$1(refreshOnChange = true, defaultScreens = {}) {
	const screensRef = (0, import_react.useRef)(defaultScreens);
	const [, forceUpdate] = useForceUpdate();
	const responsiveObserver = responsiveObserver_default();
	useLayoutEffect_default(() => {
		const token$1 = responsiveObserver.subscribe((supportScreens) => {
			screensRef.current = supportScreens;
			if (refreshOnChange) forceUpdate();
		});
		return () => responsiveObserver.unsubscribe(token$1);
	}, []);
	return screensRef.current;
}
var useBreakpoint_default = useBreakpoint$1;

//#endregion
//#region node_modules/antd/es/avatar/AvatarContext.js
var AvatarContext = /* @__PURE__ */ import_react.createContext({});
var AvatarContext_default = AvatarContext;

//#endregion
//#region node_modules/antd/es/avatar/style/index.js
var genBaseStyle$13 = (token$1) => {
	const { antCls, componentCls, iconCls, avatarBg, avatarColor, containerSize, containerSizeLG, containerSizeSM, textFontSize, textFontSizeLG, textFontSizeSM, iconFontSize, iconFontSizeLG, iconFontSizeSM, borderRadius, borderRadiusLG, borderRadiusSM, lineWidth, lineType } = token$1;
	const avatarSizeStyle = (size, fontSize, iconFontSize$1, radius$1) => ({
		width: size,
		height: size,
		borderRadius: "50%",
		fontSize,
		[`&${componentCls}-square`]: { borderRadius: radius$1 },
		[`&${componentCls}-icon`]: {
			fontSize: iconFontSize$1,
			[`> ${iconCls}`]: { margin: 0 }
		}
	});
	return { [componentCls]: {
		...resetComponent(token$1),
		position: "relative",
		display: "inline-flex",
		justifyContent: "center",
		alignItems: "center",
		overflow: "hidden",
		color: avatarColor,
		whiteSpace: "nowrap",
		textAlign: "center",
		verticalAlign: "middle",
		background: avatarBg,
		border: `${unit(lineWidth)} ${lineType} transparent`,
		"&-image": { background: "transparent" },
		[`${antCls}-image-img`]: { display: "block" },
		...avatarSizeStyle(containerSize, textFontSize, iconFontSize, borderRadius),
		"&-lg": { ...avatarSizeStyle(containerSizeLG, textFontSizeLG, iconFontSizeLG, borderRadiusLG) },
		"&-sm": { ...avatarSizeStyle(containerSizeSM, textFontSizeSM, iconFontSizeSM, borderRadiusSM) },
		"> img": {
			display: "block",
			width: "100%",
			height: "100%",
			objectFit: "cover"
		}
	} };
};
var genGroupStyle$2 = (token$1) => {
	const { componentCls, groupBorderColor, groupOverlapping, groupSpace } = token$1;
	return {
		[`${componentCls}-group`]: {
			display: "inline-flex",
			[componentCls]: { borderColor: groupBorderColor },
			"> *:not(:first-child)": { marginInlineStart: groupOverlapping }
		},
		[`${componentCls}-group-popover`]: { [`${componentCls} + ${componentCls}`]: { marginInlineStart: groupSpace } }
	};
};
const prepareComponentToken$46 = (token$1) => {
	const { controlHeight, controlHeightLG, controlHeightSM, fontSize, fontSizeLG, fontSizeXL, fontSizeHeading3, marginXS, marginXXS, colorBorderBg } = token$1;
	return {
		containerSize: controlHeight,
		containerSizeLG: controlHeightLG,
		containerSizeSM: controlHeightSM,
		textFontSize: fontSize,
		textFontSizeLG: fontSize,
		textFontSizeSM: fontSize,
		iconFontSize: Math.round((fontSizeLG + fontSizeXL) / 2),
		iconFontSizeLG: fontSizeHeading3,
		iconFontSizeSM: fontSize,
		groupSpace: marginXXS,
		groupOverlapping: -marginXS,
		groupBorderColor: colorBorderBg
	};
};
var style_default$51 = genStyleHooks("Avatar", (token$1) => {
	const { colorTextLightSolid, colorTextPlaceholder } = token$1;
	const avatarToken = merge(token$1, {
		avatarBg: colorTextPlaceholder,
		avatarColor: colorTextLightSolid
	});
	return [genBaseStyle$13(avatarToken), genGroupStyle$2(avatarToken)];
}, prepareComponentToken$46);

//#endregion
//#region node_modules/antd/es/avatar/Avatar.js
var Avatar$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, shape, size: customSize, src, srcSet, icon, className, rootClassName, style: style$1, alt, draggable, children, crossOrigin, gap = 4, onError, ...others } = props;
	const [scale, setScale] = import_react.useState(1);
	const [mounted, setMounted] = import_react.useState(false);
	const [isImgExist, setIsImgExist] = import_react.useState(true);
	const avatarNodeRef = import_react.useRef(null);
	const avatarChildrenRef = import_react.useRef(null);
	const avatarNodeMergedRef = composeRef(ref, avatarNodeRef);
	const { getPrefixCls, className: contextClassName, style: contextStyle } = useComponentConfig("avatar");
	const avatarCtx = import_react.useContext(AvatarContext_default);
	const setScaleParam = () => {
		if (!avatarChildrenRef.current || !avatarNodeRef.current) return;
		const childrenWidth = avatarChildrenRef.current.offsetWidth;
		const nodeWidth = avatarNodeRef.current.offsetWidth;
		if (childrenWidth !== 0 && nodeWidth !== 0) {
			if (gap * 2 < nodeWidth) setScale(nodeWidth - gap * 2 < childrenWidth ? (nodeWidth - gap * 2) / childrenWidth : 1);
		}
	};
	import_react.useEffect(() => {
		setMounted(true);
	}, []);
	import_react.useEffect(() => {
		setIsImgExist(true);
		setScale(1);
	}, [src]);
	import_react.useEffect(setScaleParam, [gap]);
	const handleImgLoadError = () => {
		if (onError?.() !== false) setIsImgExist(false);
	};
	const size = useSize_default((ctxSize) => customSize ?? avatarCtx?.size ?? ctxSize ?? "default");
	const screens = useBreakpoint_default(Object.keys(typeof size === "object" ? size || {} : {}).some((key) => [
		"xs",
		"sm",
		"md",
		"lg",
		"xl",
		"xxl"
	].includes(key)));
	const responsiveSizeStyle = import_react.useMemo(() => {
		if (typeof size !== "object") return {};
		const currentSize = size[responsiveArray.find((screen) => screens[screen])];
		return currentSize ? {
			width: currentSize,
			height: currentSize,
			fontSize: currentSize && (icon || children) ? currentSize / 2 : 18
		} : {};
	}, [
		screens,
		size,
		icon,
		children
	]);
	devUseWarning("Avatar")(!(typeof icon === "string" && icon.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${icon}\` at https://ant.design/components/icon`);
	const prefixCls = getPrefixCls("avatar", customizePrefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$51(prefixCls, rootCls);
	const sizeCls = clsx({
		[`${prefixCls}-lg`]: size === "large",
		[`${prefixCls}-sm`]: size === "small"
	});
	const hasImageElement = /* @__PURE__ */ import_react.isValidElement(src);
	const classString = clsx(prefixCls, sizeCls, contextClassName, `${prefixCls}-${shape || avatarCtx?.shape || "circle"}`, {
		[`${prefixCls}-image`]: hasImageElement || src && isImgExist,
		[`${prefixCls}-icon`]: !!icon
	}, cssVarCls, rootCls, className, rootClassName, hashId);
	const sizeStyle = typeof size === "number" ? {
		width: size,
		height: size,
		fontSize: icon ? size / 2 : 18
	} : {};
	let childrenToRender;
	if (typeof src === "string" && isImgExist) childrenToRender = /* @__PURE__ */ import_react.createElement("img", {
		src,
		draggable,
		srcSet,
		onError: handleImgLoadError,
		alt,
		crossOrigin
	});
	else if (hasImageElement) childrenToRender = src;
	else if (icon) childrenToRender = icon;
	else if (mounted || scale !== 1) {
		const transformString = `scale(${scale})`;
		const childrenStyle = {
			msTransform: transformString,
			WebkitTransform: transformString,
			transform: transformString
		};
		childrenToRender = /* @__PURE__ */ import_react.createElement(es_default$2, { onResize: setScaleParam }, /* @__PURE__ */ import_react.createElement("span", {
			className: `${prefixCls}-string`,
			ref: avatarChildrenRef,
			style: childrenStyle
		}, children));
	} else childrenToRender = /* @__PURE__ */ import_react.createElement("span", {
		className: `${prefixCls}-string`,
		style: { opacity: 0 },
		ref: avatarChildrenRef
	}, children);
	return /* @__PURE__ */ import_react.createElement("span", {
		...others,
		style: {
			...sizeStyle,
			...responsiveSizeStyle,
			...contextStyle,
			...style$1
		},
		className: classString,
		ref: avatarNodeMergedRef
	}, childrenToRender);
});
Avatar$1.displayName = "Avatar";
var Avatar_default = Avatar$1;

//#endregion
//#region node_modules/antd/es/_util/getRenderPropValue.js
const getRenderPropValue = (propValue) => {
	if (!propValue) return null;
	return typeof propValue === "function" ? propValue() : propValue;
};

//#endregion
//#region node_modules/@rc-component/tooltip/es/Popup.js
var Popup$1 = (props) => {
	const { children, prefixCls, id, classNames, styles, className, style: style$1 } = props;
	return /* @__PURE__ */ import_react.createElement("div", {
		id,
		className: clsx(`${prefixCls}-container`, classNames?.container, className),
		style: {
			...styles?.container,
			...style$1
		},
		role: "tooltip"
	}, typeof children === "function" ? children() : children);
};
var Popup_default = Popup$1;

//#endregion
//#region node_modules/@rc-component/tooltip/es/placements.js
var autoAdjustOverflowTopBottom = {
	shiftX: 64,
	adjustY: 1
};
var autoAdjustOverflowLeftRight = {
	adjustX: 1,
	shiftY: true
};
var targetOffset$2 = [0, 0];
const placements$3 = {
	left: {
		points: ["cr", "cl"],
		overflow: autoAdjustOverflowLeftRight,
		offset: [-4, 0],
		targetOffset: targetOffset$2
	},
	right: {
		points: ["cl", "cr"],
		overflow: autoAdjustOverflowLeftRight,
		offset: [4, 0],
		targetOffset: targetOffset$2
	},
	top: {
		points: ["bc", "tc"],
		overflow: autoAdjustOverflowTopBottom,
		offset: [0, -4],
		targetOffset: targetOffset$2
	},
	bottom: {
		points: ["tc", "bc"],
		overflow: autoAdjustOverflowTopBottom,
		offset: [0, 4],
		targetOffset: targetOffset$2
	},
	topLeft: {
		points: ["bl", "tl"],
		overflow: autoAdjustOverflowTopBottom,
		offset: [0, -4],
		targetOffset: targetOffset$2
	},
	leftTop: {
		points: ["tr", "tl"],
		overflow: autoAdjustOverflowLeftRight,
		offset: [-4, 0],
		targetOffset: targetOffset$2
	},
	topRight: {
		points: ["br", "tr"],
		overflow: autoAdjustOverflowTopBottom,
		offset: [0, -4],
		targetOffset: targetOffset$2
	},
	rightTop: {
		points: ["tl", "tr"],
		overflow: autoAdjustOverflowLeftRight,
		offset: [4, 0],
		targetOffset: targetOffset$2
	},
	bottomRight: {
		points: ["tr", "br"],
		overflow: autoAdjustOverflowTopBottom,
		offset: [0, 4],
		targetOffset: targetOffset$2
	},
	rightBottom: {
		points: ["bl", "br"],
		overflow: autoAdjustOverflowLeftRight,
		offset: [4, 0],
		targetOffset: targetOffset$2
	},
	bottomLeft: {
		points: ["tl", "bl"],
		overflow: autoAdjustOverflowTopBottom,
		offset: [0, 4],
		targetOffset: targetOffset$2
	},
	leftBottom: {
		points: ["br", "bl"],
		overflow: autoAdjustOverflowLeftRight,
		offset: [-4, 0],
		targetOffset: targetOffset$2
	}
};

//#endregion
//#region node_modules/@rc-component/tooltip/es/Tooltip.js
function _extends$77() {
	_extends$77 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$77.apply(this, arguments);
}
var Tooltip$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { trigger = ["hover"], mouseEnterDelay = 0, mouseLeaveDelay = .1, prefixCls = "rc-tooltip", children, onVisibleChange, afterVisibleChange, motion: motion$1, placement = "right", align = {}, destroyOnHidden = false, defaultVisible, getTooltipContainer, arrowContent, overlay, id, showArrow = true, classNames, styles, ...restProps } = props;
	const mergedId = useId_default(id);
	const triggerRef = (0, import_react.useRef)(null);
	(0, import_react.useImperativeHandle)(ref, () => triggerRef.current);
	const extraProps = { ...restProps };
	if ("visible" in props) extraProps.popupVisible = props.visible;
	const mergedArrow = import_react.useMemo(() => {
		if (!showArrow) return false;
		const arrowConfig = showArrow === true ? {} : showArrow;
		return {
			...arrowConfig,
			className: clsx(arrowConfig.className, classNames?.arrow),
			style: {
				...arrowConfig.style,
				...styles?.arrow
			},
			content: arrowConfig.content ?? arrowContent
		};
	}, [
		showArrow,
		classNames?.arrow,
		styles?.arrow,
		arrowContent
	]);
	const getChildren = ({ open: open$2 }) => {
		const child = import_react.Children.only(children);
		const ariaProps = { "aria-describedby": overlay && open$2 ? mergedId : void 0 };
		return /* @__PURE__ */ import_react.cloneElement(child, ariaProps);
	};
	return /* @__PURE__ */ import_react.createElement(es_default$6, _extends$77({
		popupClassName: classNames?.root,
		prefixCls,
		popup: /* @__PURE__ */ import_react.createElement(Popup_default, {
			key: "content",
			prefixCls,
			id: mergedId,
			classNames,
			styles
		}, overlay),
		action: trigger,
		builtinPlacements: placements$3,
		popupPlacement: placement,
		ref: triggerRef,
		popupAlign: align,
		getPopupContainer: getTooltipContainer,
		onOpenChange: onVisibleChange,
		afterOpenChange: afterVisibleChange,
		popupMotion: motion$1,
		defaultPopupVisible: defaultVisible,
		autoDestroy: destroyOnHidden,
		mouseLeaveDelay,
		popupStyle: styles?.root,
		mouseEnterDelay,
		arrow: mergedArrow,
		uniqueContainerClassName: classNames?.uniqueContainer,
		uniqueContainerStyle: styles?.uniqueContainer
	}, extraProps), getChildren);
});
var Tooltip_default = Tooltip$1;

//#endregion
//#region node_modules/@rc-component/tooltip/es/index.js
var es_default$31 = Tooltip_default;

//#endregion
//#region node_modules/antd/es/style/roundedArrow.js
function getArrowToken(token$1) {
	const { sizePopupArrow, borderRadiusXS, borderRadiusOuter } = token$1;
	const unitWidth = sizePopupArrow / 2;
	const ax = 0;
	const ay = unitWidth;
	const bx = borderRadiusOuter * 1 / Math.sqrt(2);
	const by = unitWidth - borderRadiusOuter * (1 - 1 / Math.sqrt(2));
	const cx = unitWidth - borderRadiusXS * (1 / Math.sqrt(2));
	const cy = borderRadiusOuter * (Math.sqrt(2) - 1) + borderRadiusXS * (1 / Math.sqrt(2));
	const dx = 2 * unitWidth - cx;
	const dy = cy;
	const ex = 2 * unitWidth - bx;
	const ey = by;
	const fx = 2 * unitWidth - ax;
	const fy = ay;
	const shadowWidth = unitWidth * Math.sqrt(2) + borderRadiusOuter * (Math.sqrt(2) - 2);
	const polygonOffset = borderRadiusOuter * (Math.sqrt(2) - 1);
	const arrowPolygon = `polygon(${polygonOffset}px 100%, 50% ${polygonOffset}px, ${2 * unitWidth - polygonOffset}px 100%, ${polygonOffset}px 100%)`;
	return {
		arrowShadowWidth: shadowWidth,
		arrowPath: `path('M ${ax} ${ay} A ${borderRadiusOuter} ${borderRadiusOuter} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${borderRadiusXS} ${borderRadiusXS} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${borderRadiusOuter} ${borderRadiusOuter} 0 0 0 ${fx} ${fy} Z')`,
		arrowPolygon
	};
}
const genRoundedArrow = (token$1, bgColor, boxShadow) => {
	const { sizePopupArrow, arrowPolygon, arrowPath, arrowShadowWidth, borderRadiusXS, calc } = token$1;
	return {
		pointerEvents: "none",
		width: sizePopupArrow,
		height: sizePopupArrow,
		overflow: "hidden",
		"&::before": {
			position: "absolute",
			bottom: 0,
			insetInlineStart: 0,
			width: sizePopupArrow,
			height: calc(sizePopupArrow).div(2).equal(),
			background: bgColor,
			clipPath: {
				_multi_value_: true,
				value: [arrowPolygon, arrowPath]
			},
			content: "\"\""
		},
		"&::after": {
			content: "\"\"",
			position: "absolute",
			width: arrowShadowWidth,
			height: arrowShadowWidth,
			bottom: 0,
			insetInline: 0,
			margin: "auto",
			borderRadius: {
				_skip_check_: true,
				value: `0 0 ${unit(borderRadiusXS)} 0`
			},
			transform: "translateY(50%) rotate(-135deg)",
			boxShadow,
			zIndex: 0,
			background: "transparent"
		}
	};
};

//#endregion
//#region node_modules/antd/es/style/placementArrow.js
const MAX_VERTICAL_CONTENT_RADIUS = 8;
function getArrowOffsetToken(options) {
	const { contentRadius, limitVerticalRadius } = options;
	const arrowOffset = contentRadius > 12 ? contentRadius + 2 : 12;
	return {
		arrowOffsetHorizontal: arrowOffset,
		arrowOffsetVertical: limitVerticalRadius ? MAX_VERTICAL_CONTENT_RADIUS : arrowOffset
	};
}
function isInject(valid, code) {
	if (!valid) return {};
	return code;
}
function getArrowStyle(token$1, colorBg, options) {
	const { componentCls, boxShadowPopoverArrow, arrowOffsetVertical, arrowOffsetHorizontal } = token$1;
	const { arrowDistance = 0, arrowPlacement = {
		left: true,
		right: true,
		top: true,
		bottom: true
	} } = options || {};
	return { [componentCls]: {
		[`${componentCls}-arrow`]: [{
			position: "absolute",
			zIndex: 1,
			display: "block",
			...genRoundedArrow(token$1, colorBg, boxShadowPopoverArrow),
			"&:before": { background: colorBg }
		}],
		...isInject(!!arrowPlacement.top, {
			[[
				`&-placement-top > ${componentCls}-arrow`,
				`&-placement-topLeft > ${componentCls}-arrow`,
				`&-placement-topRight > ${componentCls}-arrow`
			].join(",")]: {
				bottom: arrowDistance,
				transform: "translateY(100%) rotate(180deg)"
			},
			[`&-placement-top > ${componentCls}-arrow`]: {
				left: {
					_skip_check_: true,
					value: "50%"
				},
				transform: "translateX(-50%) translateY(100%) rotate(180deg)"
			},
			"&-placement-topLeft": {
				"--arrow-offset-horizontal": arrowOffsetHorizontal,
				[`> ${componentCls}-arrow`]: { left: {
					_skip_check_: true,
					value: arrowOffsetHorizontal
				} }
			},
			"&-placement-topRight": {
				"--arrow-offset-horizontal": `calc(100% - ${unit(arrowOffsetHorizontal)})`,
				[`> ${componentCls}-arrow`]: { right: {
					_skip_check_: true,
					value: arrowOffsetHorizontal
				} }
			}
		}),
		...isInject(!!arrowPlacement.bottom, {
			[[
				`&-placement-bottom > ${componentCls}-arrow`,
				`&-placement-bottomLeft > ${componentCls}-arrow`,
				`&-placement-bottomRight > ${componentCls}-arrow`
			].join(",")]: {
				top: arrowDistance,
				transform: `translateY(-100%)`
			},
			[`&-placement-bottom > ${componentCls}-arrow`]: {
				left: {
					_skip_check_: true,
					value: "50%"
				},
				transform: `translateX(-50%) translateY(-100%)`
			},
			"&-placement-bottomLeft": {
				"--arrow-offset-horizontal": arrowOffsetHorizontal,
				[`> ${componentCls}-arrow`]: { left: {
					_skip_check_: true,
					value: arrowOffsetHorizontal
				} }
			},
			"&-placement-bottomRight": {
				"--arrow-offset-horizontal": `calc(100% - ${unit(arrowOffsetHorizontal)})`,
				[`> ${componentCls}-arrow`]: { right: {
					_skip_check_: true,
					value: arrowOffsetHorizontal
				} }
			}
		}),
		...isInject(!!arrowPlacement.left, {
			[[
				`&-placement-left > ${componentCls}-arrow`,
				`&-placement-leftTop > ${componentCls}-arrow`,
				`&-placement-leftBottom > ${componentCls}-arrow`
			].join(",")]: {
				right: {
					_skip_check_: true,
					value: arrowDistance
				},
				transform: "translateX(100%) rotate(90deg)"
			},
			[`&-placement-left > ${componentCls}-arrow`]: {
				top: {
					_skip_check_: true,
					value: "50%"
				},
				transform: "translateY(-50%) translateX(100%) rotate(90deg)"
			},
			[`&-placement-leftTop > ${componentCls}-arrow`]: { top: arrowOffsetVertical },
			[`&-placement-leftBottom > ${componentCls}-arrow`]: { bottom: arrowOffsetVertical }
		}),
		...isInject(!!arrowPlacement.right, {
			[[
				`&-placement-right > ${componentCls}-arrow`,
				`&-placement-rightTop > ${componentCls}-arrow`,
				`&-placement-rightBottom > ${componentCls}-arrow`
			].join(",")]: {
				left: {
					_skip_check_: true,
					value: arrowDistance
				},
				transform: "translateX(-100%) rotate(-90deg)"
			},
			[`&-placement-right > ${componentCls}-arrow`]: {
				top: {
					_skip_check_: true,
					value: "50%"
				},
				transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
			},
			[`&-placement-rightTop > ${componentCls}-arrow`]: { top: arrowOffsetVertical },
			[`&-placement-rightBottom > ${componentCls}-arrow`]: { bottom: arrowOffsetVertical }
		})
	} };
}

//#endregion
//#region node_modules/antd/es/_util/placements.js
function getOverflowOptions(placement, arrowOffset, arrowWidth, autoAdjustOverflow$2) {
	if (autoAdjustOverflow$2 === false) return {
		adjustX: false,
		adjustY: false
	};
	const overflow = autoAdjustOverflow$2 && typeof autoAdjustOverflow$2 === "object" ? autoAdjustOverflow$2 : {};
	const baseOverflow = {};
	switch (placement) {
		case "top":
		case "bottom":
			baseOverflow.shiftX = arrowOffset.arrowOffsetHorizontal * 2 + arrowWidth;
			baseOverflow.shiftY = true;
			baseOverflow.adjustY = true;
			break;
		case "left":
		case "right":
			baseOverflow.shiftY = arrowOffset.arrowOffsetVertical * 2 + arrowWidth;
			baseOverflow.shiftX = true;
			baseOverflow.adjustX = true;
			break;
	}
	const mergedOverflow = {
		...baseOverflow,
		...overflow
	};
	if (!mergedOverflow.shiftX) mergedOverflow.adjustX = true;
	if (!mergedOverflow.shiftY) mergedOverflow.adjustY = true;
	return mergedOverflow;
}
var PlacementAlignMap = {
	left: { points: ["cr", "cl"] },
	right: { points: ["cl", "cr"] },
	top: { points: ["bc", "tc"] },
	bottom: { points: ["tc", "bc"] },
	topLeft: { points: ["bl", "tl"] },
	leftTop: { points: ["tr", "tl"] },
	topRight: { points: ["br", "tr"] },
	rightTop: { points: ["tl", "tr"] },
	bottomRight: { points: ["tr", "br"] },
	rightBottom: { points: ["bl", "br"] },
	bottomLeft: { points: ["tl", "bl"] },
	leftBottom: { points: ["br", "bl"] }
};
var ArrowCenterPlacementAlignMap = {
	topLeft: { points: ["bl", "tc"] },
	leftTop: { points: ["tr", "cl"] },
	topRight: { points: ["br", "tc"] },
	rightTop: { points: ["tl", "cr"] },
	bottomRight: { points: ["tr", "bc"] },
	rightBottom: { points: ["bl", "cr"] },
	bottomLeft: { points: ["tl", "bc"] },
	leftBottom: { points: ["br", "cl"] }
};
var DisableAutoArrowList = new Set([
	"topLeft",
	"topRight",
	"bottomLeft",
	"bottomRight",
	"leftTop",
	"leftBottom",
	"rightTop",
	"rightBottom"
]);
function getPlacements(config) {
	const { arrowWidth, autoAdjustOverflow: autoAdjustOverflow$2, arrowPointAtCenter, offset: offset$2, borderRadius, visibleFirst } = config;
	const halfArrowWidth = arrowWidth / 2;
	const placementMap = {};
	const arrowOffset = getArrowOffsetToken({
		contentRadius: borderRadius,
		limitVerticalRadius: true
	});
	Object.keys(PlacementAlignMap).forEach((key) => {
		const placementInfo = {
			...arrowPointAtCenter && ArrowCenterPlacementAlignMap[key] || PlacementAlignMap[key],
			offset: [0, 0],
			dynamicInset: true
		};
		placementMap[key] = placementInfo;
		if (DisableAutoArrowList.has(key)) placementInfo.autoArrow = false;
		switch (key) {
			case "top":
			case "topLeft":
			case "topRight":
				placementInfo.offset[1] = -halfArrowWidth - offset$2;
				break;
			case "bottom":
			case "bottomLeft":
			case "bottomRight":
				placementInfo.offset[1] = halfArrowWidth + offset$2;
				break;
			case "left":
			case "leftTop":
			case "leftBottom":
				placementInfo.offset[0] = -halfArrowWidth - offset$2;
				break;
			case "right":
			case "rightTop":
			case "rightBottom":
				placementInfo.offset[0] = halfArrowWidth + offset$2;
				break;
		}
		if (arrowPointAtCenter) switch (key) {
			case "topLeft":
			case "bottomLeft":
				placementInfo.offset[0] = -arrowOffset.arrowOffsetHorizontal - halfArrowWidth;
				break;
			case "topRight":
			case "bottomRight":
				placementInfo.offset[0] = arrowOffset.arrowOffsetHorizontal + halfArrowWidth;
				break;
			case "leftTop":
			case "rightTop":
				placementInfo.offset[1] = -arrowOffset.arrowOffsetHorizontal * 2 + halfArrowWidth;
				break;
			case "leftBottom":
			case "rightBottom":
				placementInfo.offset[1] = arrowOffset.arrowOffsetHorizontal * 2 - halfArrowWidth;
				break;
		}
		placementInfo.overflow = getOverflowOptions(key, arrowOffset, arrowWidth, autoAdjustOverflow$2);
		if (visibleFirst) placementInfo.htmlRegion = "visibleFirst";
	});
	return placementMap;
}

//#endregion
//#region node_modules/antd/es/tooltip/hook/useMergedArrow.js
var useMergedArrow = (providedArrow, providedContextArrow) => {
	const toConfig = (arrow) => typeof arrow === "boolean" ? { show: arrow } : arrow || {};
	return import_react.useMemo(() => {
		const arrowConfig = toConfig(providedArrow);
		const contextArrowConfig = toConfig(providedContextArrow);
		return {
			...contextArrowConfig,
			...arrowConfig,
			show: arrowConfig.show ?? contextArrowConfig.show ?? true
		};
	}, [providedArrow, providedContextArrow]);
};
var useMergedArrow_default = useMergedArrow;

//#endregion
//#region node_modules/antd/es/tooltip/style/index.js
var genTooltipStyle = (token$1) => {
	const { calc, componentCls, tooltipMaxWidth, tooltipColor, tooltipBg, tooltipBorderRadius, zIndexPopup, controlHeight, boxShadowSecondary, paddingSM, paddingXS, arrowOffsetHorizontal, sizePopupArrow } = token$1;
	const edgeAlignMinWidth = calc(tooltipBorderRadius).add(sizePopupArrow).add(arrowOffsetHorizontal).equal();
	const sharedBodyStyle = {
		minWidth: calc(tooltipBorderRadius).mul(2).add(sizePopupArrow).equal(),
		minHeight: controlHeight,
		padding: `${unit(token$1.calc(paddingSM).div(2).equal())} ${unit(paddingXS)}`,
		color: `var(--ant-tooltip-color, ${tooltipColor})`,
		textAlign: "start",
		textDecoration: "none",
		wordWrap: "break-word",
		backgroundColor: tooltipBg,
		borderRadius: tooltipBorderRadius,
		boxShadow: boxShadowSecondary,
		boxSizing: "border-box"
	};
	const sharedTransformOrigin = {
		"--valid-offset-x": "var(--arrow-offset-horizontal, var(--arrow-x))",
		transformOrigin: [`var(--valid-offset-x, 50%)`, `var(--arrow-y, 50%)`].join(" ")
	};
	return [
		{ [componentCls]: {
			...resetComponent(token$1),
			position: "absolute",
			zIndex: zIndexPopup,
			display: "block",
			width: "max-content",
			maxWidth: tooltipMaxWidth,
			visibility: "visible",
			...sharedTransformOrigin,
			"&-hidden": { display: "none" },
			"--antd-arrow-background-color": tooltipBg,
			[`${componentCls}-container`]: [sharedBodyStyle, initFadeMotion(token$1, true)],
			[`&:has(~ ${componentCls}-unique-container)`]: { [`${componentCls}-container`]: {
				border: "none",
				background: "transparent",
				boxShadow: "none"
			} },
			[[
				`&-placement-topLeft`,
				`&-placement-topRight`,
				`&-placement-bottomLeft`,
				`&-placement-bottomRight`
			].join(",")]: { minWidth: edgeAlignMinWidth },
			[[
				`&-placement-left`,
				`&-placement-leftTop`,
				`&-placement-leftBottom`,
				`&-placement-right`,
				`&-placement-rightTop`,
				`&-placement-rightBottom`
			].join(",")]: { [`${componentCls}-inner`]: { borderRadius: token$1.min(tooltipBorderRadius, MAX_VERTICAL_CONTENT_RADIUS) } },
			[`${componentCls}-content`]: { position: "relative" },
			...genPresetColor(token$1, (colorKey, { darkColor }) => ({ [`&${componentCls}-${colorKey}`]: {
				[`${componentCls}-container`]: { backgroundColor: darkColor },
				[`${componentCls}-arrow`]: { "--antd-arrow-background-color": darkColor }
			} })),
			"&-rtl": { direction: "rtl" }
		} },
		getArrowStyle(token$1, "var(--antd-arrow-background-color)"),
		{ [`${componentCls}-pure`]: {
			position: "relative",
			maxWidth: "none",
			margin: token$1.sizePopupArrow
		} },
		{ [`${componentCls}-unique-container`]: {
			...sharedBodyStyle,
			...sharedTransformOrigin,
			position: "absolute",
			zIndex: calc(zIndexPopup).sub(1).equal(),
			"&-hidden": { display: "none" },
			"&-visible": { transition: `all ${token$1.motionDurationSlow}` }
		} }
	];
};
const prepareComponentToken$45 = (token$1) => ({
	zIndexPopup: token$1.zIndexPopupBase + 70,
	...getArrowOffsetToken({
		contentRadius: token$1.borderRadius,
		limitVerticalRadius: true
	}),
	...getArrowToken(merge(token$1, { borderRadiusOuter: Math.min(token$1.borderRadiusOuter, 4) }))
});
var style_default$53 = (prefixCls, rootCls, injectStyle = true) => {
	return genStyleHooks("Tooltip", (token$1) => {
		const { borderRadius, colorTextLightSolid, colorBgSpotlight } = token$1;
		return [genTooltipStyle(merge(token$1, {
			tooltipMaxWidth: 250,
			tooltipColor: colorTextLightSolid,
			tooltipBorderRadius: borderRadius,
			tooltipBg: colorBgSpotlight
		})), initZoomMotion(token$1, "zoom-big-fast")];
	}, prepareComponentToken$45, {
		resetStyle: false,
		injectStyle
	})(prefixCls, rootCls);
};

//#endregion
//#region node_modules/antd/es/_util/colors.js
var inverseColors = PresetColors.map((color) => `${color}-inverse`);
const PresetStatusColors = [
	"success",
	"processing",
	"error",
	"default",
	"warning"
];
/**
* determine if the color keyword belongs to the `Ant Design` {@link PresetColors}.
* @param color color to be judged
* @param includeInverse whether to include reversed colors
*/
function isPresetColor(color, includeInverse = true) {
	if (includeInverse) return [].concat(_toConsumableArray(inverseColors), _toConsumableArray(PresetColors)).includes(color);
	return PresetColors.includes(color);
}
function isPresetStatusColor(color) {
	return PresetStatusColors.includes(color);
}

//#endregion
//#region node_modules/antd/es/tooltip/util.js
function parseColor(prefixCls, color) {
	const isInternalColor = isPresetColor(color);
	const className = clsx({ [`${prefixCls}-${color}`]: color && isInternalColor });
	const overlayStyle = {};
	const arrowStyle = {};
	const rgb = generateColor(color).toRgb();
	const textColor = (.299 * rgb.r + .587 * rgb.g + .114 * rgb.b) / 255 < .5 ? "#FFF" : "#000";
	if (color && !isInternalColor) {
		overlayStyle.background = color;
		overlayStyle["--ant-tooltip-color"] = textColor;
		arrowStyle["--antd-arrow-background-color"] = color;
	}
	return {
		className,
		overlayStyle,
		arrowStyle
	};
}

//#endregion
//#region node_modules/antd/es/tooltip/PurePanel.js
/** @private Internal Component. Do not use in your production. */
var PurePanel$10 = (props) => {
	const { prefixCls: customizePrefixCls, className, placement = "top", title, color, overlayInnerStyle, classNames, styles } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$53(prefixCls, rootCls);
	const colorInfo = parseColor(prefixCls, color);
	const arrowContentStyle = colorInfo.arrowStyle;
	const innerStyles = import_react.useMemo(() => {
		return { container: {
			...overlayInnerStyle,
			...colorInfo.overlayStyle
		} };
	}, [overlayInnerStyle, colorInfo.overlayStyle]);
	const mergedProps = {
		...props,
		placement
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([classNames], [innerStyles, styles], { props: mergedProps });
	const rootClassName = clsx(rootCls, hashId, cssVarCls, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className, colorInfo.className);
	return /* @__PURE__ */ import_react.createElement("div", {
		className: rootClassName,
		style: arrowContentStyle
	}, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-arrow` }), /* @__PURE__ */ import_react.createElement(Popup_default, {
		...props,
		className: hashId,
		prefixCls,
		classNames: mergedClassNames,
		styles: mergedStyles
	}, title));
};
var PurePanel_default$8 = PurePanel$10;

//#endregion
//#region node_modules/antd/es/tooltip/index.js
var Tooltip = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, openClassName, getTooltipContainer, color, children, afterOpenChange, arrow: tooltipArrow, destroyTooltipOnHide, destroyOnHidden, title, overlay, trigger, builtinPlacements, autoAdjustOverflow: autoAdjustOverflow$2 = true, motion: motion$1, getPopupContainer, placement = "top", mouseEnterDelay = .1, mouseLeaveDelay = .1, rootClassName, styles, classNames, onOpenChange, overlayInnerStyle, overlayStyle, overlayClassName, ...restProps } = props;
	const [, token$1] = useToken();
	const { getPopupContainer: getContextPopupContainer, getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles, arrow: contextArrow, trigger: contextTrigger } = useComponentConfig("tooltip");
	const mergedArrow = useMergedArrow_default(tooltipArrow, contextArrow);
	const mergedShowArrow = mergedArrow.show;
	const mergedTrigger = trigger || contextTrigger || "hover";
	const warning$3 = devUseWarning("Tooltip");
	const tooltipRef = import_react.useRef(null);
	const forceAlign = () => {
		tooltipRef.current?.forceAlign();
	};
	import_react.useImperativeHandle(ref, () => ({
		forceAlign,
		nativeElement: tooltipRef.current?.nativeElement,
		popupElement: tooltipRef.current?.popupElement
	}));
	[
		["overlayStyle", "styles.root"],
		["overlayInnerStyle", "styles.container"],
		["overlayClassName", "classNames.root"],
		["destroyTooltipOnHide", "destroyOnHidden"]
	].forEach(([deprecatedName, newName]) => {
		warning$3.deprecated(!(deprecatedName in props), deprecatedName, newName);
	});
	warning$3(!destroyTooltipOnHide || typeof destroyTooltipOnHide === "boolean", "usage", "`destroyTooltipOnHide` no need config `keepParent` anymore. Please use `boolean` value directly.");
	const [open$2, setOpen] = useControlledState(props.defaultOpen ?? false, props.open);
	const noTitle = !title && !overlay && title !== 0;
	const onInternalOpenChange = (vis) => {
		setOpen(noTitle ? false : vis);
		if (!noTitle && onOpenChange) onOpenChange(vis);
	};
	const tooltipPlacements = import_react.useMemo(() => {
		return builtinPlacements || getPlacements({
			arrowPointAtCenter: mergedArrow?.pointAtCenter ?? false,
			autoAdjustOverflow: autoAdjustOverflow$2,
			arrowWidth: mergedShowArrow ? token$1.sizePopupArrow : 0,
			borderRadius: token$1.borderRadius,
			offset: token$1.marginXXS,
			visibleFirst: true
		});
	}, [
		mergedArrow,
		builtinPlacements,
		token$1,
		mergedShowArrow,
		autoAdjustOverflow$2
	]);
	const memoOverlay = import_react.useMemo(() => {
		if (title === 0) return title;
		return overlay || title || "";
	}, [overlay, title]);
	const memoOverlayWrapper = /* @__PURE__ */ import_react.createElement(ContextIsolator_default, { space: true }, typeof memoOverlay === "function" ? memoOverlay() : memoOverlay);
	const mergedProps = {
		...props,
		trigger: mergedTrigger,
		color,
		placement,
		builtinPlacements,
		openClassName,
		arrow: tooltipArrow,
		autoAdjustOverflow: autoAdjustOverflow$2,
		getPopupContainer,
		children,
		destroyTooltipOnHide,
		destroyOnHidden
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
	const rootPrefixCls = getPrefixCls();
	const injectFromPopover = props["data-popover-inject"];
	let tempOpen = open$2;
	if (!("open" in props) && noTitle) tempOpen = false;
	const child = /* @__PURE__ */ import_react.isValidElement(children) && !isFragment(children) ? children : /* @__PURE__ */ import_react.createElement("span", null, children);
	const childProps = child.props;
	const childCls = !childProps.className || typeof childProps.className === "string" ? clsx(childProps.className, openClassName || `${prefixCls}-open`) : childProps.className;
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$53(prefixCls, rootCls, !injectFromPopover);
	const colorInfo = parseColor(prefixCls, color);
	const arrowContentStyle = colorInfo.arrowStyle;
	const themeCls = clsx(rootCls, hashId, cssVarCls);
	const rootClassNames = clsx(overlayClassName, { [`${prefixCls}-rtl`]: direction === "rtl" }, colorInfo.className, rootClassName, themeCls, contextClassName, mergedClassNames.root);
	const [zIndex, contextZIndex] = useZIndex("Tooltip", restProps.zIndex);
	const containerStyle = {
		...mergedStyles.container,
		...overlayInnerStyle,
		...colorInfo.overlayStyle
	};
	const content = /* @__PURE__ */ import_react.createElement(es_default$31, {
		unique: true,
		...restProps,
		trigger: mergedTrigger,
		zIndex,
		showArrow: mergedShowArrow,
		placement,
		mouseEnterDelay,
		mouseLeaveDelay,
		prefixCls,
		classNames: {
			root: rootClassNames,
			container: mergedClassNames.container,
			arrow: mergedClassNames.arrow,
			uniqueContainer: clsx(themeCls, mergedClassNames.container)
		},
		styles: {
			root: {
				...arrowContentStyle,
				...mergedStyles.root,
				...contextStyle,
				...overlayStyle
			},
			container: containerStyle,
			uniqueContainer: containerStyle,
			arrow: mergedStyles.arrow
		},
		getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,
		ref: tooltipRef,
		builtinPlacements: tooltipPlacements,
		overlay: memoOverlayWrapper,
		visible: tempOpen,
		onVisibleChange: onInternalOpenChange,
		afterVisibleChange: afterOpenChange,
		arrowContent: /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-arrow-content` }),
		motion: {
			motionName: getTransitionName(rootPrefixCls, "zoom-big-fast", typeof motion$1?.motionName === "string" ? motion$1?.motionName : void 0),
			motionDeadline: 1e3
		},
		destroyOnHidden: destroyOnHidden ?? !!destroyTooltipOnHide
	}, tempOpen ? cloneElement(child, { className: childCls }) : child);
	return /* @__PURE__ */ import_react.createElement(zindexContext_default.Provider, { value: contextZIndex }, content);
});
Tooltip.displayName = "Tooltip";
Tooltip._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default$8;
Tooltip.UniqueProvider = UniqueProvider_default;
var tooltip_default = Tooltip;

//#endregion
//#region node_modules/antd/es/popover/style/index.js
var genBaseStyle$12 = (token$1) => {
	const { componentCls, popoverColor, titleMinWidth, fontWeightStrong, innerPadding, boxShadowSecondary, colorTextHeading, borderRadiusLG, zIndexPopup, titleMarginBottom, colorBgElevated, popoverBg, titleBorderBottom, innerContentPadding, titlePadding } = token$1;
	return [
		{ [componentCls]: {
			...resetComponent(token$1),
			position: "absolute",
			top: 0,
			left: {
				_skip_check_: true,
				value: 0
			},
			zIndex: zIndexPopup,
			fontWeight: "normal",
			whiteSpace: "normal",
			textAlign: "start",
			cursor: "auto",
			userSelect: "text",
			"--valid-offset-x": "var(--arrow-offset-horizontal, var(--arrow-x))",
			transformOrigin: [`var(--valid-offset-x, 50%)`, `var(--arrow-y, 50%)`].join(" "),
			"--antd-arrow-background-color": colorBgElevated,
			width: "max-content",
			maxWidth: "100vw",
			"&-rtl": { direction: "rtl" },
			"&-hidden": { display: "none" },
			[`${componentCls}-content`]: { position: "relative" },
			[`${componentCls}-container`]: {
				backgroundColor: popoverBg,
				backgroundClip: "padding-box",
				borderRadius: borderRadiusLG,
				boxShadow: boxShadowSecondary,
				padding: innerPadding
			},
			[`${componentCls}-title`]: {
				minWidth: titleMinWidth,
				marginBottom: titleMarginBottom,
				color: colorTextHeading,
				fontWeight: fontWeightStrong,
				borderBottom: titleBorderBottom,
				padding: titlePadding
			},
			[`${componentCls}-content`]: {
				color: popoverColor,
				padding: innerContentPadding
			}
		} },
		getArrowStyle(token$1, "var(--antd-arrow-background-color)"),
		{ [`${componentCls}-pure`]: {
			position: "relative",
			maxWidth: "none",
			margin: token$1.sizePopupArrow,
			display: "inline-block"
		} }
	];
};
var genColorStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: PresetColors.map((colorKey) => {
		const lightColor = token$1[`${colorKey}6`];
		return { [`&${componentCls}-${colorKey}`]: {
			"--antd-arrow-background-color": lightColor,
			[`${componentCls}-inner`]: { backgroundColor: lightColor },
			[`${componentCls}-arrow`]: { background: "transparent" }
		} };
	}) };
};
const prepareComponentToken$44 = (token$1) => {
	const { lineWidth, controlHeight, fontHeight, padding, wireframe, zIndexPopupBase, borderRadiusLG, marginXS, lineType, colorSplit, paddingSM } = token$1;
	const titlePaddingBlockDist = controlHeight - fontHeight;
	const popoverTitlePaddingBlockTop = titlePaddingBlockDist / 2;
	const popoverTitlePaddingBlockBottom = titlePaddingBlockDist / 2 - lineWidth;
	const popoverPaddingHorizontal = padding;
	return {
		titleMinWidth: 177,
		zIndexPopup: zIndexPopupBase + 30,
		...getArrowToken(token$1),
		...getArrowOffsetToken({
			contentRadius: borderRadiusLG,
			limitVerticalRadius: true
		}),
		innerPadding: wireframe ? 0 : 12,
		titleMarginBottom: wireframe ? 0 : marginXS,
		titlePadding: wireframe ? `${popoverTitlePaddingBlockTop}px ${popoverPaddingHorizontal}px ${popoverTitlePaddingBlockBottom}px` : 0,
		titleBorderBottom: wireframe ? `${lineWidth}px ${lineType} ${colorSplit}` : "none",
		innerContentPadding: wireframe ? `${paddingSM}px ${popoverPaddingHorizontal}px` : 0
	};
};
var style_default$52 = genStyleHooks("Popover", (token$1) => {
	const { colorBgElevated, colorText } = token$1;
	const popoverToken = merge(token$1, {
		popoverBg: colorBgElevated,
		popoverColor: colorText
	});
	return [
		genBaseStyle$12(popoverToken),
		genColorStyle(popoverToken),
		initZoomMotion(popoverToken, "zoom-big")
	];
}, prepareComponentToken$44, {
	resetStyle: false,
	deprecatedTokens: [["width", "titleMinWidth"], ["minWidth", "titleMinWidth"]]
});

//#endregion
//#region node_modules/antd/es/popover/PurePanel.js
const Overlay$2 = (props) => {
	const { title, content, prefixCls, classNames, styles } = props;
	if (!title && !content) return null;
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, title && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-title`, classNames?.title),
		style: styles?.title
	}, title), content && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-content`, classNames?.content),
		style: styles?.content
	}, content));
};
const RawPurePanel = (props) => {
	const { hashId, prefixCls, className, style: style$1, placement = "top", title, content, children, classNames, styles } = props;
	const titleNode = getRenderPropValue(title);
	const contentNode = getRenderPropValue(content);
	const mergedProps = {
		...props,
		placement
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([classNames], [styles], { props: mergedProps });
	const rootClassName = clsx(hashId, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className);
	return /* @__PURE__ */ import_react.createElement("div", {
		className: rootClassName,
		style: style$1
	}, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-arrow` }), /* @__PURE__ */ import_react.createElement(Popup_default, {
		...props,
		className: hashId,
		prefixCls,
		classNames: mergedClassNames,
		styles: mergedStyles
	}, children || /* @__PURE__ */ import_react.createElement(Overlay$2, {
		prefixCls,
		title: titleNode,
		content: contentNode,
		classNames: mergedClassNames,
		styles: mergedStyles
	})));
};
var PurePanel$9 = (props) => {
	const { prefixCls: customizePrefixCls, className, ...restProps } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("popover", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$52(prefixCls);
	return /* @__PURE__ */ import_react.createElement(RawPurePanel, {
		...restProps,
		prefixCls,
		hashId,
		className: clsx(className, cssVarCls)
	});
};
var PurePanel_default$3 = PurePanel$9;

//#endregion
//#region node_modules/antd/es/popover/index.js
var Popover = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, title, content, overlayClassName, placement = "top", trigger, children, mouseEnterDelay = .1, mouseLeaveDelay = .1, onOpenChange, overlayStyle = {}, styles, classNames, motion: motion$1, arrow: popoverArrow, ...restProps } = props;
	const { getPrefixCls, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles, arrow: contextArrow, trigger: contextTrigger } = useComponentConfig("popover");
	const prefixCls = getPrefixCls("popover", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$52(prefixCls);
	const rootPrefixCls = getPrefixCls();
	const mergedArrow = useMergedArrow_default(popoverArrow, contextArrow);
	const mergedTrigger = trigger || contextTrigger || "hover";
	const mergedProps = {
		...props,
		placement,
		trigger: mergedTrigger,
		mouseEnterDelay,
		mouseLeaveDelay,
		overlayStyle,
		styles,
		classNames
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const rootClassNames = clsx(overlayClassName, hashId, cssVarCls, contextClassName, mergedClassNames.root);
	const [open$2, setOpen] = useControlledState(props.defaultOpen ?? false, props.open);
	const settingOpen = (value, e$2) => {
		setOpen(value);
		onOpenChange?.(value, e$2);
	};
	const onKeyDown$1 = (e$2) => {
		if (e$2.keyCode === KeyCode_default.ESC) settingOpen(false, e$2);
	};
	const onInternalOpenChange = (value) => {
		settingOpen(value);
	};
	const titleNode = getRenderPropValue(title);
	const contentNode = getRenderPropValue(content);
	return /* @__PURE__ */ import_react.createElement(tooltip_default, {
		unique: false,
		arrow: mergedArrow,
		placement,
		trigger: mergedTrigger,
		mouseEnterDelay,
		mouseLeaveDelay,
		...restProps,
		prefixCls,
		classNames: {
			root: rootClassNames,
			container: mergedClassNames.container,
			arrow: mergedClassNames.arrow
		},
		styles: {
			root: {
				...mergedStyles.root,
				...contextStyle,
				...overlayStyle
			},
			container: mergedStyles.container,
			arrow: mergedStyles.arrow
		},
		ref,
		open: open$2,
		onOpenChange: onInternalOpenChange,
		overlay: titleNode || contentNode ? /* @__PURE__ */ import_react.createElement(Overlay$2, {
			prefixCls,
			title: titleNode,
			content: contentNode,
			classNames: mergedClassNames,
			styles: mergedStyles
		}) : null,
		motion: { motionName: getTransitionName(rootPrefixCls, "zoom-big", typeof motion$1?.motionName === "string" ? motion$1?.motionName : void 0) },
		"data-popover-inject": true
	}, cloneElement(children, { onKeyDown: (e$2) => {
		if (/* @__PURE__ */ (0, import_react.isValidElement)(children)) children?.props.onKeyDown?.(e$2);
		onKeyDown$1(e$2);
	} }));
});
Popover._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default$3;
Popover.displayName = "Popover";
var popover_default = Popover;

//#endregion
//#region node_modules/antd/es/avatar/AvatarGroup.js
var AvatarContextProvider = (props) => {
	const { size, shape } = import_react.useContext(AvatarContext_default);
	const avatarContextValue = import_react.useMemo(() => ({
		size: props.size || size,
		shape: props.shape || shape
	}), [
		props.size,
		props.shape,
		size,
		shape
	]);
	return /* @__PURE__ */ import_react.createElement(AvatarContext_default.Provider, { value: avatarContextValue }, props.children);
};
var AvatarGroup = (props) => {
	const { getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const { prefixCls: customizePrefixCls, className, rootClassName, style: style$1, maxCount, maxStyle, size, shape, maxPopoverPlacement, maxPopoverTrigger, children, max } = props;
	{
		const warning$3 = devUseWarning("Avatar.Group");
		[
			["maxCount", "max={{ count: number }}"],
			["maxStyle", "max={{ style: CSSProperties }}"],
			["maxPopoverPlacement", "max={{ popover: PopoverProps }}"],
			["maxPopoverTrigger", "max={{ popover: PopoverProps }}"]
		].forEach(([deprecatedName, newName]) => {
			warning$3.deprecated(!(deprecatedName in props), deprecatedName, newName);
		});
	}
	const prefixCls = getPrefixCls("avatar", customizePrefixCls);
	const groupPrefixCls = `${prefixCls}-group`;
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$51(prefixCls, rootCls);
	const cls = clsx(groupPrefixCls, { [`${groupPrefixCls}-rtl`]: direction === "rtl" }, cssVarCls, rootCls, className, rootClassName, hashId);
	const childrenWithProps = toArray(children).map((child, index$1) => cloneElement(child, { key: `avatar-key-${index$1}` }));
	const mergeCount = max?.count || maxCount;
	const numOfChildren = childrenWithProps.length;
	if (mergeCount && mergeCount < numOfChildren) {
		const childrenShow = childrenWithProps.slice(0, mergeCount);
		const childrenHidden = childrenWithProps.slice(mergeCount, numOfChildren);
		const mergeStyle = max?.style || maxStyle;
		const mergePopoverTrigger = max?.popover?.trigger || maxPopoverTrigger || "hover";
		const mergePopoverPlacement = max?.popover?.placement || maxPopoverPlacement || "top";
		const popoverProps = {
			content: childrenHidden,
			...max?.popover,
			placement: mergePopoverPlacement,
			trigger: mergePopoverTrigger,
			rootClassName: clsx(`${groupPrefixCls}-popover`, max?.popover?.rootClassName)
		};
		childrenShow.push(/* @__PURE__ */ import_react.createElement(popover_default, {
			key: "avatar-popover-key",
			destroyOnHidden: true,
			...popoverProps
		}, /* @__PURE__ */ import_react.createElement(Avatar_default, { style: mergeStyle }, `+${numOfChildren - mergeCount}`)));
		return /* @__PURE__ */ import_react.createElement(AvatarContextProvider, {
			shape,
			size
		}, /* @__PURE__ */ import_react.createElement("div", {
			className: cls,
			style: style$1
		}, childrenShow));
	}
	return /* @__PURE__ */ import_react.createElement(AvatarContextProvider, {
		shape,
		size
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: cls,
		style: style$1
	}, childrenWithProps));
};
var AvatarGroup_default = AvatarGroup;

//#endregion
//#region node_modules/antd/es/avatar/index.js
var Avatar = Avatar_default;
Avatar.Group = AvatarGroup_default;
var avatar_default = Avatar;

//#endregion
//#region node_modules/antd/es/back-top/style/index.js
var genSharedBackTopStyle = (token$1) => {
	const { componentCls, backTopFontSize, backTopSize, zIndexPopup } = token$1;
	return { [componentCls]: {
		...resetComponent(token$1),
		position: "fixed",
		insetInlineEnd: token$1.backTopInlineEnd,
		insetBlockEnd: token$1.backTopBlockEnd,
		zIndex: zIndexPopup,
		width: 40,
		height: 40,
		cursor: "pointer",
		"&:empty": { display: "none" },
		[`${componentCls}-content`]: {
			width: backTopSize,
			height: backTopSize,
			overflow: "hidden",
			color: token$1.backTopColor,
			textAlign: "center",
			backgroundColor: token$1.backTopBackground,
			borderRadius: backTopSize,
			transition: `all ${token$1.motionDurationMid}`,
			"&:hover": {
				backgroundColor: token$1.backTopHoverBackground,
				transition: `all ${token$1.motionDurationMid}`
			}
		},
		[`${componentCls}-icon`]: {
			fontSize: backTopFontSize,
			lineHeight: unit(backTopSize)
		}
	} };
};
var genMediaBackTopStyle = (token$1) => {
	const { componentCls, screenMD, screenXS, backTopInlineEndMD, backTopInlineEndXS } = token$1;
	return {
		[`@media (max-width: ${unit(screenMD)})`]: { [componentCls]: { insetInlineEnd: backTopInlineEndMD } },
		[`@media (max-width: ${unit(screenXS)})`]: { [componentCls]: { insetInlineEnd: backTopInlineEndXS } }
	};
};
const prepareComponentToken$43 = (token$1) => ({ zIndexPopup: token$1.zIndexBase + 10 });
var style_default$50 = genStyleHooks("BackTop", (token$1) => {
	const { fontSizeHeading3, colorTextDescription, colorTextLightSolid, colorText, controlHeightLG, calc } = token$1;
	const backTopToken = merge(token$1, {
		backTopBackground: colorTextDescription,
		backTopColor: colorTextLightSolid,
		backTopHoverBackground: colorText,
		backTopFontSize: fontSizeHeading3,
		backTopSize: controlHeightLG,
		backTopBlockEnd: calc(controlHeightLG).mul(1.25).equal(),
		backTopInlineEnd: calc(controlHeightLG).mul(2.5).equal(),
		backTopInlineEndMD: calc(controlHeightLG).mul(1.5).equal(),
		backTopInlineEndXS: calc(controlHeightLG).mul(.5).equal()
	});
	return [genSharedBackTopStyle(backTopToken), genMediaBackTopStyle(backTopToken)];
}, prepareComponentToken$43);

//#endregion
//#region node_modules/antd/es/back-top/index.js
var BackTop$1 = (props) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, visibilityHeight = 400, target, onClick, duration = 450, children } = props;
	const [visible, setVisible] = import_react.useState(visibilityHeight === 0);
	const ref = import_react.useRef(null);
	const getDefaultTarget$1 = () => ref.current?.ownerDocument || window;
	const handleScroll = throttleByAnimationFrame_default((e$2) => {
		setVisible(getScroll_default(e$2.target) >= visibilityHeight);
	});
	devUseWarning("BackTop").deprecated(false, "BackTop", "FloatButton.BackTop");
	import_react.useEffect(() => {
		const container = (target || getDefaultTarget$1)();
		handleScroll({ target: container });
		container?.addEventListener("scroll", handleScroll);
		return () => {
			handleScroll.cancel();
			container?.removeEventListener("scroll", handleScroll);
		};
	}, [target]);
	const scrollToTop = (e$2) => {
		scrollTo(0, {
			getContainer: target || getDefaultTarget$1,
			duration
		});
		onClick?.(e$2);
	};
	const { getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("back-top", customizePrefixCls);
	const rootPrefixCls = getPrefixCls();
	const [hashId, cssVarCls] = style_default$50(prefixCls, useCSSVarCls_default(prefixCls));
	const classString = clsx(hashId, cssVarCls, prefixCls, { [`${prefixCls}-rtl`]: direction === "rtl" }, className, rootClassName);
	const divProps = omit(props, [
		"prefixCls",
		"className",
		"rootClassName",
		"children",
		"visibilityHeight",
		"target"
	]);
	const defaultElement = /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-content` }, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-icon` }, /* @__PURE__ */ import_react.createElement(VerticalAlignTopOutlined_default, null)));
	return /* @__PURE__ */ import_react.createElement("div", {
		...divProps,
		className: classString,
		onClick: scrollToTop,
		ref
	}, /* @__PURE__ */ import_react.createElement(es_default$1, {
		visible,
		motionName: `${rootPrefixCls}-fade`
	}, ({ className: motionClassName }) => cloneElement(children || defaultElement, ({ className: cloneCls }) => ({ className: clsx(motionClassName, cloneCls) }))));
};
BackTop$1.displayName = "Deprecated.BackTop";
var back_top_default = BackTop$1;

//#endregion
//#region node_modules/antd/es/badge/SingleNumber.js
var UnitNumber = (props) => {
	const { prefixCls, value, current, offset: offset$2 = 0 } = props;
	let style$1;
	if (offset$2) style$1 = {
		position: "absolute",
		top: `${offset$2}00%`,
		left: 0
	};
	return /* @__PURE__ */ import_react.createElement("span", {
		style: style$1,
		className: clsx(`${prefixCls}-only-unit`, { current })
	}, value);
};
function getOffset$3(start, end, unit$2) {
	let index$1 = start;
	let offset$2 = 0;
	while ((index$1 + 10) % 10 !== end) {
		index$1 += unit$2;
		offset$2 += unit$2;
	}
	return offset$2;
}
var SingleNumber = (props) => {
	const { prefixCls, count: originCount, value: originValue } = props;
	const value = Number(originValue);
	const count = Math.abs(originCount);
	const [prevValue, setPrevValue] = import_react.useState(value);
	const [prevCount, setPrevCount] = import_react.useState(count);
	const onTransitionEnd = () => {
		setPrevValue(value);
		setPrevCount(count);
	};
	import_react.useEffect(() => {
		const timer = setTimeout(onTransitionEnd, 1e3);
		return () => clearTimeout(timer);
	}, [value]);
	let unitNodes;
	let offsetStyle;
	if (prevValue === value || Number.isNaN(value) || Number.isNaN(prevValue)) {
		unitNodes = [/* @__PURE__ */ import_react.createElement(UnitNumber, {
			...props,
			key: value,
			current: true
		})];
		offsetStyle = { transition: "none" };
	} else {
		unitNodes = [];
		const end = value + 10;
		const unitNumberList = [];
		for (let index$1 = value; index$1 <= end; index$1 += 1) unitNumberList.push(index$1);
		const unit$2 = prevCount < count ? 1 : -1;
		const prevIndex = unitNumberList.findIndex((n$1) => n$1 % 10 === prevValue);
		unitNodes = (unit$2 < 0 ? unitNumberList.slice(0, prevIndex + 1) : unitNumberList.slice(prevIndex)).map((n$1, index$1) => {
			const singleUnit = n$1 % 10;
			return /* @__PURE__ */ import_react.createElement(UnitNumber, {
				...props,
				key: n$1,
				value: singleUnit,
				offset: unit$2 < 0 ? index$1 - prevIndex : index$1,
				current: index$1 === prevIndex
			});
		});
		offsetStyle = { transform: `translateY(${-getOffset$3(prevValue, value, unit$2)}00%)` };
	}
	return /* @__PURE__ */ import_react.createElement("span", {
		className: `${prefixCls}-only`,
		style: offsetStyle,
		onTransitionEnd
	}, unitNodes);
};
var SingleNumber_default = SingleNumber;

//#endregion
//#region node_modules/antd/es/badge/ScrollNumber.js
var ScrollNumber = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, count, className, motionClassName, style: style$1, title, show, component: Component$2 = "sup", children, ...restProps } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("scroll-number", customizePrefixCls);
	const newProps = {
		...restProps,
		"data-show": show,
		style: style$1,
		className: clsx(prefixCls, className, motionClassName),
		title
	};
	let numberNodes = count;
	if (count && Number(count) % 1 === 0) {
		const numberList = String(count).split("");
		numberNodes = /* @__PURE__ */ import_react.createElement("bdi", null, numberList.map((num, i) => /* @__PURE__ */ import_react.createElement(SingleNumber_default, {
			prefixCls,
			count: Number(count),
			value: num,
			key: numberList.length - i
		})));
	}
	if (style$1?.borderColor) newProps.style = {
		...style$1,
		boxShadow: `0 0 0 1px ${style$1.borderColor} inset`
	};
	if (children) return cloneElement(children, (oriProps) => ({ className: clsx(`${prefixCls}-custom-component`, oriProps?.className, motionClassName) }));
	return /* @__PURE__ */ import_react.createElement(Component$2, {
		...newProps,
		ref
	}, numberNodes);
});
var ScrollNumber_default = ScrollNumber;

//#endregion
//#region node_modules/antd/es/badge/style/index.js
var antStatusProcessing = new Keyframes_default("antStatusProcessing", {
	"0%": {
		transform: "scale(0.8)",
		opacity: .5
	},
	"100%": {
		transform: "scale(2.4)",
		opacity: 0
	}
});
var antZoomBadgeIn = new Keyframes_default("antZoomBadgeIn", {
	"0%": {
		transform: "scale(0) translate(50%, -50%)",
		opacity: 0
	},
	"100%": { transform: "scale(1) translate(50%, -50%)" }
});
var antZoomBadgeOut = new Keyframes_default("antZoomBadgeOut", {
	"0%": { transform: "scale(1) translate(50%, -50%)" },
	"100%": {
		transform: "scale(0) translate(50%, -50%)",
		opacity: 0
	}
});
var antNoWrapperZoomBadgeIn = new Keyframes_default("antNoWrapperZoomBadgeIn", {
	"0%": {
		transform: "scale(0)",
		opacity: 0
	},
	"100%": { transform: "scale(1)" }
});
var antNoWrapperZoomBadgeOut = new Keyframes_default("antNoWrapperZoomBadgeOut", {
	"0%": { transform: "scale(1)" },
	"100%": {
		transform: "scale(0)",
		opacity: 0
	}
});
var antBadgeLoadingCircle = new Keyframes_default("antBadgeLoadingCircle", {
	"0%": { transformOrigin: "50%" },
	"100%": {
		transform: "translate(50%, -50%) rotate(360deg)",
		transformOrigin: "50%"
	}
});
var genSharedBadgeStyle = (token$1) => {
	const { componentCls, iconCls, antCls, badgeShadowSize, textFontSize, textFontSizeSM, statusSize, dotSize, textFontWeight, indicatorHeight, indicatorHeightSM, marginXS, calc } = token$1;
	const numberPrefixCls = `${antCls}-scroll-number`;
	const colorPreset = genPresetColor(token$1, (colorKey, { darkColor }) => ({ [`&${componentCls} ${componentCls}-color-${colorKey}`]: {
		background: darkColor,
		[`&:not(${componentCls}-count)`]: { color: darkColor },
		"a:hover &": { background: darkColor }
	} }));
	return { [componentCls]: {
		...resetComponent(token$1),
		position: "relative",
		display: "inline-block",
		width: "fit-content",
		lineHeight: 1,
		[`${componentCls}-count`]: {
			display: "inline-flex",
			justifyContent: "center",
			zIndex: token$1.indicatorZIndex,
			minWidth: indicatorHeight,
			height: indicatorHeight,
			color: token$1.badgeTextColor,
			fontWeight: textFontWeight,
			fontSize: textFontSize,
			lineHeight: unit(indicatorHeight),
			whiteSpace: "nowrap",
			textAlign: "center",
			background: token$1.badgeColor,
			borderRadius: calc(indicatorHeight).div(2).equal(),
			boxShadow: `0 0 0 ${unit(badgeShadowSize)} ${token$1.badgeShadowColor}`,
			transition: `background ${token$1.motionDurationMid}`,
			a: { color: token$1.badgeTextColor },
			"a:hover": { color: token$1.badgeTextColor },
			"a:hover &": { background: token$1.badgeColorHover }
		},
		[`${componentCls}-count-sm`]: {
			minWidth: indicatorHeightSM,
			height: indicatorHeightSM,
			fontSize: textFontSizeSM,
			lineHeight: unit(indicatorHeightSM),
			borderRadius: calc(indicatorHeightSM).div(2).equal()
		},
		[`${componentCls}-multiple-words`]: {
			padding: `0 ${unit(token$1.paddingXS)}`,
			bdi: { unicodeBidi: "plaintext" }
		},
		[`${componentCls}-dot`]: {
			zIndex: token$1.indicatorZIndex,
			width: dotSize,
			minWidth: dotSize,
			height: dotSize,
			background: token$1.badgeColor,
			borderRadius: "100%",
			boxShadow: `0 0 0 ${unit(badgeShadowSize)} ${token$1.badgeShadowColor}`
		},
		[`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
			position: "absolute",
			top: 0,
			insetInlineEnd: 0,
			transform: "translate(50%, -50%)",
			transformOrigin: "100% 0%",
			[`&${iconCls}-spin`]: {
				animationName: antBadgeLoadingCircle,
				animationDuration: "1s",
				animationIterationCount: "infinite",
				animationTimingFunction: "linear"
			}
		},
		[`&${componentCls}-status`]: {
			lineHeight: "inherit",
			verticalAlign: "baseline",
			[`${componentCls}-status-dot`]: {
				position: "relative",
				top: -1,
				display: "inline-block",
				width: statusSize,
				height: statusSize,
				verticalAlign: "middle",
				borderRadius: "50%"
			},
			[`${componentCls}-status-success`]: { backgroundColor: token$1.colorSuccess },
			[`${componentCls}-status-processing`]: {
				overflow: "visible",
				color: token$1.colorInfo,
				backgroundColor: token$1.colorInfo,
				borderColor: "currentcolor",
				"&::after": {
					position: "absolute",
					top: 0,
					insetInlineStart: 0,
					width: "100%",
					height: "100%",
					borderWidth: badgeShadowSize,
					borderStyle: "solid",
					borderColor: "inherit",
					borderRadius: "50%",
					animationName: antStatusProcessing,
					animationDuration: token$1.badgeProcessingDuration,
					animationIterationCount: "infinite",
					animationTimingFunction: "ease-in-out",
					content: "\"\""
				}
			},
			[`${componentCls}-status-default`]: { backgroundColor: token$1.colorTextPlaceholder },
			[`${componentCls}-status-error`]: { backgroundColor: token$1.colorError },
			[`${componentCls}-status-warning`]: { backgroundColor: token$1.colorWarning },
			[`${componentCls}-status-text`]: {
				marginInlineStart: marginXS,
				color: token$1.colorText,
				fontSize: token$1.fontSize
			}
		},
		...colorPreset,
		[`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
			animationName: antZoomBadgeIn,
			animationDuration: token$1.motionDurationSlow,
			animationTimingFunction: token$1.motionEaseOutBack,
			animationFillMode: "both"
		},
		[`${componentCls}-zoom-leave`]: {
			animationName: antZoomBadgeOut,
			animationDuration: token$1.motionDurationSlow,
			animationTimingFunction: token$1.motionEaseOutBack,
			animationFillMode: "both"
		},
		[`&${componentCls}-not-a-wrapper`]: {
			[`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
				animationName: antNoWrapperZoomBadgeIn,
				animationDuration: token$1.motionDurationSlow,
				animationTimingFunction: token$1.motionEaseOutBack
			},
			[`${componentCls}-zoom-leave`]: {
				animationName: antNoWrapperZoomBadgeOut,
				animationDuration: token$1.motionDurationSlow,
				animationTimingFunction: token$1.motionEaseOutBack
			},
			[`&:not(${componentCls}-status)`]: { verticalAlign: "middle" },
			[`${numberPrefixCls}-custom-component, ${componentCls}-count`]: { transform: "none" },
			[`${numberPrefixCls}-custom-component, ${numberPrefixCls}`]: {
				position: "relative",
				top: "auto",
				display: "block",
				transformOrigin: "50% 50%"
			}
		},
		[numberPrefixCls]: {
			overflow: "hidden",
			transition: `all ${token$1.motionDurationMid} ${token$1.motionEaseOutBack}`,
			[`${numberPrefixCls}-only`]: {
				position: "relative",
				display: "inline-block",
				height: indicatorHeight,
				transition: `all ${token$1.motionDurationSlow} ${token$1.motionEaseOutBack}`,
				WebkitTransformStyle: "preserve-3d",
				WebkitBackfaceVisibility: "hidden",
				[`> p${numberPrefixCls}-only-unit`]: {
					height: indicatorHeight,
					margin: 0,
					WebkitTransformStyle: "preserve-3d",
					WebkitBackfaceVisibility: "hidden"
				}
			},
			[`${numberPrefixCls}-symbol`]: { verticalAlign: "top" }
		},
		"&-rtl": {
			direction: "rtl",
			[`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: { transform: "translate(-50%, -50%)" }
		}
	} };
};
const prepareToken$3 = (token$1) => {
	const { fontHeight, lineWidth, marginXS, colorBorderBg } = token$1;
	const badgeFontHeight = fontHeight;
	const badgeShadowSize = lineWidth;
	const badgeTextColor = token$1.colorTextLightSolid;
	const badgeColor = token$1.colorError;
	const badgeColorHover = token$1.colorErrorHover;
	return merge(token$1, {
		badgeFontHeight,
		badgeShadowSize,
		badgeTextColor,
		badgeColor,
		badgeColorHover,
		badgeShadowColor: colorBorderBg,
		badgeProcessingDuration: "1.2s",
		badgeRibbonOffset: marginXS,
		badgeRibbonCornerTransform: "scaleY(0.75)",
		badgeRibbonCornerFilter: `brightness(75%)`
	});
};
const prepareComponentToken$42 = (token$1) => {
	const { fontSize, lineHeight, fontSizeSM, lineWidth } = token$1;
	return {
		indicatorZIndex: "auto",
		indicatorHeight: Math.round(fontSize * lineHeight) - 2 * lineWidth,
		indicatorHeightSM: fontSize,
		dotSize: fontSizeSM / 2,
		textFontSize: fontSizeSM,
		textFontSizeSM: fontSizeSM,
		textFontWeight: "normal",
		statusSize: fontSizeSM / 2
	};
};
var style_default$49 = genStyleHooks("Badge", (token$1) => {
	return genSharedBadgeStyle(prepareToken$3(token$1));
}, prepareComponentToken$42);

//#endregion
//#region node_modules/antd/es/badge/Badge.js
var Badge$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, scrollNumberPrefixCls: customizeScrollNumberPrefixCls, children, status, text, color, count = null, overflowCount = 99, dot = false, size = "default", title, offset: offset$2, style: style$1, className, rootClassName, classNames, styles, showZero = false, ...restProps } = props;
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("badge");
	const prefixCls = getPrefixCls("badge", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$49(prefixCls);
	const mergedProps = {
		...props,
		overflowCount,
		size,
		dot,
		showZero
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const numberedDisplayCount = count > overflowCount ? `${overflowCount}+` : count;
	const isZero = numberedDisplayCount === "0" || numberedDisplayCount === 0 || text === "0" || text === 0;
	const ignoreCount = count === null || isZero && !showZero;
	const hasStatus = (isNonNullable_default(status) || isNonNullable_default(color)) && ignoreCount;
	const hasStatusValue = isNonNullable_default(status) || !isZero;
	const showAsDot = dot && !isZero;
	const mergedCount = showAsDot ? "" : numberedDisplayCount;
	const isHidden = (0, import_react.useMemo)(() => {
		return ((!isNonNullable_default(mergedCount) || mergedCount === "") && (!isNonNullable_default(text) || text === "") || isZero && !showZero) && !showAsDot;
	}, [
		mergedCount,
		isZero,
		showZero,
		showAsDot,
		text
	]);
	const countRef = (0, import_react.useRef)(count);
	if (!isHidden) countRef.current = count;
	const livingCount = countRef.current;
	const displayCountRef = (0, import_react.useRef)(mergedCount);
	if (!isHidden) displayCountRef.current = mergedCount;
	const displayCount = displayCountRef.current;
	const isDotRef = (0, import_react.useRef)(showAsDot);
	if (!isHidden) isDotRef.current = showAsDot;
	const mergedStyle = (0, import_react.useMemo)(() => {
		if (!offset$2) return {
			...contextStyle,
			...style$1
		};
		const horizontalOffset = Number.parseInt(offset$2[0], 10);
		return {
			marginTop: offset$2[1],
			insetInlineEnd: -horizontalOffset,
			...contextStyle,
			...style$1
		};
	}, [
		offset$2,
		style$1,
		contextStyle
	]);
	const titleNode = title ?? (typeof livingCount === "string" || typeof livingCount === "number" ? livingCount : void 0);
	const showStatusTextNode = !isHidden && (text === 0 ? showZero : !!text && text !== true);
	const statusTextNode = !showStatusTextNode ? null : /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-status-text` }, text);
	const displayNode = !livingCount || typeof livingCount !== "object" ? void 0 : cloneElement(livingCount, (oriProps) => ({ style: {
		...mergedStyle,
		...oriProps.style
	} }));
	const isInternalColor = isPresetColor(color, false);
	const statusCls = clsx(mergedClassNames.indicator, {
		[`${prefixCls}-status-dot`]: hasStatus,
		[`${prefixCls}-status-${status}`]: !!status,
		[`${prefixCls}-color-${color}`]: isInternalColor
	});
	const statusStyle = {};
	if (color && !isInternalColor) {
		statusStyle.color = color;
		statusStyle.background = color;
	}
	const badgeClassName = clsx(prefixCls, {
		[`${prefixCls}-status`]: hasStatus,
		[`${prefixCls}-not-a-wrapper`]: !children,
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, className, rootClassName, contextClassName, mergedClassNames.root, hashId, cssVarCls);
	if (!children && hasStatus && (text || hasStatusValue || !ignoreCount)) {
		const statusTextColor = mergedStyle.color;
		return /* @__PURE__ */ import_react.createElement("span", {
			...restProps,
			className: badgeClassName,
			style: {
				...mergedStyles.root,
				...mergedStyle
			}
		}, /* @__PURE__ */ import_react.createElement("span", {
			className: statusCls,
			style: {
				...mergedStyles.indicator,
				...statusStyle
			}
		}), showStatusTextNode && /* @__PURE__ */ import_react.createElement("span", {
			style: { color: statusTextColor },
			className: `${prefixCls}-status-text`
		}, text));
	}
	return /* @__PURE__ */ import_react.createElement("span", {
		ref,
		...restProps,
		className: badgeClassName,
		style: mergedStyles.root
	}, children, /* @__PURE__ */ import_react.createElement(es_default$1, {
		visible: !isHidden,
		motionName: `${prefixCls}-zoom`,
		motionAppear: false,
		motionDeadline: 1e3
	}, ({ className: motionClassName }) => {
		const scrollNumberPrefixCls = getPrefixCls("scroll-number", customizeScrollNumberPrefixCls);
		const isDot = isDotRef.current;
		const scrollNumberCls = clsx(mergedClassNames.indicator, {
			[`${prefixCls}-dot`]: isDot,
			[`${prefixCls}-count`]: !isDot,
			[`${prefixCls}-count-sm`]: size === "small",
			[`${prefixCls}-multiple-words`]: !isDot && displayCount && displayCount.toString().length > 1,
			[`${prefixCls}-status-${status}`]: !!status,
			[`${prefixCls}-color-${color}`]: isInternalColor
		});
		let scrollNumberStyle = {
			...mergedStyles.indicator,
			...mergedStyle
		};
		if (color && !isInternalColor) {
			scrollNumberStyle = scrollNumberStyle || {};
			scrollNumberStyle.background = color;
		}
		return /* @__PURE__ */ import_react.createElement(ScrollNumber_default, {
			prefixCls: scrollNumberPrefixCls,
			show: !isHidden,
			motionClassName,
			className: scrollNumberCls,
			count: displayCount,
			title: titleNode,
			style: scrollNumberStyle,
			key: "scrollNumber"
		}, displayNode);
	}), statusTextNode);
});
Badge$1.displayName = "Badge";
var Badge_default = Badge$1;

//#endregion
//#region node_modules/antd/es/badge/style/ribbon.js
var genRibbonStyle = (token$1) => {
	const { antCls, badgeFontHeight, marginXS, badgeRibbonOffset, calc } = token$1;
	const ribbonPrefixCls = `${antCls}-ribbon`;
	const ribbonWrapperPrefixCls = `${antCls}-ribbon-wrapper`;
	const statusRibbonPreset = genPresetColor(token$1, (colorKey, { darkColor }) => ({ [`&${ribbonPrefixCls}-color-${colorKey}`]: {
		background: darkColor,
		color: darkColor
	} }));
	return {
		[ribbonWrapperPrefixCls]: { position: "relative" },
		[ribbonPrefixCls]: {
			...resetComponent(token$1),
			position: "absolute",
			top: marginXS,
			padding: `0 ${unit(token$1.paddingXS)}`,
			color: token$1.colorPrimary,
			lineHeight: unit(badgeFontHeight),
			whiteSpace: "nowrap",
			backgroundColor: token$1.colorPrimary,
			borderRadius: token$1.borderRadiusSM,
			[`${ribbonPrefixCls}-content`]: { color: token$1.badgeTextColor },
			[`${ribbonPrefixCls}-corner`]: {
				position: "absolute",
				top: "100%",
				width: badgeRibbonOffset,
				height: badgeRibbonOffset,
				color: "currentcolor",
				border: `${unit(calc(badgeRibbonOffset).div(2).equal())} solid`,
				transform: token$1.badgeRibbonCornerTransform,
				transformOrigin: "top",
				filter: token$1.badgeRibbonCornerFilter
			},
			...statusRibbonPreset,
			[`&${ribbonPrefixCls}-placement-end`]: {
				insetInlineEnd: calc(badgeRibbonOffset).mul(-1).equal(),
				borderEndEndRadius: 0,
				[`${ribbonPrefixCls}-corner`]: {
					insetInlineEnd: 0,
					borderInlineEndColor: "transparent",
					borderBlockEndColor: "transparent"
				}
			},
			[`&${ribbonPrefixCls}-placement-start`]: {
				insetInlineStart: calc(badgeRibbonOffset).mul(-1).equal(),
				borderEndStartRadius: 0,
				[`${ribbonPrefixCls}-corner`]: {
					insetInlineStart: 0,
					borderBlockEndColor: "transparent",
					borderInlineStartColor: "transparent"
				}
			},
			"&-rtl": { direction: "rtl" }
		}
	};
};
var ribbon_default = genStyleHooks(["Badge", "Ribbon"], (token$1) => {
	return genRibbonStyle(prepareToken$3(token$1));
}, prepareComponentToken$42);

//#endregion
//#region node_modules/antd/es/badge/Ribbon.js
var Ribbon = (props) => {
	const { className, prefixCls: customizePrefixCls, style: style$1, color, children, text, placement = "end", rootClassName, styles, classNames: ribbonClassNames } = props;
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("ribbon");
	const prefixCls = getPrefixCls("ribbon", customizePrefixCls);
	const wrapperCls = `${prefixCls}-wrapper`;
	const [hashId, cssVarCls] = ribbon_default(prefixCls, wrapperCls);
	const mergedProps = {
		...props,
		placement
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, ribbonClassNames], [contextStyles, styles], { props: mergedProps });
	const colorInPreset = isPresetColor(color, false);
	const ribbonCls = clsx(prefixCls, `${prefixCls}-placement-${placement}`, {
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-color-${color}`]: colorInPreset
	}, className, contextClassName, mergedClassNames.indicator);
	const colorStyle = {};
	const cornerColorStyle = {};
	if (color && !colorInPreset) {
		colorStyle.background = color;
		cornerColorStyle.color = color;
	}
	return /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(wrapperCls, rootClassName, hashId, cssVarCls, mergedClassNames.root),
		style: mergedStyles.root
	}, children, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(ribbonCls, hashId),
		style: {
			...colorStyle,
			...mergedStyles.indicator,
			...contextStyle,
			...style$1
		}
	}, /* @__PURE__ */ import_react.createElement("span", {
		className: clsx(`${prefixCls}-content`, mergedClassNames.content),
		style: mergedStyles.content
	}, text), /* @__PURE__ */ import_react.createElement("div", {
		className: `${prefixCls}-corner`,
		style: cornerColorStyle
	})));
};
Ribbon.displayName = "Ribbon";
var Ribbon_default = Ribbon;

//#endregion
//#region node_modules/antd/es/badge/index.js
var Badge = Badge_default;
Badge.Ribbon = Ribbon_default;
var badge_default = Badge;

//#endregion
//#region node_modules/antd/es/breadcrumb/BreadcrumbContext.js
var BreadcrumbContext = /* @__PURE__ */ import_react.createContext({});
var BreadcrumbContext_default = BreadcrumbContext;

//#endregion
//#region node_modules/@rc-component/dropdown/es/hooks/useAccessibility.js
var { ESC: ESC$1, TAB } = KeyCode_default;
function useAccessibility$1({ visible, triggerRef, onVisibleChange, autoFocus, overlayRef }) {
	const focusMenuRef = import_react.useRef(false);
	const handleCloseMenuAndReturnFocus = () => {
		if (visible) {
			triggerRef.current?.focus?.();
			onVisibleChange?.(false);
		}
	};
	const focusMenu = () => {
		if (overlayRef.current?.focus) {
			overlayRef.current.focus();
			focusMenuRef.current = true;
			return true;
		}
		return false;
	};
	const handleKeyDown = (event) => {
		switch (event.keyCode) {
			case ESC$1:
				handleCloseMenuAndReturnFocus();
				break;
			case TAB: {
				let focusResult = false;
				if (!focusMenuRef.current) focusResult = focusMenu();
				if (focusResult) event.preventDefault();
				else handleCloseMenuAndReturnFocus();
				break;
			}
		}
	};
	import_react.useEffect(() => {
		if (visible) {
			window.addEventListener("keydown", handleKeyDown);
			if (autoFocus) raf_default(focusMenu, 3);
			return () => {
				window.removeEventListener("keydown", handleKeyDown);
				focusMenuRef.current = false;
			};
		}
		return () => {
			focusMenuRef.current = false;
		};
	}, [visible]);
}

//#endregion
//#region node_modules/@rc-component/dropdown/es/Overlay.js
var Overlay$1 = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	const { overlay, arrow, prefixCls } = props;
	const overlayNode = (0, import_react.useMemo)(() => {
		let overlayElement;
		if (typeof overlay === "function") overlayElement = overlay();
		else overlayElement = overlay;
		return overlayElement;
	}, [overlay]);
	const composedRef = composeRef(ref, getNodeRef(overlayNode));
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, arrow && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-arrow` }), /* @__PURE__ */ import_react.cloneElement(overlayNode, { ref: supportRef(overlayNode) ? composedRef : void 0 }));
});
var Overlay_default = Overlay$1;

//#endregion
//#region node_modules/@rc-component/dropdown/es/placements.js
var autoAdjustOverflow$1 = {
	adjustX: 1,
	adjustY: 1
};
var targetOffset$1 = [0, 0];
var placements$2 = {
	topLeft: {
		points: ["bl", "tl"],
		overflow: autoAdjustOverflow$1,
		offset: [0, -4],
		targetOffset: targetOffset$1
	},
	top: {
		points: ["bc", "tc"],
		overflow: autoAdjustOverflow$1,
		offset: [0, -4],
		targetOffset: targetOffset$1
	},
	topRight: {
		points: ["br", "tr"],
		overflow: autoAdjustOverflow$1,
		offset: [0, -4],
		targetOffset: targetOffset$1
	},
	bottomLeft: {
		points: ["tl", "bl"],
		overflow: autoAdjustOverflow$1,
		offset: [0, 4],
		targetOffset: targetOffset$1
	},
	bottom: {
		points: ["tc", "bc"],
		overflow: autoAdjustOverflow$1,
		offset: [0, 4],
		targetOffset: targetOffset$1
	},
	bottomRight: {
		points: ["tr", "br"],
		overflow: autoAdjustOverflow$1,
		offset: [0, 4],
		targetOffset: targetOffset$1
	}
};
var placements_default = placements$2;

//#endregion
//#region node_modules/@rc-component/dropdown/es/Dropdown.js
function _extends$76() {
	_extends$76 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$76.apply(this, arguments);
}
var Dropdown$2 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { arrow = false, prefixCls = "rc-dropdown", transitionName, animation, align, placement = "bottomLeft", placements: placements$4 = placements_default, getPopupContainer, showAction, hideAction, overlayClassName, overlayStyle, visible, trigger = ["hover"], autoFocus, overlay, children, onVisibleChange, ...otherProps } = props;
	const [triggerVisible, setTriggerVisible] = import_react.useState();
	const mergedVisible = "visible" in props ? visible : triggerVisible;
	const mergedMotionName = animation ? `${prefixCls}-${animation}` : transitionName;
	const triggerRef = import_react.useRef(null);
	const overlayRef = import_react.useRef(null);
	const childRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => triggerRef.current);
	const handleVisibleChange = (newVisible) => {
		setTriggerVisible(newVisible);
		onVisibleChange?.(newVisible);
	};
	useAccessibility$1({
		visible: mergedVisible,
		triggerRef: childRef,
		onVisibleChange: handleVisibleChange,
		autoFocus,
		overlayRef
	});
	const onClick = (e$2) => {
		const { onOverlayClick } = props;
		setTriggerVisible(false);
		if (onOverlayClick) onOverlayClick(e$2);
	};
	const getMenuElement = () => /* @__PURE__ */ import_react.createElement(Overlay_default, {
		ref: overlayRef,
		overlay,
		prefixCls,
		arrow
	});
	const getMenuElementOrLambda = () => {
		if (typeof overlay === "function") return getMenuElement;
		return getMenuElement();
	};
	const getMinOverlayWidthMatchTrigger = () => {
		const { minOverlayWidthMatchTrigger, alignPoint } = props;
		if ("minOverlayWidthMatchTrigger" in props) return minOverlayWidthMatchTrigger;
		return !alignPoint;
	};
	const getOpenClassName = () => {
		const { openClassName } = props;
		if (openClassName !== void 0) return openClassName;
		return `${prefixCls}-open`;
	};
	const childrenNode = /* @__PURE__ */ import_react.cloneElement(children, {
		className: clsx(children.props?.className, mergedVisible && getOpenClassName()),
		ref: supportRef(children) ? composeRef(childRef, getNodeRef(children)) : void 0
	});
	let triggerHideAction = hideAction;
	if (!triggerHideAction && trigger.indexOf("contextMenu") !== -1) triggerHideAction = ["click"];
	return /* @__PURE__ */ import_react.createElement(es_default$6, _extends$76({ builtinPlacements: placements$4 }, otherProps, {
		prefixCls,
		ref: triggerRef,
		popupClassName: clsx(overlayClassName, { [`${prefixCls}-show-arrow`]: arrow }),
		popupStyle: overlayStyle,
		action: trigger,
		showAction,
		hideAction: triggerHideAction,
		popupPlacement: placement,
		popupAlign: align,
		popupMotion: { motionName: mergedMotionName },
		popupVisible: mergedVisible,
		stretch: getMinOverlayWidthMatchTrigger() ? "minWidth" : "",
		popup: getMenuElementOrLambda(),
		onOpenChange: handleVisibleChange,
		onPopupClick: onClick,
		getPopupContainer
	}), childrenNode);
});
var Dropdown_default = Dropdown$2;

//#endregion
//#region node_modules/@rc-component/dropdown/es/index.js
var es_default$29 = Dropdown_default;

//#endregion
//#region node_modules/antd/es/_util/isPrimitive.js
var isPrimitive = (value) => typeof value !== "object" && typeof value !== "function" || value === null;
var isPrimitive_default = isPrimitive;

//#endregion
//#region node_modules/@rc-component/menu/es/context/IdContext.js
const IdContext = /* @__PURE__ */ import_react.createContext(null);
function getMenuId(uuid$5, eventKey) {
	return `${uuid$5}-${eventKey}`;
}
/**
* Get `data-menu-id`
*/
function useMenuId(eventKey) {
	return getMenuId(import_react.useContext(IdContext), eventKey);
}

//#endregion
//#region node_modules/@rc-component/menu/es/context/MenuContext.js
const MenuContext$1 = /* @__PURE__ */ import_react.createContext(null);
function mergeProps(origin, target) {
	const clone = { ...origin };
	Object.keys(target).forEach((key) => {
		const value = target[key];
		if (value !== void 0) clone[key] = value;
	});
	return clone;
}
function InheritableContextProvider({ children, locked, ...restProps }) {
	const context = import_react.useContext(MenuContext$1);
	const inheritableContext = useMemo$1(() => mergeProps(context, restProps), [context, restProps], (prev$1, next$1) => !locked && (prev$1[0] !== next$1[0] || !isEqual_default(prev$1[1], next$1[1], true)));
	return /* @__PURE__ */ import_react.createElement(MenuContext$1.Provider, { value: inheritableContext }, children);
}

//#endregion
//#region node_modules/@rc-component/menu/es/context/PathContext.js
var EmptyList = [];
const PathRegisterContext = /* @__PURE__ */ import_react.createContext(null);
function useMeasure() {
	return import_react.useContext(PathRegisterContext);
}
const PathTrackerContext = /* @__PURE__ */ import_react.createContext(EmptyList);
function useFullPath(eventKey) {
	const parentKeyPath = import_react.useContext(PathTrackerContext);
	return import_react.useMemo(() => eventKey !== void 0 ? [...parentKeyPath, eventKey] : parentKeyPath, [parentKeyPath, eventKey]);
}
const PathUserContext = /* @__PURE__ */ import_react.createContext(null);

//#endregion
//#region node_modules/@rc-component/menu/es/context/PrivateContext.js
var PrivateContext = /* @__PURE__ */ import_react.createContext({});
var PrivateContext_default = PrivateContext;

//#endregion
//#region node_modules/@rc-component/util/es/Dom/focus.js
function focusable(node$1, includePositive = false) {
	if (isVisible_default(node$1)) {
		const nodeName = node$1.nodeName.toLowerCase();
		const isFocusableElement = [
			"input",
			"select",
			"textarea",
			"button"
		].includes(nodeName) || node$1.isContentEditable || nodeName === "a" && !!node$1.getAttribute("href");
		const tabIndexAttr = node$1.getAttribute("tabindex");
		const tabIndexNum = Number(tabIndexAttr);
		let tabIndex = null;
		if (tabIndexAttr && !Number.isNaN(tabIndexNum)) tabIndex = tabIndexNum;
		else if (isFocusableElement && tabIndex === null) tabIndex = 0;
		if (isFocusableElement && node$1.disabled) tabIndex = null;
		return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);
	}
	return false;
}
function getFocusNodeList(node$1, includePositive = false) {
	const res = [...node$1.querySelectorAll("*")].filter((child) => {
		return focusable(child, includePositive);
	});
	if (focusable(node$1, includePositive)) res.unshift(node$1);
	return res;
}
/**
* Focus element and set cursor position for input/textarea elements.
*/
function triggerFocus(element, option) {
	if (!element) return;
	element.focus(option);
	const { cursor } = option || {};
	if (cursor && (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement)) {
		const len = element.value.length;
		switch (cursor) {
			case "start":
				element.setSelectionRange(0, 0);
				break;
			case "end":
				element.setSelectionRange(len, len);
				break;
			default: element.setSelectionRange(0, len);
		}
	}
}

//#endregion
//#region node_modules/@rc-component/menu/es/hooks/useAccessibility.js
var { LEFT, RIGHT, UP, DOWN, ENTER, ESC, HOME, END } = KeyCode_default;
var ArrowKeys = [
	UP,
	DOWN,
	LEFT,
	RIGHT
];
function getOffset$2(mode, isRootLevel, isRtl, which) {
	const prev$1 = "prev";
	const next$1 = "next";
	const children = "children";
	const parent = "parent";
	if (mode === "inline" && which === ENTER) return { inlineTrigger: true };
	const inline$1 = {
		[UP]: prev$1,
		[DOWN]: next$1
	};
	const horizontal = {
		[LEFT]: isRtl ? next$1 : prev$1,
		[RIGHT]: isRtl ? prev$1 : next$1,
		[DOWN]: children,
		[ENTER]: children
	};
	const vertical = {
		[UP]: prev$1,
		[DOWN]: next$1,
		[ENTER]: children,
		[ESC]: parent,
		[LEFT]: isRtl ? children : parent,
		[RIGHT]: isRtl ? parent : children
	};
	switch ({
		inline: inline$1,
		horizontal,
		vertical,
		inlineSub: inline$1,
		horizontalSub: vertical,
		verticalSub: vertical
	}[`${mode}${isRootLevel ? "" : "Sub"}`]?.[which]) {
		case prev$1: return {
			offset: -1,
			sibling: true
		};
		case next$1: return {
			offset: 1,
			sibling: true
		};
		case parent: return {
			offset: -1,
			sibling: false
		};
		case children: return {
			offset: 1,
			sibling: false
		};
		default: return null;
	}
}
function findContainerUL(element) {
	let current = element;
	while (current) {
		if (current.getAttribute("data-menu-list")) return current;
		current = current.parentElement;
	}
	/* istanbul ignore next */
	return null;
}
/**
* Find focused element within element set provided
*/
function getFocusElement(activeElement, elements) {
	let current = activeElement || document.activeElement;
	while (current) {
		if (elements.has(current)) return current;
		current = current.parentElement;
	}
	return null;
}
/**
* Get focusable elements from the element set under provided container
*/
function getFocusableElements(container, elements) {
	return getFocusNodeList(container, true).filter((ele) => elements.has(ele));
}
function getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offset$2 = 1) {
	if (!parentQueryContainer) return null;
	const sameLevelFocusableMenuElementList = getFocusableElements(parentQueryContainer, elements);
	const count = sameLevelFocusableMenuElementList.length;
	let focusIndex = sameLevelFocusableMenuElementList.findIndex((ele) => focusMenuElement === ele);
	if (offset$2 < 0) if (focusIndex === -1) focusIndex = count - 1;
	else focusIndex -= 1;
	else if (offset$2 > 0) focusIndex += 1;
	focusIndex = (focusIndex + count) % count;
	return sameLevelFocusableMenuElementList[focusIndex];
}
const refreshElements = (keys$1, id) => {
	const elements = /* @__PURE__ */ new Set();
	const key2element = /* @__PURE__ */ new Map();
	const element2key = /* @__PURE__ */ new Map();
	keys$1.forEach((key) => {
		const element = document.querySelector(`[data-menu-id='${getMenuId(id, key)}']`);
		if (element) {
			elements.add(element);
			element2key.set(element, key);
			key2element.set(key, element);
		}
	});
	return {
		elements,
		key2element,
		element2key
	};
};
function useAccessibility(mode, activeKey, isRtl, id, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {
	const rafRef = import_react.useRef();
	const activeRef = import_react.useRef();
	activeRef.current = activeKey;
	const cleanRaf = () => {
		raf_default.cancel(rafRef.current);
	};
	import_react.useEffect(() => () => {
		cleanRaf();
	}, []);
	return (e$2) => {
		const { which } = e$2;
		if ([
			...ArrowKeys,
			ENTER,
			ESC,
			HOME,
			END
		].includes(which)) {
			const keys$1 = getKeys();
			let refreshedElements = refreshElements(keys$1, id);
			const { elements, key2element, element2key } = refreshedElements;
			const focusMenuElement = getFocusElement(key2element.get(activeKey), elements);
			const focusMenuKey = element2key.get(focusMenuElement);
			const offsetObj = getOffset$2(mode, getKeyPath(focusMenuKey, true).length === 1, isRtl, which);
			if (!offsetObj && which !== HOME && which !== END) return;
			if (ArrowKeys.includes(which) || [HOME, END].includes(which)) e$2.preventDefault();
			const tryFocus = (menuElement) => {
				if (menuElement) {
					let focusTargetElement = menuElement;
					const link = menuElement.querySelector("a");
					if (link?.getAttribute("href")) focusTargetElement = link;
					const targetKey = element2key.get(menuElement);
					triggerActiveKey(targetKey);
					/**
					* Do not `useEffect` here since `tryFocus` may trigger async
					* which makes React sync update the `activeKey`
					* that force render before `useRef` set the next activeKey
					*/
					cleanRaf();
					rafRef.current = raf_default(() => {
						if (activeRef.current === targetKey) focusTargetElement.focus();
					});
				}
			};
			if ([HOME, END].includes(which) || offsetObj.sibling || !focusMenuElement) {
				let parentQueryContainer;
				if (!focusMenuElement || mode === "inline") parentQueryContainer = containerRef.current;
				else parentQueryContainer = findContainerUL(focusMenuElement);
				let targetElement;
				const focusableElements = getFocusableElements(parentQueryContainer, elements);
				if (which === HOME) targetElement = focusableElements[0];
				else if (which === END) targetElement = focusableElements[focusableElements.length - 1];
				else targetElement = getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offsetObj.offset);
				tryFocus(targetElement);
			} else if (offsetObj.inlineTrigger) triggerAccessibilityOpen(focusMenuKey);
			else if (offsetObj.offset > 0) {
				triggerAccessibilityOpen(focusMenuKey, true);
				cleanRaf();
				rafRef.current = raf_default(() => {
					refreshedElements = refreshElements(keys$1, id);
					const controlId = focusMenuElement.getAttribute("aria-controls");
					tryFocus(getNextFocusElement(document.getElementById(controlId), refreshedElements.elements));
				}, 5);
			} else if (offsetObj.offset < 0) {
				const keyPath = getKeyPath(focusMenuKey, true);
				const parentKey = keyPath[keyPath.length - 2];
				const parentMenuElement = key2element.get(parentKey);
				triggerAccessibilityOpen(parentKey, false);
				tryFocus(parentMenuElement);
			}
		}
		originOnKeyDown?.(e$2);
	};
}

//#endregion
//#region node_modules/@rc-component/menu/es/utils/timeUtil.js
function nextSlice(callback) {
	/* istanbul ignore next */
	Promise.resolve().then(callback);
}

//#endregion
//#region node_modules/@rc-component/menu/es/hooks/useKeyRecords.js
var PATH_SPLIT = "__RC_UTIL_PATH_SPLIT__";
var getPathStr = (keyPath) => keyPath.join(PATH_SPLIT);
var getPathKeys = (keyPathStr) => keyPathStr.split(PATH_SPLIT);
const OVERFLOW_KEY = "rc-menu-more";
function useKeyRecords() {
	const [, internalForceUpdate] = import_react.useState({});
	const key2pathRef = (0, import_react.useRef)(/* @__PURE__ */ new Map());
	const path2keyRef = (0, import_react.useRef)(/* @__PURE__ */ new Map());
	const [overflowKeys, setOverflowKeys] = import_react.useState([]);
	const updateRef = (0, import_react.useRef)(0);
	const destroyRef = (0, import_react.useRef)(false);
	const forceUpdate = () => {
		if (!destroyRef.current) internalForceUpdate({});
	};
	const registerPath = (0, import_react.useCallback)((key, keyPath) => {
		warning_default$1(!key2pathRef.current.has(key), `Duplicated key '${key}' used in Menu by path [${keyPath.join(" > ")}]`);
		const connectedPath = getPathStr(keyPath);
		path2keyRef.current.set(connectedPath, key);
		key2pathRef.current.set(key, connectedPath);
		updateRef.current += 1;
		const id = updateRef.current;
		nextSlice(() => {
			if (id === updateRef.current) forceUpdate();
		});
	}, []);
	const unregisterPath = (0, import_react.useCallback)((key, keyPath) => {
		const connectedPath = getPathStr(keyPath);
		path2keyRef.current.delete(connectedPath);
		key2pathRef.current.delete(key);
	}, []);
	const refreshOverflowKeys = (0, import_react.useCallback)((keys$1) => {
		setOverflowKeys(keys$1);
	}, []);
	const getKeyPath = (0, import_react.useCallback)((eventKey, includeOverflow) => {
		const keys$1 = getPathKeys(key2pathRef.current.get(eventKey) || "");
		if (includeOverflow && overflowKeys.includes(keys$1[0])) keys$1.unshift(OVERFLOW_KEY);
		return keys$1;
	}, [overflowKeys]);
	const isSubPathKey = (0, import_react.useCallback)((pathKeys, eventKey) => pathKeys.filter((item) => item !== void 0).some((pathKey$1) => {
		return getKeyPath(pathKey$1, true).includes(eventKey);
	}), [getKeyPath]);
	const getKeys = () => {
		const keys$1 = [...key2pathRef.current.keys()];
		if (overflowKeys.length) keys$1.push(OVERFLOW_KEY);
		return keys$1;
	};
	/**
	* Find current key related child path keys
	*/
	const getSubPathKeys = (0, import_react.useCallback)((key) => {
		const connectedPath = `${key2pathRef.current.get(key)}${PATH_SPLIT}`;
		const pathKeys = /* @__PURE__ */ new Set();
		[...path2keyRef.current.keys()].forEach((pathKey$1) => {
			if (pathKey$1.startsWith(connectedPath)) pathKeys.add(path2keyRef.current.get(pathKey$1));
		});
		return pathKeys;
	}, []);
	import_react.useEffect(() => () => {
		destroyRef.current = true;
	}, []);
	return {
		registerPath,
		unregisterPath,
		refreshOverflowKeys,
		isSubPathKey,
		getKeyPath,
		getKeys,
		getSubPathKeys
	};
}

//#endregion
//#region node_modules/@rc-component/menu/es/hooks/useMemoCallback.js
/**
* Cache callback function that always return same ref instead.
* This is used for context optimization.
*/
function useMemoCallback(func) {
	const funRef = import_react.useRef(func);
	funRef.current = func;
	const callback = import_react.useCallback((...args) => funRef.current?.(...args), []);
	return func ? callback : void 0;
}

//#endregion
//#region node_modules/@rc-component/menu/es/hooks/useActive.js
function useActive$1(eventKey, disabled, onMouseEnter, onMouseLeave) {
	const { activeKey, onActive, onInactive } = import_react.useContext(MenuContext$1);
	const ret = { active: activeKey === eventKey };
	if (!disabled) {
		ret.onMouseEnter = (domEvent) => {
			onMouseEnter?.({
				key: eventKey,
				domEvent
			});
			onActive(eventKey);
		};
		ret.onMouseLeave = (domEvent) => {
			onMouseLeave?.({
				key: eventKey,
				domEvent
			});
			onInactive(eventKey);
		};
	}
	return ret;
}

//#endregion
//#region node_modules/@rc-component/menu/es/hooks/useDirectionStyle.js
function useDirectionStyle(level) {
	const { mode, rtl, inlineIndent } = import_react.useContext(MenuContext$1);
	if (mode !== "inline") return null;
	const len = level;
	return rtl ? { paddingRight: len * inlineIndent } : { paddingLeft: len * inlineIndent };
}

//#endregion
//#region node_modules/@rc-component/menu/es/Icon.js
function Icon$2({ icon, props, children }) {
	let iconNode;
	if (icon === null || icon === false) return null;
	if (typeof icon === "function") iconNode = /* @__PURE__ */ import_react.createElement(icon, { ...props });
	else if (typeof icon !== "boolean") iconNode = icon;
	return iconNode || children || null;
}

//#endregion
//#region node_modules/@rc-component/menu/es/utils/warnUtil.js
/**
* `onClick` event return `info.item` which point to react node directly.
* We should warning this since it will not work on FC.
*/
function warnItemProp({ item, ...restInfo }) {
	Object.defineProperty(restInfo, "item", { get: () => {
		warning_default$1(false, "`info.item` is deprecated since we will move to function component that not provides React Node instance in future.");
		return item;
	} });
	return restInfo;
}

//#endregion
//#region node_modules/@rc-component/menu/es/MenuItem.js
function _extends$75() {
	_extends$75 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$75.apply(this, arguments);
}
var LegacyMenuItem = class extends import_react.Component {
	render() {
		const { title, attribute, elementRef, ...restProps } = this.props;
		const passedProps = omit(restProps, [
			"eventKey",
			"popupClassName",
			"popupOffset",
			"onTitleClick"
		]);
		warning_default$1(!attribute, "`attribute` of Menu.Item is deprecated. Please pass attribute directly.");
		return /* @__PURE__ */ import_react.createElement(es_default$30.Item, _extends$75({}, attribute, { title: typeof title === "string" ? title : void 0 }, passedProps, { ref: elementRef }));
	}
};
/**
* Real Menu Item component
*/
var InternalMenuItem = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { style: style$1, className, eventKey, warnKey, disabled, itemIcon, children, role, onMouseEnter, onMouseLeave, onClick, onKeyDown: onKeyDown$1, onFocus, ...restProps } = props;
	const domDataId = useMenuId(eventKey);
	const { prefixCls, onItemClick, disabled: contextDisabled, overflowDisabled, itemIcon: contextItemIcon, selectedKeys, onActive } = import_react.useContext(MenuContext$1);
	const { _internalRenderMenuItem } = import_react.useContext(PrivateContext_default);
	const itemCls = `${prefixCls}-item`;
	const legacyMenuItemRef = import_react.useRef();
	const elementRef = import_react.useRef();
	const mergedDisabled = contextDisabled || disabled;
	const mergedEleRef = useComposeRef(ref, elementRef);
	const connectedKeys = useFullPath(eventKey);
	if (warnKey) warning_default$1(false, "MenuItem should not leave undefined `key`.");
	const getEventInfo = (e$2) => {
		return {
			key: eventKey,
			keyPath: [...connectedKeys].reverse(),
			item: legacyMenuItemRef.current,
			domEvent: e$2
		};
	};
	const mergedItemIcon = itemIcon || contextItemIcon;
	const { active, ...activeProps } = useActive$1(eventKey, mergedDisabled, onMouseEnter, onMouseLeave);
	const selected = selectedKeys.includes(eventKey);
	const directionStyle = useDirectionStyle(connectedKeys.length);
	const onInternalClick = (e$2) => {
		if (mergedDisabled) return;
		const info = getEventInfo(e$2);
		onClick?.(warnItemProp(info));
		onItemClick(info);
	};
	const onInternalKeyDown = (e$2) => {
		onKeyDown$1?.(e$2);
		if (e$2.which === KeyCode_default.ENTER) {
			const info = getEventInfo(e$2);
			onClick?.(warnItemProp(info));
			onItemClick(info);
		}
	};
	/**
	* Used for accessibility. Helper will focus element without key board.
	* We should manually trigger an active
	*/
	const onInternalFocus = (e$2) => {
		onActive(eventKey);
		onFocus?.(e$2);
	};
	const optionRoleProps = {};
	if (props.role === "option") optionRoleProps["aria-selected"] = selected;
	let renderNode = /* @__PURE__ */ import_react.createElement(LegacyMenuItem, _extends$75({
		ref: legacyMenuItemRef,
		elementRef: mergedEleRef,
		role: role === null ? "none" : role || "menuitem",
		tabIndex: disabled ? null : -1,
		"data-menu-id": overflowDisabled && domDataId ? null : domDataId
	}, omit(restProps, ["extra"]), activeProps, optionRoleProps, {
		component: "li",
		"aria-disabled": disabled,
		style: {
			...directionStyle,
			...style$1
		},
		className: clsx(itemCls, {
			[`${itemCls}-active`]: active,
			[`${itemCls}-selected`]: selected,
			[`${itemCls}-disabled`]: mergedDisabled
		}, className),
		onClick: onInternalClick,
		onKeyDown: onInternalKeyDown,
		onFocus: onInternalFocus
	}), children, /* @__PURE__ */ import_react.createElement(Icon$2, {
		props: {
			...props,
			isSelected: selected
		},
		icon: mergedItemIcon
	}));
	if (_internalRenderMenuItem) renderNode = _internalRenderMenuItem(renderNode, props, { selected });
	return renderNode;
});
function MenuItem$1(props, ref) {
	const { eventKey } = props;
	const measure = useMeasure();
	const connectedKeyPath = useFullPath(eventKey);
	import_react.useEffect(() => {
		if (measure) {
			measure.registerPath(eventKey, connectedKeyPath);
			return () => {
				measure.unregisterPath(eventKey, connectedKeyPath);
			};
		}
	}, [connectedKeyPath]);
	if (measure) return null;
	return /* @__PURE__ */ import_react.createElement(InternalMenuItem, _extends$75({}, props, { ref }));
}
var MenuItem_default = /* @__PURE__ */ import_react.forwardRef(MenuItem$1);

//#endregion
//#region node_modules/@rc-component/menu/es/SubMenu/SubMenuList.js
function _extends$74() {
	_extends$74 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$74.apply(this, arguments);
}
var InternalSubMenuList = ({ className, children, ...restProps }, ref) => {
	const { prefixCls, mode, rtl } = import_react.useContext(MenuContext$1);
	return /* @__PURE__ */ import_react.createElement("ul", _extends$74({
		className: clsx(prefixCls, rtl && `${prefixCls}-rtl`, `${prefixCls}-sub`, `${prefixCls}-${mode === "inline" ? "inline" : "vertical"}`, className),
		role: "menu"
	}, restProps, {
		"data-menu-list": true,
		ref
	}), children);
};
var SubMenuList = /* @__PURE__ */ import_react.forwardRef(InternalSubMenuList);
SubMenuList.displayName = "SubMenuList";
var SubMenuList_default = SubMenuList;

//#endregion
//#region node_modules/@rc-component/menu/es/utils/commonUtil.js
function parseChildren(children, keyPath) {
	return toArray(children).map((child, index$1) => {
		if (/* @__PURE__ */ import_react.isValidElement(child)) {
			const { key } = child;
			let eventKey = child.props?.eventKey ?? key;
			const emptyKey = eventKey === null || eventKey === void 0;
			if (emptyKey) eventKey = `tmp_key-${[...keyPath, index$1].join("-")}`;
			const cloneProps = {
				key: eventKey,
				eventKey
			};
			if (emptyKey) cloneProps.warnKey = true;
			return /* @__PURE__ */ import_react.cloneElement(child, cloneProps);
		}
		return child;
	});
}

//#endregion
//#region node_modules/@rc-component/menu/es/placements.js
var autoAdjustOverflow = {
	adjustX: 1,
	adjustY: 1
};
const placements$1 = {
	topLeft: {
		points: ["bl", "tl"],
		overflow: autoAdjustOverflow
	},
	topRight: {
		points: ["br", "tr"],
		overflow: autoAdjustOverflow
	},
	bottomLeft: {
		points: ["tl", "bl"],
		overflow: autoAdjustOverflow
	},
	bottomRight: {
		points: ["tr", "br"],
		overflow: autoAdjustOverflow
	},
	leftTop: {
		points: ["tr", "tl"],
		overflow: autoAdjustOverflow
	},
	leftBottom: {
		points: ["br", "bl"],
		overflow: autoAdjustOverflow
	},
	rightTop: {
		points: ["tl", "tr"],
		overflow: autoAdjustOverflow
	},
	rightBottom: {
		points: ["bl", "br"],
		overflow: autoAdjustOverflow
	}
};
const placementsRtl = {
	topLeft: {
		points: ["bl", "tl"],
		overflow: autoAdjustOverflow
	},
	topRight: {
		points: ["br", "tr"],
		overflow: autoAdjustOverflow
	},
	bottomLeft: {
		points: ["tl", "bl"],
		overflow: autoAdjustOverflow
	},
	bottomRight: {
		points: ["tr", "br"],
		overflow: autoAdjustOverflow
	},
	rightTop: {
		points: ["tr", "tl"],
		overflow: autoAdjustOverflow
	},
	rightBottom: {
		points: ["br", "bl"],
		overflow: autoAdjustOverflow
	},
	leftTop: {
		points: ["tl", "tr"],
		overflow: autoAdjustOverflow
	},
	leftBottom: {
		points: ["bl", "br"],
		overflow: autoAdjustOverflow
	}
};

//#endregion
//#region node_modules/@rc-component/menu/es/utils/motionUtil.js
function getMotion(mode, motion$1, defaultMotions) {
	if (motion$1) return motion$1;
	if (defaultMotions) return defaultMotions[mode] || defaultMotions.other;
}

//#endregion
//#region node_modules/@rc-component/menu/es/SubMenu/PopupTrigger.js
var popupPlacementMap = {
	horizontal: "bottomLeft",
	vertical: "rightTop",
	"vertical-left": "rightTop",
	"vertical-right": "leftTop"
};
function PopupTrigger({ prefixCls, visible, children, popup, popupStyle, popupClassName, popupOffset, disabled, mode, onVisibleChange }) {
	const { getPopupContainer, rtl, subMenuOpenDelay, subMenuCloseDelay, builtinPlacements, triggerSubMenuAction, forceSubMenuRender, rootClassName, motion: motion$1, defaultMotions } = import_react.useContext(MenuContext$1);
	const [innerVisible, setInnerVisible] = import_react.useState(false);
	const placement = rtl ? {
		...placementsRtl,
		...builtinPlacements
	} : {
		...placements$1,
		...builtinPlacements
	};
	const popupPlacement = popupPlacementMap[mode];
	const targetMotion = getMotion(mode, motion$1, defaultMotions);
	const targetMotionRef = import_react.useRef(targetMotion);
	if (mode !== "inline")
 /**
	* PopupTrigger is only used for vertical and horizontal types.
	* When collapsed is unfolded, the inline animation will destroy the vertical animation.
	*/
	targetMotionRef.current = targetMotion;
	const mergedMotion = {
		...targetMotionRef.current,
		leavedClassName: `${prefixCls}-hidden`,
		removeOnLeave: false,
		motionAppear: true
	};
	const visibleRef = import_react.useRef();
	import_react.useEffect(() => {
		visibleRef.current = raf_default(() => {
			setInnerVisible(visible);
		});
		return () => {
			raf_default.cancel(visibleRef.current);
		};
	}, [visible]);
	return /* @__PURE__ */ import_react.createElement(es_default$6, {
		prefixCls,
		popupClassName: clsx(`${prefixCls}-popup`, { [`${prefixCls}-rtl`]: rtl }, popupClassName, rootClassName),
		stretch: mode === "horizontal" ? "minWidth" : null,
		getPopupContainer,
		builtinPlacements: placement,
		popupPlacement,
		popupVisible: innerVisible,
		popup,
		popupStyle,
		popupAlign: popupOffset && { offset: popupOffset },
		action: disabled ? [] : [triggerSubMenuAction],
		mouseEnterDelay: subMenuOpenDelay,
		mouseLeaveDelay: subMenuCloseDelay,
		onPopupVisibleChange: onVisibleChange,
		forceRender: forceSubMenuRender,
		popupMotion: mergedMotion,
		fresh: true
	}, children);
}

//#endregion
//#region node_modules/@rc-component/menu/es/SubMenu/InlineSubMenuList.js
function _extends$73() {
	_extends$73 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$73.apply(this, arguments);
}
function InlineSubMenuList({ id, open: open$2, keyPath, children }) {
	const fixedMode = "inline";
	const { prefixCls, forceSubMenuRender, motion: motion$1, defaultMotions, mode } = import_react.useContext(MenuContext$1);
	const sameModeRef = import_react.useRef(false);
	sameModeRef.current = mode === fixedMode;
	const [destroy$2, setDestroy] = import_react.useState(!sameModeRef.current);
	const mergedOpen = sameModeRef.current ? open$2 : false;
	import_react.useEffect(() => {
		if (sameModeRef.current) setDestroy(false);
	}, [mode]);
	const mergedMotion = { ...getMotion(fixedMode, motion$1, defaultMotions) };
	if (keyPath.length > 1) mergedMotion.motionAppear = false;
	const originOnVisibleChanged = mergedMotion.onVisibleChanged;
	mergedMotion.onVisibleChanged = (newVisible) => {
		if (!sameModeRef.current && !newVisible) setDestroy(true);
		return originOnVisibleChanged?.(newVisible);
	};
	if (destroy$2) return null;
	return /* @__PURE__ */ import_react.createElement(InheritableContextProvider, {
		mode: fixedMode,
		locked: !sameModeRef.current
	}, /* @__PURE__ */ import_react.createElement(es_default$1, _extends$73({ visible: mergedOpen }, mergedMotion, {
		forceRender: forceSubMenuRender,
		removeOnLeave: false,
		leavedClassName: `${prefixCls}-hidden`
	}), ({ className: motionClassName, style: motionStyle }) => {
		return /* @__PURE__ */ import_react.createElement(SubMenuList_default, {
			id,
			className: motionClassName,
			style: motionStyle
		}, children);
	}));
}

//#endregion
//#region node_modules/@rc-component/menu/es/SubMenu/index.js
function _extends$72() {
	_extends$72 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$72.apply(this, arguments);
}
var InternalSubMenu = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { style: style$1, className, styles, classNames: menuClassNames, title, eventKey, warnKey, disabled, internalPopupClose, children, itemIcon, expandIcon, popupClassName, popupOffset, popupStyle, onClick, onMouseEnter, onMouseLeave, onTitleClick, onTitleMouseEnter, onTitleMouseLeave, popupRender: propsPopupRender, ...restProps } = props;
	const domDataId = useMenuId(eventKey);
	const { prefixCls, mode, openKeys, disabled: contextDisabled, overflowDisabled, activeKey, selectedKeys, itemIcon: contextItemIcon, expandIcon: contextExpandIcon, onItemClick, onOpenChange, onActive, popupRender: contextPopupRender } = import_react.useContext(MenuContext$1);
	const { _internalRenderSubMenuItem } = import_react.useContext(PrivateContext_default);
	const { isSubPathKey } = import_react.useContext(PathUserContext);
	const connectedPath = useFullPath();
	const subMenuPrefixCls = `${prefixCls}-submenu`;
	const mergedDisabled = contextDisabled || disabled;
	const elementRef = import_react.useRef();
	const popupRef = import_react.useRef();
	if (warnKey) warning_default$1(false, "SubMenu should not leave undefined `key`.");
	const mergedItemIcon = itemIcon ?? contextItemIcon;
	const mergedExpandIcon = expandIcon ?? contextExpandIcon;
	const originOpen = openKeys.includes(eventKey);
	const open$2 = !overflowDisabled && originOpen;
	const childrenSelected = isSubPathKey(selectedKeys, eventKey);
	const { active, ...activeProps } = useActive$1(eventKey, mergedDisabled, onTitleMouseEnter, onTitleMouseLeave);
	const [childrenActive, setChildrenActive] = import_react.useState(false);
	const triggerChildrenActive = (newActive) => {
		if (!mergedDisabled) setChildrenActive(newActive);
	};
	const onInternalMouseEnter = (domEvent) => {
		triggerChildrenActive(true);
		onMouseEnter?.({
			key: eventKey,
			domEvent
		});
	};
	const onInternalMouseLeave = (domEvent) => {
		triggerChildrenActive(false);
		onMouseLeave?.({
			key: eventKey,
			domEvent
		});
	};
	const mergedActive = import_react.useMemo(() => {
		if (active) return active;
		if (mode !== "inline") return childrenActive || isSubPathKey([activeKey], eventKey);
		return false;
	}, [
		mode,
		active,
		activeKey,
		childrenActive,
		eventKey,
		isSubPathKey
	]);
	const directionStyle = useDirectionStyle(connectedPath.length);
	const onInternalTitleClick = (e$2) => {
		if (mergedDisabled) return;
		onTitleClick?.({
			key: eventKey,
			domEvent: e$2
		});
		if (mode === "inline") onOpenChange(eventKey, !originOpen);
	};
	const onMergedItemClick = useMemoCallback((info) => {
		onClick?.(warnItemProp(info));
		onItemClick(info);
	});
	const onPopupVisibleChange = (newVisible) => {
		if (mode !== "inline") onOpenChange(eventKey, newVisible);
	};
	/**
	* Used for accessibility. Helper will focus element without key board.
	* We should manually trigger an active
	*/
	const onInternalFocus = () => {
		onActive(eventKey);
	};
	const popupId = domDataId && `${domDataId}-popup`;
	const expandIconNode = import_react.useMemo(() => /* @__PURE__ */ import_react.createElement(Icon$2, {
		icon: mode !== "horizontal" ? mergedExpandIcon : void 0,
		props: {
			...props,
			isOpen: open$2,
			isSubMenu: true
		}
	}, /* @__PURE__ */ import_react.createElement("i", { className: `${subMenuPrefixCls}-arrow` })), [
		mode,
		mergedExpandIcon,
		props,
		open$2,
		subMenuPrefixCls
	]);
	let titleNode = /* @__PURE__ */ import_react.createElement("div", _extends$72({
		role: "menuitem",
		style: directionStyle,
		className: `${subMenuPrefixCls}-title`,
		tabIndex: mergedDisabled ? null : -1,
		ref: elementRef,
		title: typeof title === "string" ? title : null,
		"data-menu-id": overflowDisabled && domDataId ? null : domDataId,
		"aria-expanded": open$2,
		"aria-haspopup": true,
		"aria-controls": popupId,
		"aria-disabled": mergedDisabled,
		onClick: onInternalTitleClick,
		onFocus: onInternalFocus
	}, activeProps), title, expandIconNode);
	const triggerModeRef = import_react.useRef(mode);
	if (mode !== "inline" && connectedPath.length > 1) triggerModeRef.current = "vertical";
	else triggerModeRef.current = mode;
	const popupContentTriggerMode = triggerModeRef.current;
	const renderPopupContent = import_react.useMemo(() => {
		const originNode = /* @__PURE__ */ import_react.createElement(InheritableContextProvider, {
			classNames: menuClassNames,
			styles,
			mode: popupContentTriggerMode === "horizontal" ? "vertical" : popupContentTriggerMode
		}, /* @__PURE__ */ import_react.createElement(SubMenuList_default, {
			id: popupId,
			ref: popupRef
		}, children));
		const mergedPopupRender = propsPopupRender || contextPopupRender;
		if (mergedPopupRender) return mergedPopupRender(originNode, {
			item: props,
			keys: connectedPath
		});
		return originNode;
	}, [
		propsPopupRender,
		contextPopupRender,
		connectedPath,
		popupId,
		children,
		props,
		popupContentTriggerMode
	]);
	if (!overflowDisabled) {
		const triggerMode = triggerModeRef.current;
		titleNode = /* @__PURE__ */ import_react.createElement(PopupTrigger, {
			mode: triggerMode,
			prefixCls: subMenuPrefixCls,
			visible: !internalPopupClose && open$2 && mode !== "inline",
			popupClassName,
			popupOffset,
			popupStyle,
			popup: renderPopupContent,
			disabled: mergedDisabled,
			onVisibleChange: onPopupVisibleChange
		}, titleNode);
	}
	let listNode = /* @__PURE__ */ import_react.createElement(es_default$30.Item, _extends$72({
		ref,
		role: "none"
	}, restProps, {
		component: "li",
		style: style$1,
		className: clsx(subMenuPrefixCls, `${subMenuPrefixCls}-${mode}`, className, {
			[`${subMenuPrefixCls}-open`]: open$2,
			[`${subMenuPrefixCls}-active`]: mergedActive,
			[`${subMenuPrefixCls}-selected`]: childrenSelected,
			[`${subMenuPrefixCls}-disabled`]: mergedDisabled
		}),
		onMouseEnter: onInternalMouseEnter,
		onMouseLeave: onInternalMouseLeave
	}), titleNode, !overflowDisabled && /* @__PURE__ */ import_react.createElement(InlineSubMenuList, {
		id: popupId,
		open: open$2,
		keyPath: connectedPath
	}, children));
	if (_internalRenderSubMenuItem) listNode = _internalRenderSubMenuItem(listNode, props, {
		selected: childrenSelected,
		active: mergedActive,
		open: open$2,
		disabled: mergedDisabled
	});
	return /* @__PURE__ */ import_react.createElement(InheritableContextProvider, {
		classNames: menuClassNames,
		styles,
		onItemClick: onMergedItemClick,
		mode: mode === "horizontal" ? "vertical" : mode,
		itemIcon: mergedItemIcon,
		expandIcon: mergedExpandIcon
	}, listNode);
});
var SubMenu$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { eventKey, children } = props;
	const connectedKeyPath = useFullPath(eventKey);
	const childList = parseChildren(children, connectedKeyPath);
	const measure = useMeasure();
	import_react.useEffect(() => {
		if (measure) {
			measure.registerPath(eventKey, connectedKeyPath);
			return () => {
				measure.unregisterPath(eventKey, connectedKeyPath);
			};
		}
	}, [connectedKeyPath]);
	let renderNode;
	if (measure) renderNode = childList;
	else renderNode = /* @__PURE__ */ import_react.createElement(InternalSubMenu, _extends$72({ ref }, props), childList);
	return /* @__PURE__ */ import_react.createElement(PathTrackerContext.Provider, { value: connectedKeyPath }, renderNode);
});
SubMenu$1.displayName = "SubMenu";
var SubMenu_default$1 = SubMenu$1;

//#endregion
//#region node_modules/@rc-component/menu/es/Divider.js
function Divider$1({ className, style: style$1 }) {
	const { prefixCls } = import_react.useContext(MenuContext$1);
	if (useMeasure()) return null;
	return /* @__PURE__ */ import_react.createElement("li", {
		role: "separator",
		className: clsx(`${prefixCls}-item-divider`, className),
		style: style$1
	});
}

//#endregion
//#region node_modules/@rc-component/menu/es/MenuItemGroup.js
function _extends$71() {
	_extends$71 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$71.apply(this, arguments);
}
var InternalMenuItemGroup = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { className, title, eventKey, children, ...restProps } = props;
	const { prefixCls, classNames: menuClassNames, styles } = import_react.useContext(MenuContext$1);
	const groupPrefixCls = `${prefixCls}-item-group`;
	return /* @__PURE__ */ import_react.createElement("li", _extends$71({
		ref,
		role: "presentation"
	}, restProps, {
		onClick: (e$2) => e$2.stopPropagation(),
		className: clsx(groupPrefixCls, className)
	}), /* @__PURE__ */ import_react.createElement("div", {
		role: "presentation",
		className: clsx(`${groupPrefixCls}-title`, menuClassNames?.listTitle),
		style: styles?.listTitle,
		title: typeof title === "string" ? title : void 0
	}, title), /* @__PURE__ */ import_react.createElement("ul", {
		role: "group",
		className: clsx(`${groupPrefixCls}-list`, menuClassNames?.list),
		style: styles?.list
	}, children));
});
var MenuItemGroup = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { eventKey, children } = props;
	const childList = parseChildren(children, useFullPath(eventKey));
	if (useMeasure()) return childList;
	return /* @__PURE__ */ import_react.createElement(InternalMenuItemGroup, _extends$71({ ref }, omit(props, ["warnKey"])), childList);
});
MenuItemGroup.displayName = "MenuItemGroup";
var MenuItemGroup_default = MenuItemGroup;

//#endregion
//#region node_modules/@rc-component/menu/es/utils/nodeUtil.js
function _extends$70() {
	_extends$70 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$70.apply(this, arguments);
}
function convertItemsToNodes(list, components$1, prefixCls) {
	const { item: MergedMenuItem, group: MergedMenuItemGroup, submenu: MergedSubMenu, divider: MergedDivider } = components$1;
	return (list || []).map((opt, index$1) => {
		if (opt && typeof opt === "object") {
			const { label, children, key, type: type$2, extra, ...restProps } = opt;
			const mergedKey = key ?? `tmp-${index$1}`;
			if (children || type$2 === "group") {
				if (type$2 === "group") return /* @__PURE__ */ import_react.createElement(MergedMenuItemGroup, _extends$70({ key: mergedKey }, restProps, { title: label }), convertItemsToNodes(children, components$1, prefixCls));
				return /* @__PURE__ */ import_react.createElement(MergedSubMenu, _extends$70({ key: mergedKey }, restProps, { title: label }), convertItemsToNodes(children, components$1, prefixCls));
			}
			if (type$2 === "divider") return /* @__PURE__ */ import_react.createElement(MergedDivider, _extends$70({ key: mergedKey }, restProps));
			return /* @__PURE__ */ import_react.createElement(MergedMenuItem, _extends$70({ key: mergedKey }, restProps, { extra }), label, (!!extra || extra === 0) && /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-item-extra` }, extra));
		}
		return null;
	}).filter((opt) => opt);
}
function parseItems(children, items, keyPath, components$1, prefixCls) {
	let childNodes = children;
	const mergedComponents = {
		divider: Divider$1,
		item: MenuItem_default,
		group: MenuItemGroup_default,
		submenu: SubMenu_default$1,
		...components$1
	};
	if (items) childNodes = convertItemsToNodes(items, mergedComponents, prefixCls);
	return parseChildren(childNodes, keyPath);
}

//#endregion
//#region node_modules/@rc-component/menu/es/Menu.js
var import_react_dom$3 = require_react_dom();
function _extends$69() {
	_extends$69 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$69.apply(this, arguments);
}
/**
* Menu modify after refactor:
* ## Add
* - disabled
*
* ## Remove
* - openTransitionName
* - openAnimation
* - onDestroy
* - siderCollapsed: Seems antd do not use this prop (Need test in antd)
* - collapsedWidth: Seems this logic should be handle by antd Layout.Sider
*/
var EMPTY_LIST$4 = [];
var Menu$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls = "rc-menu", rootClassName, style: style$1, className, styles, classNames: menuClassNames, tabIndex = 0, items, children, direction, id, mode = "vertical", inlineCollapsed, disabled, disabledOverflow, subMenuOpenDelay = .1, subMenuCloseDelay = .1, forceSubMenuRender, defaultOpenKeys, openKeys, activeKey, defaultActiveFirst, selectable = true, multiple = false, defaultSelectedKeys, selectedKeys, onSelect, onDeselect, inlineIndent = 24, motion: motion$1, defaultMotions, triggerSubMenuAction = "hover", builtinPlacements, itemIcon, expandIcon, overflowedIndicator = "...", overflowedIndicatorPopupClassName, getPopupContainer, onClick, onOpenChange, onKeyDown: onKeyDown$1, openAnimation, openTransitionName, _internalRenderMenuItem, _internalRenderSubMenuItem, _internalComponents, popupRender, ...restProps } = props;
	const [childList, measureChildList] = import_react.useMemo(() => [parseItems(children, items, EMPTY_LIST$4, _internalComponents, prefixCls), parseItems(children, items, EMPTY_LIST$4, {}, prefixCls)], [
		children,
		items,
		_internalComponents
	]);
	const [mounted, setMounted] = import_react.useState(false);
	const containerRef = import_react.useRef();
	const uuid$5 = useId_default(id ? `rc-menu-uuid-${id}` : "rc-menu-uuid");
	const isRtl = direction === "rtl";
	warning_default$1(!openAnimation && !openTransitionName, "`openAnimation` and `openTransitionName` is removed. Please use `motion` or `defaultMotion` instead.");
	const [innerOpenKeys, setMergedOpenKeys] = useControlledState(defaultOpenKeys, openKeys);
	const mergedOpenKeys = innerOpenKeys || EMPTY_LIST$4;
	const triggerOpenKeys = (keys$1, forceFlush = false) => {
		function doUpdate() {
			setMergedOpenKeys(keys$1);
			onOpenChange?.(keys$1);
		}
		if (forceFlush) (0, import_react_dom$3.flushSync)(doUpdate);
		else doUpdate();
	};
	const [inlineCacheOpenKeys, setInlineCacheOpenKeys] = import_react.useState(mergedOpenKeys);
	const mountRef = import_react.useRef(false);
	const [mergedMode, mergedInlineCollapsed] = import_react.useMemo(() => {
		if ((mode === "inline" || mode === "vertical") && inlineCollapsed) return ["vertical", inlineCollapsed];
		return [mode, false];
	}, [mode, inlineCollapsed]);
	const isInlineMode = mergedMode === "inline";
	const [internalMode, setInternalMode] = import_react.useState(mergedMode);
	const [internalInlineCollapsed, setInternalInlineCollapsed] = import_react.useState(mergedInlineCollapsed);
	import_react.useEffect(() => {
		setInternalMode(mergedMode);
		setInternalInlineCollapsed(mergedInlineCollapsed);
		if (!mountRef.current) return;
		if (isInlineMode) setMergedOpenKeys(inlineCacheOpenKeys);
		else triggerOpenKeys(EMPTY_LIST$4);
	}, [mergedMode, mergedInlineCollapsed]);
	const [lastVisibleIndex, setLastVisibleIndex] = import_react.useState(0);
	const allVisible = lastVisibleIndex >= childList.length - 1 || internalMode !== "horizontal" || disabledOverflow;
	import_react.useEffect(() => {
		if (isInlineMode) setInlineCacheOpenKeys(mergedOpenKeys);
	}, [mergedOpenKeys]);
	import_react.useEffect(() => {
		mountRef.current = true;
		return () => {
			mountRef.current = false;
		};
	}, []);
	const { registerPath, unregisterPath, refreshOverflowKeys, isSubPathKey, getKeyPath, getKeys, getSubPathKeys } = useKeyRecords();
	const registerPathContext = import_react.useMemo(() => ({
		registerPath,
		unregisterPath
	}), [registerPath, unregisterPath]);
	const pathUserContext = import_react.useMemo(() => ({ isSubPathKey }), [isSubPathKey]);
	import_react.useEffect(() => {
		refreshOverflowKeys(allVisible ? EMPTY_LIST$4 : childList.slice(lastVisibleIndex + 1).map((child) => child.key));
	}, [lastVisibleIndex, allVisible]);
	const [mergedActiveKey, setMergedActiveKey] = useControlledState(activeKey || defaultActiveFirst && childList[0]?.key, activeKey);
	const onActive = useMemoCallback((key) => {
		setMergedActiveKey(key);
	});
	const onInactive = useMemoCallback(() => {
		setMergedActiveKey(void 0);
	});
	(0, import_react.useImperativeHandle)(ref, () => {
		return {
			list: containerRef.current,
			focus: (options) => {
				const keys$1 = getKeys();
				const { elements, key2element, element2key } = refreshElements(keys$1, uuid$5);
				const focusableElements = getFocusableElements(containerRef.current, elements);
				let shouldFocusKey;
				if (mergedActiveKey && keys$1.includes(mergedActiveKey)) shouldFocusKey = mergedActiveKey;
				else shouldFocusKey = focusableElements[0] ? element2key.get(focusableElements[0]) : childList.find((node$1) => !node$1.props.disabled)?.key;
				const elementToFocus = key2element.get(shouldFocusKey);
				if (shouldFocusKey && elementToFocus) elementToFocus?.focus?.(options);
			},
			findItem: ({ key: itemKey$2 }) => {
				const { key2element } = refreshElements(getKeys(), uuid$5);
				return key2element.get(itemKey$2) || null;
			}
		};
	});
	const [internalSelectKeys, setMergedSelectKeys] = useControlledState(defaultSelectedKeys || [], selectedKeys);
	const mergedSelectKeys = import_react.useMemo(() => {
		if (Array.isArray(internalSelectKeys)) return internalSelectKeys;
		if (internalSelectKeys === null || internalSelectKeys === void 0) return EMPTY_LIST$4;
		return [internalSelectKeys];
	}, [internalSelectKeys]);
	const triggerSelection = (info) => {
		if (selectable) {
			const { key: targetKey } = info;
			const exist = mergedSelectKeys.includes(targetKey);
			let newSelectKeys;
			if (multiple) if (exist) newSelectKeys = mergedSelectKeys.filter((key) => key !== targetKey);
			else newSelectKeys = [...mergedSelectKeys, targetKey];
			else newSelectKeys = [targetKey];
			setMergedSelectKeys(newSelectKeys);
			const selectInfo = {
				...info,
				selectedKeys: newSelectKeys
			};
			if (exist) onDeselect?.(selectInfo);
			else onSelect?.(selectInfo);
		}
		if (!multiple && mergedOpenKeys.length && internalMode !== "inline") triggerOpenKeys(EMPTY_LIST$4);
	};
	/**
	* Click for item. SubMenu do not have selection status
	*/
	const onInternalClick = useMemoCallback((info) => {
		onClick?.(warnItemProp(info));
		triggerSelection(info);
	});
	const onInternalOpenChange = useMemoCallback((key, open$2) => {
		let newOpenKeys = mergedOpenKeys.filter((k) => k !== key);
		if (open$2) newOpenKeys.push(key);
		else if (internalMode !== "inline") {
			const subPathKeys = getSubPathKeys(key);
			newOpenKeys = newOpenKeys.filter((k) => !subPathKeys.has(k));
		}
		if (!isEqual_default(mergedOpenKeys, newOpenKeys, true)) triggerOpenKeys(newOpenKeys, true);
	});
	const triggerAccessibilityOpen = (key, open$2) => {
		onInternalOpenChange(key, open$2 ?? !mergedOpenKeys.includes(key));
	};
	const onInternalKeyDown = useAccessibility(internalMode, mergedActiveKey, isRtl, uuid$5, containerRef, getKeys, getKeyPath, setMergedActiveKey, triggerAccessibilityOpen, onKeyDown$1);
	import_react.useEffect(() => {
		setMounted(true);
	}, []);
	const privateContext = import_react.useMemo(() => ({
		_internalRenderMenuItem,
		_internalRenderSubMenuItem
	}), [_internalRenderMenuItem, _internalRenderSubMenuItem]);
	const wrappedChildList = internalMode !== "horizontal" || disabledOverflow ? childList : childList.map((child, index$1) => /* @__PURE__ */ import_react.createElement(InheritableContextProvider, {
		key: child.key,
		overflowDisabled: index$1 > lastVisibleIndex,
		classNames: menuClassNames,
		styles
	}, child));
	const container = /* @__PURE__ */ import_react.createElement(es_default$30, _extends$69({
		id,
		ref: containerRef,
		prefixCls: `${prefixCls}-overflow`,
		component: "ul",
		itemComponent: MenuItem_default,
		className: clsx(prefixCls, `${prefixCls}-root`, `${prefixCls}-${internalMode}`, className, {
			[`${prefixCls}-inline-collapsed`]: internalInlineCollapsed,
			[`${prefixCls}-rtl`]: isRtl
		}, rootClassName),
		dir: direction,
		style: style$1,
		role: "menu",
		tabIndex,
		data: wrappedChildList,
		renderRawItem: (node$1) => node$1,
		renderRawRest: (omitItems) => {
			const len = omitItems.length;
			const originOmitItems = len ? childList.slice(-len) : null;
			return /* @__PURE__ */ import_react.createElement(SubMenu_default$1, {
				eventKey: OVERFLOW_KEY,
				title: overflowedIndicator,
				disabled: allVisible,
				internalPopupClose: len === 0,
				popupClassName: overflowedIndicatorPopupClassName
			}, originOmitItems);
		},
		maxCount: internalMode !== "horizontal" || disabledOverflow ? es_default$30.INVALIDATE : es_default$30.RESPONSIVE,
		ssr: "full",
		"data-menu-list": true,
		onVisibleChange: (newLastIndex) => {
			setLastVisibleIndex(newLastIndex);
		},
		onKeyDown: onInternalKeyDown
	}, restProps));
	return /* @__PURE__ */ import_react.createElement(PrivateContext_default.Provider, { value: privateContext }, /* @__PURE__ */ import_react.createElement(IdContext.Provider, { value: uuid$5 }, /* @__PURE__ */ import_react.createElement(InheritableContextProvider, {
		prefixCls,
		rootClassName,
		classNames: menuClassNames,
		styles,
		mode: internalMode,
		openKeys: mergedOpenKeys,
		rtl: isRtl,
		disabled,
		motion: mounted ? motion$1 : null,
		defaultMotions: mounted ? defaultMotions : null,
		activeKey: mergedActiveKey,
		onActive,
		onInactive,
		selectedKeys: mergedSelectKeys,
		inlineIndent,
		subMenuOpenDelay,
		subMenuCloseDelay,
		forceSubMenuRender,
		builtinPlacements,
		triggerSubMenuAction,
		getPopupContainer,
		itemIcon,
		expandIcon,
		onItemClick: onInternalClick,
		onOpenChange: onInternalOpenChange,
		popupRender
	}, /* @__PURE__ */ import_react.createElement(PathUserContext.Provider, { value: pathUserContext }, container), /* @__PURE__ */ import_react.createElement("div", {
		style: { display: "none" },
		"aria-hidden": true
	}, /* @__PURE__ */ import_react.createElement(PathRegisterContext.Provider, { value: registerPathContext }, measureChildList)))));
});
var Menu_default = Menu$1;

//#endregion
//#region node_modules/@rc-component/menu/es/index.js
var ExportMenu = Menu_default;
ExportMenu.Item = MenuItem_default;
ExportMenu.SubMenu = SubMenu_default$1;
ExportMenu.ItemGroup = MenuItemGroup_default;
ExportMenu.Divider = Divider$1;
var es_default$14 = ExportMenu;

//#endregion
//#region node_modules/antd/es/layout/context.js
const LayoutContext = /* @__PURE__ */ import_react.createContext({ siderHook: {
	addSider: () => null,
	removeSider: () => null
} });

//#endregion
//#region node_modules/antd/es/layout/style/index.js
var genLayoutStyle = (token$1) => {
	const { antCls, componentCls, colorText, footerBg, headerHeight, headerPadding, headerColor, footerPadding, fontSize, bodyBg, headerBg } = token$1;
	return {
		[componentCls]: {
			display: "flex",
			flex: "auto",
			flexDirection: "column",
			minHeight: 0,
			background: bodyBg,
			"&, *": { boxSizing: "border-box" },
			[`&${componentCls}-has-sider`]: {
				flexDirection: "row",
				[`> ${componentCls}, > ${componentCls}-content`]: { width: 0 }
			},
			[`${componentCls}-header, &${componentCls}-footer`]: { flex: "0 0 auto" },
			"&-rtl": { direction: "rtl" }
		},
		[`${componentCls}-header`]: {
			height: headerHeight,
			padding: headerPadding,
			color: headerColor,
			lineHeight: unit(headerHeight),
			background: headerBg,
			[`${antCls}-menu`]: { lineHeight: "inherit" }
		},
		[`${componentCls}-footer`]: {
			padding: footerPadding,
			color: colorText,
			fontSize,
			background: footerBg
		},
		[`${componentCls}-content`]: {
			flex: "auto",
			color: colorText,
			minHeight: 0
		}
	};
};
const prepareComponentToken$41 = (token$1) => {
	const { colorBgLayout, controlHeight, controlHeightLG, colorText, controlHeightSM, marginXXS, colorTextLightSolid, colorBgContainer } = token$1;
	const paddingInline = controlHeightLG * 1.25;
	return {
		colorBgHeader: "#001529",
		colorBgBody: colorBgLayout,
		colorBgTrigger: "#002140",
		bodyBg: colorBgLayout,
		headerBg: "#001529",
		headerHeight: controlHeight * 2,
		headerPadding: `0 ${paddingInline}px`,
		headerColor: colorText,
		footerPadding: `${controlHeightSM}px ${paddingInline}px`,
		footerBg: colorBgLayout,
		siderBg: "#001529",
		triggerHeight: controlHeightLG + marginXXS * 2,
		triggerBg: "#002140",
		triggerColor: colorTextLightSolid,
		zeroTriggerWidth: controlHeightLG,
		zeroTriggerHeight: controlHeightLG,
		lightSiderBg: colorBgContainer,
		lightTriggerBg: colorBgContainer,
		lightTriggerColor: colorText
	};
};
const DEPRECATED_TOKENS = [
	["colorBgBody", "bodyBg"],
	["colorBgHeader", "headerBg"],
	["colorBgTrigger", "triggerBg"]
];
var style_default$24 = genStyleHooks("Layout", genLayoutStyle, prepareComponentToken$41, { deprecatedTokens: DEPRECATED_TOKENS });

//#endregion
//#region node_modules/antd/es/layout/style/sider.js
var genSiderStyle = (token$1) => {
	const { componentCls, siderBg, motionDurationMid, motionDurationSlow, antCls, triggerHeight, triggerColor, triggerBg, headerHeight, zeroTriggerWidth, zeroTriggerHeight, borderRadiusLG, lightSiderBg, lightTriggerColor, lightTriggerBg, bodyBg } = token$1;
	return { [componentCls]: {
		position: "relative",
		minWidth: 0,
		background: siderBg,
		transition: `all ${motionDurationMid}, background 0s`,
		"&-has-trigger": { paddingBottom: triggerHeight },
		"&-right": { order: 1 },
		[`${componentCls}-children`]: {
			height: "100%",
			marginTop: -.1,
			paddingTop: .1,
			[`${antCls}-menu${antCls}-menu-inline-collapsed`]: { width: "auto" }
		},
		[`&-zero-width ${componentCls}-children`]: { overflow: "hidden" },
		[`${componentCls}-trigger`]: {
			position: "fixed",
			bottom: 0,
			zIndex: 1,
			height: triggerHeight,
			color: triggerColor,
			lineHeight: unit(triggerHeight),
			textAlign: "center",
			background: triggerBg,
			cursor: "pointer",
			transition: `all ${motionDurationMid}`
		},
		[`${componentCls}-zero-width-trigger`]: {
			position: "absolute",
			top: headerHeight,
			insetInlineEnd: token$1.calc(zeroTriggerWidth).mul(-1).equal(),
			zIndex: 1,
			width: zeroTriggerWidth,
			height: zeroTriggerHeight,
			color: triggerColor,
			fontSize: token$1.fontSizeXL,
			display: "flex",
			alignItems: "center",
			justifyContent: "center",
			background: siderBg,
			borderRadius: `0 ${unit(borderRadiusLG)} ${unit(borderRadiusLG)} 0`,
			cursor: "pointer",
			transition: `background ${motionDurationSlow} ease`,
			"&::after": {
				position: "absolute",
				inset: 0,
				background: "transparent",
				transition: `all ${motionDurationSlow}`,
				content: "\"\""
			},
			"&:hover::after": { background: `rgba(255, 255, 255, 0.2)` },
			"&-right": {
				insetInlineStart: token$1.calc(zeroTriggerWidth).mul(-1).equal(),
				borderRadius: `${unit(borderRadiusLG)} 0 0 ${unit(borderRadiusLG)}`
			}
		},
		"&-light": {
			background: lightSiderBg,
			[`${componentCls}-trigger`]: {
				color: lightTriggerColor,
				background: lightTriggerBg
			},
			[`${componentCls}-zero-width-trigger`]: {
				color: lightTriggerColor,
				background: lightTriggerBg,
				border: `1px solid ${bodyBg}`,
				borderInlineStart: 0
			}
		}
	} };
};
var sider_default = genStyleHooks(["Layout", "Sider"], genSiderStyle, prepareComponentToken$41, { deprecatedTokens: DEPRECATED_TOKENS });

//#endregion
//#region node_modules/antd/es/layout/Sider.js
var dimensionMaxMap = {
	xs: "479.98px",
	sm: "575.98px",
	md: "767.98px",
	lg: "991.98px",
	xl: "1199.98px",
	xxl: "1599.98px"
};
var isNumeric = (val) => !Number.isNaN(Number.parseFloat(val)) && Number.isFinite(Number(val));
const SiderContext = /* @__PURE__ */ import_react.createContext({});
var generateId = (() => {
	let i = 0;
	return (prefix$1 = "") => {
		i += 1;
		return `${prefix$1}${i}`;
	};
})();
var Sider = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, className, trigger, children, defaultCollapsed = false, theme = "dark", style: style$1 = {}, collapsible = false, reverseArrow = false, width = 200, collapsedWidth = 80, zeroWidthTriggerStyle, breakpoint, onCollapse, onBreakpoint, ...otherProps } = props;
	const { siderHook } = (0, import_react.useContext)(LayoutContext);
	const [collapsed, setCollapsed] = (0, import_react.useState)("collapsed" in props ? props.collapsed : defaultCollapsed);
	const [below, setBelow] = (0, import_react.useState)(false);
	(0, import_react.useEffect)(() => {
		if ("collapsed" in props) setCollapsed(props.collapsed);
	}, [props.collapsed]);
	const handleSetCollapsed = (value, type$2) => {
		if (!("collapsed" in props)) setCollapsed(value);
		onCollapse?.(value, type$2);
	};
	const { getPrefixCls, direction } = (0, import_react.useContext)(ConfigContext);
	const prefixCls = getPrefixCls("layout-sider", customizePrefixCls);
	const [hashId, cssVarCls] = sider_default(prefixCls);
	const responsiveHandlerRef = (0, import_react.useRef)(null);
	responsiveHandlerRef.current = (mql) => {
		setBelow(mql.matches);
		onBreakpoint?.(mql.matches);
		if (collapsed !== mql.matches) handleSetCollapsed(mql.matches, "responsive");
	};
	(0, import_react.useEffect)(() => {
		function responsiveHandler(mql$1) {
			return responsiveHandlerRef.current?.(mql$1);
		}
		let mql;
		if (typeof window?.matchMedia !== "undefined" && breakpoint && breakpoint in dimensionMaxMap) {
			mql = window.matchMedia(`screen and (max-width: ${dimensionMaxMap[breakpoint]})`);
			if (typeof mql?.addEventListener === "function") mql.addEventListener("change", responsiveHandler);
			responsiveHandler(mql);
		}
		return () => {
			if (typeof mql?.removeEventListener === "function") mql.removeEventListener("change", responsiveHandler);
		};
	}, [breakpoint]);
	(0, import_react.useEffect)(() => {
		const uniqueId = generateId("ant-sider-");
		siderHook.addSider(uniqueId);
		return () => siderHook.removeSider(uniqueId);
	}, []);
	const toggle = () => {
		handleSetCollapsed(!collapsed, "clickTrigger");
	};
	const divProps = omit(otherProps, ["collapsed"]);
	const rawWidth = collapsed ? collapsedWidth : width;
	const siderWidth = isNumeric(rawWidth) ? `${rawWidth}px` : String(rawWidth);
	const zeroWidthTrigger = Number.parseFloat(String(collapsedWidth || 0)) === 0 ? /* @__PURE__ */ import_react.createElement("span", {
		onClick: toggle,
		className: clsx(`${prefixCls}-zero-width-trigger`, `${prefixCls}-zero-width-trigger-${reverseArrow ? "right" : "left"}`),
		style: zeroWidthTriggerStyle
	}, trigger || /* @__PURE__ */ import_react.createElement(BarsOutlined_default, null)) : null;
	const reverseIcon = direction === "rtl" === !reverseArrow;
	const defaultTrigger = {
		expanded: reverseIcon ? /* @__PURE__ */ import_react.createElement(RightOutlined_default, null) : /* @__PURE__ */ import_react.createElement(LeftOutlined_default, null),
		collapsed: reverseIcon ? /* @__PURE__ */ import_react.createElement(LeftOutlined_default, null) : /* @__PURE__ */ import_react.createElement(RightOutlined_default, null)
	}[collapsed ? "collapsed" : "expanded"];
	const triggerDom = trigger !== null ? zeroWidthTrigger || /* @__PURE__ */ import_react.createElement("div", {
		className: `${prefixCls}-trigger`,
		onClick: toggle,
		style: { width: siderWidth }
	}, trigger || defaultTrigger) : null;
	const divStyle = {
		...style$1,
		flex: `0 0 ${siderWidth}`,
		maxWidth: siderWidth,
		minWidth: siderWidth,
		width: siderWidth
	};
	const siderCls = clsx(prefixCls, `${prefixCls}-${theme}`, {
		[`${prefixCls}-collapsed`]: !!collapsed,
		[`${prefixCls}-has-trigger`]: collapsible && trigger !== null && !zeroWidthTrigger,
		[`${prefixCls}-below`]: !!below,
		[`${prefixCls}-zero-width`]: Number.parseFloat(siderWidth) === 0
	}, className, hashId, cssVarCls);
	const contextValue = import_react.useMemo(() => ({ siderCollapsed: collapsed }), [collapsed]);
	return /* @__PURE__ */ import_react.createElement(SiderContext.Provider, { value: contextValue }, /* @__PURE__ */ import_react.createElement("aside", {
		className: siderCls,
		...divProps,
		style: divStyle,
		ref
	}, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-children` }, children), collapsible || below && zeroWidthTrigger ? triggerDom : null));
});
Sider.displayName = "Sider";
var Sider_default = Sider;

//#endregion
//#region node_modules/antd/es/menu/MenuContext.js
var MenuContext = /* @__PURE__ */ (0, import_react.createContext)({
	prefixCls: "",
	firstLevel: true,
	inlineCollapsed: false,
	styles: null,
	classNames: null
});
var MenuContext_default = MenuContext;

//#endregion
//#region node_modules/antd/es/menu/MenuDivider.js
var MenuDivider = (props) => {
	const { prefixCls: customizePrefixCls, className, dashed, ...restProps } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const classString = clsx({ [`${getPrefixCls("menu", customizePrefixCls)}-item-divider-dashed`]: !!dashed }, className);
	return /* @__PURE__ */ import_react.createElement(Divider$1, {
		className: classString,
		...restProps
	});
};
var MenuDivider_default = MenuDivider;

//#endregion
//#region node_modules/antd/es/menu/MenuItem.js
var MenuItem = (props) => {
	const { className, children, icon, title, danger, extra } = props;
	const { prefixCls, firstLevel, direction, disableMenuItemTitleTooltip, inlineCollapsed: isInlineCollapsed, styles, classNames } = import_react.useContext(MenuContext_default);
	const renderItemChildren = (inlineCollapsed) => {
		const label = children?.[0];
		const wrapNode = /* @__PURE__ */ import_react.createElement("span", {
			className: clsx(`${prefixCls}-title-content`, firstLevel ? classNames.itemContent : classNames.subMenu.itemContent, { [`${prefixCls}-title-content-with-extra`]: !!extra || extra === 0 }),
			style: firstLevel ? styles.itemContent : styles.subMenu.itemContent
		}, children);
		if (!icon || /* @__PURE__ */ import_react.isValidElement(children) && children.type === "span") {
			if (children && inlineCollapsed && firstLevel && typeof label === "string") return /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-inline-collapsed-noicon` }, label.charAt(0));
		}
		return wrapNode;
	};
	const { siderCollapsed } = import_react.useContext(SiderContext);
	let tooltipTitle = title;
	if (typeof title === "undefined") tooltipTitle = firstLevel ? children : "";
	else if (title === false) tooltipTitle = "";
	const tooltipProps = { title: tooltipTitle };
	if (!siderCollapsed && !isInlineCollapsed) {
		tooltipProps.title = null;
		tooltipProps.open = false;
	}
	const childrenLength = toArray(children).length;
	let returnNode = /* @__PURE__ */ import_react.createElement(MenuItem_default, {
		...omit(props, [
			"title",
			"icon",
			"danger"
		]),
		className: clsx(firstLevel ? classNames.item : classNames.subMenu.item, {
			[`${prefixCls}-item-danger`]: danger,
			[`${prefixCls}-item-only-child`]: (icon ? childrenLength + 1 : childrenLength) === 1
		}, className),
		style: {
			...firstLevel ? styles.item : styles.subMenu.item,
			...props.style
		},
		title: typeof title === "string" ? title : void 0
	}, cloneElement(icon, (oriProps) => ({
		className: clsx(`${prefixCls}-item-icon`, firstLevel ? classNames.itemIcon : classNames.subMenu.itemIcon, oriProps.className),
		style: {
			...firstLevel ? styles.itemIcon : styles.subMenu.itemIcon,
			...oriProps.style
		}
	})), renderItemChildren(isInlineCollapsed));
	if (!disableMenuItemTitleTooltip) returnNode = /* @__PURE__ */ import_react.createElement(tooltip_default, {
		...tooltipProps,
		placement: direction === "rtl" ? "left" : "right",
		classNames: { root: `${prefixCls}-inline-collapsed-tooltip` }
	}, returnNode);
	return returnNode;
};
var MenuItem_default$1 = MenuItem;

//#endregion
//#region node_modules/antd/es/menu/OverrideContext.js
var OverrideContext = /* @__PURE__ */ import_react.createContext(null);
/** @internal Only used for Dropdown component. Do not use this in your production. */
const OverrideProvider = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { children, ...restProps } = props;
	const override = import_react.useContext(OverrideContext);
	const context = import_react.useMemo(() => ({
		...override,
		...restProps
	}), [
		override,
		restProps.prefixCls,
		restProps.mode,
		restProps.selectable,
		restProps.rootClassName
	]);
	const canRef = supportNodeRef(children);
	const mergedRef = useComposeRef(ref, canRef ? getNodeRef(children) : null);
	return /* @__PURE__ */ import_react.createElement(OverrideContext.Provider, { value: context }, /* @__PURE__ */ import_react.createElement(ContextIsolator_default, { space: true }, canRef ? /* @__PURE__ */ import_react.cloneElement(children, { ref: mergedRef }) : children));
});
/** @internal Only used for Dropdown component. Do not use this in your production. */
var OverrideContext_default = OverrideContext;

//#endregion
//#region node_modules/antd/es/menu/style/horizontal.js
var getHorizontalStyle = (token$1) => {
	const { componentCls, motionDurationSlow, horizontalLineHeight, colorSplit, lineWidth, lineType, itemPaddingInline } = token$1;
	return { [`${componentCls}-horizontal`]: {
		lineHeight: horizontalLineHeight,
		border: 0,
		borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
		boxShadow: "none",
		"&::after": {
			display: "block",
			clear: "both",
			height: 0,
			content: "\"\\20\""
		},
		[`${componentCls}-item, ${componentCls}-submenu`]: {
			position: "relative",
			display: "inline-block",
			verticalAlign: "bottom",
			paddingInline: itemPaddingInline
		},
		[`> ${componentCls}-item:hover,
        > ${componentCls}-item-active,
        > ${componentCls}-submenu ${componentCls}-submenu-title:hover`]: { backgroundColor: "transparent" },
		[`${componentCls}-item, ${componentCls}-submenu-title`]: { transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`].join(",") },
		[`${componentCls}-submenu-arrow`]: { display: "none" }
	} };
};
var horizontal_default$2 = getHorizontalStyle;

//#endregion
//#region node_modules/antd/es/menu/style/rtl.js
var getRTLStyle = ({ componentCls, menuArrowOffset, calc }) => ({
	[`${componentCls}-rtl`]: { direction: "rtl" },
	[`${componentCls}-submenu-rtl`]: { transformOrigin: "100% 0" },
	[`${componentCls}-rtl${componentCls}-vertical,
    ${componentCls}-submenu-rtl ${componentCls}-vertical`]: { [`${componentCls}-submenu-arrow`]: {
		"&::before": { transform: `rotate(-45deg) translateY(${unit(calc(menuArrowOffset).mul(-1).equal())})` },
		"&::after": { transform: `rotate(45deg) translateY(${unit(menuArrowOffset)})` }
	} }
});
var rtl_default$3 = getRTLStyle;

//#endregion
//#region node_modules/antd/es/menu/style/theme.js
var accessibilityFocus = (token$1) => genFocusOutline(token$1);
var getThemeStyle = (token$1, themeSuffix) => {
	const { componentCls, itemColor, itemSelectedColor, subMenuItemSelectedColor, groupTitleColor, itemBg, subMenuItemBg, itemSelectedBg, activeBarHeight, activeBarWidth, activeBarBorderWidth, motionDurationSlow, motionEaseInOut, motionEaseOut, itemPaddingInline, motionDurationMid, itemHoverColor, lineType, colorSplit, itemDisabledColor, dangerItemColor, dangerItemHoverColor, dangerItemSelectedColor, dangerItemActiveBg, dangerItemSelectedBg, popupBg, itemHoverBg, itemActiveBg, menuSubMenuBg, horizontalItemSelectedColor, horizontalItemSelectedBg, horizontalItemBorderRadius, horizontalItemHoverBg } = token$1;
	return { [`${componentCls}-${themeSuffix}, ${componentCls}-${themeSuffix} > ${componentCls}`]: {
		color: itemColor,
		background: itemBg,
		[`&${componentCls}-root:focus-visible`]: { ...accessibilityFocus(token$1) },
		[`${componentCls}-item`]: { "&-group-title, &-extra": { color: groupTitleColor } },
		[`${componentCls}-submenu-selected > ${componentCls}-submenu-title`]: { color: subMenuItemSelectedColor },
		[`${componentCls}-item, ${componentCls}-submenu-title`]: {
			color: itemColor,
			[`&:not(${componentCls}-item-disabled):focus-visible`]: { ...accessibilityFocus(token$1) }
		},
		[`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: { color: `${itemDisabledColor} !important` },
		[`${componentCls}-item:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: { [`&:hover, > ${componentCls}-submenu-title:hover`]: { color: itemHoverColor } },
		[`&:not(${componentCls}-horizontal)`]: {
			[`${componentCls}-item:not(${componentCls}-item-selected)`]: {
				"&:hover": { backgroundColor: itemHoverBg },
				"&:active": { backgroundColor: itemActiveBg }
			},
			[`${componentCls}-submenu-title`]: {
				"&:hover": { backgroundColor: itemHoverBg },
				"&:active": { backgroundColor: itemActiveBg }
			}
		},
		[`${componentCls}-item-danger`]: {
			color: dangerItemColor,
			[`&${componentCls}-item:hover`]: { [`&:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: { color: dangerItemHoverColor } },
			[`&${componentCls}-item:active`]: { background: dangerItemActiveBg }
		},
		[`${componentCls}-item a`]: { "&, &:hover": { color: "inherit" } },
		[`${componentCls}-item-selected`]: {
			color: itemSelectedColor,
			[`&${componentCls}-item-danger`]: { color: dangerItemSelectedColor },
			"a, a:hover": { color: "inherit" }
		},
		[`& ${componentCls}-item-selected`]: {
			backgroundColor: itemSelectedBg,
			[`&${componentCls}-item-danger`]: { backgroundColor: dangerItemSelectedBg }
		},
		[`&${componentCls}-submenu > ${componentCls}`]: { backgroundColor: menuSubMenuBg },
		[`&${componentCls}-popup > ${componentCls}`]: { backgroundColor: popupBg },
		[`&${componentCls}-submenu-popup > ${componentCls}`]: { backgroundColor: popupBg },
		[`&${componentCls}-horizontal`]: {
			...themeSuffix === "dark" ? { borderBottom: 0 } : {},
			[`> ${componentCls}-item, > ${componentCls}-submenu`]: {
				top: activeBarBorderWidth,
				marginTop: token$1.calc(activeBarBorderWidth).mul(-1).equal(),
				marginBottom: 0,
				borderRadius: horizontalItemBorderRadius,
				"&::after": {
					position: "absolute",
					insetInline: itemPaddingInline,
					bottom: 0,
					borderBottom: `${unit(activeBarHeight)} solid transparent`,
					transition: `border-color ${motionDurationSlow} ${motionEaseInOut}`,
					content: "\"\""
				},
				"&:hover, &-active, &-open": {
					background: horizontalItemHoverBg,
					"&::after": {
						borderBottomWidth: activeBarHeight,
						borderBottomColor: horizontalItemSelectedColor
					}
				},
				"&-selected": {
					color: horizontalItemSelectedColor,
					backgroundColor: horizontalItemSelectedBg,
					"&:hover": { backgroundColor: horizontalItemSelectedBg },
					"&::after": {
						borderBottomWidth: activeBarHeight,
						borderBottomColor: horizontalItemSelectedColor
					}
				}
			}
		},
		[`&${componentCls}-root`]: { [`&${componentCls}-inline, &${componentCls}-vertical`]: { borderInlineEnd: `${unit(activeBarBorderWidth)} ${lineType} ${colorSplit}` } },
		[`&${componentCls}-inline`]: {
			[`${componentCls}-sub${componentCls}-inline`]: { background: subMenuItemBg },
			[`${componentCls}-item`]: {
				position: "relative",
				"&::after": {
					position: "absolute",
					insetBlock: 0,
					insetInlineEnd: 0,
					borderInlineEnd: `${unit(activeBarWidth)} solid ${itemSelectedColor}`,
					transform: "scaleY(0.0001)",
					opacity: 0,
					transition: [`transform ${motionDurationMid} ${motionEaseOut}`, `opacity ${motionDurationMid} ${motionEaseOut}`].join(","),
					content: "\"\""
				},
				[`&${componentCls}-item-danger`]: { "&::after": { borderInlineEndColor: dangerItemSelectedColor } }
			},
			[`${componentCls}-selected, ${componentCls}-item-selected`]: { "&::after": {
				transform: "scaleY(1)",
				opacity: 1,
				transition: [`transform ${motionDurationMid} ${motionEaseInOut}`, `opacity ${motionDurationMid} ${motionEaseInOut}`].join(",")
			} }
		}
	} };
};
var theme_default$2 = getThemeStyle;

//#endregion
//#region node_modules/antd/es/menu/style/vertical.js
var getVerticalInlineStyle = (token$1) => {
	const { componentCls, itemHeight, itemMarginInline, padding, menuArrowSize, marginXS, itemMarginBlock, itemWidth, itemPaddingInline } = token$1;
	const paddingWithArrow = token$1.calc(menuArrowSize).add(padding).add(marginXS).equal();
	return {
		[`${componentCls}-item`]: {
			position: "relative",
			overflow: "hidden"
		},
		[`${componentCls}-item, ${componentCls}-submenu-title`]: {
			height: itemHeight,
			lineHeight: unit(itemHeight),
			paddingInline: itemPaddingInline,
			overflow: "hidden",
			textOverflow: "ellipsis",
			marginInline: itemMarginInline,
			marginBlock: itemMarginBlock,
			width: itemWidth
		},
		[`> ${componentCls}-item,
            > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
			height: itemHeight,
			lineHeight: unit(itemHeight)
		},
		[`${componentCls}-item-group-list ${componentCls}-submenu-title,
            ${componentCls}-submenu-title`]: { paddingInlineEnd: paddingWithArrow }
	};
};
var getVerticalStyle = (token$1) => {
	const { componentCls, iconCls, itemHeight, colorTextLightSolid, dropdownWidth, controlHeightLG, motionEaseOut, paddingXL, itemMarginInline, fontSizeLG, motionDurationFast, motionDurationSlow, paddingXS, boxShadowSecondary, collapsedWidth, collapsedIconSize } = token$1;
	const inlineItemStyle = {
		height: itemHeight,
		lineHeight: unit(itemHeight),
		listStylePosition: "inside",
		listStyleType: "disc"
	};
	return [
		{
			[componentCls]: { "&-inline, &-vertical": {
				[`&${componentCls}-root`]: { boxShadow: "none" },
				...getVerticalInlineStyle(token$1)
			} },
			[`${componentCls}-submenu-popup`]: { [`${componentCls}-vertical`]: {
				...getVerticalInlineStyle(token$1),
				boxShadow: boxShadowSecondary
			} }
		},
		{ [`${componentCls}-submenu-popup ${componentCls}-vertical${componentCls}-sub`]: {
			minWidth: dropdownWidth,
			maxHeight: `calc(100vh - ${unit(token$1.calc(controlHeightLG).mul(2.5).equal())})`,
			padding: "0",
			overflow: "hidden",
			borderInlineEnd: 0,
			"&:not([class*='-active'])": {
				overflowX: "hidden",
				overflowY: "auto"
			}
		} },
		{ [`${componentCls}-inline`]: {
			width: "100%",
			[`&${componentCls}-root`]: { [`${componentCls}-item, ${componentCls}-submenu-title`]: {
				display: "flex",
				alignItems: "center",
				transition: [
					`border-color ${motionDurationSlow}`,
					`background ${motionDurationSlow}`,
					`padding ${motionDurationFast} ${motionEaseOut}`
				].join(","),
				[`> ${componentCls}-title-content`]: {
					flex: "auto",
					minWidth: 0,
					overflow: "hidden",
					textOverflow: "ellipsis"
				},
				"> *": { flex: "none" }
			} },
			[`${componentCls}-sub${componentCls}-inline`]: {
				padding: 0,
				border: 0,
				borderRadius: 0,
				boxShadow: "none",
				[`& > ${componentCls}-submenu > ${componentCls}-submenu-title`]: inlineItemStyle,
				[`& ${componentCls}-item-group-title`]: { paddingInlineStart: paddingXL }
			},
			[`${componentCls}-item`]: inlineItemStyle
		} },
		{ [`${componentCls}-inline-collapsed`]: {
			width: collapsedWidth,
			[`&${componentCls}-root`]: { [`${componentCls}-item, ${componentCls}-submenu ${componentCls}-submenu-title`]: { [`> ${componentCls}-inline-collapsed-noicon`]: {
				fontSize: fontSizeLG,
				textAlign: "center"
			} } },
			[`> ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-submenu > ${componentCls}-submenu-title,
          > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
				insetInlineStart: 0,
				paddingInline: `calc(50% - ${unit(token$1.calc(collapsedIconSize).div(2).equal())} - ${unit(itemMarginInline)})`,
				textOverflow: "clip",
				[`
            ${componentCls}-submenu-arrow,
            ${componentCls}-submenu-expand-icon
          `]: { opacity: 0 },
				[`${componentCls}-item-icon, ${iconCls}`]: {
					margin: 0,
					fontSize: collapsedIconSize,
					lineHeight: unit(itemHeight),
					"+ span": {
						display: "inline-block",
						opacity: 0
					}
				}
			},
			[`${componentCls}-item-icon, ${iconCls}`]: { display: "inline-block" },
			"&-tooltip": {
				pointerEvents: "none",
				[`${componentCls}-item-icon, ${iconCls}`]: { display: "none" },
				"a, a:hover": { color: colorTextLightSolid }
			},
			[`${componentCls}-item-group-title`]: {
				...textEllipsis,
				paddingInline: paddingXS
			}
		} }
	];
};
var vertical_default$1 = getVerticalStyle;

//#endregion
//#region node_modules/antd/es/menu/style/index.js
var genMenuItemStyle = (token$1) => {
	const { componentCls, motionDurationSlow, motionDurationMid, motionEaseInOut, motionEaseOut, iconCls, iconSize, iconMarginInlineEnd } = token$1;
	return {
		[`${componentCls}-item, ${componentCls}-submenu-title`]: {
			position: "relative",
			display: "block",
			margin: 0,
			whiteSpace: "nowrap",
			cursor: "pointer",
			transition: [
				`border-color ${motionDurationSlow}`,
				`background ${motionDurationSlow}`,
				`padding calc(${motionDurationSlow} + 0.1s) ${motionEaseInOut}`
			].join(","),
			[`${componentCls}-item-icon, ${iconCls}`]: {
				minWidth: iconSize,
				fontSize: iconSize,
				transition: [
					`font-size ${motionDurationMid} ${motionEaseOut}`,
					`margin ${motionDurationSlow} ${motionEaseInOut}`,
					`color ${motionDurationSlow}`
				].join(","),
				"+ span": {
					marginInlineStart: iconMarginInlineEnd,
					opacity: 1,
					transition: [
						`opacity ${motionDurationSlow} ${motionEaseInOut}`,
						`margin ${motionDurationSlow}`,
						`color ${motionDurationSlow}`
					].join(",")
				}
			},
			[`${componentCls}-item-icon`]: { ...resetIcon() },
			[`&${componentCls}-item-only-child`]: { [`> ${iconCls}, > ${componentCls}-item-icon`]: { marginInlineEnd: 0 } }
		},
		[`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
			background: "none !important",
			cursor: "not-allowed",
			"&::after": { borderColor: "transparent !important" },
			a: {
				color: "inherit !important",
				cursor: "not-allowed",
				pointerEvents: "none"
			},
			[`> ${componentCls}-submenu-title`]: {
				color: "inherit !important",
				cursor: "not-allowed"
			}
		}
	};
};
var genSubMenuArrowStyle = (token$1) => {
	const { componentCls, motionDurationSlow, motionEaseInOut, borderRadius, menuArrowSize, menuArrowOffset } = token$1;
	return { [`${componentCls}-submenu`]: {
		"&-expand-icon, &-arrow": {
			position: "absolute",
			top: "50%",
			insetInlineEnd: token$1.margin,
			width: menuArrowSize,
			color: "currentcolor",
			transform: "translateY(-50%)",
			transition: `transform ${motionDurationSlow} ${motionEaseInOut}, opacity ${motionDurationSlow}`
		},
		"&-arrow": {
			"&::before, &::after": {
				position: "absolute",
				width: token$1.calc(menuArrowSize).mul(.6).equal(),
				height: token$1.calc(menuArrowSize).mul(.15).equal(),
				backgroundColor: "currentcolor",
				borderRadius,
				transition: [
					`background ${motionDurationSlow} ${motionEaseInOut}`,
					`transform ${motionDurationSlow} ${motionEaseInOut}`,
					`top ${motionDurationSlow} ${motionEaseInOut}`,
					`color ${motionDurationSlow} ${motionEaseInOut}`
				].join(","),
				content: "\"\""
			},
			"&::before": { transform: `rotate(45deg) translateY(${unit(token$1.calc(menuArrowOffset).mul(-1).equal())})` },
			"&::after": { transform: `rotate(-45deg) translateY(${unit(menuArrowOffset)})` }
		}
	} };
};
var getBaseStyle = (token$1) => {
	const { antCls, componentCls, fontSize, motionDurationSlow, motionDurationMid, motionEaseInOut, paddingXS, padding, colorSplit, lineWidth, zIndexPopup, borderRadiusLG, subMenuItemBorderRadius, menuArrowSize, menuArrowOffset, lineType, groupTitleLineHeight, groupTitleFontSize } = token$1;
	return [
		{
			"": { [componentCls]: {
				...clearFix(),
				"&-hidden": { display: "none" }
			} },
			[`${componentCls}-submenu-hidden`]: { display: "none" }
		},
		{ [componentCls]: {
			...resetComponent(token$1),
			...clearFix(),
			marginBottom: 0,
			paddingInlineStart: 0,
			fontSize,
			lineHeight: 0,
			listStyle: "none",
			outline: "none",
			transition: `width ${motionDurationSlow} cubic-bezier(0.2, 0, 0, 1) 0s`,
			"ul, ol": {
				margin: 0,
				padding: 0,
				listStyle: "none"
			},
			"&-overflow": {
				display: "flex",
				[`${componentCls}-item`]: { flex: "none" }
			},
			[`${componentCls}-item, ${componentCls}-submenu, ${componentCls}-submenu-title`]: { borderRadius: token$1.itemBorderRadius },
			[`${componentCls}-item-group-title`]: {
				padding: `${unit(paddingXS)} ${unit(padding)}`,
				fontSize: groupTitleFontSize,
				lineHeight: groupTitleLineHeight,
				transition: `all ${motionDurationSlow}`
			},
			[`&-horizontal ${componentCls}-submenu`]: { transition: [`border-color ${motionDurationSlow} ${motionEaseInOut}`, `background ${motionDurationSlow} ${motionEaseInOut}`].join(",") },
			[`${componentCls}-submenu, ${componentCls}-submenu-inline`]: { transition: [
				`border-color ${motionDurationSlow} ${motionEaseInOut}`,
				`background ${motionDurationSlow} ${motionEaseInOut}`,
				`padding ${motionDurationMid} ${motionEaseInOut}`
			].join(",") },
			[`${componentCls}-submenu ${componentCls}-sub`]: {
				cursor: "initial",
				transition: [`background ${motionDurationSlow} ${motionEaseInOut}`, `padding ${motionDurationSlow} ${motionEaseInOut}`].join(",")
			},
			[`${componentCls}-title-content`]: {
				transition: `color ${motionDurationSlow}`,
				"&-with-extra": {
					display: "inline-flex",
					alignItems: "center",
					width: "100%"
				},
				[`> ${antCls}-typography-ellipsis-single-line`]: {
					display: "inline",
					verticalAlign: "unset"
				},
				[`${componentCls}-item-extra`]: {
					marginInlineStart: "auto",
					paddingInlineStart: token$1.padding
				}
			},
			[`${componentCls}-item a`]: { "&::before": {
				position: "absolute",
				inset: 0,
				backgroundColor: "transparent",
				content: "\"\""
			} },
			[`${componentCls}-item-divider`]: {
				overflow: "hidden",
				lineHeight: 0,
				borderColor: colorSplit,
				borderStyle: lineType,
				borderWidth: 0,
				borderTopWidth: lineWidth,
				marginBlock: lineWidth,
				padding: 0,
				"&-dashed": { borderStyle: "dashed" }
			},
			...genMenuItemStyle(token$1),
			[`${componentCls}-item-group`]: { [`${componentCls}-item-group-list`]: {
				margin: 0,
				padding: 0,
				[`${componentCls}-item, ${componentCls}-submenu-title`]: { paddingInline: `${unit(token$1.calc(fontSize).mul(2).equal())} ${unit(padding)}` }
			} },
			"&-submenu": {
				"&-popup": {
					position: "absolute",
					zIndex: zIndexPopup,
					borderRadius: borderRadiusLG,
					boxShadow: "none",
					transformOrigin: "0 0",
					[`&${componentCls}-submenu`]: { background: "transparent" },
					"&::before": {
						position: "absolute",
						inset: 0,
						zIndex: -1,
						width: "100%",
						height: "100%",
						opacity: 0,
						content: "\"\""
					},
					[`> ${componentCls}`]: {
						borderRadius: borderRadiusLG,
						...genMenuItemStyle(token$1),
						...genSubMenuArrowStyle(token$1),
						[`${componentCls}-item, ${componentCls}-submenu > ${componentCls}-submenu-title`]: { borderRadius: subMenuItemBorderRadius },
						[`${componentCls}-submenu-title::after`]: { transition: `transform ${motionDurationSlow} ${motionEaseInOut}` }
					}
				},
				[`
          &-placement-leftTop,
          &-placement-bottomRight,
          `]: { transformOrigin: "100% 0" },
				[`
          &-placement-leftBottom,
          &-placement-topRight,
          `]: { transformOrigin: "100% 100%" },
				[`
          &-placement-rightBottom,
          &-placement-topLeft,
          `]: { transformOrigin: "0 100%" },
				[`
          &-placement-bottomLeft,
          &-placement-rightTop,
          `]: { transformOrigin: "0 0" },
				[`
          &-placement-leftTop,
          &-placement-leftBottom
          `]: { paddingInlineEnd: token$1.paddingXS },
				[`
          &-placement-rightTop,
          &-placement-rightBottom
          `]: { paddingInlineStart: token$1.paddingXS },
				[`
          &-placement-topRight,
          &-placement-topLeft
          `]: { paddingBottom: token$1.paddingXS },
				[`
          &-placement-bottomRight,
          &-placement-bottomLeft
          `]: { paddingTop: token$1.paddingXS }
			},
			...genSubMenuArrowStyle(token$1),
			[`&-inline-collapsed ${componentCls}-submenu-arrow,
        &-inline ${componentCls}-submenu-arrow`]: {
				"&::before": { transform: `rotate(-45deg) translateX(${unit(menuArrowOffset)})` },
				"&::after": { transform: `rotate(45deg) translateX(${unit(token$1.calc(menuArrowOffset).mul(-1).equal())})` }
			},
			[`${componentCls}-submenu-open${componentCls}-submenu-inline > ${componentCls}-submenu-title > ${componentCls}-submenu-arrow`]: {
				transform: `translateY(${unit(token$1.calc(menuArrowSize).mul(.2).mul(-1).equal())})`,
				"&::after": { transform: `rotate(-45deg) translateX(${unit(token$1.calc(menuArrowOffset).mul(-1).equal())})` },
				"&::before": { transform: `rotate(45deg) translateX(${unit(menuArrowOffset)})` }
			}
		} },
		{ [`${antCls}-layout-header`]: { [componentCls]: { lineHeight: "inherit" } } }
	];
};
const prepareComponentToken$40 = (token$1) => {
	const { colorPrimary, colorError, colorTextDisabled, colorErrorBg, colorText, colorTextDescription, colorBgContainer, colorFillAlter, colorFillContent, lineWidth, lineWidthBold, controlItemBgActive, colorBgTextHover, controlHeightLG, lineHeight, colorBgElevated, marginXXS, padding, fontSize, controlHeightSM, fontSizeLG, colorTextLightSolid, colorErrorHover } = token$1;
	const activeBarWidth = token$1.activeBarWidth ?? 0;
	const activeBarBorderWidth = token$1.activeBarBorderWidth ?? lineWidth;
	const itemMarginInline = token$1.itemMarginInline ?? token$1.marginXXS;
	const colorTextDark = new FastColor(colorTextLightSolid).setA(.65).toRgbString();
	return {
		dropdownWidth: 160,
		zIndexPopup: token$1.zIndexPopupBase + 50,
		radiusItem: token$1.borderRadiusLG,
		itemBorderRadius: token$1.borderRadiusLG,
		radiusSubMenuItem: token$1.borderRadiusSM,
		subMenuItemBorderRadius: token$1.borderRadiusSM,
		colorItemText: colorText,
		itemColor: colorText,
		colorItemTextHover: colorText,
		itemHoverColor: colorText,
		colorItemTextHoverHorizontal: colorPrimary,
		horizontalItemHoverColor: colorPrimary,
		colorGroupTitle: colorTextDescription,
		groupTitleColor: colorTextDescription,
		colorItemTextSelected: colorPrimary,
		itemSelectedColor: colorPrimary,
		subMenuItemSelectedColor: colorPrimary,
		colorItemTextSelectedHorizontal: colorPrimary,
		horizontalItemSelectedColor: colorPrimary,
		colorItemBg: colorBgContainer,
		itemBg: colorBgContainer,
		colorItemBgHover: colorBgTextHover,
		itemHoverBg: colorBgTextHover,
		colorItemBgActive: colorFillContent,
		itemActiveBg: controlItemBgActive,
		colorSubItemBg: colorFillAlter,
		subMenuItemBg: colorFillAlter,
		colorItemBgSelected: controlItemBgActive,
		itemSelectedBg: controlItemBgActive,
		colorItemBgSelectedHorizontal: "transparent",
		horizontalItemSelectedBg: "transparent",
		colorActiveBarWidth: 0,
		activeBarWidth,
		colorActiveBarHeight: lineWidthBold,
		activeBarHeight: lineWidthBold,
		colorActiveBarBorderSize: lineWidth,
		activeBarBorderWidth,
		colorItemTextDisabled: colorTextDisabled,
		itemDisabledColor: colorTextDisabled,
		colorDangerItemText: colorError,
		dangerItemColor: colorError,
		colorDangerItemTextHover: colorError,
		dangerItemHoverColor: colorError,
		colorDangerItemTextSelected: colorError,
		dangerItemSelectedColor: colorError,
		colorDangerItemBgActive: colorErrorBg,
		dangerItemActiveBg: colorErrorBg,
		colorDangerItemBgSelected: colorErrorBg,
		dangerItemSelectedBg: colorErrorBg,
		itemMarginInline,
		horizontalItemBorderRadius: 0,
		horizontalItemHoverBg: "transparent",
		itemHeight: controlHeightLG,
		groupTitleLineHeight: lineHeight,
		collapsedWidth: controlHeightLG * 2,
		popupBg: colorBgElevated,
		itemMarginBlock: marginXXS,
		itemPaddingInline: padding,
		horizontalLineHeight: `${controlHeightLG * 1.15}px`,
		iconSize: fontSize,
		iconMarginInlineEnd: controlHeightSM - fontSize,
		collapsedIconSize: fontSizeLG,
		groupTitleFontSize: fontSize,
		darkItemDisabledColor: new FastColor(colorTextLightSolid).setA(.25).toRgbString(),
		darkItemColor: colorTextDark,
		darkDangerItemColor: colorError,
		darkItemBg: "#001529",
		darkPopupBg: "#001529",
		darkSubMenuItemBg: "#000c17",
		darkItemSelectedColor: colorTextLightSolid,
		darkItemSelectedBg: colorPrimary,
		darkDangerItemSelectedBg: colorError,
		darkItemHoverBg: "transparent",
		darkGroupTitleColor: colorTextDark,
		darkItemHoverColor: colorTextLightSolid,
		darkDangerItemHoverColor: colorErrorHover,
		darkDangerItemSelectedColor: colorTextLightSolid,
		darkDangerItemActiveBg: colorError,
		itemWidth: activeBarWidth ? `calc(100% + ${activeBarBorderWidth}px)` : `calc(100% - ${itemMarginInline * 2}px)`
	};
};
var style_default$48 = (prefixCls, rootCls = prefixCls, injectStyle = true) => {
	return genStyleHooks("Menu", (token$1) => {
		const { colorBgElevated, controlHeightLG, fontSize, darkItemColor, darkDangerItemColor, darkItemBg, darkSubMenuItemBg, darkItemSelectedColor, darkItemSelectedBg, darkDangerItemSelectedBg, darkItemHoverBg, darkGroupTitleColor, darkItemHoverColor, darkItemDisabledColor, darkDangerItemHoverColor, darkDangerItemSelectedColor, darkDangerItemActiveBg, popupBg, darkPopupBg } = token$1;
		const menuArrowSize = token$1.calc(fontSize).div(7).mul(5).equal();
		const menuToken = merge(token$1, {
			menuArrowSize,
			menuHorizontalHeight: token$1.calc(controlHeightLG).mul(1.15).equal(),
			menuArrowOffset: token$1.calc(menuArrowSize).mul(.25).equal(),
			menuSubMenuBg: colorBgElevated,
			calc: token$1.calc,
			popupBg
		});
		const menuDarkToken = merge(menuToken, {
			itemColor: darkItemColor,
			itemHoverColor: darkItemHoverColor,
			groupTitleColor: darkGroupTitleColor,
			itemSelectedColor: darkItemSelectedColor,
			subMenuItemSelectedColor: darkItemSelectedColor,
			itemBg: darkItemBg,
			popupBg: darkPopupBg,
			subMenuItemBg: darkSubMenuItemBg,
			itemActiveBg: "transparent",
			itemSelectedBg: darkItemSelectedBg,
			activeBarHeight: 0,
			activeBarBorderWidth: 0,
			itemHoverBg: darkItemHoverBg,
			itemDisabledColor: darkItemDisabledColor,
			dangerItemColor: darkDangerItemColor,
			dangerItemHoverColor: darkDangerItemHoverColor,
			dangerItemSelectedColor: darkDangerItemSelectedColor,
			dangerItemActiveBg: darkDangerItemActiveBg,
			dangerItemSelectedBg: darkDangerItemSelectedBg,
			menuSubMenuBg: darkSubMenuItemBg,
			horizontalItemSelectedColor: darkItemSelectedColor,
			horizontalItemSelectedBg: darkItemSelectedBg
		});
		return [
			getBaseStyle(menuToken),
			horizontal_default$2(menuToken),
			vertical_default$1(menuToken),
			theme_default$2(menuToken, "light"),
			theme_default$2(menuDarkToken, "dark"),
			rtl_default$3(menuToken),
			collapse_default$1(menuToken),
			initSlideMotion(menuToken, "slide-up"),
			initSlideMotion(menuToken, "slide-down"),
			initZoomMotion(menuToken, "zoom-big")
		];
	}, prepareComponentToken$40, {
		deprecatedTokens: [
			["colorGroupTitle", "groupTitleColor"],
			["radiusItem", "itemBorderRadius"],
			["radiusSubMenuItem", "subMenuItemBorderRadius"],
			["colorItemText", "itemColor"],
			["colorItemTextHover", "itemHoverColor"],
			["colorItemTextHoverHorizontal", "horizontalItemHoverColor"],
			["colorItemTextSelected", "itemSelectedColor"],
			["colorItemTextSelectedHorizontal", "horizontalItemSelectedColor"],
			["colorItemTextDisabled", "itemDisabledColor"],
			["colorDangerItemText", "dangerItemColor"],
			["colorDangerItemTextHover", "dangerItemHoverColor"],
			["colorDangerItemTextSelected", "dangerItemSelectedColor"],
			["colorDangerItemBgActive", "dangerItemActiveBg"],
			["colorDangerItemBgSelected", "dangerItemSelectedBg"],
			["colorItemBg", "itemBg"],
			["colorItemBgHover", "itemHoverBg"],
			["colorSubItemBg", "subMenuItemBg"],
			["colorItemBgActive", "itemActiveBg"],
			["colorItemBgSelectedHorizontal", "horizontalItemSelectedBg"],
			["colorActiveBarWidth", "activeBarWidth"],
			["colorActiveBarHeight", "activeBarHeight"],
			["colorActiveBarBorderSize", "activeBarBorderWidth"],
			["colorItemBgSelected", "itemSelectedBg"]
		],
		injectStyle,
		unitless: { groupTitleLineHeight: true }
	})(prefixCls, rootCls);
};

//#endregion
//#region node_modules/antd/es/menu/SubMenu.js
var SubMenu = (props) => {
	const { popupClassName, icon, title, theme: customTheme } = props;
	const context = import_react.useContext(MenuContext_default);
	const { prefixCls, inlineCollapsed, theme: contextTheme, classNames, styles } = context;
	const parentPath = useFullPath();
	let titleNode;
	if (!icon) titleNode = inlineCollapsed && !parentPath.length && title && typeof title === "string" ? /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-inline-collapsed-noicon` }, title.charAt(0)) : /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-title-content` }, title);
	else {
		const titleIsSpan = /* @__PURE__ */ import_react.isValidElement(title) && title.type === "span";
		titleNode = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, cloneElement(icon, (oriProps) => ({
			className: clsx(oriProps.className, `${prefixCls}-item-icon`, classNames.itemIcon),
			style: {
				...oriProps.style,
				...styles.itemIcon
			}
		})), titleIsSpan ? title : /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-title-content` }, title));
	}
	const contextValue = import_react.useMemo(() => ({
		...context,
		firstLevel: false
	}), [context]);
	const [zIndex] = useZIndex("Menu");
	return /* @__PURE__ */ import_react.createElement(MenuContext_default.Provider, { value: contextValue }, /* @__PURE__ */ import_react.createElement(SubMenu_default$1, {
		...omit(props, ["icon"]),
		title: titleNode,
		classNames: {
			list: classNames.subMenu.list,
			listTitle: classNames.subMenu.itemTitle
		},
		styles: {
			list: styles.subMenu.list,
			listTitle: styles.subMenu.itemTitle
		},
		popupClassName: clsx(prefixCls, popupClassName, classNames.popup.root, `${prefixCls}-${customTheme || contextTheme}`),
		popupStyle: {
			zIndex,
			...props.popupStyle,
			...styles.popup.root
		}
	}));
};
var SubMenu_default = SubMenu;

//#endregion
//#region node_modules/antd/es/menu/menu.js
function isEmptyIcon(icon) {
	return icon === null || icon === false;
}
var MENU_COMPONENTS = {
	item: MenuItem_default$1,
	submenu: SubMenu_default,
	divider: MenuDivider_default
};
var InternalMenu = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	const override = import_react.useContext(OverrideContext_default);
	const overrideObj = override || {};
	const { prefixCls: customizePrefixCls, className, style: style$1, theme = "light", expandIcon, _internalDisableMenuItemTitleTooltip, inlineCollapsed, siderCollapsed, rootClassName, mode, selectable, onClick, overflowedIndicatorPopupClassName, classNames, styles, ...restProps } = props;
	const { menu } = import_react.useContext(ConfigContext);
	const { getPrefixCls, getPopupContainer, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("menu");
	const rootPrefixCls = getPrefixCls();
	const passedProps = omit(restProps, ["collapsedWidth"]);
	{
		const warning$3 = devUseWarning("Menu");
		warning$3(!("inlineCollapsed" in props && mode !== "inline"), "usage", "`inlineCollapsed` should only be used when `mode` is inline.");
		warning$3.deprecated("items" in props && !props.children, "children", "items");
	}
	overrideObj.validator?.({ mode });
	const onItemClick = useEvent_default((...args) => {
		onClick?.(...args);
		overrideObj.onClick?.();
	});
	const mergedMode = overrideObj.mode || mode;
	const mergedSelectable = selectable ?? overrideObj.selectable;
	const mergedInlineCollapsed = inlineCollapsed ?? siderCollapsed;
	const mergedProps = {
		...props,
		mode: mergedMode,
		inlineCollapsed: mergedInlineCollapsed,
		selectable: mergedSelectable,
		theme
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps }, {
		popup: { _default: "root" },
		subMenu: { _default: "item" }
	});
	const defaultMotions = {
		horizontal: { motionName: `${rootPrefixCls}-slide-up` },
		inline: motion_default(rootPrefixCls),
		other: { motionName: `${rootPrefixCls}-zoom-big` }
	};
	const prefixCls = getPrefixCls("menu", customizePrefixCls || overrideObj.prefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$48(prefixCls, rootCls, !override);
	const menuClassName = clsx(`${prefixCls}-${theme}`, contextClassName, className);
	const mergedExpandIcon = import_react.useMemo(() => {
		if (typeof expandIcon === "function" || isEmptyIcon(expandIcon)) return expandIcon || null;
		if (typeof overrideObj.expandIcon === "function" || isEmptyIcon(overrideObj.expandIcon)) return overrideObj.expandIcon || null;
		if (typeof menu?.expandIcon === "function" || isEmptyIcon(menu?.expandIcon)) return menu?.expandIcon || null;
		const mergedIcon = expandIcon ?? overrideObj?.expandIcon ?? menu?.expandIcon;
		return cloneElement(mergedIcon, { className: clsx(`${prefixCls}-submenu-expand-icon`, /* @__PURE__ */ import_react.isValidElement(mergedIcon) ? mergedIcon.props?.className : void 0) });
	}, [
		expandIcon,
		overrideObj?.expandIcon,
		menu?.expandIcon,
		prefixCls
	]);
	const contextValue = import_react.useMemo(() => ({
		prefixCls,
		inlineCollapsed: mergedInlineCollapsed || false,
		direction,
		firstLevel: true,
		theme,
		mode: mergedMode,
		disableMenuItemTitleTooltip: _internalDisableMenuItemTitleTooltip,
		classNames: mergedClassNames,
		styles: mergedStyles
	}), [
		prefixCls,
		mergedInlineCollapsed,
		direction,
		_internalDisableMenuItemTitleTooltip,
		theme,
		mergedMode,
		mergedClassNames,
		mergedStyles
	]);
	return /* @__PURE__ */ import_react.createElement(OverrideContext_default.Provider, { value: null }, /* @__PURE__ */ import_react.createElement(MenuContext_default.Provider, { value: contextValue }, /* @__PURE__ */ import_react.createElement(es_default$14, {
		getPopupContainer,
		overflowedIndicator: /* @__PURE__ */ import_react.createElement(EllipsisOutlined_default, null),
		overflowedIndicatorPopupClassName: clsx(prefixCls, `${prefixCls}-${theme}`, overflowedIndicatorPopupClassName),
		classNames: {
			list: mergedClassNames.list,
			listTitle: mergedClassNames.itemTitle
		},
		styles: {
			list: mergedStyles.list,
			listTitle: mergedStyles.itemTitle
		},
		mode: mergedMode,
		selectable: mergedSelectable,
		onClick: onItemClick,
		...passedProps,
		inlineCollapsed: mergedInlineCollapsed,
		style: {
			...mergedStyles.root,
			...contextStyle,
			...style$1
		},
		className: menuClassName,
		prefixCls,
		direction,
		defaultMotions,
		expandIcon: mergedExpandIcon,
		ref,
		rootClassName: clsx(rootClassName, hashId, overrideObj.rootClassName, cssVarCls, rootCls, mergedClassNames.root),
		_internalComponents: MENU_COMPONENTS
	})));
});
var menu_default$1 = InternalMenu;

//#endregion
//#region node_modules/antd/es/menu/index.js
var Menu = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	const menuRef = (0, import_react.useRef)(null);
	const context = import_react.useContext(SiderContext);
	(0, import_react.useImperativeHandle)(ref, () => ({
		menu: menuRef.current,
		focus: (options) => {
			menuRef.current?.focus(options);
		}
	}));
	return /* @__PURE__ */ import_react.createElement(menu_default$1, {
		ref: menuRef,
		...props,
		...context
	});
});
Menu.Item = MenuItem_default$1;
Menu.SubMenu = SubMenu_default;
Menu.Divider = MenuDivider_default;
Menu.ItemGroup = MenuItemGroup_default;
Menu.displayName = "Menu";
var menu_default = Menu;

//#endregion
//#region node_modules/antd/es/dropdown/style/status.js
var genStatusStyle$2 = (token$1) => {
	const { componentCls, menuCls, colorError, colorTextLightSolid } = token$1;
	const itemCls = `${menuCls}-item`;
	return { [`${componentCls}, ${componentCls}-menu-submenu`]: { [`${menuCls} ${itemCls}`]: { [`&${itemCls}-danger:not(${itemCls}-disabled)`]: {
		color: colorError,
		"&:hover": {
			color: colorTextLightSolid,
			backgroundColor: colorError
		}
	} } } };
};
var status_default$1 = genStatusStyle$2;

//#endregion
//#region node_modules/antd/es/dropdown/style/index.js
var genBaseStyle$11 = (token$1) => {
	const { componentCls, menuCls, zIndexPopup, dropdownArrowDistance, sizePopupArrow, antCls, iconCls, motionDurationMid, paddingBlock, fontSize, dropdownEdgeChildPadding, colorTextDisabled, fontSizeIcon, controlPaddingHorizontal, colorBgElevated } = token$1;
	return [
		{ [componentCls]: {
			position: "absolute",
			top: -9999,
			left: {
				_skip_check_: true,
				value: -9999
			},
			zIndex: zIndexPopup,
			display: "block",
			"&::before": {
				position: "absolute",
				insetBlock: token$1.calc(sizePopupArrow).div(2).sub(dropdownArrowDistance).equal(),
				zIndex: -9999,
				opacity: 1e-4,
				content: "\"\""
			},
			"&-menu-vertical": {
				maxHeight: "100vh",
				overflowY: "auto"
			},
			[`&-trigger${antCls}-btn`]: { [`& > ${iconCls}-down, & > ${antCls}-btn-icon > ${iconCls}-down`]: { fontSize: fontSizeIcon } },
			[`${componentCls}-wrap`]: {
				position: "relative",
				[`${antCls}-btn > ${iconCls}-down`]: { fontSize: fontSizeIcon },
				[`${iconCls}-down::before`]: { transition: `transform ${motionDurationMid}` }
			},
			[`${componentCls}-wrap-open`]: { [`${iconCls}-down::before`]: { transform: `rotate(180deg)` } },
			[`
        &-hidden,
        &-menu-hidden,
        &-menu-submenu-hidden
      `]: { display: "none" },
			[`&${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomRight,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomRight`]: { animationName: slideUpIn },
			[`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-top,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-top,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topRight`]: { animationName: slideDownIn },
			[`&${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomRight`]: { animationName: slideUpOut },
			[`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-top,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topRight`]: { animationName: slideDownOut }
		} },
		getArrowStyle(token$1, colorBgElevated, { arrowPlacement: {
			top: true,
			bottom: true
		} }),
		{
			[`${componentCls} ${menuCls}`]: {
				position: "relative",
				margin: 0
			},
			[`${menuCls}-submenu-popup`]: {
				position: "absolute",
				zIndex: zIndexPopup,
				background: "transparent",
				boxShadow: "none",
				transformOrigin: "0 0",
				"ul, li": {
					listStyle: "none",
					margin: 0
				}
			},
			[`${componentCls}, ${componentCls}-menu-submenu`]: {
				...resetComponent(token$1),
				[menuCls]: {
					padding: dropdownEdgeChildPadding,
					listStyleType: "none",
					backgroundColor: colorBgElevated,
					backgroundClip: "padding-box",
					borderRadius: token$1.borderRadiusLG,
					outline: "none",
					boxShadow: token$1.boxShadowSecondary,
					...genFocusStyle(token$1),
					"&:empty": {
						padding: 0,
						boxShadow: "none"
					},
					[`${menuCls}-item-group-title`]: {
						padding: `${unit(paddingBlock)} ${unit(controlPaddingHorizontal)}`,
						color: token$1.colorTextDescription,
						transition: `all ${motionDurationMid}`
					},
					[`${menuCls}-item`]: {
						position: "relative",
						display: "flex",
						alignItems: "center"
					},
					[`${menuCls}-item-icon`]: {
						minWidth: fontSize,
						marginInlineEnd: token$1.marginXS,
						fontSize: token$1.fontSizeSM
					},
					[`${menuCls}-title-content`]: {
						flex: "auto",
						"&-with-extra": {
							display: "inline-flex",
							alignItems: "center",
							width: "100%"
						},
						"> a": {
							color: "inherit",
							transition: `all ${motionDurationMid}`,
							"&:hover": { color: "inherit" },
							"&::after": {
								position: "absolute",
								inset: 0,
								content: "\"\""
							}
						},
						[`${menuCls}-item-extra`]: {
							paddingInlineStart: token$1.padding,
							marginInlineStart: "auto",
							fontSize: token$1.fontSizeSM,
							color: token$1.colorTextDescription
						}
					},
					[`${menuCls}-item, ${menuCls}-submenu-title`]: {
						display: "flex",
						margin: 0,
						padding: `${unit(paddingBlock)} ${unit(controlPaddingHorizontal)}`,
						color: token$1.colorText,
						fontWeight: "normal",
						fontSize,
						lineHeight: token$1.lineHeight,
						cursor: "pointer",
						transition: `all ${motionDurationMid}`,
						borderRadius: token$1.borderRadiusSM,
						"&:hover, &-active": { backgroundColor: token$1.controlItemBgHover },
						...genFocusStyle(token$1),
						"&-selected": {
							color: token$1.colorPrimary,
							backgroundColor: token$1.controlItemBgActive,
							"&:hover, &-active": { backgroundColor: token$1.controlItemBgActiveHover }
						},
						"&-disabled": {
							color: colorTextDisabled,
							cursor: "not-allowed",
							"&:hover": {
								color: colorTextDisabled,
								backgroundColor: colorBgElevated,
								cursor: "not-allowed"
							},
							a: { pointerEvents: "none" }
						},
						"&-divider": {
							height: 1,
							margin: `${unit(token$1.marginXXS)} 0`,
							overflow: "hidden",
							lineHeight: 0,
							backgroundColor: token$1.colorSplit
						},
						[`${componentCls}-menu-submenu-expand-icon`]: {
							position: "absolute",
							insetInlineEnd: token$1.paddingXS,
							[`${componentCls}-menu-submenu-arrow-icon`]: {
								marginInlineEnd: "0 !important",
								color: token$1.colorIcon,
								fontSize: fontSizeIcon,
								fontStyle: "normal"
							}
						}
					},
					[`${menuCls}-item-group-list`]: {
						margin: `0 ${unit(token$1.marginXS)}`,
						padding: 0,
						listStyle: "none"
					},
					[`${menuCls}-submenu-title`]: { paddingInlineEnd: token$1.calc(controlPaddingHorizontal).add(token$1.fontSizeSM).equal() },
					[`${menuCls}-submenu-vertical`]: { position: "relative" },
					[`${menuCls}-submenu${menuCls}-submenu-disabled ${componentCls}-menu-submenu-title`]: { [`&, ${componentCls}-menu-submenu-arrow-icon`]: {
						color: colorTextDisabled,
						backgroundColor: colorBgElevated,
						cursor: "not-allowed"
					} },
					[`${menuCls}-submenu-selected ${componentCls}-menu-submenu-title`]: { color: token$1.colorPrimary }
				}
			}
		},
		[
			initSlideMotion(token$1, "slide-up"),
			initSlideMotion(token$1, "slide-down"),
			initMoveMotion(token$1, "move-up"),
			initMoveMotion(token$1, "move-down"),
			initZoomMotion(token$1, "zoom-big")
		]
	];
};
const prepareComponentToken$39 = (token$1) => ({
	zIndexPopup: token$1.zIndexPopupBase + 50,
	paddingBlock: (token$1.controlHeight - token$1.fontSize * token$1.lineHeight) / 2,
	...getArrowOffsetToken({
		contentRadius: token$1.borderRadiusLG,
		limitVerticalRadius: true
	}),
	...getArrowToken(token$1)
});
var style_default$47 = genStyleHooks("Dropdown", (token$1) => {
	const { marginXXS, sizePopupArrow, paddingXXS, componentCls } = token$1;
	const dropdownToken = merge(token$1, {
		menuCls: `${componentCls}-menu`,
		dropdownArrowDistance: token$1.calc(sizePopupArrow).div(2).add(marginXXS).equal(),
		dropdownEdgeChildPadding: paddingXXS
	});
	return [genBaseStyle$11(dropdownToken), status_default$1(dropdownToken)];
}, prepareComponentToken$39, { resetStyle: false });

//#endregion
//#region node_modules/antd/es/dropdown/dropdown.js
var Dropdown$1 = (props) => {
	const { menu, arrow, prefixCls: customizePrefixCls, children, trigger, disabled, dropdownRender, popupRender, getPopupContainer, overlayClassName, rootClassName, overlayStyle, open: open$2, onOpenChange, mouseEnterDelay = .15, mouseLeaveDelay = .1, autoAdjustOverflow: autoAdjustOverflow$2 = true, placement = "", transitionName, classNames, styles, destroyPopupOnHide, destroyOnHidden } = props;
	const { getPrefixCls, direction, getPopupContainer: getContextPopupContainer, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("dropdown");
	const mergedProps = {
		...props,
		mouseEnterDelay,
		mouseLeaveDelay,
		autoAdjustOverflow: autoAdjustOverflow$2
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const mergedRootStyles = {
		...contextStyle,
		...overlayStyle,
		...mergedStyles.root
	};
	const mergedPopupRender = popupRender || dropdownRender;
	const warning$3 = devUseWarning("Dropdown");
	Object.entries({
		dropdownRender: "popupRender",
		destroyPopupOnHide: "destroyOnHidden",
		overlayClassName: "classNames.root",
		overlayStyle: "styles.root"
	}).forEach(([deprecatedName, newName]) => {
		warning$3.deprecated(!(deprecatedName in props), deprecatedName, newName);
	});
	if (placement.includes("Center")) warning$3.deprecated(!placement.includes("Center"), `placement: ${placement}`, `placement: ${placement.slice(0, placement.indexOf("Center"))}`);
	const memoTransitionName = import_react.useMemo(() => {
		const rootPrefixCls = getPrefixCls();
		if (transitionName !== void 0) return transitionName;
		if (placement.includes("top")) return `${rootPrefixCls}-slide-down`;
		return `${rootPrefixCls}-slide-up`;
	}, [
		getPrefixCls,
		placement,
		transitionName
	]);
	const memoPlacement = import_react.useMemo(() => {
		if (!placement) return direction === "rtl" ? "bottomRight" : "bottomLeft";
		if (placement.includes("Center")) return placement.slice(0, placement.indexOf("Center"));
		return placement;
	}, [placement, direction]);
	const prefixCls = getPrefixCls("dropdown", customizePrefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$47(prefixCls, rootCls);
	const [, token$1] = useToken();
	const child = import_react.Children.only(isPrimitive_default(children) ? /* @__PURE__ */ import_react.createElement("span", null, children) : children);
	const popupTrigger = cloneElement(child, {
		className: clsx(`${prefixCls}-trigger`, { [`${prefixCls}-rtl`]: direction === "rtl" }, child.props.className),
		disabled: child.props.disabled ?? disabled
	});
	const triggerActions = disabled ? [] : trigger;
	const alignPoint = !!triggerActions?.includes("contextMenu");
	const [mergedOpen, setOpen] = useControlledState(false, open$2);
	const onInnerOpenChange = useEvent_default((nextOpen) => {
		onOpenChange?.(nextOpen, { source: "trigger" });
		setOpen(nextOpen);
	});
	const overlayClassNameCustomized = clsx(overlayClassName, rootClassName, hashId, cssVarCls, rootCls, contextClassName, mergedClassNames.root, { [`${prefixCls}-rtl`]: direction === "rtl" });
	const builtinPlacements = getPlacements({
		arrowPointAtCenter: typeof arrow === "object" && arrow.pointAtCenter,
		autoAdjustOverflow: autoAdjustOverflow$2,
		offset: token$1.marginXXS,
		arrowWidth: arrow ? token$1.sizePopupArrow : 0,
		borderRadius: token$1.borderRadius
	});
	const onMenuClick = useEvent_default(() => {
		if (menu?.selectable && menu?.multiple) return;
		onOpenChange?.(false, { source: "menu" });
		setOpen(false);
	});
	const renderOverlay = () => {
		const menuClassNames = omit(mergedClassNames, ["root"]);
		const menuStyles = omit(mergedStyles, ["root"]);
		let overlayNode;
		if (menu?.items) overlayNode = /* @__PURE__ */ import_react.createElement(menu_default, {
			...menu,
			classNames: {
				...menuClassNames,
				subMenu: { ...menuClassNames }
			},
			styles: {
				...menuStyles,
				subMenu: { ...menuStyles }
			}
		});
		if (mergedPopupRender) overlayNode = mergedPopupRender(overlayNode);
		overlayNode = import_react.Children.only(typeof overlayNode === "string" ? /* @__PURE__ */ import_react.createElement("span", null, overlayNode) : overlayNode);
		return /* @__PURE__ */ import_react.createElement(OverrideProvider, {
			prefixCls: `${prefixCls}-menu`,
			rootClassName: clsx(cssVarCls, rootCls),
			expandIcon: /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-menu-submenu-arrow` }, direction === "rtl" ? /* @__PURE__ */ import_react.createElement(LeftOutlined_default, { className: `${prefixCls}-menu-submenu-arrow-icon` }) : /* @__PURE__ */ import_react.createElement(RightOutlined_default, { className: `${prefixCls}-menu-submenu-arrow-icon` })),
			mode: "vertical",
			selectable: false,
			onClick: onMenuClick,
			validator: ({ mode }) => {
				warning$3(!mode || mode === "vertical", "usage", `mode="${mode}" is not supported for Dropdown's Menu.`);
			}
		}, overlayNode);
	};
	const [zIndex, contextZIndex] = useZIndex("Dropdown", mergedRootStyles.zIndex);
	let renderNode = /* @__PURE__ */ import_react.createElement(es_default$29, {
		alignPoint,
		...omit(props, ["rootClassName", "onOpenChange"]),
		mouseEnterDelay,
		mouseLeaveDelay,
		visible: mergedOpen,
		builtinPlacements,
		arrow: !!arrow,
		overlayClassName: overlayClassNameCustomized,
		prefixCls,
		getPopupContainer: getPopupContainer || getContextPopupContainer,
		transitionName: memoTransitionName,
		trigger: triggerActions,
		overlay: renderOverlay,
		placement: memoPlacement,
		onVisibleChange: onInnerOpenChange,
		overlayStyle: {
			...mergedRootStyles,
			zIndex
		},
		autoDestroy: destroyOnHidden ?? destroyPopupOnHide
	}, popupTrigger);
	if (zIndex) renderNode = /* @__PURE__ */ import_react.createElement(zindexContext_default.Provider, { value: contextZIndex }, renderNode);
	return renderNode;
};
var PurePanel$8 = PurePanel_default(Dropdown$1, "align", void 0, "dropdown", (prefixCls) => prefixCls);
/* istanbul ignore next */
var WrapPurePanel = (props) => /* @__PURE__ */ import_react.createElement(PurePanel$8, { ...props }, /* @__PURE__ */ import_react.createElement("span", null));
Dropdown$1._InternalPanelDoNotUseOrYouWillBeFired = WrapPurePanel;
Dropdown$1.displayName = "Dropdown";
var dropdown_default$1 = Dropdown$1;

//#endregion
//#region node_modules/antd/es/breadcrumb/BreadcrumbSeparator.js
var BreadcrumbSeparator = ({ children }) => {
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("breadcrumb");
	const { classNames: mergedClassNames, styles: mergedStyles } = import_react.useContext(BreadcrumbContext_default);
	return /* @__PURE__ */ import_react.createElement("li", {
		className: clsx(`${prefixCls}-separator`, mergedClassNames?.separator),
		style: mergedStyles?.separator,
		"aria-hidden": "true"
	}, children === "" ? children : children || "/");
};
BreadcrumbSeparator.__ANT_BREADCRUMB_SEPARATOR = true;
var BreadcrumbSeparator_default = BreadcrumbSeparator;

//#endregion
//#region node_modules/antd/es/breadcrumb/useItemRender.js
function getBreadcrumbName(route, params) {
	if (!isNonNullable_default(route.title)) return null;
	const paramsKeys = Object.keys(params).join("|");
	return typeof route.title === "object" ? route.title : String(route.title).replace(new RegExp(`:(${paramsKeys})`, "g"), (replacement, key) => params[key] || replacement);
}
function renderItem(prefixCls, item, children, href) {
	if (!isNonNullable_default(children)) return null;
	const { className, onClick, ...restItem } = item;
	const passedProps = {
		...pickAttrs(restItem, {
			data: true,
			aria: true
		}),
		onClick
	};
	if (href !== void 0) return /* @__PURE__ */ import_react.createElement("a", {
		...passedProps,
		className: clsx(`${prefixCls}-link`, className),
		href
	}, children);
	return /* @__PURE__ */ import_react.createElement("span", {
		...passedProps,
		className: clsx(`${prefixCls}-link`, className)
	}, children);
}
function useItemRender(prefixCls, itemRender) {
	const mergedItemRender = (item, params, routes, path$1, href) => {
		if (itemRender) return itemRender(item, params, routes, path$1);
		return renderItem(prefixCls, item, getBreadcrumbName(item, params), href);
	};
	return mergedItemRender;
}

//#endregion
//#region node_modules/antd/es/breadcrumb/BreadcrumbItem.js
const InternalBreadcrumbItem = (props) => {
	const { prefixCls, separator = "/", children, menu, dropdownProps, href } = props;
	const { classNames: mergedClassNames, styles: mergedStyles } = import_react.useContext(BreadcrumbContext_default);
	/** If overlay is have Wrap a Dropdown */
	const renderBreadcrumbNode = (breadcrumbItem) => {
		if (menu) {
			const mergeDropDownProps = { ...dropdownProps };
			if (menu) {
				const { items, ...menuProps } = menu || {};
				mergeDropDownProps.menu = {
					...menuProps,
					items: items?.map(({ key, title, label, path: path$1, ...itemProps }, index$1) => {
						let mergedLabel = label ?? title;
						if (path$1) mergedLabel = /* @__PURE__ */ import_react.createElement("a", { href: `${href}${path$1}` }, mergedLabel);
						return {
							...itemProps,
							key: key ?? index$1,
							label: mergedLabel
						};
					})
				};
			}
			return /* @__PURE__ */ import_react.createElement(dropdown_default$1, {
				placement: "bottom",
				...mergeDropDownProps
			}, /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-overlay-link` }, breadcrumbItem, /* @__PURE__ */ import_react.createElement(DownOutlined_default, null)));
		}
		return breadcrumbItem;
	};
	const link = renderBreadcrumbNode(children);
	if (isNonNullable_default(link)) return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("li", {
		className: clsx_default(`${prefixCls}-item`, mergedClassNames?.item),
		style: mergedStyles?.item
	}, link), separator && /* @__PURE__ */ import_react.createElement(BreadcrumbSeparator_default, null, separator));
	return null;
};
var BreadcrumbItem = (props) => {
	const { prefixCls: customizePrefixCls, children, href, ...restProps } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("breadcrumb", customizePrefixCls);
	return /* @__PURE__ */ import_react.createElement(InternalBreadcrumbItem, {
		...restProps,
		prefixCls
	}, renderItem(prefixCls, restProps, children, href));
};
BreadcrumbItem.__ANT_BREADCRUMB_ITEM = true;
var BreadcrumbItem_default = BreadcrumbItem;

//#endregion
//#region node_modules/antd/es/breadcrumb/style/index.js
var genBreadcrumbStyle = (token$1) => {
	const { componentCls, iconCls, calc } = token$1;
	return { [componentCls]: {
		...resetComponent(token$1),
		color: token$1.itemColor,
		fontSize: token$1.fontSize,
		[iconCls]: { fontSize: token$1.iconFontSize },
		ol: {
			display: "flex",
			flexWrap: "wrap",
			margin: 0,
			padding: 0,
			listStyle: "none"
		},
		[`${componentCls}-item a`]: {
			color: token$1.linkColor,
			transition: `color ${token$1.motionDurationMid}`,
			padding: `0 ${unit(token$1.paddingXXS)}`,
			borderRadius: token$1.borderRadiusSM,
			height: token$1.fontHeight,
			display: "inline-block",
			marginInline: calc(token$1.marginXXS).mul(-1).equal(),
			"&:hover": {
				color: token$1.linkHoverColor,
				backgroundColor: token$1.colorBgTextHover
			},
			...genFocusStyle(token$1)
		},
		[`${componentCls}-item:last-child`]: { color: token$1.lastItemColor },
		[`${componentCls}-separator`]: {
			marginInline: token$1.separatorMargin,
			color: token$1.separatorColor
		},
		[`${componentCls}-link`]: { [`
          > ${iconCls} + span,
          > ${iconCls} + a
        `]: { marginInlineStart: token$1.marginXXS } },
		[`${componentCls}-overlay-link`]: {
			borderRadius: token$1.borderRadiusSM,
			height: token$1.fontHeight,
			display: "inline-block",
			padding: `0 ${unit(token$1.paddingXXS)}`,
			marginInline: calc(token$1.marginXXS).mul(-1).equal(),
			[`> ${iconCls}`]: {
				marginInlineStart: token$1.marginXXS,
				fontSize: token$1.fontSizeIcon
			},
			"&:hover": {
				color: token$1.linkHoverColor,
				backgroundColor: token$1.colorBgTextHover,
				a: { color: token$1.linkHoverColor }
			},
			a: { "&:hover": { backgroundColor: "transparent" } }
		},
		[`&${token$1.componentCls}-rtl`]: { direction: "rtl" }
	} };
};
const prepareComponentToken$38 = (token$1) => ({
	itemColor: token$1.colorTextDescription,
	lastItemColor: token$1.colorText,
	iconFontSize: token$1.fontSize,
	linkColor: token$1.colorTextDescription,
	linkHoverColor: token$1.colorText,
	separatorColor: token$1.colorTextDescription,
	separatorMargin: token$1.marginXS
});
var style_default$46 = genStyleHooks("Breadcrumb", (token$1) => {
	return genBreadcrumbStyle(merge(token$1, {}));
}, prepareComponentToken$38);

//#endregion
//#region node_modules/antd/es/breadcrumb/useItems.js
function route2item(route) {
	const { breadcrumbName, children, ...rest } = route;
	const clone = {
		title: breadcrumbName,
		...rest
	};
	if (children) clone.menu = { items: children.map(({ breadcrumbName: itemBreadcrumbName, ...itemProps }) => ({
		...itemProps,
		title: itemBreadcrumbName
	})) };
	return clone;
}
function useItems$3(items, routes) {
	return (0, import_react.useMemo)(() => {
		if (items) return items;
		if (routes) return routes.map(route2item);
		return null;
	}, [items, routes]);
}

//#endregion
//#region node_modules/antd/es/breadcrumb/Breadcrumb.js
var getPath = (params, path$1) => {
	if (path$1 === void 0) return path$1;
	let mergedPath = (path$1 || "").replace(/^\//, "");
	Object.keys(params).forEach((key) => {
		mergedPath = mergedPath.replace(`:${key}`, params[key]);
	});
	return mergedPath;
};
var Breadcrumb = (props) => {
	const { prefixCls: customizePrefixCls, separator, style: style$1, className, rootClassName, routes: legacyRoutes, items, children, itemRender, params = {}, classNames, styles, ...restProps } = props;
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles, separator: contextSeparator } = useComponentConfig("breadcrumb");
	const mergedSeparator = separator ?? contextSeparator ?? "/";
	let crumbs;
	const prefixCls = getPrefixCls("breadcrumb", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$46(prefixCls);
	const mergedItems = useItems$3(items, legacyRoutes);
	const mergedProps = import_react.useMemo(() => {
		return {
			...props,
			separator: mergedSeparator
		};
	}, [props, mergedSeparator]);
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	{
		const warning$3 = devUseWarning("Breadcrumb");
		warning$3.deprecated(!legacyRoutes, "routes", "items");
		if (!mergedItems || mergedItems.length === 0) {
			const childList = toArray(children);
			warning$3.deprecated(childList.length === 0, "Breadcrumb.Item and Breadcrumb.Separator", "items");
			childList.forEach((element) => {
				if (element) warning$3(element.type && (element.type.__ANT_BREADCRUMB_ITEM === true || element.type.__ANT_BREADCRUMB_SEPARATOR === true), "usage", "Only accepts Breadcrumb.Item and Breadcrumb.Separator as it's children");
			});
		}
	}
	const mergedItemRender = useItemRender(prefixCls, itemRender);
	if (mergedItems && mergedItems.length > 0) {
		const paths = [];
		const itemRenderRoutes = items || legacyRoutes;
		crumbs = mergedItems.map((item, index$1) => {
			const { path: path$1, key, type: type$2, menu, onClick, className: itemClassName, style: style$2, separator: itemSeparator, dropdownProps } = item;
			const mergedPath = getPath(params, path$1);
			if (mergedPath !== void 0) paths.push(mergedPath);
			const mergedKey = key ?? index$1;
			if (type$2 === "separator") return /* @__PURE__ */ import_react.createElement(BreadcrumbSeparator_default, { key: mergedKey }, itemSeparator);
			const itemProps = {};
			const isLastItem = index$1 === mergedItems.length - 1;
			if (menu) itemProps.menu = menu;
			let { href } = item;
			if (paths.length && mergedPath !== void 0) href = `#/${paths.join("/")}`;
			return /* @__PURE__ */ import_react.createElement(InternalBreadcrumbItem, {
				key: mergedKey,
				...itemProps,
				...pickAttrs(item, {
					data: true,
					aria: true
				}),
				className: itemClassName,
				style: style$2,
				dropdownProps,
				href,
				separator: isLastItem ? "" : mergedSeparator,
				onClick,
				prefixCls
			}, mergedItemRender(item, params, itemRenderRoutes, paths, href));
		});
	} else if (children) {
		const childrenLength = toArray(children).length;
		crumbs = toArray(children).map((element, index$1) => {
			if (!element) return element;
			return cloneElement(element, {
				separator: index$1 === childrenLength - 1 ? "" : mergedSeparator,
				key: index$1
			});
		});
	}
	const breadcrumbClassName = clsx(prefixCls, contextClassName, { [`${prefixCls}-rtl`]: direction === "rtl" }, className, rootClassName, mergedClassNames.root, hashId, cssVarCls);
	const mergedStyle = {
		...mergedStyles.root,
		...contextStyle,
		...style$1
	};
	const memoizedValue = import_react.useMemo(() => ({
		classNames: mergedClassNames,
		styles: mergedStyles
	}), [mergedClassNames, mergedStyles]);
	return /* @__PURE__ */ import_react.createElement(BreadcrumbContext_default.Provider, { value: memoizedValue }, /* @__PURE__ */ import_react.createElement("nav", {
		className: breadcrumbClassName,
		style: mergedStyle,
		...restProps
	}, /* @__PURE__ */ import_react.createElement("ol", null, crumbs)));
};
Breadcrumb.Item = BreadcrumbItem_default;
Breadcrumb.Separator = BreadcrumbSeparator_default;
Breadcrumb.displayName = "Breadcrumb";
var Breadcrumb_default = Breadcrumb;

//#endregion
//#region node_modules/antd/es/breadcrumb/index.js
var breadcrumb_default = Breadcrumb_default;

//#endregion
//#region node_modules/antd/es/button/index.js
var button_default = Button_default;

//#endregion
//#region node_modules/dayjs/dayjs.min.js
var require_dayjs_min = /* @__PURE__ */ __commonJS({ "node_modules/dayjs/dayjs.min.js": ((exports, module) => {
	(function(t$1, e$2) {
		"object" == typeof exports && "undefined" != typeof module ? module.exports = e$2() : "function" == typeof define && define.amd ? define(e$2) : (t$1 = "undefined" != typeof globalThis ? globalThis : t$1 || self).dayjs = e$2();
	})(exports, (function() {
		var t$1 = 1e3, e$2 = 6e4, n$1 = 36e5, r$1 = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o$2 = "week", c = "month", f = "quarter", h = "year", d = "date", l$1 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = {
			name: "en",
			weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
			months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
			ordinal: function(t$2) {
				var e$3 = [
					"th",
					"st",
					"nd",
					"rd"
				], n$2 = t$2 % 100;
				return "[" + t$2 + (e$3[(n$2 - 20) % 10] || e$3[n$2] || e$3[0]) + "]";
			}
		}, m = function(t$2, e$3, n$2) {
			var r$2 = String(t$2);
			return !r$2 || r$2.length >= e$3 ? t$2 : "" + Array(e$3 + 1 - r$2.length).join(n$2) + t$2;
		}, v = {
			s: m,
			z: function(t$2) {
				var e$3 = -t$2.utcOffset(), n$2 = Math.abs(e$3), r$2 = Math.floor(n$2 / 60), i$1 = n$2 % 60;
				return (e$3 <= 0 ? "+" : "-") + m(r$2, 2, "0") + ":" + m(i$1, 2, "0");
			},
			m: function t$2(e$3, n$2) {
				if (e$3.date() < n$2.date()) return -t$2(n$2, e$3);
				var r$2 = 12 * (n$2.year() - e$3.year()) + (n$2.month() - e$3.month()), i$1 = e$3.clone().add(r$2, c), s$1 = n$2 - i$1 < 0, u$1 = e$3.clone().add(r$2 + (s$1 ? -1 : 1), c);
				return +(-(r$2 + (n$2 - i$1) / (s$1 ? i$1 - u$1 : u$1 - i$1)) || 0);
			},
			a: function(t$2) {
				return t$2 < 0 ? Math.ceil(t$2) || 0 : Math.floor(t$2);
			},
			p: function(t$2) {
				return {
					M: c,
					y: h,
					w: o$2,
					d: a,
					D: d,
					h: u,
					m: s,
					s: i,
					ms: r$1,
					Q: f
				}[t$2] || String(t$2 || "").toLowerCase().replace(/s$/, "");
			},
			u: function(t$2) {
				return void 0 === t$2;
			}
		}, g = "en", D = {};
		D[g] = M;
		var p = "$isDayjsObject", S = function(t$2) {
			return t$2 instanceof _ || !(!t$2 || !t$2[p]);
		}, w = function t$2(e$3, n$2, r$2) {
			var i$1;
			if (!e$3) return g;
			if ("string" == typeof e$3) {
				var s$1 = e$3.toLowerCase();
				D[s$1] && (i$1 = s$1), n$2 && (D[s$1] = n$2, i$1 = s$1);
				var u$1 = e$3.split("-");
				if (!i$1 && u$1.length > 1) return t$2(u$1[0]);
			} else {
				var a$1 = e$3.name;
				D[a$1] = e$3, i$1 = a$1;
			}
			return !r$2 && i$1 && (g = i$1), i$1 || !r$2 && g;
		}, O = function(t$2, e$3) {
			if (S(t$2)) return t$2.clone();
			var n$2 = "object" == typeof e$3 ? e$3 : {};
			return n$2.date = t$2, n$2.args = arguments, new _(n$2);
		}, b = v;
		b.l = w, b.i = S, b.w = function(t$2, e$3) {
			return O(t$2, {
				locale: e$3.$L,
				utc: e$3.$u,
				x: e$3.$x,
				$offset: e$3.$offset
			});
		};
		var _ = function() {
			function M$1(t$2) {
				this.$L = w(t$2.locale, null, !0), this.parse(t$2), this.$x = this.$x || t$2.x || {}, this[p] = !0;
			}
			var m$1 = M$1.prototype;
			return m$1.parse = function(t$2) {
				this.$d = function(t$3) {
					var e$3 = t$3.date, n$2 = t$3.utc;
					if (null === e$3) return /* @__PURE__ */ new Date(NaN);
					if (b.u(e$3)) return /* @__PURE__ */ new Date();
					if (e$3 instanceof Date) return new Date(e$3);
					if ("string" == typeof e$3 && !/Z$/i.test(e$3)) {
						var r$2 = e$3.match($);
						if (r$2) {
							var i$1 = r$2[2] - 1 || 0, s$1 = (r$2[7] || "0").substring(0, 3);
							return n$2 ? new Date(Date.UTC(r$2[1], i$1, r$2[3] || 1, r$2[4] || 0, r$2[5] || 0, r$2[6] || 0, s$1)) : new Date(r$2[1], i$1, r$2[3] || 1, r$2[4] || 0, r$2[5] || 0, r$2[6] || 0, s$1);
						}
					}
					return new Date(e$3);
				}(t$2), this.init();
			}, m$1.init = function() {
				var t$2 = this.$d;
				this.$y = t$2.getFullYear(), this.$M = t$2.getMonth(), this.$D = t$2.getDate(), this.$W = t$2.getDay(), this.$H = t$2.getHours(), this.$m = t$2.getMinutes(), this.$s = t$2.getSeconds(), this.$ms = t$2.getMilliseconds();
			}, m$1.$utils = function() {
				return b;
			}, m$1.isValid = function() {
				return !(this.$d.toString() === l$1);
			}, m$1.isSame = function(t$2, e$3) {
				var n$2 = O(t$2);
				return this.startOf(e$3) <= n$2 && n$2 <= this.endOf(e$3);
			}, m$1.isAfter = function(t$2, e$3) {
				return O(t$2) < this.startOf(e$3);
			}, m$1.isBefore = function(t$2, e$3) {
				return this.endOf(e$3) < O(t$2);
			}, m$1.$g = function(t$2, e$3, n$2) {
				return b.u(t$2) ? this[e$3] : this.set(n$2, t$2);
			}, m$1.unix = function() {
				return Math.floor(this.valueOf() / 1e3);
			}, m$1.valueOf = function() {
				return this.$d.getTime();
			}, m$1.startOf = function(t$2, e$3) {
				var n$2 = this, r$2 = !!b.u(e$3) || e$3, f$1 = b.p(t$2), l$2 = function(t$3, e$4) {
					var i$1 = b.w(n$2.$u ? Date.UTC(n$2.$y, e$4, t$3) : new Date(n$2.$y, e$4, t$3), n$2);
					return r$2 ? i$1 : i$1.endOf(a);
				}, $$1 = function(t$3, e$4) {
					return b.w(n$2.toDate()[t$3].apply(n$2.toDate("s"), (r$2 ? [
						0,
						0,
						0,
						0
					] : [
						23,
						59,
						59,
						999
					]).slice(e$4)), n$2);
				}, y$1 = this.$W, M$2 = this.$M, m$2 = this.$D, v$1 = "set" + (this.$u ? "UTC" : "");
				switch (f$1) {
					case h: return r$2 ? l$2(1, 0) : l$2(31, 11);
					case c: return r$2 ? l$2(1, M$2) : l$2(0, M$2 + 1);
					case o$2:
						var g$1 = this.$locale().weekStart || 0, D$1 = (y$1 < g$1 ? y$1 + 7 : y$1) - g$1;
						return l$2(r$2 ? m$2 - D$1 : m$2 + (6 - D$1), M$2);
					case a:
					case d: return $$1(v$1 + "Hours", 0);
					case u: return $$1(v$1 + "Minutes", 1);
					case s: return $$1(v$1 + "Seconds", 2);
					case i: return $$1(v$1 + "Milliseconds", 3);
					default: return this.clone();
				}
			}, m$1.endOf = function(t$2) {
				return this.startOf(t$2, !1);
			}, m$1.$set = function(t$2, e$3) {
				var n$2, o$3 = b.p(t$2), f$1 = "set" + (this.$u ? "UTC" : ""), l$2 = (n$2 = {}, n$2[a] = f$1 + "Date", n$2[d] = f$1 + "Date", n$2[c] = f$1 + "Month", n$2[h] = f$1 + "FullYear", n$2[u] = f$1 + "Hours", n$2[s] = f$1 + "Minutes", n$2[i] = f$1 + "Seconds", n$2[r$1] = f$1 + "Milliseconds", n$2)[o$3], $$1 = o$3 === a ? this.$D + (e$3 - this.$W) : e$3;
				if (o$3 === c || o$3 === h) {
					var y$1 = this.clone().set(d, 1);
					y$1.$d[l$2]($$1), y$1.init(), this.$d = y$1.set(d, Math.min(this.$D, y$1.daysInMonth())).$d;
				} else l$2 && this.$d[l$2]($$1);
				return this.init(), this;
			}, m$1.set = function(t$2, e$3) {
				return this.clone().$set(t$2, e$3);
			}, m$1.get = function(t$2) {
				return this[b.p(t$2)]();
			}, m$1.add = function(r$2, f$1) {
				var d$1, l$2 = this;
				r$2 = Number(r$2);
				var $$1 = b.p(f$1), y$1 = function(t$2) {
					var e$3 = O(l$2);
					return b.w(e$3.date(e$3.date() + Math.round(t$2 * r$2)), l$2);
				};
				if ($$1 === c) return this.set(c, this.$M + r$2);
				if ($$1 === h) return this.set(h, this.$y + r$2);
				if ($$1 === a) return y$1(1);
				if ($$1 === o$2) return y$1(7);
				var M$2 = (d$1 = {}, d$1[s] = e$2, d$1[u] = n$1, d$1[i] = t$1, d$1)[$$1] || 1, m$2 = this.$d.getTime() + r$2 * M$2;
				return b.w(m$2, this);
			}, m$1.subtract = function(t$2, e$3) {
				return this.add(-1 * t$2, e$3);
			}, m$1.format = function(t$2) {
				var e$3 = this, n$2 = this.$locale();
				if (!this.isValid()) return n$2.invalidDate || l$1;
				var r$2 = t$2 || "YYYY-MM-DDTHH:mm:ssZ", i$1 = b.z(this), s$1 = this.$H, u$1 = this.$m, a$1 = this.$M, o$3 = n$2.weekdays, c$1 = n$2.months, f$1 = n$2.meridiem, h$1 = function(t$3, n$3, i$2, s$2) {
					return t$3 && (t$3[n$3] || t$3(e$3, r$2)) || i$2[n$3].slice(0, s$2);
				}, d$1 = function(t$3) {
					return b.s(s$1 % 12 || 12, t$3, "0");
				}, $$1 = f$1 || function(t$3, e$4, n$3) {
					var r$3 = t$3 < 12 ? "AM" : "PM";
					return n$3 ? r$3.toLowerCase() : r$3;
				};
				return r$2.replace(y, (function(t$3, r$3) {
					return r$3 || function(t$4) {
						switch (t$4) {
							case "YY": return String(e$3.$y).slice(-2);
							case "YYYY": return b.s(e$3.$y, 4, "0");
							case "M": return a$1 + 1;
							case "MM": return b.s(a$1 + 1, 2, "0");
							case "MMM": return h$1(n$2.monthsShort, a$1, c$1, 3);
							case "MMMM": return h$1(c$1, a$1);
							case "D": return e$3.$D;
							case "DD": return b.s(e$3.$D, 2, "0");
							case "d": return String(e$3.$W);
							case "dd": return h$1(n$2.weekdaysMin, e$3.$W, o$3, 2);
							case "ddd": return h$1(n$2.weekdaysShort, e$3.$W, o$3, 3);
							case "dddd": return o$3[e$3.$W];
							case "H": return String(s$1);
							case "HH": return b.s(s$1, 2, "0");
							case "h": return d$1(1);
							case "hh": return d$1(2);
							case "a": return $$1(s$1, u$1, !0);
							case "A": return $$1(s$1, u$1, !1);
							case "m": return String(u$1);
							case "mm": return b.s(u$1, 2, "0");
							case "s": return String(e$3.$s);
							case "ss": return b.s(e$3.$s, 2, "0");
							case "SSS": return b.s(e$3.$ms, 3, "0");
							case "Z": return i$1;
						}
						return null;
					}(t$3) || i$1.replace(":", "");
				}));
			}, m$1.utcOffset = function() {
				return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
			}, m$1.diff = function(r$2, d$1, l$2) {
				var $$1, y$1 = this, M$2 = b.p(d$1), m$2 = O(r$2), v$1 = (m$2.utcOffset() - this.utcOffset()) * e$2, g$1 = this - m$2, D$1 = function() {
					return b.m(y$1, m$2);
				};
				switch (M$2) {
					case h:
						$$1 = D$1() / 12;
						break;
					case c:
						$$1 = D$1();
						break;
					case f:
						$$1 = D$1() / 3;
						break;
					case o$2:
						$$1 = (g$1 - v$1) / 6048e5;
						break;
					case a:
						$$1 = (g$1 - v$1) / 864e5;
						break;
					case u:
						$$1 = g$1 / n$1;
						break;
					case s:
						$$1 = g$1 / e$2;
						break;
					case i:
						$$1 = g$1 / t$1;
						break;
					default: $$1 = g$1;
				}
				return l$2 ? $$1 : b.a($$1);
			}, m$1.daysInMonth = function() {
				return this.endOf(c).$D;
			}, m$1.$locale = function() {
				return D[this.$L];
			}, m$1.locale = function(t$2, e$3) {
				if (!t$2) return this.$L;
				var n$2 = this.clone(), r$2 = w(t$2, e$3, !0);
				return r$2 && (n$2.$L = r$2), n$2;
			}, m$1.clone = function() {
				return b.w(this.$d, this);
			}, m$1.toDate = function() {
				return new Date(this.valueOf());
			}, m$1.toJSON = function() {
				return this.isValid() ? this.toISOString() : null;
			}, m$1.toISOString = function() {
				return this.$d.toISOString();
			}, m$1.toString = function() {
				return this.$d.toUTCString();
			}, M$1;
		}(), k = _.prototype;
		return O.prototype = k, [
			["$ms", r$1],
			["$s", i],
			["$m", s],
			["$H", u],
			["$W", a],
			["$M", c],
			["$y", h],
			["$D", d]
		].forEach((function(t$2) {
			k[t$2[1]] = function(e$3) {
				return this.$g(e$3, t$2[0], t$2[1]);
			};
		})), O.extend = function(t$2, e$3) {
			return t$2.$i || (t$2(e$3, _, O), t$2.$i = !0), O;
		}, O.locale = w, O.isDayjs = S, O.unix = function(t$2) {
			return O(1e3 * t$2);
		}, O.en = D[g], O.Ls = D, O.p = {}, O;
	}));
}) });

//#endregion
//#region node_modules/dayjs/plugin/weekday.js
var require_weekday = /* @__PURE__ */ __commonJS({ "node_modules/dayjs/plugin/weekday.js": ((exports, module) => {
	(function(e$2, t$1) {
		"object" == typeof exports && "undefined" != typeof module ? module.exports = t$1() : "function" == typeof define && define.amd ? define(t$1) : (e$2 = "undefined" != typeof globalThis ? globalThis : e$2 || self).dayjs_plugin_weekday = t$1();
	})(exports, (function() {
		return function(e$2, t$1) {
			t$1.prototype.weekday = function(e$3) {
				var t$2 = this.$locale().weekStart || 0, i = this.$W, n$1 = (i < t$2 ? i + 7 : i) - t$2;
				return this.$utils().u(e$3) ? n$1 : this.subtract(n$1, "day").add(e$3, "day");
			};
		};
	}));
}) });

//#endregion
//#region node_modules/dayjs/plugin/localeData.js
var require_localeData = /* @__PURE__ */ __commonJS({ "node_modules/dayjs/plugin/localeData.js": ((exports, module) => {
	(function(n$1, e$2) {
		"object" == typeof exports && "undefined" != typeof module ? module.exports = e$2() : "function" == typeof define && define.amd ? define(e$2) : (n$1 = "undefined" != typeof globalThis ? globalThis : n$1 || self).dayjs_plugin_localeData = e$2();
	})(exports, (function() {
		return function(n$1, e$2, t$1) {
			var r$1 = e$2.prototype, o$2 = function(n$2) {
				return n$2 && (n$2.indexOf ? n$2 : n$2.s);
			}, u = function(n$2, e$3, t$2, r$2, u$1) {
				var i$1 = n$2.name ? n$2 : n$2.$locale(), a$1 = o$2(i$1[e$3]), s$1 = o$2(i$1[t$2]), f = a$1 || s$1.map((function(n$3) {
					return n$3.slice(0, r$2);
				}));
				if (!u$1) return f;
				var d = i$1.weekStart;
				return f.map((function(n$3, e$4) {
					return f[(e$4 + (d || 0)) % 7];
				}));
			}, i = function() {
				return t$1.Ls[t$1.locale()];
			}, a = function(n$2, e$3) {
				return n$2.formats[e$3] || function(n$3) {
					return n$3.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (function(n$4, e$4, t$2) {
						return e$4 || t$2.slice(1);
					}));
				}(n$2.formats[e$3.toUpperCase()]);
			}, s = function() {
				var n$2 = this;
				return {
					months: function(e$3) {
						return e$3 ? e$3.format("MMMM") : u(n$2, "months");
					},
					monthsShort: function(e$3) {
						return e$3 ? e$3.format("MMM") : u(n$2, "monthsShort", "months", 3);
					},
					firstDayOfWeek: function() {
						return n$2.$locale().weekStart || 0;
					},
					weekdays: function(e$3) {
						return e$3 ? e$3.format("dddd") : u(n$2, "weekdays");
					},
					weekdaysMin: function(e$3) {
						return e$3 ? e$3.format("dd") : u(n$2, "weekdaysMin", "weekdays", 2);
					},
					weekdaysShort: function(e$3) {
						return e$3 ? e$3.format("ddd") : u(n$2, "weekdaysShort", "weekdays", 3);
					},
					longDateFormat: function(e$3) {
						return a(n$2.$locale(), e$3);
					},
					meridiem: this.$locale().meridiem,
					ordinal: this.$locale().ordinal
				};
			};
			r$1.localeData = function() {
				return s.bind(this)();
			}, t$1.localeData = function() {
				var n$2 = i();
				return {
					firstDayOfWeek: function() {
						return n$2.weekStart || 0;
					},
					weekdays: function() {
						return t$1.weekdays();
					},
					weekdaysShort: function() {
						return t$1.weekdaysShort();
					},
					weekdaysMin: function() {
						return t$1.weekdaysMin();
					},
					months: function() {
						return t$1.months();
					},
					monthsShort: function() {
						return t$1.monthsShort();
					},
					longDateFormat: function(e$3) {
						return a(n$2, e$3);
					},
					meridiem: n$2.meridiem,
					ordinal: n$2.ordinal
				};
			}, t$1.months = function() {
				return u(i(), "months");
			}, t$1.monthsShort = function() {
				return u(i(), "monthsShort", "months", 3);
			}, t$1.weekdays = function(n$2) {
				return u(i(), "weekdays", null, null, n$2);
			}, t$1.weekdaysShort = function(n$2) {
				return u(i(), "weekdaysShort", "weekdays", 3, n$2);
			}, t$1.weekdaysMin = function(n$2) {
				return u(i(), "weekdaysMin", "weekdays", 2, n$2);
			};
		};
	}));
}) });

//#endregion
//#region node_modules/dayjs/plugin/weekOfYear.js
var require_weekOfYear = /* @__PURE__ */ __commonJS({ "node_modules/dayjs/plugin/weekOfYear.js": ((exports, module) => {
	(function(e$2, t$1) {
		"object" == typeof exports && "undefined" != typeof module ? module.exports = t$1() : "function" == typeof define && define.amd ? define(t$1) : (e$2 = "undefined" != typeof globalThis ? globalThis : e$2 || self).dayjs_plugin_weekOfYear = t$1();
	})(exports, (function() {
		var e$2 = "week", t$1 = "year";
		return function(i, n$1, r$1) {
			var f = n$1.prototype;
			f.week = function(i$1) {
				if (void 0 === i$1 && (i$1 = null), null !== i$1) return this.add(7 * (i$1 - this.week()), "day");
				var n$2 = this.$locale().yearStart || 1;
				if (11 === this.month() && this.date() > 25) {
					var f$1 = r$1(this).startOf(t$1).add(1, t$1).date(n$2), s = r$1(this).endOf(e$2);
					if (f$1.isBefore(s)) return 1;
				}
				var a = r$1(this).startOf(t$1).date(n$2).startOf(e$2).subtract(1, "millisecond"), o$2 = this.diff(a, e$2, !0);
				return o$2 < 0 ? r$1(this).startOf("week").week() : Math.ceil(o$2);
			}, f.weeks = function(e$3) {
				return void 0 === e$3 && (e$3 = null), this.week(e$3);
			};
		};
	}));
}) });

//#endregion
//#region node_modules/dayjs/plugin/weekYear.js
var require_weekYear = /* @__PURE__ */ __commonJS({ "node_modules/dayjs/plugin/weekYear.js": ((exports, module) => {
	(function(e$2, t$1) {
		"object" == typeof exports && "undefined" != typeof module ? module.exports = t$1() : "function" == typeof define && define.amd ? define(t$1) : (e$2 = "undefined" != typeof globalThis ? globalThis : e$2 || self).dayjs_plugin_weekYear = t$1();
	})(exports, (function() {
		return function(e$2, t$1) {
			t$1.prototype.weekYear = function() {
				var e$3 = this.month(), t$2 = this.week(), n$1 = this.year();
				return 1 === t$2 && 11 === e$3 ? n$1 + 1 : 0 === e$3 && t$2 >= 52 ? n$1 - 1 : n$1;
			};
		};
	}));
}) });

//#endregion
//#region node_modules/dayjs/plugin/advancedFormat.js
var require_advancedFormat = /* @__PURE__ */ __commonJS({ "node_modules/dayjs/plugin/advancedFormat.js": ((exports, module) => {
	(function(e$2, t$1) {
		"object" == typeof exports && "undefined" != typeof module ? module.exports = t$1() : "function" == typeof define && define.amd ? define(t$1) : (e$2 = "undefined" != typeof globalThis ? globalThis : e$2 || self).dayjs_plugin_advancedFormat = t$1();
	})(exports, (function() {
		return function(e$2, t$1) {
			var r$1 = t$1.prototype, n$1 = r$1.format;
			r$1.format = function(e$3) {
				var t$2 = this, r$2 = this.$locale();
				if (!this.isValid()) return n$1.bind(this)(e$3);
				var s = this.$utils(), a = (e$3 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, (function(e$4) {
					switch (e$4) {
						case "Q": return Math.ceil((t$2.$M + 1) / 3);
						case "Do": return r$2.ordinal(t$2.$D);
						case "gggg": return t$2.weekYear();
						case "GGGG": return t$2.isoWeekYear();
						case "wo": return r$2.ordinal(t$2.week(), "W");
						case "w":
						case "ww": return s.s(t$2.week(), "w" === e$4 ? 1 : 2, "0");
						case "W":
						case "WW": return s.s(t$2.isoWeek(), "W" === e$4 ? 1 : 2, "0");
						case "k":
						case "kk": return s.s(String(0 === t$2.$H ? 24 : t$2.$H), "k" === e$4 ? 1 : 2, "0");
						case "X": return Math.floor(t$2.$d.getTime() / 1e3);
						case "x": return t$2.$d.getTime();
						case "z": return "[" + t$2.offsetName() + "]";
						case "zzz": return "[" + t$2.offsetName("long") + "]";
						default: return e$4;
					}
				}));
				return n$1.bind(this)(a);
			};
		};
	}));
}) });

//#endregion
//#region node_modules/dayjs/plugin/customParseFormat.js
var require_customParseFormat = /* @__PURE__ */ __commonJS({ "node_modules/dayjs/plugin/customParseFormat.js": ((exports, module) => {
	(function(e$2, t$1) {
		"object" == typeof exports && "undefined" != typeof module ? module.exports = t$1() : "function" == typeof define && define.amd ? define(t$1) : (e$2 = "undefined" != typeof globalThis ? globalThis : e$2 || self).dayjs_plugin_customParseFormat = t$1();
	})(exports, (function() {
		var e$2 = {
			LTS: "h:mm:ss A",
			LT: "h:mm A",
			L: "MM/DD/YYYY",
			LL: "MMMM D, YYYY",
			LLL: "MMMM D, YYYY h:mm A",
			LLLL: "dddd, MMMM D, YYYY h:mm A"
		}, t$1 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n$1 = /\d/, r$1 = /\d\d/, i = /\d\d?/, o$2 = /\d*[^-_:/,()\s\d]+/, s = {}, a = function(e$3) {
			return (e$3 = +e$3) + (e$3 > 68 ? 1900 : 2e3);
		};
		var f = function(e$3) {
			return function(t$2) {
				this[e$3] = +t$2;
			};
		}, h = [/[+-]\d\d:?(\d\d)?|Z/, function(e$3) {
			(this.zone || (this.zone = {})).offset = function(e$4) {
				if (!e$4) return 0;
				if ("Z" === e$4) return 0;
				var t$2 = e$4.match(/([+-]|\d\d)/g), n$2 = 60 * t$2[1] + (+t$2[2] || 0);
				return 0 === n$2 ? 0 : "+" === t$2[0] ? -n$2 : n$2;
			}(e$3);
		}], u = function(e$3) {
			var t$2 = s[e$3];
			return t$2 && (t$2.indexOf ? t$2 : t$2.s.concat(t$2.f));
		}, d = function(e$3, t$2) {
			var n$2, r$2 = s.meridiem;
			if (r$2) {
				for (var i$1 = 1; i$1 <= 24; i$1 += 1) if (e$3.indexOf(r$2(i$1, 0, t$2)) > -1) {
					n$2 = i$1 > 12;
					break;
				}
			} else n$2 = e$3 === (t$2 ? "pm" : "PM");
			return n$2;
		}, c = {
			A: [o$2, function(e$3) {
				this.afternoon = d(e$3, !1);
			}],
			a: [o$2, function(e$3) {
				this.afternoon = d(e$3, !0);
			}],
			Q: [n$1, function(e$3) {
				this.month = 3 * (e$3 - 1) + 1;
			}],
			S: [n$1, function(e$3) {
				this.milliseconds = 100 * +e$3;
			}],
			SS: [r$1, function(e$3) {
				this.milliseconds = 10 * +e$3;
			}],
			SSS: [/\d{3}/, function(e$3) {
				this.milliseconds = +e$3;
			}],
			s: [i, f("seconds")],
			ss: [i, f("seconds")],
			m: [i, f("minutes")],
			mm: [i, f("minutes")],
			H: [i, f("hours")],
			h: [i, f("hours")],
			HH: [i, f("hours")],
			hh: [i, f("hours")],
			D: [i, f("day")],
			DD: [r$1, f("day")],
			Do: [o$2, function(e$3) {
				var t$2 = s.ordinal;
				if (this.day = e$3.match(/\d+/)[0], t$2) for (var r$2 = 1; r$2 <= 31; r$2 += 1) t$2(r$2).replace(/\[|\]/g, "") === e$3 && (this.day = r$2);
			}],
			w: [i, f("week")],
			ww: [r$1, f("week")],
			M: [i, f("month")],
			MM: [r$1, f("month")],
			MMM: [o$2, function(e$3) {
				var t$2 = u("months"), n$2 = (u("monthsShort") || t$2.map((function(e$4) {
					return e$4.slice(0, 3);
				}))).indexOf(e$3) + 1;
				if (n$2 < 1) throw new Error();
				this.month = n$2 % 12 || n$2;
			}],
			MMMM: [o$2, function(e$3) {
				var t$2 = u("months").indexOf(e$3) + 1;
				if (t$2 < 1) throw new Error();
				this.month = t$2 % 12 || t$2;
			}],
			Y: [/[+-]?\d+/, f("year")],
			YY: [r$1, function(e$3) {
				this.year = a(e$3);
			}],
			YYYY: [/\d{4}/, f("year")],
			Z: h,
			ZZ: h
		};
		function l$1(n$2) {
			var r$2 = n$2, i$1 = s && s.formats;
			for (var o$3 = (n$2 = r$2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (function(t$2, n$3, r$3) {
				var o$4 = r$3 && r$3.toUpperCase();
				return n$3 || i$1[r$3] || e$2[r$3] || i$1[o$4].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (function(e$3, t$3, n$4) {
					return t$3 || n$4.slice(1);
				}));
			}))).match(t$1), a$1 = o$3.length, f$1 = 0; f$1 < a$1; f$1 += 1) {
				var h$1 = o$3[f$1], u$1 = c[h$1], d$1 = u$1 && u$1[0], l$2 = u$1 && u$1[1];
				o$3[f$1] = l$2 ? {
					regex: d$1,
					parser: l$2
				} : h$1.replace(/^\[|\]$/g, "");
			}
			return function(e$3) {
				for (var t$2 = {}, n$3 = 0, r$3 = 0; n$3 < a$1; n$3 += 1) {
					var i$2 = o$3[n$3];
					if ("string" == typeof i$2) r$3 += i$2.length;
					else {
						var s$1 = i$2.regex, f$2 = i$2.parser, h$2 = e$3.slice(r$3), u$2 = s$1.exec(h$2)[0];
						f$2.call(t$2, u$2), e$3 = e$3.replace(u$2, "");
					}
				}
				return function(e$4) {
					var t$3 = e$4.afternoon;
					if (void 0 !== t$3) {
						var n$4 = e$4.hours;
						t$3 ? n$4 < 12 && (e$4.hours += 12) : 12 === n$4 && (e$4.hours = 0), delete e$4.afternoon;
					}
				}(t$2), t$2;
			};
		}
		return function(e$3, t$2, n$2) {
			n$2.p.customParseFormat = !0, e$3 && e$3.parseTwoDigitYear && (a = e$3.parseTwoDigitYear);
			var r$2 = t$2.prototype, i$1 = r$2.parse;
			r$2.parse = function(e$4) {
				var t$3 = e$4.date, r$3 = e$4.utc, o$3 = e$4.args;
				this.$u = r$3;
				var a$1 = o$3[1];
				if ("string" == typeof a$1) {
					var f$1 = !0 === o$3[2], h$1 = !0 === o$3[3], u$1 = f$1 || h$1, d$1 = o$3[2];
					h$1 && (d$1 = o$3[2]), s = this.$locale(), !f$1 && d$1 && (s = n$2.Ls[d$1]), this.$d = function(e$5, t$4, n$3, r$4) {
						try {
							if (["x", "X"].indexOf(t$4) > -1) return /* @__PURE__ */ new Date(("X" === t$4 ? 1e3 : 1) * e$5);
							var i$2 = l$1(t$4)(e$5), o$4 = i$2.year, s$1 = i$2.month, a$2 = i$2.day, f$2 = i$2.hours, h$2 = i$2.minutes, u$2 = i$2.seconds, d$2 = i$2.milliseconds, c$2 = i$2.zone, m$1 = i$2.week, M$1 = /* @__PURE__ */ new Date(), Y = a$2 || (o$4 || s$1 ? 1 : M$1.getDate()), p = o$4 || M$1.getFullYear(), v = 0;
							o$4 && !s$1 || (v = s$1 > 0 ? s$1 - 1 : M$1.getMonth());
							var D, w = f$2 || 0, g = h$2 || 0, y = u$2 || 0, L = d$2 || 0;
							return c$2 ? new Date(Date.UTC(p, v, Y, w, g, y, L + 60 * c$2.offset * 1e3)) : n$3 ? new Date(Date.UTC(p, v, Y, w, g, y, L)) : (D = new Date(p, v, Y, w, g, y, L), m$1 && (D = r$4(D).week(m$1).toDate()), D);
						} catch (e$6) {
							return /* @__PURE__ */ new Date("");
						}
					}(t$3, a$1, r$3, n$2), this.init(), d$1 && !0 !== d$1 && (this.$L = this.locale(d$1).$L), u$1 && t$3 != this.format(a$1) && (this.$d = /* @__PURE__ */ new Date("")), s = {};
				} else if (a$1 instanceof Array) for (var c$1 = a$1.length, m = 1; m <= c$1; m += 1) {
					o$3[1] = a$1[m - 1];
					var M = n$2.apply(this, o$3);
					if (M.isValid()) {
						this.$d = M.$d, this.$L = M.$L, this.init();
						break;
					}
					m === c$1 && (this.$d = /* @__PURE__ */ new Date(""));
				}
				else i$1.call(this, e$4);
			};
		};
	}));
}) });

//#endregion
//#region node_modules/@rc-component/picker/es/generate/dayjs.js
var import_dayjs_min = /* @__PURE__ */ __toESM(require_dayjs_min());
var import_weekday = /* @__PURE__ */ __toESM(require_weekday());
var import_localeData = /* @__PURE__ */ __toESM(require_localeData());
var import_weekOfYear = /* @__PURE__ */ __toESM(require_weekOfYear());
var import_weekYear = /* @__PURE__ */ __toESM(require_weekYear());
var import_advancedFormat = /* @__PURE__ */ __toESM(require_advancedFormat());
var import_customParseFormat = /* @__PURE__ */ __toESM(require_customParseFormat());
import_dayjs_min.default.extend(import_customParseFormat.default);
import_dayjs_min.default.extend(import_advancedFormat.default);
import_dayjs_min.default.extend(import_weekday.default);
import_dayjs_min.default.extend(import_localeData.default);
import_dayjs_min.default.extend(import_weekOfYear.default);
import_dayjs_min.default.extend(import_weekYear.default);
import_dayjs_min.default.extend(function(o$2, c) {
	var proto = c.prototype;
	var oldFormat = proto.format;
	proto.format = function f(formatStr) {
		var str = (formatStr || "").replace("Wo", "wo");
		return oldFormat.bind(this)(str);
	};
});
var localeMap = {
	bn_BD: "bn-bd",
	by_BY: "be",
	en_GB: "en-gb",
	en_US: "en",
	fr_BE: "fr",
	fr_CA: "fr-ca",
	hy_AM: "hy-am",
	kmr_IQ: "ku",
	nl_BE: "nl-be",
	pt_BR: "pt-br",
	zh_CN: "zh-cn",
	zh_HK: "zh-hk",
	zh_TW: "zh-tw"
};
var parseLocale = function parseLocale$1(locale$5) {
	return localeMap[locale$5] || locale$5.split("_")[0];
};
/* istanbul ignore next */
var parseNoMatchNotice = function parseNoMatchNotice$1() {};
var generateConfig = {
	getNow: function getNow() {
		var now$1 = (0, import_dayjs_min.default)();
		if (typeof now$1.tz === "function") return now$1.tz();
		return now$1;
	},
	getFixedDate: function getFixedDate(string$1) {
		return (0, import_dayjs_min.default)(string$1, ["YYYY-M-DD", "YYYY-MM-DD"]);
	},
	getEndDate: function getEndDate(date$1) {
		return date$1.endOf("month");
	},
	getWeekDay: function getWeekDay(date$1) {
		var clone = date$1.locale("en");
		return clone.weekday() + clone.localeData().firstDayOfWeek();
	},
	getYear: function getYear(date$1) {
		return date$1.year();
	},
	getMonth: function getMonth(date$1) {
		return date$1.month();
	},
	getDate: function getDate(date$1) {
		return date$1.date();
	},
	getHour: function getHour(date$1) {
		return date$1.hour();
	},
	getMinute: function getMinute(date$1) {
		return date$1.minute();
	},
	getSecond: function getSecond(date$1) {
		return date$1.second();
	},
	getMillisecond: function getMillisecond(date$1) {
		return date$1.millisecond();
	},
	addYear: function addYear(date$1, diff) {
		return date$1.add(diff, "year");
	},
	addMonth: function addMonth(date$1, diff) {
		return date$1.add(diff, "month");
	},
	addDate: function addDate(date$1, diff) {
		return date$1.add(diff, "day");
	},
	setYear: function setYear(date$1, year) {
		return date$1.year(year);
	},
	setMonth: function setMonth(date$1, month) {
		return date$1.month(month);
	},
	setDate: function setDate(date$1, num) {
		return date$1.date(num);
	},
	setHour: function setHour(date$1, hour) {
		return date$1.hour(hour);
	},
	setMinute: function setMinute(date$1, minute) {
		return date$1.minute(minute);
	},
	setSecond: function setSecond(date$1, second) {
		return date$1.second(second);
	},
	setMillisecond: function setMillisecond(date$1, milliseconds) {
		return date$1.millisecond(milliseconds);
	},
	isAfter: function isAfter(date1, date2) {
		return date1.isAfter(date2);
	},
	isValidate: function isValidate(date$1) {
		return date$1.isValid();
	},
	locale: {
		getWeekFirstDay: function getWeekFirstDay(locale$5) {
			return (0, import_dayjs_min.default)().locale(parseLocale(locale$5)).localeData().firstDayOfWeek();
		},
		getWeekFirstDate: function getWeekFirstDate(locale$5, date$1) {
			return date$1.locale(parseLocale(locale$5)).weekday(0);
		},
		getWeek: function getWeek(locale$5, date$1) {
			return date$1.locale(parseLocale(locale$5)).week();
		},
		getShortWeekDays: function getShortWeekDays(locale$5) {
			return (0, import_dayjs_min.default)().locale(parseLocale(locale$5)).localeData().weekdaysMin();
		},
		getShortMonths: function getShortMonths(locale$5) {
			return (0, import_dayjs_min.default)().locale(parseLocale(locale$5)).localeData().monthsShort();
		},
		format: function format$1(locale$5, date$1, _format) {
			return date$1.locale(parseLocale(locale$5)).format(_format);
		},
		parse: function parse$1(locale$5, text, formats) {
			var localeStr = parseLocale(locale$5);
			for (var i = 0; i < formats.length; i += 1) {
				var format$1 = formats[i];
				var formatText = text;
				if (format$1.includes("wo") || format$1.includes("Wo")) {
					var year = formatText.split("-")[0];
					var weekStr = formatText.split("-")[1];
					var firstWeek = (0, import_dayjs_min.default)(year, "YYYY").startOf("year").locale(localeStr);
					for (var j = 0; j <= 52; j += 1) {
						var nextWeek = firstWeek.add(j, "week");
						if (nextWeek.format("Wo") === weekStr) return nextWeek;
					}
					parseNoMatchNotice();
					return null;
				}
				var date$1 = (0, import_dayjs_min.default)(formatText, format$1, true).locale(localeStr);
				if (date$1.isValid()) return date$1;
			}
			if (text) parseNoMatchNotice();
			return null;
		}
	}
};
var dayjs_default = generateConfig;

//#endregion
//#region node_modules/@rc-component/picker/es/utils/uiUtil.js
function getRealPlacement(placement, rtl) {
	if (placement !== void 0) return placement;
	return rtl ? "bottomRight" : "bottomLeft";
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/context.js
var PickerContext = /* @__PURE__ */ import_react.createContext(null);
var context_default$5 = PickerContext;

//#endregion
//#region node_modules/@rc-component/picker/es/PickerTrigger/index.js
function _typeof$29(o$2) {
	"@babel/helpers - typeof";
	return _typeof$29 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$29(o$2);
}
function _defineProperty$27(obj, key, value) {
	key = _toPropertyKey$26(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$26(t$1) {
	var i = _toPrimitive$26(t$1, "string");
	return "symbol" == _typeof$29(i) ? i : String(i);
}
function _toPrimitive$26(t$1, r$1) {
	if ("object" != _typeof$29(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$29(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var BUILT_IN_PLACEMENTS$1 = {
	bottomLeft: {
		points: ["tl", "bl"],
		offset: [0, 4],
		overflow: {
			adjustX: 1,
			adjustY: 1
		}
	},
	bottomRight: {
		points: ["tr", "br"],
		offset: [0, 4],
		overflow: {
			adjustX: 1,
			adjustY: 1
		}
	},
	topLeft: {
		points: ["bl", "tl"],
		offset: [0, -4],
		overflow: {
			adjustX: 0,
			adjustY: 1
		}
	},
	topRight: {
		points: ["br", "tr"],
		offset: [0, -4],
		overflow: {
			adjustX: 0,
			adjustY: 1
		}
	}
};
function PickerTrigger(_ref) {
	var popupElement = _ref.popupElement, popupStyle = _ref.popupStyle, popupClassName = _ref.popupClassName, popupAlign = _ref.popupAlign, transitionName = _ref.transitionName, getPopupContainer = _ref.getPopupContainer, children = _ref.children, range$1 = _ref.range, placement = _ref.placement, _ref$builtinPlacement = _ref.builtinPlacements, builtinPlacements = _ref$builtinPlacement === void 0 ? BUILT_IN_PLACEMENTS$1 : _ref$builtinPlacement, direction = _ref.direction, visible = _ref.visible, onClose = _ref.onClose;
	var prefixCls = import_react.useContext(context_default$5).prefixCls;
	var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
	var realPlacement = getRealPlacement(placement, direction === "rtl");
	return /* @__PURE__ */ import_react.createElement(es_default$6, {
		showAction: [],
		hideAction: ["click"],
		popupPlacement: realPlacement,
		builtinPlacements,
		prefixCls: dropdownPrefixCls,
		popupMotion: { motionName: transitionName },
		popup: popupElement,
		popupAlign,
		popupVisible: visible,
		popupClassName: clsx(popupClassName, _defineProperty$27(_defineProperty$27({}, "".concat(dropdownPrefixCls, "-range"), range$1), "".concat(dropdownPrefixCls, "-rtl"), direction === "rtl")),
		popupStyle,
		stretch: "minWidth",
		getPopupContainer,
		onPopupVisibleChange: function onPopupVisibleChange(nextVisible) {
			if (!nextVisible) onClose();
		}
	}, children);
}
var PickerTrigger_default = PickerTrigger;

//#endregion
//#region node_modules/@rc-component/picker/es/utils/miscUtil.js
function _toConsumableArray$8(arr) {
	return _arrayWithoutHoles$7(arr) || _iterableToArray$7(arr) || _unsupportedIterableToArray$34(arr) || _nonIterableSpread$7();
}
function _nonIterableSpread$7() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$34(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$33(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$33(o$2, minLen);
}
function _iterableToArray$7(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$7(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$33(arr);
}
function _arrayLikeToArray$33(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function leftPad(str, length$1) {
	var fill = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
	var current = String(str);
	while (current.length < length$1) current = "".concat(fill).concat(current);
	return current;
}
/**
* Convert `value` to array. Will provide `[]` if is null or undefined.
*/
function toArray$5(val) {
	if (val === null || val === void 0) return [];
	return Array.isArray(val) ? val : [val];
}
function fillIndex(ori, index$1, value) {
	var clone = _toConsumableArray$8(ori);
	clone[index$1] = value;
	return clone;
}
/** Pick props from the key list. Will filter empty value */
function pickProps(props, keys$1) {
	var clone = {};
	(keys$1 || Object.keys(props)).forEach(function(key) {
		if (props[key] !== void 0) clone[key] = props[key];
	});
	return clone;
}
function getRowFormat(picker, locale$5, format$1) {
	if (format$1) return format$1;
	switch (picker) {
		case "time": return locale$5.fieldTimeFormat;
		case "datetime": return locale$5.fieldDateTimeFormat;
		case "month": return locale$5.fieldMonthFormat;
		case "year": return locale$5.fieldYearFormat;
		case "quarter": return locale$5.fieldQuarterFormat;
		case "week": return locale$5.fieldWeekFormat;
		default: return locale$5.fieldDateFormat;
	}
}
function getFromDate(calendarValues, activeIndexList, activeIndex) {
	var mergedActiveIndex = activeIndex !== void 0 ? activeIndex : activeIndexList[activeIndexList.length - 1];
	var firstValuedIndex = activeIndexList.find(function(index$1) {
		return calendarValues[index$1];
	});
	return mergedActiveIndex !== firstValuedIndex ? calendarValues[firstValuedIndex] : void 0;
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerTrigger/util.js
function pickTriggerProps(props) {
	return pickProps(props, [
		"placement",
		"builtinPlacements",
		"popupAlign",
		"getPopupContainer",
		"transitionName",
		"direction"
	]);
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/hooks/useCellRender.js
function _typeof$28(o$2) {
	"@babel/helpers - typeof";
	return _typeof$28 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$28(o$2);
}
function ownKeys$16(e$2, r$1) {
	var t$1 = Object.keys(e$2);
	if (Object.getOwnPropertySymbols) {
		var o$2 = Object.getOwnPropertySymbols(e$2);
		r$1 && (o$2 = o$2.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e$2, r$2).enumerable;
		})), t$1.push.apply(t$1, o$2);
	}
	return t$1;
}
function _objectSpread$16(e$2) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$16(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$26(e$2, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$2, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$16(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e$2, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e$2;
}
function _defineProperty$26(obj, key, value) {
	key = _toPropertyKey$25(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$25(t$1) {
	var i = _toPrimitive$25(t$1, "string");
	return "symbol" == _typeof$28(i) ? i : String(i);
}
function _toPrimitive$25(t$1, r$1) {
	if ("object" != _typeof$28(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$28(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function useCellRender$1(cellRender, dateRender, monthCellRender, range$1) {
	warning_default$1(!dateRender, "'dateRender' is deprecated. Please use 'cellRender' instead.");
	warning_default$1(!monthCellRender, "'monthCellRender' is deprecated. Please use 'cellRender' instead.");
	var mergedCellRender = import_react.useMemo(function() {
		if (cellRender) return cellRender;
		return function(current, info) {
			var date$1 = current;
			if (dateRender && info.type === "date") return dateRender(date$1, info.today);
			if (monthCellRender && info.type === "month") return monthCellRender(date$1, info.locale);
			return info.originNode;
		};
	}, [
		cellRender,
		monthCellRender,
		dateRender
	]);
	return import_react.useCallback(function(date$1, info) {
		return mergedCellRender(date$1, _objectSpread$16(_objectSpread$16({}, info), {}, { range: range$1 }));
	}, [mergedCellRender, range$1]);
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/hooks/useFieldsInvalidate.js
function _slicedToArray$31(arr, i) {
	return _arrayWithHoles$30(arr) || _iterableToArrayLimit$30(arr, i) || _unsupportedIterableToArray$33(arr, i) || _nonIterableRest$30();
}
function _nonIterableRest$30() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$33(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$32(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$32(o$2, minLen);
}
function _arrayLikeToArray$32(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$30(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$30(arr) {
	if (Array.isArray(arr)) return arr;
}
/**
* Used to control each fields invalidate status
*/
function useFieldsInvalidate(calendarValue, isInvalidateDate) {
	var allowEmpty = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
	var _React$useState2 = _slicedToArray$31(import_react.useState([false, false]), 2), fieldsInvalidates = _React$useState2[0], setFieldsInvalidates = _React$useState2[1];
	return [import_react.useMemo(function() {
		return fieldsInvalidates.map(function(invalid, index$1) {
			if (invalid) return true;
			var current = calendarValue[index$1];
			if (!current) return false;
			if (!allowEmpty[index$1] && !current) return true;
			if (current && isInvalidateDate(current, { activeIndex: index$1 })) return true;
			return false;
		});
	}, [
		calendarValue,
		fieldsInvalidates,
		isInvalidateDate,
		allowEmpty
	]), function onSelectorInvalid(invalid, index$1) {
		setFieldsInvalidates(function(ori) {
			return fillIndex(ori, index$1, invalid);
		});
	}];
}

//#endregion
//#region node_modules/@rc-component/picker/es/hooks/useLocale.js
function _typeof$27(o$2) {
	"@babel/helpers - typeof";
	return _typeof$27 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$27(o$2);
}
function ownKeys$15(e$2, r$1) {
	var t$1 = Object.keys(e$2);
	if (Object.getOwnPropertySymbols) {
		var o$2 = Object.getOwnPropertySymbols(e$2);
		r$1 && (o$2 = o$2.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e$2, r$2).enumerable;
		})), t$1.push.apply(t$1, o$2);
	}
	return t$1;
}
function _objectSpread$15(e$2) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$15(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$25(e$2, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$2, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$15(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e$2, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e$2;
}
function _defineProperty$25(obj, key, value) {
	key = _toPropertyKey$24(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$24(t$1) {
	var i = _toPrimitive$24(t$1, "string");
	return "symbol" == _typeof$27(i) ? i : String(i);
}
function _toPrimitive$24(t$1, r$1) {
	if ("object" != _typeof$27(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$27(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function fillTimeFormat(showHour, showMinute, showSecond, showMillisecond, showMeridiem) {
	var timeFormat = "";
	var cells = [];
	if (showHour) cells.push(showMeridiem ? "hh" : "HH");
	if (showMinute) cells.push("mm");
	if (showSecond) cells.push("ss");
	timeFormat = cells.join(":");
	if (showMillisecond) timeFormat += ".SSS";
	if (showMeridiem) timeFormat += " A";
	return timeFormat;
}
/**
* Used for `useFilledProps` since it already in the React.useMemo
*/
function fillLocale(locale$5, showHour, showMinute, showSecond, showMillisecond, use12Hours) {
	var fieldDateTimeFormat = locale$5.fieldDateTimeFormat, fieldDateFormat = locale$5.fieldDateFormat, fieldTimeFormat = locale$5.fieldTimeFormat, fieldMonthFormat = locale$5.fieldMonthFormat, fieldYearFormat = locale$5.fieldYearFormat, fieldWeekFormat = locale$5.fieldWeekFormat, fieldQuarterFormat = locale$5.fieldQuarterFormat, yearFormat = locale$5.yearFormat, cellYearFormat = locale$5.cellYearFormat, cellQuarterFormat = locale$5.cellQuarterFormat, dayFormat = locale$5.dayFormat, cellDateFormat = locale$5.cellDateFormat;
	var timeFormat = fillTimeFormat(showHour, showMinute, showSecond, showMillisecond, use12Hours);
	return _objectSpread$15(_objectSpread$15({}, locale$5), {}, {
		fieldDateTimeFormat: fieldDateTimeFormat || "YYYY-MM-DD ".concat(timeFormat),
		fieldDateFormat: fieldDateFormat || "YYYY-MM-DD",
		fieldTimeFormat: fieldTimeFormat || timeFormat,
		fieldMonthFormat: fieldMonthFormat || "YYYY-MM",
		fieldYearFormat: fieldYearFormat || "YYYY",
		fieldWeekFormat: fieldWeekFormat || "gggg-wo",
		fieldQuarterFormat: fieldQuarterFormat || "YYYY-[Q]Q",
		yearFormat: yearFormat || "YYYY",
		cellYearFormat: cellYearFormat || "YYYY",
		cellQuarterFormat: cellQuarterFormat || "[Q]Q",
		cellDateFormat: cellDateFormat || dayFormat || "D"
	});
}
/**
* Fill locale format as start up
*/
function useLocale(locale$5, showProps) {
	var showHour = showProps.showHour, showMinute = showProps.showMinute, showSecond = showProps.showSecond, showMillisecond = showProps.showMillisecond, use12Hours = showProps.use12Hours;
	return import_react.useMemo(function() {
		return fillLocale(locale$5, showHour, showMinute, showSecond, showMillisecond, use12Hours);
	}, [
		locale$5,
		showHour,
		showMinute,
		showSecond,
		showMillisecond,
		use12Hours
	]);
}

//#endregion
//#region node_modules/@rc-component/picker/es/hooks/useTimeConfig.js
function ownKeys$14(e$2, r$1) {
	var t$1 = Object.keys(e$2);
	if (Object.getOwnPropertySymbols) {
		var o$2 = Object.getOwnPropertySymbols(e$2);
		r$1 && (o$2 = o$2.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e$2, r$2).enumerable;
		})), t$1.push.apply(t$1, o$2);
	}
	return t$1;
}
function _objectSpread$14(e$2) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$14(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$24(e$2, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$2, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$14(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e$2, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e$2;
}
function _defineProperty$24(obj, key, value) {
	key = _toPropertyKey$23(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$23(t$1) {
	var i = _toPrimitive$23(t$1, "string");
	return "symbol" == _typeof$26(i) ? i : String(i);
}
function _toPrimitive$23(t$1, r$1) {
	if ("object" != _typeof$26(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$26(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _slicedToArray$30(arr, i) {
	return _arrayWithHoles$29(arr) || _iterableToArrayLimit$29(arr, i) || _unsupportedIterableToArray$32(arr, i) || _nonIterableRest$29();
}
function _nonIterableRest$29() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$32(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$31(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$31(o$2, minLen);
}
function _arrayLikeToArray$31(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$29(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$29(arr) {
	if (Array.isArray(arr)) return arr;
}
function _typeof$26(o$2) {
	"@babel/helpers - typeof";
	return _typeof$26 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$26(o$2);
}
function checkShow(format$1, keywords, show) {
	return show !== null && show !== void 0 ? show : keywords.some(function(keyword) {
		return format$1.includes(keyword);
	});
}
var showTimeKeys = [
	"showNow",
	"showHour",
	"showMinute",
	"showSecond",
	"showMillisecond",
	"use12Hours",
	"hourStep",
	"minuteStep",
	"secondStep",
	"millisecondStep",
	"hideDisabledOptions",
	"defaultValue",
	"disabledHours",
	"disabledMinutes",
	"disabledSeconds",
	"disabledMilliseconds",
	"disabledTime",
	"changeOnScroll",
	"defaultOpenValue"
];
/**
* Get SharedTimeProps from props.
*/
function pickTimeProps(props) {
	var timeProps = pickProps(props, showTimeKeys);
	var format$1 = props.format, picker = props.picker;
	var propFormat = null;
	if (format$1) {
		propFormat = format$1;
		if (Array.isArray(propFormat)) propFormat = propFormat[0];
		propFormat = _typeof$26(propFormat) === "object" ? propFormat.format : propFormat;
	}
	if (picker === "time") timeProps.format = propFormat;
	return [timeProps, propFormat];
}
function isStringFormat(format$1) {
	return format$1 && typeof format$1 === "string";
}
/** Check if all the showXXX is `undefined` */
function existShowConfig(showHour, showMinute, showSecond, showMillisecond) {
	return [
		showHour,
		showMinute,
		showSecond,
		showMillisecond
	].some(function(show) {
		return show !== void 0;
	});
}
/** Fill the showXXX if needed */
function fillShowConfig(hasShowConfig, showHour, showMinute, showSecond, showMillisecond) {
	var parsedShowHour = showHour;
	var parsedShowMinute = showMinute;
	var parsedShowSecond = showSecond;
	if (!hasShowConfig && !parsedShowHour && !parsedShowMinute && !parsedShowSecond && !showMillisecond) {
		parsedShowHour = true;
		parsedShowMinute = true;
		parsedShowSecond = true;
	} else if (hasShowConfig) {
		var _parsedShowHour, _parsedShowMinute, _parsedShowSecond;
		var existFalse = [
			parsedShowHour,
			parsedShowMinute,
			parsedShowSecond
		].some(function(show) {
			return show === false;
		});
		var existTrue = [
			parsedShowHour,
			parsedShowMinute,
			parsedShowSecond
		].some(function(show) {
			return show === true;
		});
		var defaultShow = existFalse ? true : !existTrue;
		parsedShowHour = (_parsedShowHour = parsedShowHour) !== null && _parsedShowHour !== void 0 ? _parsedShowHour : defaultShow;
		parsedShowMinute = (_parsedShowMinute = parsedShowMinute) !== null && _parsedShowMinute !== void 0 ? _parsedShowMinute : defaultShow;
		parsedShowSecond = (_parsedShowSecond = parsedShowSecond) !== null && _parsedShowSecond !== void 0 ? _parsedShowSecond : defaultShow;
	}
	return [
		parsedShowHour,
		parsedShowMinute,
		parsedShowSecond,
		showMillisecond
	];
}
/**
* Get `showHour`, `showMinute`, `showSecond` or other from the props.
* This is pure function, will not get `showXXX` from the `format` prop.
*/
function getTimeProps(componentProps) {
	var showTime = componentProps.showTime;
	var _pickTimeProps2 = _slicedToArray$30(pickTimeProps(componentProps), 2), pickedProps = _pickTimeProps2[0], propFormat = _pickTimeProps2[1];
	var showTimeConfig = showTime && _typeof$26(showTime) === "object" ? showTime : {};
	var timeConfig = _objectSpread$14(_objectSpread$14({ defaultOpenValue: showTimeConfig.defaultOpenValue || showTimeConfig.defaultValue }, pickedProps), showTimeConfig);
	var showMillisecond = timeConfig.showMillisecond;
	var showHour = timeConfig.showHour, showMinute = timeConfig.showMinute, showSecond = timeConfig.showSecond;
	var _fillShowConfig2 = _slicedToArray$30(fillShowConfig(existShowConfig(showHour, showMinute, showSecond, showMillisecond), showHour, showMinute, showSecond, showMillisecond), 3);
	showHour = _fillShowConfig2[0];
	showMinute = _fillShowConfig2[1];
	showSecond = _fillShowConfig2[2];
	return [
		timeConfig,
		_objectSpread$14(_objectSpread$14({}, timeConfig), {}, {
			showHour,
			showMinute,
			showSecond,
			showMillisecond
		}),
		timeConfig.format,
		propFormat
	];
}
function fillShowTimeConfig(picker, showTimeFormat, propFormat, timeConfig, locale$5) {
	if (picker === "datetime" || picker === "time") {
		var pickedProps = timeConfig;
		var baselineFormat = getRowFormat(picker, locale$5, null);
		var formatList = [showTimeFormat, propFormat];
		for (var i = 0; i < formatList.length; i += 1) {
			var format$1 = toArray$5(formatList[i])[0];
			if (isStringFormat(format$1)) {
				baselineFormat = format$1;
				break;
			}
		}
		var showHour = pickedProps.showHour, showMinute = pickedProps.showMinute, showSecond = pickedProps.showSecond, showMillisecond = pickedProps.showMillisecond;
		var use12Hours = pickedProps.use12Hours;
		var showMeridiem = checkShow(baselineFormat, [
			"a",
			"A",
			"LT",
			"LLL",
			"LTS"
		], use12Hours);
		var hasShowConfig = existShowConfig(showHour, showMinute, showSecond, showMillisecond);
		if (!hasShowConfig) {
			showHour = checkShow(baselineFormat, [
				"H",
				"h",
				"k",
				"LT",
				"LLL"
			]);
			showMinute = checkShow(baselineFormat, [
				"m",
				"LT",
				"LLL"
			]);
			showSecond = checkShow(baselineFormat, ["s", "LTS"]);
			showMillisecond = checkShow(baselineFormat, ["SSS"]);
		}
		var _fillShowConfig4 = _slicedToArray$30(fillShowConfig(hasShowConfig, showHour, showMinute, showSecond, showMillisecond), 3);
		showHour = _fillShowConfig4[0];
		showMinute = _fillShowConfig4[1];
		showSecond = _fillShowConfig4[2];
		var timeFormat = showTimeFormat || fillTimeFormat(showHour, showMinute, showSecond, showMillisecond, showMeridiem);
		return _objectSpread$14(_objectSpread$14({}, pickedProps), {}, {
			format: timeFormat,
			showHour,
			showMinute,
			showSecond,
			showMillisecond,
			use12Hours: showMeridiem
		});
	}
	return null;
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/Selector/hooks/useClearIcon.js
function _typeof$25(o$2) {
	"@babel/helpers - typeof";
	return _typeof$25 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$25(o$2);
}
/**
* Used for `useFilledProps` since it already in the React.useMemo
*/
function fillClearIcon(prefixCls, allowClear, clearIcon) {
	if (clearIcon) warning_default$1(false, "`clearIcon` will be removed in future. Please use `allowClear` instead.");
	if (allowClear === false) return null;
	return (allowClear && _typeof$25(allowClear) === "object" ? allowClear : {}).clearIcon || clearIcon || /* @__PURE__ */ import_react.createElement("span", { className: "".concat(prefixCls, "-clear-btn") });
}

//#endregion
//#region node_modules/@rc-component/picker/es/utils/dateUtil.js
var WEEK_DAY_COUNT = 7;
/**
* Wrap the compare logic.
* This will compare the each of value is empty first.
* 1. All is empty, return true.
* 2. One is empty, return false.
* 3. return customize compare logic.
*/
function nullableCompare(value1, value2, oriCompareFn) {
	if (!value1 && !value2 || value1 === value2) return true;
	if (!value1 || !value2) return false;
	return oriCompareFn();
}
function isSameDecade(generateConfig$1, decade1, decade2) {
	return nullableCompare(decade1, decade2, function() {
		return Math.floor(generateConfig$1.getYear(decade1) / 10) === Math.floor(generateConfig$1.getYear(decade2) / 10);
	});
}
function isSameYear$1(generateConfig$1, year1, year2) {
	return nullableCompare(year1, year2, function() {
		return generateConfig$1.getYear(year1) === generateConfig$1.getYear(year2);
	});
}
function getQuarter(generateConfig$1, date$1) {
	return Math.floor(generateConfig$1.getMonth(date$1) / 3) + 1;
}
function isSameQuarter(generateConfig$1, quarter1, quarter2) {
	return nullableCompare(quarter1, quarter2, function() {
		return isSameYear$1(generateConfig$1, quarter1, quarter2) && getQuarter(generateConfig$1, quarter1) === getQuarter(generateConfig$1, quarter2);
	});
}
function isSameMonth$1(generateConfig$1, month1, month2) {
	return nullableCompare(month1, month2, function() {
		return isSameYear$1(generateConfig$1, month1, month2) && generateConfig$1.getMonth(month1) === generateConfig$1.getMonth(month2);
	});
}
function isSameDate$1(generateConfig$1, date1, date2) {
	return nullableCompare(date1, date2, function() {
		return isSameYear$1(generateConfig$1, date1, date2) && isSameMonth$1(generateConfig$1, date1, date2) && generateConfig$1.getDate(date1) === generateConfig$1.getDate(date2);
	});
}
function isSameTime(generateConfig$1, time1, time2) {
	return nullableCompare(time1, time2, function() {
		return generateConfig$1.getHour(time1) === generateConfig$1.getHour(time2) && generateConfig$1.getMinute(time1) === generateConfig$1.getMinute(time2) && generateConfig$1.getSecond(time1) === generateConfig$1.getSecond(time2);
	});
}
/**
* Check if the Date is all the same of timestamp
*/
function isSameTimestamp(generateConfig$1, time1, time2) {
	return nullableCompare(time1, time2, function() {
		return isSameDate$1(generateConfig$1, time1, time2) && isSameTime(generateConfig$1, time1, time2) && generateConfig$1.getMillisecond(time1) === generateConfig$1.getMillisecond(time2);
	});
}
function isSameWeek(generateConfig$1, locale$5, date1, date2) {
	return nullableCompare(date1, date2, function() {
		return isSameYear$1(generateConfig$1, generateConfig$1.locale.getWeekFirstDate(locale$5, date1), generateConfig$1.locale.getWeekFirstDate(locale$5, date2)) && generateConfig$1.locale.getWeek(locale$5, date1) === generateConfig$1.locale.getWeek(locale$5, date2);
	});
}
function isSame(generateConfig$1, locale$5, source, target, type$2) {
	switch (type$2) {
		case "date": return isSameDate$1(generateConfig$1, source, target);
		case "week": return isSameWeek(generateConfig$1, locale$5.locale, source, target);
		case "month": return isSameMonth$1(generateConfig$1, source, target);
		case "quarter": return isSameQuarter(generateConfig$1, source, target);
		case "year": return isSameYear$1(generateConfig$1, source, target);
		case "decade": return isSameDecade(generateConfig$1, source, target);
		case "time": return isSameTime(generateConfig$1, source, target);
		default: return isSameTimestamp(generateConfig$1, source, target);
	}
}
/** Between in date but not equal of date */
function isInRange(generateConfig$1, startDate, endDate, current) {
	if (!startDate || !endDate || !current) return false;
	return generateConfig$1.isAfter(current, startDate) && generateConfig$1.isAfter(endDate, current);
}
function isSameOrAfter(generateConfig$1, locale$5, date1, date2, type$2) {
	if (isSame(generateConfig$1, locale$5, date1, date2, type$2)) return true;
	return generateConfig$1.isAfter(date1, date2);
}
function getWeekStartDate(locale$5, generateConfig$1, value) {
	var weekFirstDay = generateConfig$1.locale.getWeekFirstDay(locale$5);
	var monthStartDate = generateConfig$1.setDate(value, 1);
	var startDateWeekDay = generateConfig$1.getWeekDay(monthStartDate);
	var alignStartDate = generateConfig$1.addDate(monthStartDate, weekFirstDay - startDateWeekDay);
	if (generateConfig$1.getMonth(alignStartDate) === generateConfig$1.getMonth(value) && generateConfig$1.getDate(alignStartDate) > 1) alignStartDate = generateConfig$1.addDate(alignStartDate, -7);
	return alignStartDate;
}
function formatValue(value, _ref) {
	var generateConfig$1 = _ref.generateConfig, locale$5 = _ref.locale, format$1 = _ref.format;
	if (!value) return "";
	return typeof format$1 === "function" ? format$1(value) : generateConfig$1.locale.format(locale$5.locale, value, format$1);
}
/**
* Fill the time info into Date if provided.
*/
function fillTime(generateConfig$1, date$1, time) {
	var tmpDate = date$1;
	var getFn = [
		"getHour",
		"getMinute",
		"getSecond",
		"getMillisecond"
	];
	[
		"setHour",
		"setMinute",
		"setSecond",
		"setMillisecond"
	].forEach(function(fn, index$1) {
		if (time) tmpDate = generateConfig$1[fn](tmpDate, generateConfig$1[getFn[index$1]](time));
		else tmpDate = generateConfig$1[fn](tmpDate, 0);
	});
	return tmpDate;
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/hooks/useDisabledBoundary.js
/**
* Merge `disabledDate` with `minDate` & `maxDate`.
*/
function useDisabledBoundary(generateConfig$1, locale$5, disabledDate, minDate, maxDate) {
	return useEvent_default(function(date$1, info) {
		if (disabledDate && disabledDate(date$1, info)) return true;
		if (minDate && generateConfig$1.isAfter(minDate, date$1) && !isSame(generateConfig$1, locale$5, minDate, date$1, info.type)) return true;
		if (maxDate && generateConfig$1.isAfter(date$1, maxDate) && !isSame(generateConfig$1, locale$5, maxDate, date$1, info.type)) return true;
		return false;
	});
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/hooks/useFieldFormat.js
function _typeof$24(o$2) {
	"@babel/helpers - typeof";
	return _typeof$24 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$24(o$2);
}
function useFieldFormat(picker, locale$5, format$1) {
	return import_react.useMemo(function() {
		var formatList = toArray$5(getRowFormat(picker, locale$5, format$1));
		var firstFormat = formatList[0];
		var maskFormat = _typeof$24(firstFormat) === "object" && firstFormat.type === "mask" ? firstFormat.format : null;
		return [formatList.map(function(config) {
			return typeof config === "string" || typeof config === "function" ? config : config.format;
		}), maskFormat];
	}, [
		picker,
		locale$5,
		format$1
	]);
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/hooks/useInputReadOnly.js
function useInputReadOnly(formatList, inputReadOnly, multiple) {
	if (typeof formatList[0] === "function" || multiple) return true;
	return inputReadOnly;
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/hooks/useInvalidate.js
function _typeof$23(o$2) {
	"@babel/helpers - typeof";
	return _typeof$23 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$23(o$2);
}
function ownKeys$13(e$2, r$1) {
	var t$1 = Object.keys(e$2);
	if (Object.getOwnPropertySymbols) {
		var o$2 = Object.getOwnPropertySymbols(e$2);
		r$1 && (o$2 = o$2.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e$2, r$2).enumerable;
		})), t$1.push.apply(t$1, o$2);
	}
	return t$1;
}
function _objectSpread$13(e$2) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$13(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$23(e$2, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$2, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$13(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e$2, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e$2;
}
function _defineProperty$23(obj, key, value) {
	key = _toPropertyKey$22(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$22(t$1) {
	var i = _toPrimitive$22(t$1, "string");
	return "symbol" == _typeof$23(i) ? i : String(i);
}
function _toPrimitive$22(t$1, r$1) {
	if ("object" != _typeof$23(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$23(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
/**
* Check if provided date is valid for the `disabledDate` & `showTime.disabledTime`.
*/
function useInvalidate(generateConfig$1, picker, disabledDate, showTime) {
	return useEvent_default(function(date$1, info) {
		var outsideInfo = _objectSpread$13({ type: picker }, info);
		delete outsideInfo.activeIndex;
		if (!generateConfig$1.isValidate(date$1) || disabledDate && disabledDate(date$1, outsideInfo)) return true;
		if ((picker === "date" || picker === "time") && showTime) {
			var _showTime$disabledTim;
			var range$1 = info && info.activeIndex === 1 ? "end" : "start";
			var _ref = ((_showTime$disabledTim = showTime.disabledTime) === null || _showTime$disabledTim === void 0 ? void 0 : _showTime$disabledTim.call(showTime, date$1, range$1, { from: outsideInfo.from })) || {}, disabledHours = _ref.disabledHours, disabledMinutes = _ref.disabledMinutes, disabledSeconds = _ref.disabledSeconds, disabledMilliseconds = _ref.disabledMilliseconds;
			var legacyDisabledHours = showTime.disabledHours, legacyDisabledMinutes = showTime.disabledMinutes, legacyDisabledSeconds = showTime.disabledSeconds;
			var mergedDisabledHours = disabledHours || legacyDisabledHours;
			var mergedDisabledMinutes = disabledMinutes || legacyDisabledMinutes;
			var mergedDisabledSeconds = disabledSeconds || legacyDisabledSeconds;
			var hour = generateConfig$1.getHour(date$1);
			var minute = generateConfig$1.getMinute(date$1);
			var second = generateConfig$1.getSecond(date$1);
			var millisecond = generateConfig$1.getMillisecond(date$1);
			if (mergedDisabledHours && mergedDisabledHours().includes(hour)) return true;
			if (mergedDisabledMinutes && mergedDisabledMinutes(hour).includes(minute)) return true;
			if (mergedDisabledSeconds && mergedDisabledSeconds(hour, minute).includes(second)) return true;
			if (disabledMilliseconds && disabledMilliseconds(hour, minute, second).includes(millisecond)) return true;
		}
		return false;
	});
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/hooks/useFilledProps.js
function _typeof$22(o$2) {
	"@babel/helpers - typeof";
	return _typeof$22 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$22(o$2);
}
function ownKeys$12(e$2, r$1) {
	var t$1 = Object.keys(e$2);
	if (Object.getOwnPropertySymbols) {
		var o$2 = Object.getOwnPropertySymbols(e$2);
		r$1 && (o$2 = o$2.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e$2, r$2).enumerable;
		})), t$1.push.apply(t$1, o$2);
	}
	return t$1;
}
function _objectSpread$12(e$2) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$12(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$22(e$2, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$2, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$12(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e$2, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e$2;
}
function _defineProperty$22(obj, key, value) {
	key = _toPropertyKey$21(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$21(t$1) {
	var i = _toPrimitive$21(t$1, "string");
	return "symbol" == _typeof$22(i) ? i : String(i);
}
function _toPrimitive$21(t$1, r$1) {
	if ("object" != _typeof$22(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$22(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _slicedToArray$29(arr, i) {
	return _arrayWithHoles$28(arr) || _iterableToArrayLimit$28(arr, i) || _unsupportedIterableToArray$31(arr, i) || _nonIterableRest$28();
}
function _nonIterableRest$28() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$31(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$30(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$30(o$2, minLen);
}
function _arrayLikeToArray$30(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$28(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$28(arr) {
	if (Array.isArray(arr)) return arr;
}
function useList(value) {
	var fillMode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
	return import_react.useMemo(function() {
		var list = value ? toArray$5(value) : value;
		if (fillMode && list) list[1] = list[1] || list[0];
		return list;
	}, [value, fillMode]);
}
/**
* Align the outer props with unique typed and fill undefined props.
* This is shared with both RangePicker and Picker. This will do:
* - Convert `value` & `defaultValue` to array
* - handle the legacy props fill like `clearIcon` + `allowClear` = `clearIcon`
*/
function useFilledProps(props, updater) {
	var generateConfig$1 = props.generateConfig, locale$5 = props.locale, _props$picker = props.picker, picker = _props$picker === void 0 ? "date" : _props$picker, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-picker" : _props$prefixCls, _props$previewValue = props.previewValue, previewValue = _props$previewValue === void 0 ? "hover" : _props$previewValue, _props$styles = props.styles, styles = _props$styles === void 0 ? {} : _props$styles, _props$classNames = props.classNames, classNames = _props$classNames === void 0 ? {} : _props$classNames, _props$order = props.order, order = _props$order === void 0 ? true : _props$order, _props$components = props.components, components$1 = _props$components === void 0 ? {} : _props$components, inputRender = props.inputRender, allowClear = props.allowClear, clearIcon = props.clearIcon, needConfirm = props.needConfirm, multiple = props.multiple, format$1 = props.format, inputReadOnly = props.inputReadOnly, disabledDate = props.disabledDate, minDate = props.minDate, maxDate = props.maxDate, showTime = props.showTime, value = props.value, defaultValue = props.defaultValue, pickerValue = props.pickerValue, defaultPickerValue = props.defaultPickerValue;
	var values = useList(value);
	var defaultValues = useList(defaultValue);
	var pickerValues = useList(pickerValue);
	var defaultPickerValues = useList(defaultPickerValue);
	/** Almost same as `picker`, but add `datetime` for `date` with `showTime` */
	var internalPicker = picker === "date" && showTime ? "datetime" : picker;
	/** The picker is `datetime` or `time` */
	var multipleInteractivePicker = internalPicker === "time" || internalPicker === "datetime";
	var complexPicker = multipleInteractivePicker || multiple;
	var mergedNeedConfirm = needConfirm !== null && needConfirm !== void 0 ? needConfirm : multipleInteractivePicker;
	var _getTimeProps2 = _slicedToArray$29(getTimeProps(props), 4), timeProps = _getTimeProps2[0], localeTimeProps = _getTimeProps2[1], showTimeFormat = _getTimeProps2[2], propFormat = _getTimeProps2[3];
	var mergedLocale = useLocale(locale$5, localeTimeProps);
	var mergedShowTime = import_react.useMemo(function() {
		return fillShowTimeConfig(internalPicker, showTimeFormat, propFormat, timeProps, mergedLocale);
	}, [
		internalPicker,
		showTimeFormat,
		propFormat,
		timeProps,
		mergedLocale
	]);
	if (picker === "time") {
		if ([
			"disabledHours",
			"disabledMinutes",
			"disabledSeconds"
		].some(function(key) {
			return props[key];
		})) warning_default$1(false, "'disabledHours', 'disabledMinutes', 'disabledSeconds' will be removed in the next major version, please use 'disabledTime' instead.");
	}
	var filledProps = import_react.useMemo(function() {
		return _objectSpread$12(_objectSpread$12({}, props), {}, {
			previewValue,
			prefixCls,
			locale: mergedLocale,
			picker,
			styles,
			classNames,
			order,
			components: _objectSpread$12({ input: inputRender }, components$1),
			clearIcon: fillClearIcon(prefixCls, allowClear, clearIcon),
			showTime: mergedShowTime,
			value: values,
			defaultValue: defaultValues,
			pickerValue: pickerValues,
			defaultPickerValue: defaultPickerValues
		}, updater === null || updater === void 0 ? void 0 : updater());
	}, [props]);
	var _useFieldFormat2 = _slicedToArray$29(useFieldFormat(internalPicker, mergedLocale, format$1), 2), formatList = _useFieldFormat2[0], maskFormat = _useFieldFormat2[1];
	var mergedInputReadOnly = useInputReadOnly(formatList, inputReadOnly, multiple);
	var disabledBoundaryDate = useDisabledBoundary(generateConfig$1, locale$5, disabledDate, minDate, maxDate);
	var isInvalidateDate = useInvalidate(generateConfig$1, picker, disabledBoundaryDate, mergedShowTime);
	return [
		import_react.useMemo(function() {
			return _objectSpread$12(_objectSpread$12({}, filledProps), {}, {
				needConfirm: mergedNeedConfirm,
				inputReadOnly: mergedInputReadOnly,
				disabledDate: disabledBoundaryDate
			});
		}, [
			filledProps,
			mergedNeedConfirm,
			mergedInputReadOnly,
			disabledBoundaryDate
		]),
		internalPicker,
		complexPicker,
		formatList,
		maskFormat,
		isInvalidateDate
	];
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/hooks/useDelayState.js
function _slicedToArray$28(arr, i) {
	return _arrayWithHoles$27(arr) || _iterableToArrayLimit$27(arr, i) || _unsupportedIterableToArray$30(arr, i) || _nonIterableRest$27();
}
function _nonIterableRest$27() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$30(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$29(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$29(o$2, minLen);
}
function _arrayLikeToArray$29(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$27(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$27(arr) {
	if (Array.isArray(arr)) return arr;
}
/**
* Will be `true` immediately for next effect.
* But will be `false` for a delay of effect.
*/
function useDelayState(value, defaultValue, onChange) {
	var _useControlledState2 = _slicedToArray$28(useControlledState(defaultValue, value), 2), state = _useControlledState2[0], setState = _useControlledState2[1];
	var forceUpdate = _slicedToArray$28(import_react.useState({}), 2)[1];
	var triggerUpdate = useEvent_default(function(nextState) {
		setState(nextState);
		forceUpdate({});
	});
	var nextValueRef = import_react.useRef(value);
	var rafRef = import_react.useRef();
	var cancelRaf = function cancelRaf$1() {
		raf_default.cancel(rafRef.current);
	};
	var doUpdate = useEvent_default(function() {
		triggerUpdate(nextValueRef.current);
		if (onChange && state !== nextValueRef.current) onChange(nextValueRef.current);
	});
	var updateValue = useEvent_default(function(next$1, immediately) {
		cancelRaf();
		nextValueRef.current = next$1;
		if (next$1 || immediately) doUpdate();
		else rafRef.current = raf_default(doUpdate);
	});
	import_react.useEffect(function() {
		return cancelRaf;
	}, []);
	return [state, updateValue];
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/hooks/useOpen.js
function _slicedToArray$27(arr, i) {
	return _arrayWithHoles$26(arr) || _iterableToArrayLimit$26(arr, i) || _unsupportedIterableToArray$29(arr, i) || _nonIterableRest$26();
}
function _nonIterableRest$26() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$29(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$28(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$28(o$2, minLen);
}
function _arrayLikeToArray$28(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$26(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$26(arr) {
	if (Array.isArray(arr)) return arr;
}
/**
* Control the open state.
* Will not close if activeElement is on the popup.
*/
function useOpen(open$2, defaultOpen) {
	var disabledList = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
	var onOpenChange = arguments.length > 3 ? arguments[3] : void 0;
	var _useDelayState2 = _slicedToArray$27(useDelayState(disabledList.every(function(disabled) {
		return disabled;
	}) ? false : open$2, defaultOpen || false, onOpenChange), 2), rafOpen = _useDelayState2[0], setRafOpen = _useDelayState2[1];
	function setOpen(next$1) {
		var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
		if (!config.inherit || rafOpen) setRafOpen(next$1, config.force);
	}
	return [rafOpen, setOpen];
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/hooks/usePickerRef.js
function usePickerRef(ref) {
	var selectorRef = import_react.useRef();
	import_react.useImperativeHandle(ref, function() {
		var _selectorRef$current;
		return {
			nativeElement: (_selectorRef$current = selectorRef.current) === null || _selectorRef$current === void 0 ? void 0 : _selectorRef$current.nativeElement,
			focus: function focus(options) {
				var _selectorRef$current2;
				(_selectorRef$current2 = selectorRef.current) === null || _selectorRef$current2 === void 0 || _selectorRef$current2.focus(options);
			},
			blur: function blur() {
				var _selectorRef$current3;
				(_selectorRef$current3 = selectorRef.current) === null || _selectorRef$current3 === void 0 || _selectorRef$current3.blur();
			}
		};
	});
	return selectorRef;
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/hooks/usePresets.js
function _slicedToArray$26(arr, i) {
	return _arrayWithHoles$25(arr) || _iterableToArrayLimit$25(arr, i) || _unsupportedIterableToArray$28(arr, i) || _nonIterableRest$25();
}
function _nonIterableRest$25() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$28(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$27(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$27(o$2, minLen);
}
function _arrayLikeToArray$27(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$25(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$25(arr) {
	if (Array.isArray(arr)) return arr;
}
function usePresets(presets, legacyRanges) {
	return import_react.useMemo(function() {
		if (presets) return presets;
		if (legacyRanges) {
			warning_default$1(false, "`ranges` is deprecated. Please use `presets` instead.");
			return Object.entries(legacyRanges).map(function(_ref) {
				var _ref2 = _slicedToArray$26(_ref, 2);
				return {
					label: _ref2[0],
					value: _ref2[1]
				};
			});
		}
		return [];
	}, [presets, legacyRanges]);
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/hooks/useLockEffect.js
/**
* Trigger `callback` immediately when `condition` is `true`.
* But trigger `callback` in next frame when `condition` is `false`.
*/
function useLockEffect(condition, callback) {
	var delayFrames = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
	var callbackRef = import_react.useRef(callback);
	callbackRef.current = callback;
	useLayoutUpdateEffect(function() {
		if (condition) callbackRef.current(condition);
		else {
			var id = raf_default(function() {
				callbackRef.current(condition);
			}, delayFrames);
			return function() {
				raf_default.cancel(id);
			};
		}
	}, [condition]);
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/hooks/useRangeActive.js
function _slicedToArray$25(arr, i) {
	return _arrayWithHoles$24(arr) || _iterableToArrayLimit$24(arr, i) || _unsupportedIterableToArray$27(arr, i) || _nonIterableRest$24();
}
function _nonIterableRest$24() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$27(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$26(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$26(o$2, minLen);
}
function _arrayLikeToArray$26(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$24(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$24(arr) {
	if (Array.isArray(arr)) return arr;
}
/**
* When user first focus one input, any submit will trigger focus another one.
* When second time focus one input, submit will not trigger focus again.
* When click outside to close the panel, trigger event if it can trigger onChange.
*/
function useRangeActive(disabled) {
	var empty$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
	var mergedOpen = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
	var _React$useState2 = _slicedToArray$25(import_react.useState(0), 2), activeIndex = _React$useState2[0], setActiveIndex = _React$useState2[1];
	var _React$useState4 = _slicedToArray$25(import_react.useState(false), 2), focused = _React$useState4[0], setFocused = _React$useState4[1];
	var activeListRef = import_react.useRef([]);
	var submitIndexRef = import_react.useRef(null);
	var lastOperationRef = import_react.useRef(null);
	var updateSubmitIndex = function updateSubmitIndex$1(index$1) {
		submitIndexRef.current = index$1;
	};
	var hasActiveSubmitValue = function hasActiveSubmitValue$1(index$1) {
		return submitIndexRef.current === index$1;
	};
	var triggerFocus$1 = function triggerFocus$2(nextFocus) {
		setFocused(nextFocus);
	};
	var lastOperation = function lastOperation$1(type$2) {
		if (type$2) lastOperationRef.current = type$2;
		return lastOperationRef.current;
	};
	var nextActiveIndex = function nextActiveIndex$1(nextValue) {
		var list = activeListRef.current;
		var filledActiveSet = new Set(list.filter(function(index$1) {
			return nextValue[index$1] || empty$1[index$1];
		}));
		var nextIndex = list[list.length - 1] === 0 ? 1 : 0;
		if (filledActiveSet.size >= 2 || disabled[nextIndex]) return null;
		return nextIndex;
	};
	useLockEffect(focused || mergedOpen, function() {
		if (!focused) {
			activeListRef.current = [];
			updateSubmitIndex(null);
		}
	});
	import_react.useEffect(function() {
		if (focused) activeListRef.current.push(activeIndex);
	}, [focused, activeIndex]);
	return [
		focused,
		triggerFocus$1,
		lastOperation,
		activeIndex,
		setActiveIndex,
		nextActiveIndex,
		activeListRef.current,
		updateSubmitIndex,
		hasActiveSubmitValue
	];
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/hooks/useRangeDisabledDate.js
function _typeof$21(o$2) {
	"@babel/helpers - typeof";
	return _typeof$21 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$21(o$2);
}
function ownKeys$11(e$2, r$1) {
	var t$1 = Object.keys(e$2);
	if (Object.getOwnPropertySymbols) {
		var o$2 = Object.getOwnPropertySymbols(e$2);
		r$1 && (o$2 = o$2.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e$2, r$2).enumerable;
		})), t$1.push.apply(t$1, o$2);
	}
	return t$1;
}
function _objectSpread$11(e$2) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$11(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$21(e$2, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$2, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$11(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e$2, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e$2;
}
function _defineProperty$21(obj, key, value) {
	key = _toPropertyKey$20(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$20(t$1) {
	var i = _toPrimitive$20(t$1, "string");
	return "symbol" == _typeof$21(i) ? i : String(i);
}
function _toPrimitive$20(t$1, r$1) {
	if ("object" != _typeof$21(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$21(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _slicedToArray$24(arr, i) {
	return _arrayWithHoles$23(arr) || _iterableToArrayLimit$23(arr, i) || _unsupportedIterableToArray$26(arr, i) || _nonIterableRest$23();
}
function _nonIterableRest$23() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$26(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$25(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$25(o$2, minLen);
}
function _arrayLikeToArray$25(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$23(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$23(arr) {
	if (Array.isArray(arr)) return arr;
}
/**
* RangePicker need additional logic to handle the `disabled` case. e.g.
* [disabled, enabled] should end date not before start date
*/
function useRangeDisabledDate(values, disabled, activeIndexList, generateConfig$1, locale$5, disabledDate) {
	var activeIndex = activeIndexList[activeIndexList.length - 1];
	return function rangeDisabledDate(date$1, info) {
		var _values = _slicedToArray$24(values, 2), start = _values[0], end = _values[1];
		var mergedInfo = _objectSpread$11(_objectSpread$11({}, info), {}, { from: getFromDate(values, activeIndexList) });
		if (activeIndex === 1 && disabled[0] && start && !isSame(generateConfig$1, locale$5, start, date$1, mergedInfo.type) && generateConfig$1.isAfter(start, date$1)) return true;
		if (activeIndex === 0 && disabled[1] && end && !isSame(generateConfig$1, locale$5, end, date$1, mergedInfo.type) && generateConfig$1.isAfter(date$1, end)) return true;
		return disabledDate === null || disabledDate === void 0 ? void 0 : disabledDate(date$1, mergedInfo);
	};
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/hooks/useRangePickerValue.js
function _slicedToArray$23(arr, i) {
	return _arrayWithHoles$22(arr) || _iterableToArrayLimit$22(arr, i) || _unsupportedIterableToArray$25(arr, i) || _nonIterableRest$22();
}
function _nonIterableRest$22() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$25(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$24(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$24(o$2, minLen);
}
function _arrayLikeToArray$24(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$22(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$22(arr) {
	if (Array.isArray(arr)) return arr;
}
function offsetPanelDate(generateConfig$1, picker, date$1, offset$2) {
	switch (picker) {
		case "date":
		case "week": return generateConfig$1.addMonth(date$1, offset$2);
		case "month":
		case "quarter": return generateConfig$1.addYear(date$1, offset$2);
		case "year": return generateConfig$1.addYear(date$1, offset$2 * 10);
		case "decade": return generateConfig$1.addYear(date$1, offset$2 * 100);
		default: return date$1;
	}
}
var EMPTY_LIST$3 = [];
function useRangePickerValue(generateConfig$1, locale$5, calendarValue, modes, open$2, activeIndex, pickerMode, multiplePanel) {
	var defaultPickerValue = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : EMPTY_LIST$3;
	var pickerValue = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : EMPTY_LIST$3;
	var timeDefaultValue = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : EMPTY_LIST$3;
	var onPickerValueChange = arguments.length > 11 ? arguments[11] : void 0;
	var minDate = arguments.length > 12 ? arguments[12] : void 0;
	var maxDate = arguments.length > 13 ? arguments[13] : void 0;
	var isTimePicker = pickerMode === "time";
	var mergedActiveIndex = activeIndex || 0;
	var getDefaultPickerValue = function getDefaultPickerValue$1(index$1) {
		var now$1 = generateConfig$1.getNow();
		if (isTimePicker) now$1 = fillTime(generateConfig$1, now$1);
		return defaultPickerValue[index$1] || calendarValue[index$1] || now$1;
	};
	var _pickerValue = _slicedToArray$23(pickerValue, 2), startPickerValue = _pickerValue[0], endPickerValue = _pickerValue[1];
	var _useControlledState2 = _slicedToArray$23(useControlledState(function() {
		return getDefaultPickerValue(0);
	}, startPickerValue), 2), mergedStartPickerValue = _useControlledState2[0], setStartPickerValue = _useControlledState2[1];
	var _useControlledState4 = _slicedToArray$23(useControlledState(function() {
		return getDefaultPickerValue(1);
	}, endPickerValue), 2), mergedEndPickerValue = _useControlledState4[0], setEndPickerValue = _useControlledState4[1];
	var currentPickerValue = import_react.useMemo(function() {
		var current = [mergedStartPickerValue, mergedEndPickerValue][mergedActiveIndex];
		return isTimePicker ? current : fillTime(generateConfig$1, current, timeDefaultValue[mergedActiveIndex]);
	}, [
		isTimePicker,
		mergedStartPickerValue,
		mergedEndPickerValue,
		mergedActiveIndex,
		generateConfig$1,
		timeDefaultValue
	]);
	var setCurrentPickerValue = function setCurrentPickerValue$1(nextPickerValue) {
		var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "panel";
		var updater = [setStartPickerValue, setEndPickerValue][mergedActiveIndex];
		updater(nextPickerValue);
		var clone = [mergedStartPickerValue, mergedEndPickerValue];
		clone[mergedActiveIndex] = nextPickerValue;
		if (onPickerValueChange && (!isSame(generateConfig$1, locale$5, mergedStartPickerValue, clone[0], pickerMode) || !isSame(generateConfig$1, locale$5, mergedEndPickerValue, clone[1], pickerMode))) onPickerValueChange(clone, {
			source,
			range: mergedActiveIndex === 1 ? "end" : "start",
			mode: modes
		});
	};
	/**
	* EndDate pickerValue is little different. It should be:
	* - If date picker (without time), endDate is not same year & month as startDate
	*   - pickerValue minus one month
	* - Else pass directly
	*/
	var getEndDatePickerValue = function getEndDatePickerValue$1(startDate, endDate) {
		if (multiplePanel) {
			var mode = {
				date: "month",
				week: "month",
				month: "year",
				quarter: "year"
			}[pickerMode];
			if (mode && !isSame(generateConfig$1, locale$5, startDate, endDate, mode)) return offsetPanelDate(generateConfig$1, pickerMode, endDate, -1);
			if (pickerMode === "year" && startDate) {
				if (Math.floor(generateConfig$1.getYear(startDate) / 10) !== Math.floor(generateConfig$1.getYear(endDate) / 10)) return offsetPanelDate(generateConfig$1, pickerMode, endDate, -1);
			}
		}
		return endDate;
	};
	var prevActiveIndexRef = import_react.useRef(null);
	useLayoutEffect_default(function() {
		if (open$2) {
			if (!defaultPickerValue[mergedActiveIndex]) {
				var nextPickerValue = isTimePicker ? null : generateConfig$1.getNow();
				/**
				* 1. If has prevActiveIndex, use it to avoid panel jump
				* 2. If current field has value
				*    - If `activeIndex` is 1 and `calendarValue[0]` is not same panel as `calendarValue[1]`,
				*      offset `calendarValue[1]` and set it
				*    - Else use `calendarValue[activeIndex]`
				* 3. If current field has no value but another field has value, use another field value
				* 4. Else use now (not any `calendarValue` can ref)
				*/
				if (prevActiveIndexRef.current !== null && prevActiveIndexRef.current !== mergedActiveIndex) nextPickerValue = [mergedStartPickerValue, mergedEndPickerValue][mergedActiveIndex ^ 1];
				else if (calendarValue[mergedActiveIndex]) nextPickerValue = mergedActiveIndex === 0 ? calendarValue[0] : getEndDatePickerValue(calendarValue[0], calendarValue[1]);
				else if (calendarValue[mergedActiveIndex ^ 1]) nextPickerValue = calendarValue[mergedActiveIndex ^ 1];
				if (nextPickerValue) {
					if (minDate && generateConfig$1.isAfter(minDate, nextPickerValue)) nextPickerValue = minDate;
					var offsetPickerValue = multiplePanel ? offsetPanelDate(generateConfig$1, pickerMode, nextPickerValue, 1) : nextPickerValue;
					if (maxDate && generateConfig$1.isAfter(offsetPickerValue, maxDate)) nextPickerValue = multiplePanel ? offsetPanelDate(generateConfig$1, pickerMode, maxDate, -1) : maxDate;
					setCurrentPickerValue(nextPickerValue, "reset");
				}
			}
		}
	}, [
		open$2,
		mergedActiveIndex,
		calendarValue[mergedActiveIndex]
	]);
	import_react.useEffect(function() {
		if (open$2) prevActiveIndexRef.current = mergedActiveIndex;
		else prevActiveIndexRef.current = null;
	}, [open$2, mergedActiveIndex]);
	useLayoutEffect_default(function() {
		if (open$2 && defaultPickerValue) {
			if (defaultPickerValue[mergedActiveIndex]) setCurrentPickerValue(defaultPickerValue[mergedActiveIndex], "reset");
		}
	}, [open$2, mergedActiveIndex]);
	return [currentPickerValue, setCurrentPickerValue];
}

//#endregion
//#region node_modules/@rc-component/picker/es/hooks/useSyncState.js
function _slicedToArray$22(arr, i) {
	return _arrayWithHoles$21(arr) || _iterableToArrayLimit$21(arr, i) || _unsupportedIterableToArray$24(arr, i) || _nonIterableRest$21();
}
function _nonIterableRest$21() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$24(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$23(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$23(o$2, minLen);
}
function _arrayLikeToArray$23(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$21(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$21(arr) {
	if (Array.isArray(arr)) return arr;
}
/**
* Sync value with state.
* This should only used for internal which not affect outside calculation.
* Since it's not safe for suspense.
*/
function useSyncState$2(defaultValue, controlledValue) {
	var valueRef = import_react.useRef(defaultValue);
	var forceUpdate = _slicedToArray$22(import_react.useState({}), 2)[1];
	var getter = function getter$1(useControlledValueFirst) {
		return useControlledValueFirst && controlledValue !== void 0 ? controlledValue : valueRef.current;
	};
	return [
		getter,
		function setter(nextValue) {
			valueRef.current = nextValue;
			forceUpdate({});
		},
		getter(true)
	];
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/hooks/useRangeValue.js
function _slicedToArray$21(arr, i) {
	return _arrayWithHoles$20(arr) || _iterableToArrayLimit$20(arr, i) || _unsupportedIterableToArray$23(arr, i) || _nonIterableRest$20();
}
function _nonIterableRest$20() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit$20(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$20(arr) {
	if (Array.isArray(arr)) return arr;
}
function _toConsumableArray$7(arr) {
	return _arrayWithoutHoles$6(arr) || _iterableToArray$6(arr) || _unsupportedIterableToArray$23(arr) || _nonIterableSpread$6();
}
function _nonIterableSpread$6() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$23(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$22(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$22(o$2, minLen);
}
function _iterableToArray$6(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$6(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$22(arr);
}
function _arrayLikeToArray$22(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
var EMPTY_VALUE = [];
function useUtil(generateConfig$1, locale$5, formatList) {
	return [function getDateTexts(dates) {
		return dates.map(function(date$1) {
			return formatValue(date$1, {
				generateConfig: generateConfig$1,
				locale: locale$5,
				format: formatList[0]
			});
		});
	}, function isSameDates(source, target) {
		var maxLen = Math.max(source.length, target.length);
		var diffIndex = -1;
		for (var i = 0; i < maxLen; i += 1) {
			var prev$1 = source[i] || null;
			var next$1 = target[i] || null;
			if (prev$1 !== next$1 && !isSameTimestamp(generateConfig$1, prev$1, next$1)) {
				diffIndex = i;
				break;
			}
		}
		return [diffIndex < 0, diffIndex !== 0];
	}];
}
function orderDates(dates, generateConfig$1) {
	return _toConsumableArray$7(dates).sort(function(a, b) {
		return generateConfig$1.isAfter(a, b) ? 1 : -1;
	});
}
/**
* Used for internal value management.
* It should always use `mergedValue` in render logic
*/
function useCalendarValue(mergedValue) {
	var _useSyncState2 = _slicedToArray$21(useSyncState$2(mergedValue), 2), calendarValue = _useSyncState2[0], setCalendarValue = _useSyncState2[1];
	/** Sync calendarValue & submitValue back with value */
	var syncWithValue = useEvent_default(function() {
		setCalendarValue(mergedValue);
	});
	import_react.useEffect(function() {
		syncWithValue();
	}, [mergedValue]);
	return [calendarValue, setCalendarValue];
}
/**
* Control the internal `value` align with prop `value` and provide a temp `calendarValue` for ui.
* `calendarValue` will be reset when blur & focus & open.
*/
function useInnerValue(generateConfig$1, locale$5, formatList, rangeValue, order, defaultValue, value, onCalendarChange, onOk) {
	var _useControlledState2 = _slicedToArray$21(useControlledState(defaultValue, value), 2), innerValue = _useControlledState2[0], setInnerValue = _useControlledState2[1];
	var mergedValue = innerValue || EMPTY_VALUE;
	var _useCalendarValue2 = _slicedToArray$21(useCalendarValue(mergedValue), 2), calendarValue = _useCalendarValue2[0], setCalendarValue = _useCalendarValue2[1];
	var _useUtil2 = _slicedToArray$21(useUtil(generateConfig$1, locale$5, formatList), 2), getDateTexts = _useUtil2[0], isSameDates = _useUtil2[1];
	return [
		mergedValue,
		setInnerValue,
		calendarValue,
		useEvent_default(function(nextCalendarValues) {
			var clone = _toConsumableArray$7(nextCalendarValues);
			if (rangeValue) for (var i = 0; i < 2; i += 1) clone[i] = clone[i] || null;
			else if (order) clone = orderDates(clone.filter(function(date$1) {
				return date$1;
			}), generateConfig$1);
			var _isSameDates2 = _slicedToArray$21(isSameDates(calendarValue(), clone), 2), isSameMergedDates = _isSameDates2[0], isSameStart = _isSameDates2[1];
			if (!isSameMergedDates) {
				setCalendarValue(clone);
				if (onCalendarChange) {
					var cellTexts = getDateTexts(clone);
					onCalendarChange(clone, cellTexts, { range: isSameStart ? "end" : "start" });
				}
			}
		}),
		function triggerOk() {
			if (onOk) onOk(calendarValue());
		}
	];
}
function useRangeValue(info, mergedValue, setInnerValue, getCalendarValue, triggerCalendarChange, disabled, formatList, focused, open$2, isInvalidateDate) {
	var generateConfig$1 = info.generateConfig, locale$5 = info.locale, picker = info.picker, onChange = info.onChange, allowEmpty = info.allowEmpty, order = info.order;
	var orderOnChange = disabled.some(function(d) {
		return d;
	}) ? false : order;
	var _useUtil4 = _slicedToArray$21(useUtil(generateConfig$1, locale$5, formatList), 2), getDateTexts = _useUtil4[0], isSameDates = _useUtil4[1];
	var _useSyncState4 = _slicedToArray$21(useSyncState$2(mergedValue), 2), submitValue = _useSyncState4[0], setSubmitValue = _useSyncState4[1];
	/** Sync calendarValue & submitValue back with value */
	var syncWithValue = useEvent_default(function() {
		setSubmitValue(mergedValue);
	});
	import_react.useEffect(function() {
		syncWithValue();
	}, [mergedValue]);
	var triggerSubmit = useEvent_default(function(nextValue) {
		var isNullValue = nextValue === null;
		var clone = _toConsumableArray$7(nextValue || submitValue());
		if (isNullValue) {
			var maxLen = Math.max(disabled.length, clone.length);
			for (var i = 0; i < maxLen; i += 1) if (!disabled[i]) clone[i] = null;
		}
		if (orderOnChange && clone[0] && clone[1]) clone = orderDates(clone, generateConfig$1);
		triggerCalendarChange(clone);
		var _clone2 = _slicedToArray$21(clone, 2), start = _clone2[0], end = _clone2[1];
		var startEmpty = !start;
		var endEmpty = !end;
		var validateEmptyDateRange = allowEmpty ? (!startEmpty || allowEmpty[0]) && (!endEmpty || allowEmpty[1]) : true;
		var validateOrder = !order || startEmpty || endEmpty || isSame(generateConfig$1, locale$5, start, end, picker) || generateConfig$1.isAfter(end, start);
		var validateDates = (disabled[0] || !start || !isInvalidateDate(start, { activeIndex: 0 })) && (disabled[1] || !end || !isInvalidateDate(end, {
			from: start,
			activeIndex: 1
		}));
		var allPassed = isNullValue || validateEmptyDateRange && validateOrder && validateDates;
		if (allPassed) {
			setInnerValue(clone);
			var isSameMergedDates = _slicedToArray$21(isSameDates(clone, mergedValue), 1)[0];
			if (onChange && !isSameMergedDates) {
				var everyEmpty = clone.every(function(val) {
					return !val;
				});
				onChange(isNullValue && everyEmpty ? null : clone, everyEmpty ? null : getDateTexts(clone));
			}
		}
		return allPassed;
	});
	var flushSubmit = useEvent_default(function(index$1, needTriggerChange) {
		setSubmitValue(fillIndex(submitValue(), index$1, getCalendarValue()[index$1]));
		if (needTriggerChange) triggerSubmit();
	});
	var interactiveFinished = !focused && !open$2;
	useLockEffect(!interactiveFinished, function() {
		if (interactiveFinished) {
			triggerSubmit();
			triggerCalendarChange(mergedValue);
			syncWithValue();
		}
	}, 2);
	return [flushSubmit, triggerSubmit];
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/hooks/useShowNow.js
function useShowNow(picker, mode, showNow, showToday, rangePicker) {
	if (mode !== "date" && mode !== "time") return false;
	if (showNow !== void 0) return showNow;
	if (showToday !== void 0) return showToday;
	return !rangePicker && (picker === "date" || picker === "time");
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerPanel/TimePanel/TimePanelBody/util.js
function _toConsumableArray$6(arr) {
	return _arrayWithoutHoles$5(arr) || _iterableToArray$5(arr) || _unsupportedIterableToArray$22(arr) || _nonIterableSpread$5();
}
function _nonIterableSpread$5() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$22(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$21(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$21(o$2, minLen);
}
function _iterableToArray$5(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$5(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$21(arr);
}
function _arrayLikeToArray$21(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function findValidateTime(date$1, getHourUnits, getMinuteUnits, getSecondUnits, getMillisecondUnits, generateConfig$1) {
	var nextDate = date$1;
	function alignValidate(getUnitValue$1, setUnitValue, units) {
		var nextValue = generateConfig$1[getUnitValue$1](nextDate);
		var nextUnit = units.find(function(unit$2) {
			return unit$2.value === nextValue;
		});
		if (!nextUnit || nextUnit.disabled) {
			var validateUnits = units.filter(function(unit$2) {
				return !unit$2.disabled;
			});
			var validateUnit = _toConsumableArray$6(validateUnits).reverse().find(function(unit$2) {
				return unit$2.value <= nextValue;
			}) || validateUnits[0];
			if (validateUnit) {
				nextValue = validateUnit.value;
				nextDate = generateConfig$1[setUnitValue](nextDate, nextValue);
			}
		}
		return nextValue;
	}
	var nextHour = alignValidate("getHour", "setHour", getHourUnits());
	var nextMinute = alignValidate("getMinute", "setMinute", getMinuteUnits(nextHour));
	alignValidate("getMillisecond", "setMillisecond", getMillisecondUnits(nextHour, nextMinute, alignValidate("getSecond", "setSecond", getSecondUnits(nextHour, nextMinute))));
	return nextDate;
}

//#endregion
//#region node_modules/@rc-component/picker/es/hooks/useTimeInfo.js
function _typeof$20(o$2) {
	"@babel/helpers - typeof";
	return _typeof$20 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$20(o$2);
}
function ownKeys$10(e$2, r$1) {
	var t$1 = Object.keys(e$2);
	if (Object.getOwnPropertySymbols) {
		var o$2 = Object.getOwnPropertySymbols(e$2);
		r$1 && (o$2 = o$2.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e$2, r$2).enumerable;
		})), t$1.push.apply(t$1, o$2);
	}
	return t$1;
}
function _objectSpread$10(e$2) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$10(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$20(e$2, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$2, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$10(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e$2, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e$2;
}
function _defineProperty$20(obj, key, value) {
	key = _toPropertyKey$19(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$19(t$1) {
	var i = _toPrimitive$19(t$1, "string");
	return "symbol" == _typeof$20(i) ? i : String(i);
}
function _toPrimitive$19(t$1, r$1) {
	if ("object" != _typeof$20(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$20(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _slicedToArray$20(arr, i) {
	return _arrayWithHoles$19(arr) || _iterableToArrayLimit$19(arr, i) || _unsupportedIterableToArray$21(arr, i) || _nonIterableRest$19();
}
function _nonIterableRest$19() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$21(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$20(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$20(o$2, minLen);
}
function _arrayLikeToArray$20(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$19(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$19(arr) {
	if (Array.isArray(arr)) return arr;
}
function emptyDisabled() {
	return [];
}
function generateUnits(start, end) {
	var step = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
	var hideDisabledOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
	var disabledUnits = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [];
	var pad = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 2;
	var units = [];
	var integerStep = step >= 1 ? step | 0 : 1;
	for (var i = start; i <= end; i += integerStep) {
		var disabled = disabledUnits.includes(i);
		if (!disabled || !hideDisabledOptions) units.push({
			label: leftPad(i, pad),
			value: i,
			disabled
		});
	}
	return units;
}
/**
* Parse time props to get util info
*/
function useTimeInfo(generateConfig$1) {
	var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
	var date$1 = arguments.length > 2 ? arguments[2] : void 0;
	var _ref = props || {}, use12Hours = _ref.use12Hours, _ref$hourStep = _ref.hourStep, hourStep = _ref$hourStep === void 0 ? 1 : _ref$hourStep, _ref$minuteStep = _ref.minuteStep, minuteStep = _ref$minuteStep === void 0 ? 1 : _ref$minuteStep, _ref$secondStep = _ref.secondStep, secondStep = _ref$secondStep === void 0 ? 1 : _ref$secondStep, _ref$millisecondStep = _ref.millisecondStep, millisecondStep = _ref$millisecondStep === void 0 ? 100 : _ref$millisecondStep, hideDisabledOptions = _ref.hideDisabledOptions, disabledTime = _ref.disabledTime, disabledHours = _ref.disabledHours, disabledMinutes = _ref.disabledMinutes, disabledSeconds = _ref.disabledSeconds;
	var mergedDate = import_react.useMemo(function() {
		return date$1 || generateConfig$1.getNow();
	}, [date$1, generateConfig$1]);
	var isHourStepValid = 24 % hourStep === 0;
	var isMinuteStepValid = 60 % minuteStep === 0;
	var isSecondStepValid = 60 % secondStep === 0;
	warning_default$1(isHourStepValid, "`hourStep` ".concat(hourStep, " is invalid. It should be a factor of 24."));
	warning_default$1(isMinuteStepValid, "`minuteStep` ".concat(minuteStep, " is invalid. It should be a factor of 60."));
	warning_default$1(isSecondStepValid, "`secondStep` ".concat(secondStep, " is invalid. It should be a factor of 60."));
	var getDisabledTimes = import_react.useCallback(function(targetDate) {
		var disabledConfig = (disabledTime === null || disabledTime === void 0 ? void 0 : disabledTime(targetDate)) || {};
		return [
			disabledConfig.disabledHours || disabledHours || emptyDisabled,
			disabledConfig.disabledMinutes || disabledMinutes || emptyDisabled,
			disabledConfig.disabledSeconds || disabledSeconds || emptyDisabled,
			disabledConfig.disabledMilliseconds || emptyDisabled
		];
	}, [
		disabledTime,
		disabledHours,
		disabledMinutes,
		disabledSeconds
	]);
	var _React$useMemo2 = _slicedToArray$20(import_react.useMemo(function() {
		return getDisabledTimes(mergedDate);
	}, [mergedDate, getDisabledTimes]), 4), mergedDisabledHours = _React$useMemo2[0], mergedDisabledMinutes = _React$useMemo2[1], mergedDisabledSeconds = _React$useMemo2[2], mergedDisabledMilliseconds = _React$useMemo2[3];
	var getAllUnits = import_react.useCallback(function(getDisabledHours, getDisabledMinutes, getDisabledSeconds, getDisabledMilliseconds) {
		var hours = generateUnits(0, 23, hourStep, hideDisabledOptions, getDisabledHours());
		return [
			use12Hours ? hours.map(function(unit$2) {
				return _objectSpread$10(_objectSpread$10({}, unit$2), {}, { label: leftPad(unit$2.value % 12 || 12, 2) });
			}) : hours,
			function getMinuteUnits$1(nextHour) {
				return generateUnits(0, 59, minuteStep, hideDisabledOptions, getDisabledMinutes(nextHour));
			},
			function getSecondUnits$1(nextHour, nextMinute) {
				return generateUnits(0, 59, secondStep, hideDisabledOptions, getDisabledSeconds(nextHour, nextMinute));
			},
			function getMillisecondUnits$1(nextHour, nextMinute, nextSecond) {
				return generateUnits(0, 999, millisecondStep, hideDisabledOptions, getDisabledMilliseconds(nextHour, nextMinute, nextSecond), 3);
			}
		];
	}, [
		hideDisabledOptions,
		hourStep,
		use12Hours,
		millisecondStep,
		minuteStep,
		secondStep
	]);
	var _React$useMemo4 = _slicedToArray$20(import_react.useMemo(function() {
		return getAllUnits(mergedDisabledHours, mergedDisabledMinutes, mergedDisabledSeconds, mergedDisabledMilliseconds);
	}, [
		getAllUnits,
		mergedDisabledHours,
		mergedDisabledMinutes,
		mergedDisabledSeconds,
		mergedDisabledMilliseconds
	]), 4), rowHourUnits = _React$useMemo4[0], getMinuteUnits = _React$useMemo4[1], getSecondUnits = _React$useMemo4[2], getMillisecondUnits = _React$useMemo4[3];
	return [
		function getValidTime(nextTime, certainDate) {
			var getCheckHourUnits = function getCheckHourUnits$1() {
				return rowHourUnits;
			};
			var getCheckMinuteUnits = getMinuteUnits;
			var getCheckSecondUnits = getSecondUnits;
			var getCheckMillisecondUnits = getMillisecondUnits;
			if (certainDate) {
				var _getDisabledTimes2 = _slicedToArray$20(getDisabledTimes(certainDate), 4), targetDisabledHours = _getDisabledTimes2[0], targetDisabledMinutes = _getDisabledTimes2[1], targetDisabledSeconds = _getDisabledTimes2[2], targetDisabledMilliseconds = _getDisabledTimes2[3];
				var _getAllUnits2 = _slicedToArray$20(getAllUnits(targetDisabledHours, targetDisabledMinutes, targetDisabledSeconds, targetDisabledMilliseconds), 4), targetRowHourUnits = _getAllUnits2[0], targetGetMinuteUnits = _getAllUnits2[1], targetGetSecondUnits = _getAllUnits2[2], targetGetMillisecondUnits = _getAllUnits2[3];
				getCheckHourUnits = function getCheckHourUnits$1() {
					return targetRowHourUnits;
				};
				getCheckMinuteUnits = targetGetMinuteUnits;
				getCheckSecondUnits = targetGetSecondUnits;
				getCheckMillisecondUnits = targetGetMillisecondUnits;
			}
			return findValidateTime(nextTime, getCheckHourUnits, getCheckMinuteUnits, getCheckSecondUnits, getCheckMillisecondUnits, generateConfig$1);
		},
		rowHourUnits,
		getMinuteUnits,
		getSecondUnits,
		getMillisecondUnits
	];
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/Popup/Footer.js
function _slicedToArray$19(arr, i) {
	return _arrayWithHoles$18(arr) || _iterableToArrayLimit$18(arr, i) || _unsupportedIterableToArray$20(arr, i) || _nonIterableRest$18();
}
function _nonIterableRest$18() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$20(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$19(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$19(o$2, minLen);
}
function _arrayLikeToArray$19(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$18(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$18(arr) {
	if (Array.isArray(arr)) return arr;
}
function Footer$4(props) {
	var mode = props.mode, internalMode = props.internalMode, renderExtraFooter = props.renderExtraFooter, showNow = props.showNow, showTime = props.showTime, onSubmit = props.onSubmit, onNow = props.onNow, invalid = props.invalid, needConfirm = props.needConfirm, generateConfig$1 = props.generateConfig, disabledDate = props.disabledDate;
	var _React$useContext = import_react.useContext(context_default$5), prefixCls = _React$useContext.prefixCls, locale$5 = _React$useContext.locale, _React$useContext$but = _React$useContext.button, Button$1 = _React$useContext$but === void 0 ? "button" : _React$useContext$but, classNames = _React$useContext.classNames, styles = _React$useContext.styles;
	var now$1 = generateConfig$1.getNow();
	var getValidTime = _slicedToArray$19(useTimeInfo(generateConfig$1, showTime, now$1), 1)[0];
	var extraNode = renderExtraFooter === null || renderExtraFooter === void 0 ? void 0 : renderExtraFooter(mode);
	var nowDisabled = disabledDate(now$1, { type: mode });
	var onInternalNow = function onInternalNow$1() {
		if (!nowDisabled) onNow(getValidTime(now$1));
	};
	var nowPrefixCls = "".concat(prefixCls, "-now");
	var nowBtnPrefixCls = "".concat(nowPrefixCls, "-btn");
	var presetNode = showNow && /* @__PURE__ */ import_react.createElement("li", { className: nowPrefixCls }, /* @__PURE__ */ import_react.createElement("a", {
		className: clsx(nowBtnPrefixCls, nowDisabled && "".concat(nowBtnPrefixCls, "-disabled")),
		"aria-disabled": nowDisabled,
		onClick: onInternalNow
	}, internalMode === "date" ? locale$5.today : locale$5.now));
	var okNode = needConfirm && /* @__PURE__ */ import_react.createElement("li", { className: "".concat(prefixCls, "-ok") }, /* @__PURE__ */ import_react.createElement(Button$1, {
		disabled: invalid,
		onClick: onSubmit
	}, locale$5.ok));
	var rangeNode = (presetNode || okNode) && /* @__PURE__ */ import_react.createElement("ul", { className: "".concat(prefixCls, "-ranges") }, presetNode, okNode);
	if (!extraNode && !rangeNode) return null;
	return /* @__PURE__ */ import_react.createElement("div", {
		className: clsx("".concat(prefixCls, "-footer"), classNames.popup.footer),
		style: styles.popup.footer
	}, extraNode && /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-footer-extra") }, extraNode), rangeNode);
}

//#endregion
//#region node_modules/@rc-component/picker/es/hooks/useToggleDates.js
function _toConsumableArray$5(arr) {
	return _arrayWithoutHoles$4(arr) || _iterableToArray$4(arr) || _unsupportedIterableToArray$19(arr) || _nonIterableSpread$4();
}
function _nonIterableSpread$4() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$19(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$18(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$18(o$2, minLen);
}
function _iterableToArray$4(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$4(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$18(arr);
}
function _arrayLikeToArray$18(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
/**
* Toggles the presence of a value in an array.
* If the value exists in the array, removed it.
* Else add it.
*/
function useToggleDates(generateConfig$1, locale$5, panelMode) {
	function toggleDates(list, target) {
		var index$1 = list.findIndex(function(date$1) {
			return isSame(generateConfig$1, locale$5, date$1, target, panelMode);
		});
		if (index$1 === -1) return [].concat(_toConsumableArray$5(list), [target]);
		var sliceList = _toConsumableArray$5(list);
		sliceList.splice(index$1, 1);
		return sliceList;
	}
	return toggleDates;
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerPanel/context.js
var SharedPanelContext = /* @__PURE__ */ import_react.createContext(null);
/** Used for each single Panel. e.g. DatePanel */
var PanelContext = /* @__PURE__ */ import_react.createContext(null);
function usePanelContext() {
	return import_react.useContext(PanelContext);
}
/**
* Get shared props for the SharedPanelProps interface.
*/
function useInfo(props, panelType) {
	var prefixCls = props.prefixCls, generateConfig$1 = props.generateConfig, locale$5 = props.locale, disabledDate = props.disabledDate, minDate = props.minDate, maxDate = props.maxDate, cellRender = props.cellRender, hoverValue = props.hoverValue, hoverRangeValue = props.hoverRangeValue, onHover = props.onHover, values = props.values, pickerValue = props.pickerValue, onSelect = props.onSelect, prevIcon = props.prevIcon, nextIcon = props.nextIcon, superPrevIcon = props.superPrevIcon, superNextIcon = props.superNextIcon;
	var _React$useContext = import_react.useContext(SharedPanelContext), classNames = _React$useContext.classNames, styles = _React$useContext.styles;
	var now$1 = generateConfig$1.getNow();
	return [{
		now: now$1,
		values,
		pickerValue,
		prefixCls,
		classNames,
		styles,
		disabledDate,
		minDate,
		maxDate,
		cellRender,
		hoverValue,
		hoverRangeValue,
		onHover,
		locale: locale$5,
		generateConfig: generateConfig$1,
		onSelect,
		panelType,
		prevIcon,
		nextIcon,
		superPrevIcon,
		superNextIcon
	}, now$1];
}
/**
* Internal usage for RangePicker to not to show the operation arrow
*/
var PickerHackContext = /* @__PURE__ */ import_react.createContext({});
PickerHackContext.displayName = "PickerHackContext";

//#endregion
//#region node_modules/@rc-component/picker/es/PickerPanel/PanelBody.js
function _typeof$19(o$2) {
	"@babel/helpers - typeof";
	return _typeof$19 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$19(o$2);
}
function ownKeys$9(e$2, r$1) {
	var t$1 = Object.keys(e$2);
	if (Object.getOwnPropertySymbols) {
		var o$2 = Object.getOwnPropertySymbols(e$2);
		r$1 && (o$2 = o$2.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e$2, r$2).enumerable;
		})), t$1.push.apply(t$1, o$2);
	}
	return t$1;
}
function _objectSpread$9(e$2) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$9(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$19(e$2, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$2, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$9(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e$2, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e$2;
}
function _defineProperty$19(obj, key, value) {
	key = _toPropertyKey$18(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$18(t$1) {
	var i = _toPrimitive$18(t$1, "string");
	return "symbol" == _typeof$19(i) ? i : String(i);
}
function _toPrimitive$18(t$1, r$1) {
	if ("object" != _typeof$19(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$19(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _slicedToArray$18(arr, i) {
	return _arrayWithHoles$17(arr) || _iterableToArrayLimit$17(arr, i) || _unsupportedIterableToArray$18(arr, i) || _nonIterableRest$17();
}
function _nonIterableRest$17() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$18(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$17(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$17(o$2, minLen);
}
function _arrayLikeToArray$17(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$17(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$17(arr) {
	if (Array.isArray(arr)) return arr;
}
function PanelBody(props) {
	var rowNum = props.rowNum, colNum = props.colNum, baseDate = props.baseDate, getCellDate = props.getCellDate, prefixColumn = props.prefixColumn, rowClassName = props.rowClassName, titleFormat = props.titleFormat, getCellText = props.getCellText, getCellClassName = props.getCellClassName, headerCells = props.headerCells, _props$cellSelection = props.cellSelection, cellSelection = _props$cellSelection === void 0 ? true : _props$cellSelection, disabledDate = props.disabledDate;
	var _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, classNames = _usePanelContext.classNames, styles = _usePanelContext.styles, type$2 = _usePanelContext.panelType, now$1 = _usePanelContext.now, contextDisabledDate = _usePanelContext.disabledDate, cellRender = _usePanelContext.cellRender, onHover = _usePanelContext.onHover, hoverValue = _usePanelContext.hoverValue, hoverRangeValue = _usePanelContext.hoverRangeValue, generateConfig$1 = _usePanelContext.generateConfig, values = _usePanelContext.values, locale$5 = _usePanelContext.locale, onSelect = _usePanelContext.onSelect;
	var mergedDisabledDate = disabledDate || contextDisabledDate;
	var cellPrefixCls = "".concat(prefixCls, "-cell");
	var onCellDblClick = import_react.useContext(PickerHackContext).onCellDblClick;
	var matchValues = function matchValues$1(date$1) {
		return values.some(function(singleValue) {
			return singleValue && isSame(generateConfig$1, locale$5, date$1, singleValue, type$2);
		});
	};
	var rows = [];
	for (var row = 0; row < rowNum; row += 1) {
		var rowNode = [];
		var rowStartDate = void 0;
		var _loop = function _loop$1() {
			var currentDate = getCellDate(baseDate, row * colNum + col);
			var disabled = mergedDisabledDate === null || mergedDisabledDate === void 0 ? void 0 : mergedDisabledDate(currentDate, { type: type$2 });
			if (col === 0) {
				rowStartDate = currentDate;
				if (prefixColumn) rowNode.push(prefixColumn(rowStartDate));
			}
			var inRange = false;
			var rangeStart = false;
			var rangeEnd = false;
			if (cellSelection && hoverRangeValue) {
				var _hoverRangeValue = _slicedToArray$18(hoverRangeValue, 2), hoverStart = _hoverRangeValue[0], hoverEnd = _hoverRangeValue[1];
				inRange = isInRange(generateConfig$1, hoverStart, hoverEnd, currentDate);
				rangeStart = isSame(generateConfig$1, locale$5, currentDate, hoverStart, type$2);
				rangeEnd = isSame(generateConfig$1, locale$5, currentDate, hoverEnd, type$2);
			}
			var title = titleFormat ? formatValue(currentDate, {
				locale: locale$5,
				format: titleFormat,
				generateConfig: generateConfig$1
			}) : void 0;
			var inner = /* @__PURE__ */ import_react.createElement("div", { className: "".concat(cellPrefixCls, "-inner") }, getCellText(currentDate));
			rowNode.push(/* @__PURE__ */ import_react.createElement("td", {
				key: col,
				title,
				className: clsx(cellPrefixCls, classNames.item, _objectSpread$9(_defineProperty$19(_defineProperty$19(_defineProperty$19(_defineProperty$19(_defineProperty$19(_defineProperty$19({}, "".concat(cellPrefixCls, "-disabled"), disabled), "".concat(cellPrefixCls, "-hover"), (hoverValue || []).some(function(date$1) {
					return isSame(generateConfig$1, locale$5, currentDate, date$1, type$2);
				})), "".concat(cellPrefixCls, "-in-range"), inRange && !rangeStart && !rangeEnd), "".concat(cellPrefixCls, "-range-start"), rangeStart), "".concat(cellPrefixCls, "-range-end"), rangeEnd), "".concat(prefixCls, "-cell-selected"), !hoverRangeValue && type$2 !== "week" && matchValues(currentDate)), getCellClassName(currentDate))),
				style: styles.item,
				onClick: function onClick() {
					if (!disabled) onSelect(currentDate);
				},
				onDoubleClick: function onDoubleClick() {
					if (!disabled && onCellDblClick) onCellDblClick();
				},
				onMouseEnter: function onMouseEnter() {
					if (!disabled) onHover === null || onHover === void 0 || onHover(currentDate);
				},
				onMouseLeave: function onMouseLeave() {
					if (!disabled) onHover === null || onHover === void 0 || onHover(null);
				}
			}, cellRender ? cellRender(currentDate, {
				prefixCls,
				originNode: inner,
				today: now$1,
				type: type$2,
				locale: locale$5
			}) : inner));
		};
		for (var col = 0; col < colNum; col += 1) _loop();
		rows.push(/* @__PURE__ */ import_react.createElement("tr", {
			key: row,
			className: rowClassName === null || rowClassName === void 0 ? void 0 : rowClassName(rowStartDate)
		}, rowNode));
	}
	return /* @__PURE__ */ import_react.createElement("div", {
		className: clsx("".concat(prefixCls, "-body"), classNames.body),
		style: styles.body
	}, /* @__PURE__ */ import_react.createElement("table", {
		className: clsx("".concat(prefixCls, "-content"), classNames.content),
		style: styles.content
	}, headerCells && /* @__PURE__ */ import_react.createElement("thead", null, /* @__PURE__ */ import_react.createElement("tr", null, headerCells)), /* @__PURE__ */ import_react.createElement("tbody", null, rows)));
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerPanel/PanelHeader.js
var HIDDEN_STYLE$2 = { visibility: "hidden" };
function PanelHeader(props) {
	var offset$2 = props.offset, superOffset = props.superOffset, onChange = props.onChange, getStart = props.getStart, getEnd = props.getEnd, children = props.children;
	var _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, classNames = _usePanelContext.classNames, styles = _usePanelContext.styles, _usePanelContext$prev = _usePanelContext.prevIcon, prevIcon = _usePanelContext$prev === void 0 ? "" : _usePanelContext$prev, _usePanelContext$next = _usePanelContext.nextIcon, nextIcon = _usePanelContext$next === void 0 ? "" : _usePanelContext$next, _usePanelContext$supe = _usePanelContext.superPrevIcon, superPrevIcon = _usePanelContext$supe === void 0 ? "" : _usePanelContext$supe, _usePanelContext$supe2 = _usePanelContext.superNextIcon, superNextIcon = _usePanelContext$supe2 === void 0 ? "" : _usePanelContext$supe2, minDate = _usePanelContext.minDate, maxDate = _usePanelContext.maxDate, generateConfig$1 = _usePanelContext.generateConfig, locale$5 = _usePanelContext.locale, pickerValue = _usePanelContext.pickerValue, type$2 = _usePanelContext.panelType;
	var headerPrefixCls = "".concat(prefixCls, "-header");
	var _React$useContext = import_react.useContext(PickerHackContext), hidePrev = _React$useContext.hidePrev, hideNext = _React$useContext.hideNext, hideHeader = _React$useContext.hideHeader;
	var disabledOffsetPrev = import_react.useMemo(function() {
		if (!minDate || !offset$2 || !getEnd) return false;
		return !isSameOrAfter(generateConfig$1, locale$5, getEnd(offset$2(-1, pickerValue)), minDate, type$2);
	}, [
		minDate,
		offset$2,
		pickerValue,
		getEnd,
		generateConfig$1,
		locale$5,
		type$2
	]);
	var disabledSuperOffsetPrev = import_react.useMemo(function() {
		if (!minDate || !superOffset || !getEnd) return false;
		return !isSameOrAfter(generateConfig$1, locale$5, getEnd(superOffset(-1, pickerValue)), minDate, type$2);
	}, [
		minDate,
		superOffset,
		pickerValue,
		getEnd,
		generateConfig$1,
		locale$5,
		type$2
	]);
	var disabledOffsetNext = import_react.useMemo(function() {
		if (!maxDate || !offset$2 || !getStart) return false;
		return !isSameOrAfter(generateConfig$1, locale$5, maxDate, getStart(offset$2(1, pickerValue)), type$2);
	}, [
		maxDate,
		offset$2,
		pickerValue,
		getStart,
		generateConfig$1,
		locale$5,
		type$2
	]);
	var disabledSuperOffsetNext = import_react.useMemo(function() {
		if (!maxDate || !superOffset || !getStart) return false;
		return !isSameOrAfter(generateConfig$1, locale$5, maxDate, getStart(superOffset(1, pickerValue)), type$2);
	}, [
		maxDate,
		superOffset,
		pickerValue,
		getStart,
		generateConfig$1,
		locale$5,
		type$2
	]);
	var onOffset = function onOffset$1(distance) {
		if (offset$2) onChange(offset$2(distance, pickerValue));
	};
	var onSuperOffset = function onSuperOffset$1(distance) {
		if (superOffset) onChange(superOffset(distance, pickerValue));
	};
	if (hideHeader) return null;
	var prevBtnCls = "".concat(headerPrefixCls, "-prev-btn");
	var nextBtnCls = "".concat(headerPrefixCls, "-next-btn");
	var superPrevBtnCls = "".concat(headerPrefixCls, "-super-prev-btn");
	var superNextBtnCls = "".concat(headerPrefixCls, "-super-next-btn");
	return /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(headerPrefixCls, classNames.header),
		style: styles.header
	}, superOffset && /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		"aria-label": locale$5.previousYear,
		onClick: function onClick() {
			return onSuperOffset(-1);
		},
		tabIndex: -1,
		className: clsx(superPrevBtnCls, disabledSuperOffsetPrev && "".concat(superPrevBtnCls, "-disabled")),
		disabled: disabledSuperOffsetPrev,
		style: hidePrev ? HIDDEN_STYLE$2 : {}
	}, superPrevIcon), offset$2 && /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		"aria-label": locale$5.previousMonth,
		onClick: function onClick() {
			return onOffset(-1);
		},
		tabIndex: -1,
		className: clsx(prevBtnCls, disabledOffsetPrev && "".concat(prevBtnCls, "-disabled")),
		disabled: disabledOffsetPrev,
		style: hidePrev ? HIDDEN_STYLE$2 : {}
	}, prevIcon), /* @__PURE__ */ import_react.createElement("div", { className: "".concat(headerPrefixCls, "-view") }, children), offset$2 && /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		"aria-label": locale$5.nextMonth,
		onClick: function onClick() {
			return onOffset(1);
		},
		tabIndex: -1,
		className: clsx(nextBtnCls, disabledOffsetNext && "".concat(nextBtnCls, "-disabled")),
		disabled: disabledOffsetNext,
		style: hideNext ? HIDDEN_STYLE$2 : {}
	}, nextIcon), superOffset && /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		"aria-label": locale$5.nextYear,
		onClick: function onClick() {
			return onSuperOffset(1);
		},
		tabIndex: -1,
		className: clsx(superNextBtnCls, disabledSuperOffsetNext && "".concat(superNextBtnCls, "-disabled")),
		disabled: disabledSuperOffsetNext,
		style: hideNext ? HIDDEN_STYLE$2 : {}
	}, superNextIcon));
}
var PanelHeader_default = PanelHeader;

//#endregion
//#region node_modules/@rc-component/picker/es/PickerPanel/DatePanel/index.js
function _typeof$18(o$2) {
	"@babel/helpers - typeof";
	return _typeof$18 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$18(o$2);
}
function _extends$68() {
	_extends$68 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$68.apply(this, arguments);
}
function _defineProperty$18(obj, key, value) {
	key = _toPropertyKey$17(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$17(t$1) {
	var i = _toPrimitive$17(t$1, "string");
	return "symbol" == _typeof$18(i) ? i : String(i);
}
function _toPrimitive$17(t$1, r$1) {
	if ("object" != _typeof$18(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$18(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _slicedToArray$17(arr, i) {
	return _arrayWithHoles$16(arr) || _iterableToArrayLimit$16(arr, i) || _unsupportedIterableToArray$17(arr, i) || _nonIterableRest$16();
}
function _nonIterableRest$16() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$17(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$16(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$16(o$2, minLen);
}
function _arrayLikeToArray$16(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$16(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$16(arr) {
	if (Array.isArray(arr)) return arr;
}
function DatePanel(props) {
	var prefixCls = props.prefixCls, _props$panelName = props.panelName, panelName = _props$panelName === void 0 ? "date" : _props$panelName, locale$5 = props.locale, generateConfig$1 = props.generateConfig, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange, _props$mode = props.mode, mode = _props$mode === void 0 ? "date" : _props$mode, disabledDate = props.disabledDate, onSelect = props.onSelect, onHover = props.onHover, showWeek = props.showWeek;
	var panelPrefixCls = "".concat(prefixCls, "-").concat(panelName, "-panel");
	var cellPrefixCls = "".concat(prefixCls, "-cell");
	var isWeek = mode === "week";
	var _useInfo2 = _slicedToArray$17(useInfo(props, mode), 2), info = _useInfo2[0], now$1 = _useInfo2[1];
	var weekFirstDay = generateConfig$1.locale.getWeekFirstDay(locale$5.locale);
	var monthStartDate = generateConfig$1.setDate(pickerValue, 1);
	var baseDate = getWeekStartDate(locale$5.locale, generateConfig$1, monthStartDate);
	var month = generateConfig$1.getMonth(pickerValue);
	var prefixColumn = (showWeek === void 0 ? isWeek : showWeek) ? function(date$1) {
		var disabled = disabledDate === null || disabledDate === void 0 ? void 0 : disabledDate(date$1, { type: "week" });
		return /* @__PURE__ */ import_react.createElement("td", {
			key: "week",
			className: clsx(cellPrefixCls, "".concat(cellPrefixCls, "-week"), _defineProperty$18({}, "".concat(cellPrefixCls, "-disabled"), disabled)),
			onClick: function onClick() {
				if (!disabled) onSelect(date$1);
			},
			onMouseEnter: function onMouseEnter() {
				if (!disabled) onHover === null || onHover === void 0 || onHover(date$1);
			},
			onMouseLeave: function onMouseLeave() {
				if (!disabled) onHover === null || onHover === void 0 || onHover(null);
			}
		}, /* @__PURE__ */ import_react.createElement("div", { className: "".concat(cellPrefixCls, "-inner") }, generateConfig$1.locale.getWeek(locale$5.locale, date$1)));
	} : null;
	var headerCells = [];
	var weekDaysLocale = locale$5.shortWeekDays || (generateConfig$1.locale.getShortWeekDays ? generateConfig$1.locale.getShortWeekDays(locale$5.locale) : []);
	if (prefixColumn) headerCells.push(/* @__PURE__ */ import_react.createElement("th", { key: "empty" }, /* @__PURE__ */ import_react.createElement("span", { style: {
		width: 0,
		height: 0,
		position: "absolute",
		overflow: "hidden",
		opacity: 0
	} }, locale$5.week)));
	for (var i = 0; i < WEEK_DAY_COUNT; i += 1) headerCells.push(/* @__PURE__ */ import_react.createElement("th", { key: i }, weekDaysLocale[(i + weekFirstDay) % WEEK_DAY_COUNT]));
	var getCellDate = function getCellDate$1(date$1, offset$2) {
		return generateConfig$1.addDate(date$1, offset$2);
	};
	var getCellText = function getCellText$1(date$1) {
		return formatValue(date$1, {
			locale: locale$5,
			format: locale$5.cellDateFormat,
			generateConfig: generateConfig$1
		});
	};
	var getCellClassName = function getCellClassName$1(date$1) {
		return _defineProperty$18(_defineProperty$18({}, "".concat(prefixCls, "-cell-in-view"), isSameMonth$1(generateConfig$1, date$1, pickerValue)), "".concat(prefixCls, "-cell-today"), isSameDate$1(generateConfig$1, date$1, now$1));
	};
	var monthsLocale = locale$5.shortMonths || (generateConfig$1.locale.getShortMonths ? generateConfig$1.locale.getShortMonths(locale$5.locale) : []);
	var yearNode = /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		"aria-label": locale$5.yearSelect,
		key: "year",
		onClick: function onClick() {
			onModeChange("year", pickerValue);
		},
		tabIndex: -1,
		className: "".concat(prefixCls, "-year-btn")
	}, formatValue(pickerValue, {
		locale: locale$5,
		format: locale$5.yearFormat,
		generateConfig: generateConfig$1
	}));
	var monthNode = /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		"aria-label": locale$5.monthSelect,
		key: "month",
		onClick: function onClick() {
			onModeChange("month", pickerValue);
		},
		tabIndex: -1,
		className: "".concat(prefixCls, "-month-btn")
	}, locale$5.monthFormat ? formatValue(pickerValue, {
		locale: locale$5,
		format: locale$5.monthFormat,
		generateConfig: generateConfig$1
	}) : monthsLocale[month]);
	var monthYearNodes = locale$5.monthBeforeYear ? [monthNode, yearNode] : [yearNode, monthNode];
	return /* @__PURE__ */ import_react.createElement(PanelContext.Provider, { value: info }, /* @__PURE__ */ import_react.createElement("div", { className: clsx(panelPrefixCls, showWeek && "".concat(panelPrefixCls, "-show-week")) }, /* @__PURE__ */ import_react.createElement(PanelHeader_default, {
		offset: function offset$2(distance) {
			return generateConfig$1.addMonth(pickerValue, distance);
		},
		superOffset: function superOffset(distance) {
			return generateConfig$1.addYear(pickerValue, distance);
		},
		onChange: onPickerValueChange,
		getStart: function getStart(date$1) {
			return generateConfig$1.setDate(date$1, 1);
		},
		getEnd: function getEnd(date$1) {
			var clone = generateConfig$1.setDate(date$1, 1);
			clone = generateConfig$1.addMonth(clone, 1);
			return generateConfig$1.addDate(clone, -1);
		}
	}, monthYearNodes), /* @__PURE__ */ import_react.createElement(PanelBody, _extends$68({ titleFormat: locale$5.fieldDateFormat }, props, {
		colNum: WEEK_DAY_COUNT,
		rowNum: 6,
		baseDate,
		headerCells,
		getCellDate,
		getCellText,
		getCellClassName,
		prefixColumn,
		cellSelection: !isWeek
	}))));
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerPanel/TimePanel/TimePanelBody/useScrollTo.js
var SPEED_PTG = 1 / 3;
function useScrollTo(ulRef, value) {
	var scrollingRef = import_react.useRef(false);
	var scrollRafRef = import_react.useRef(null);
	var scrollDistRef = import_react.useRef(null);
	var isScrolling = function isScrolling$1() {
		return scrollingRef.current;
	};
	var stopScroll = function stopScroll$1() {
		raf_default.cancel(scrollRafRef.current);
		scrollingRef.current = false;
	};
	var scrollRafTimesRef = import_react.useRef();
	return [
		useEvent_default(function startScroll() {
			var ul = ulRef.current;
			scrollDistRef.current = null;
			scrollRafTimesRef.current = 0;
			if (ul) {
				var targetLi = ul.querySelector("[data-value=\"".concat(value, "\"]"));
				var firstLi = ul.querySelector("li");
				var doScroll = function doScroll$1() {
					stopScroll();
					scrollingRef.current = true;
					scrollRafTimesRef.current += 1;
					var currentTop = ul.scrollTop;
					var firstLiTop = firstLi.offsetTop;
					var targetLiTop = targetLi.offsetTop;
					var targetTop = targetLiTop - firstLiTop;
					if (targetLiTop === 0 && targetLi !== firstLi || !isVisible_default(ul)) {
						if (scrollRafTimesRef.current <= 5) scrollRafRef.current = raf_default(doScroll$1);
						return;
					}
					var nextTop = currentTop + (targetTop - currentTop) * SPEED_PTG;
					var dist = Math.abs(targetTop - nextTop);
					if (scrollDistRef.current !== null && scrollDistRef.current < dist) {
						stopScroll();
						return;
					}
					scrollDistRef.current = dist;
					if (dist <= 1) {
						ul.scrollTop = targetTop;
						stopScroll();
						return;
					}
					ul.scrollTop = nextTop;
					scrollRafRef.current = raf_default(doScroll$1);
				};
				if (targetLi && firstLi) doScroll();
			}
		}),
		stopScroll,
		isScrolling
	];
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerPanel/TimePanel/TimePanelBody/TimeColumn.js
function _typeof$17(o$2) {
	"@babel/helpers - typeof";
	return _typeof$17 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$17(o$2);
}
function _defineProperty$17(obj, key, value) {
	key = _toPropertyKey$16(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$16(t$1) {
	var i = _toPrimitive$16(t$1, "string");
	return "symbol" == _typeof$17(i) ? i : String(i);
}
function _toPrimitive$16(t$1, r$1) {
	if ("object" != _typeof$17(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$17(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _toConsumableArray$4(arr) {
	return _arrayWithoutHoles$3(arr) || _iterableToArray$3(arr) || _unsupportedIterableToArray$16(arr) || _nonIterableSpread$3();
}
function _nonIterableSpread$3() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$3(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$3(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$15(arr);
}
function _slicedToArray$16(arr, i) {
	return _arrayWithHoles$15(arr) || _iterableToArrayLimit$15(arr, i) || _unsupportedIterableToArray$16(arr, i) || _nonIterableRest$15();
}
function _nonIterableRest$15() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$16(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$15(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$15(o$2, minLen);
}
function _arrayLikeToArray$15(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$15(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$15(arr) {
	if (Array.isArray(arr)) return arr;
}
var SCROLL_DELAY = 300;
function flattenUnits(units) {
	return units.map(function(_ref) {
		return [
			_ref.value,
			_ref.label,
			_ref.disabled
		].join(",");
	}).join(";");
}
function TimeColumn(props) {
	var units = props.units, value = props.value, optionalValue = props.optionalValue, type$2 = props.type, onChange = props.onChange, onHover = props.onHover, onDblClick = props.onDblClick, changeOnScroll = props.changeOnScroll;
	var _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, cellRender = _usePanelContext.cellRender, now$1 = _usePanelContext.now, locale$5 = _usePanelContext.locale, classNames = _usePanelContext.classNames, styles = _usePanelContext.styles;
	var panelPrefixCls = "".concat(prefixCls, "-time-panel");
	var cellPrefixCls = "".concat(prefixCls, "-time-panel-cell");
	var ulRef = import_react.useRef(null);
	var checkDelayRef = import_react.useRef();
	var clearDelayCheck = function clearDelayCheck$1() {
		clearTimeout(checkDelayRef.current);
	};
	var _useScrollTo2 = _slicedToArray$16(useScrollTo(ulRef, value !== null && value !== void 0 ? value : optionalValue), 3), syncScroll = _useScrollTo2[0], stopScroll = _useScrollTo2[1], isScrolling = _useScrollTo2[2];
	useLayoutEffect_default(function() {
		syncScroll();
		clearDelayCheck();
		return function() {
			stopScroll();
			clearDelayCheck();
		};
	}, [
		value,
		optionalValue,
		flattenUnits(units)
	]);
	var onInternalScroll = function onInternalScroll$1(event) {
		clearDelayCheck();
		var target = event.target;
		if (!isScrolling() && changeOnScroll) checkDelayRef.current = setTimeout(function() {
			var ul = ulRef.current;
			var firstLiTop = ul.querySelector("li").offsetTop;
			var liDistList = Array.from(ul.querySelectorAll("li")).map(function(li) {
				return li.offsetTop - firstLiTop;
			}).map(function(top, index$1) {
				if (units[index$1].disabled) return Number.MAX_SAFE_INTEGER;
				return Math.abs(top - target.scrollTop);
			});
			var minDist = Math.min.apply(Math, _toConsumableArray$4(liDistList));
			var targetUnit = units[liDistList.findIndex(function(dist) {
				return dist === minDist;
			})];
			if (targetUnit && !targetUnit.disabled) onChange(targetUnit.value);
		}, SCROLL_DELAY);
	};
	var columnPrefixCls = "".concat(panelPrefixCls, "-column");
	return /* @__PURE__ */ import_react.createElement("ul", {
		className: columnPrefixCls,
		ref: ulRef,
		"data-type": type$2,
		onScroll: onInternalScroll
	}, units.map(function(_ref2) {
		var label = _ref2.label, unitValue = _ref2.value, disabled = _ref2.disabled;
		var inner = /* @__PURE__ */ import_react.createElement("div", { className: "".concat(cellPrefixCls, "-inner") }, label);
		return /* @__PURE__ */ import_react.createElement("li", {
			key: unitValue,
			style: styles.item,
			className: clsx(cellPrefixCls, classNames.item, _defineProperty$17(_defineProperty$17({}, "".concat(cellPrefixCls, "-selected"), value === unitValue), "".concat(cellPrefixCls, "-disabled"), disabled)),
			onClick: function onClick() {
				if (!disabled) onChange(unitValue);
			},
			onDoubleClick: function onDoubleClick() {
				if (!disabled && onDblClick) onDblClick();
			},
			onMouseEnter: function onMouseEnter() {
				onHover(unitValue);
			},
			onMouseLeave: function onMouseLeave() {
				onHover(null);
			},
			"data-value": unitValue
		}, cellRender ? cellRender(unitValue, {
			prefixCls,
			originNode: inner,
			today: now$1,
			type: "time",
			subType: type$2,
			locale: locale$5
		}) : inner);
	}));
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerPanel/TimePanel/TimePanelBody/index.js
function _extends$67() {
	_extends$67 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$67.apply(this, arguments);
}
function _slicedToArray$15(arr, i) {
	return _arrayWithHoles$14(arr) || _iterableToArrayLimit$14(arr, i) || _unsupportedIterableToArray$15(arr, i) || _nonIterableRest$14();
}
function _nonIterableRest$14() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$15(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$14(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$14(o$2, minLen);
}
function _arrayLikeToArray$14(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$14(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$14(arr) {
	if (Array.isArray(arr)) return arr;
}
function isAM(hour) {
	return hour < 12;
}
function TimePanelBody(props) {
	var showHour = props.showHour, showMinute = props.showMinute, showSecond = props.showSecond, showMillisecond = props.showMillisecond, showMeridiem = props.use12Hours, changeOnScroll = props.changeOnScroll;
	var _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, classNames = _usePanelContext.classNames, styles = _usePanelContext.styles, values = _usePanelContext.values, generateConfig$1 = _usePanelContext.generateConfig, locale$5 = _usePanelContext.locale, onSelect = _usePanelContext.onSelect, _usePanelContext$onHo = _usePanelContext.onHover, onHover = _usePanelContext$onHo === void 0 ? function() {} : _usePanelContext$onHo, pickerValue = _usePanelContext.pickerValue;
	var value = (values === null || values === void 0 ? void 0 : values[0]) || null;
	var onCellDblClick = import_react.useContext(PickerHackContext).onCellDblClick;
	var _useTimeInfo2 = _slicedToArray$15(useTimeInfo(generateConfig$1, props, value), 5), getValidTime = _useTimeInfo2[0], rowHourUnits = _useTimeInfo2[1], getMinuteUnits = _useTimeInfo2[2], getSecondUnits = _useTimeInfo2[3], getMillisecondUnits = _useTimeInfo2[4];
	var getUnitValue$1 = function getUnitValue$2(func) {
		return [value && generateConfig$1[func](value), pickerValue && generateConfig$1[func](pickerValue)];
	};
	var _getUnitValue2 = _slicedToArray$15(getUnitValue$1("getHour"), 2), hour = _getUnitValue2[0], pickerHour = _getUnitValue2[1];
	var _getUnitValue4 = _slicedToArray$15(getUnitValue$1("getMinute"), 2), minute = _getUnitValue4[0], pickerMinute = _getUnitValue4[1];
	var _getUnitValue6 = _slicedToArray$15(getUnitValue$1("getSecond"), 2), second = _getUnitValue6[0], pickerSecond = _getUnitValue6[1];
	var _getUnitValue8 = _slicedToArray$15(getUnitValue$1("getMillisecond"), 2), millisecond = _getUnitValue8[0], pickerMillisecond = _getUnitValue8[1];
	var meridiem = hour === null ? null : isAM(hour) ? "am" : "pm";
	var hourUnits = import_react.useMemo(function() {
		if (!showMeridiem) return rowHourUnits;
		return isAM(hour) ? rowHourUnits.filter(function(h) {
			return isAM(h.value);
		}) : rowHourUnits.filter(function(h) {
			return !isAM(h.value);
		});
	}, [
		hour,
		rowHourUnits,
		showMeridiem
	]);
	var getEnabled = function getEnabled$1(units, val) {
		var _enabledUnits$;
		var enabledUnits = units.filter(function(unit$2) {
			return !unit$2.disabled;
		});
		return val !== null && val !== void 0 ? val : enabledUnits === null || enabledUnits === void 0 || (_enabledUnits$ = enabledUnits[0]) === null || _enabledUnits$ === void 0 ? void 0 : _enabledUnits$.value;
	};
	var validHour = getEnabled(rowHourUnits, hour);
	var minuteUnits = import_react.useMemo(function() {
		return getMinuteUnits(validHour);
	}, [getMinuteUnits, validHour]);
	var validMinute = getEnabled(minuteUnits, minute);
	var secondUnits = import_react.useMemo(function() {
		return getSecondUnits(validHour, validMinute);
	}, [
		getSecondUnits,
		validHour,
		validMinute
	]);
	var validSecond = getEnabled(secondUnits, second);
	var millisecondUnits = import_react.useMemo(function() {
		return getMillisecondUnits(validHour, validMinute, validSecond);
	}, [
		getMillisecondUnits,
		validHour,
		validMinute,
		validSecond
	]);
	var validMillisecond = getEnabled(millisecondUnits, millisecond);
	var meridiemUnits = import_react.useMemo(function() {
		if (!showMeridiem) return [];
		var base = generateConfig$1.getNow();
		var amDate = generateConfig$1.setHour(base, 6);
		var pmDate = generateConfig$1.setHour(base, 18);
		var formatMeridiem = function formatMeridiem$1(date$1, defaultLabel) {
			var cellMeridiemFormat = locale$5.cellMeridiemFormat;
			return cellMeridiemFormat ? formatValue(date$1, {
				generateConfig: generateConfig$1,
				locale: locale$5,
				format: cellMeridiemFormat
			}) : defaultLabel;
		};
		return [{
			label: formatMeridiem(amDate, "AM"),
			value: "am",
			disabled: rowHourUnits.every(function(h) {
				return h.disabled || !isAM(h.value);
			})
		}, {
			label: formatMeridiem(pmDate, "PM"),
			value: "pm",
			disabled: rowHourUnits.every(function(h) {
				return h.disabled || isAM(h.value);
			})
		}];
	}, [
		rowHourUnits,
		showMeridiem,
		generateConfig$1,
		locale$5
	]);
	/**
	* Check if time is validate or will match to validate one
	*/
	var triggerChange = function triggerChange$1(nextDate) {
		onSelect(getValidTime(nextDate));
	};
	var triggerDateTmpl = import_react.useMemo(function() {
		var tmpl = value || pickerValue || generateConfig$1.getNow();
		var isNotNull = function isNotNull$1(num) {
			return num !== null && num !== void 0;
		};
		if (isNotNull(hour)) {
			tmpl = generateConfig$1.setHour(tmpl, hour);
			tmpl = generateConfig$1.setMinute(tmpl, minute);
			tmpl = generateConfig$1.setSecond(tmpl, second);
			tmpl = generateConfig$1.setMillisecond(tmpl, millisecond);
		} else if (isNotNull(pickerHour)) {
			tmpl = generateConfig$1.setHour(tmpl, pickerHour);
			tmpl = generateConfig$1.setMinute(tmpl, pickerMinute);
			tmpl = generateConfig$1.setSecond(tmpl, pickerSecond);
			tmpl = generateConfig$1.setMillisecond(tmpl, pickerMillisecond);
		} else if (isNotNull(validHour)) {
			tmpl = generateConfig$1.setHour(tmpl, validHour);
			tmpl = generateConfig$1.setMinute(tmpl, validMinute);
			tmpl = generateConfig$1.setSecond(tmpl, validSecond);
			tmpl = generateConfig$1.setMillisecond(tmpl, validMillisecond);
		}
		return tmpl;
	}, [
		value,
		pickerValue,
		hour,
		minute,
		second,
		millisecond,
		validHour,
		validMinute,
		validSecond,
		validMillisecond,
		pickerHour,
		pickerMinute,
		pickerSecond,
		pickerMillisecond,
		generateConfig$1
	]);
	var fillColumnValue = function fillColumnValue$1(val, func) {
		if (val === null) return null;
		return generateConfig$1[func](triggerDateTmpl, val);
	};
	var getNextHourTime = function getNextHourTime$1(val) {
		return fillColumnValue(val, "setHour");
	};
	var getNextMinuteTime = function getNextMinuteTime$1(val) {
		return fillColumnValue(val, "setMinute");
	};
	var getNextSecondTime = function getNextSecondTime$1(val) {
		return fillColumnValue(val, "setSecond");
	};
	var getNextMillisecondTime = function getNextMillisecondTime$1(val) {
		return fillColumnValue(val, "setMillisecond");
	};
	var getMeridiemTime = function getMeridiemTime$1(val) {
		if (val === null) return null;
		if (val === "am" && !isAM(hour)) return generateConfig$1.setHour(triggerDateTmpl, hour - 12);
		else if (val === "pm" && isAM(hour)) return generateConfig$1.setHour(triggerDateTmpl, hour + 12);
		return triggerDateTmpl;
	};
	var onHourChange = function onHourChange$1(val) {
		triggerChange(getNextHourTime(val));
	};
	var onMinuteChange = function onMinuteChange$1(val) {
		triggerChange(getNextMinuteTime(val));
	};
	var onSecondChange = function onSecondChange$1(val) {
		triggerChange(getNextSecondTime(val));
	};
	var onMillisecondChange = function onMillisecondChange$1(val) {
		triggerChange(getNextMillisecondTime(val));
	};
	var onMeridiemChange = function onMeridiemChange$1(val) {
		triggerChange(getMeridiemTime(val));
	};
	var onHourHover = function onHourHover$1(val) {
		onHover(getNextHourTime(val));
	};
	var onMinuteHover = function onMinuteHover$1(val) {
		onHover(getNextMinuteTime(val));
	};
	var onSecondHover = function onSecondHover$1(val) {
		onHover(getNextSecondTime(val));
	};
	var onMillisecondHover = function onMillisecondHover$1(val) {
		onHover(getNextMillisecondTime(val));
	};
	var onMeridiemHover = function onMeridiemHover$1(val) {
		onHover(getMeridiemTime(val));
	};
	var sharedColumnProps = {
		onDblClick: onCellDblClick,
		changeOnScroll
	};
	return /* @__PURE__ */ import_react.createElement("div", {
		className: clsx("".concat(prefixCls, "-content"), classNames.content),
		style: styles.content
	}, showHour && /* @__PURE__ */ import_react.createElement(TimeColumn, _extends$67({
		units: hourUnits,
		value: hour,
		optionalValue: pickerHour,
		type: "hour",
		onChange: onHourChange,
		onHover: onHourHover
	}, sharedColumnProps)), showMinute && /* @__PURE__ */ import_react.createElement(TimeColumn, _extends$67({
		units: minuteUnits,
		value: minute,
		optionalValue: pickerMinute,
		type: "minute",
		onChange: onMinuteChange,
		onHover: onMinuteHover
	}, sharedColumnProps)), showSecond && /* @__PURE__ */ import_react.createElement(TimeColumn, _extends$67({
		units: secondUnits,
		value: second,
		optionalValue: pickerSecond,
		type: "second",
		onChange: onSecondChange,
		onHover: onSecondHover
	}, sharedColumnProps)), showMillisecond && /* @__PURE__ */ import_react.createElement(TimeColumn, _extends$67({
		units: millisecondUnits,
		value: millisecond,
		optionalValue: pickerMillisecond,
		type: "millisecond",
		onChange: onMillisecondChange,
		onHover: onMillisecondHover
	}, sharedColumnProps)), showMeridiem && /* @__PURE__ */ import_react.createElement(TimeColumn, _extends$67({
		units: meridiemUnits,
		value: meridiem,
		type: "meridiem",
		onChange: onMeridiemChange,
		onHover: onMeridiemHover
	}, sharedColumnProps)));
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerPanel/TimePanel/index.js
function _slicedToArray$14(arr, i) {
	return _arrayWithHoles$13(arr) || _iterableToArrayLimit$13(arr, i) || _unsupportedIterableToArray$14(arr, i) || _nonIterableRest$13();
}
function _nonIterableRest$13() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$14(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$13(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$13(o$2, minLen);
}
function _arrayLikeToArray$13(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$13(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$13(arr) {
	if (Array.isArray(arr)) return arr;
}
function TimePanel(props) {
	var prefixCls = props.prefixCls, value = props.value, locale$5 = props.locale, generateConfig$1 = props.generateConfig, showTime = props.showTime;
	var format$1 = (showTime || {}).format;
	var panelPrefixCls = "".concat(prefixCls, "-time-panel");
	var info = _slicedToArray$14(useInfo(props, "time"), 1)[0];
	return /* @__PURE__ */ import_react.createElement(PanelContext.Provider, { value: info }, /* @__PURE__ */ import_react.createElement("div", { className: clsx(panelPrefixCls) }, /* @__PURE__ */ import_react.createElement(PanelHeader_default, null, value ? formatValue(value, {
		locale: locale$5,
		format: format$1,
		generateConfig: generateConfig$1
	}) : "\xA0"), /* @__PURE__ */ import_react.createElement(TimePanelBody, showTime)));
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerPanel/DateTimePanel/index.js
function _extends$66() {
	_extends$66 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$66.apply(this, arguments);
}
function _slicedToArray$13(arr, i) {
	return _arrayWithHoles$12(arr) || _iterableToArrayLimit$12(arr, i) || _unsupportedIterableToArray$13(arr, i) || _nonIterableRest$12();
}
function _nonIterableRest$12() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$13(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$12(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$12(o$2, minLen);
}
function _arrayLikeToArray$12(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$12(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$12(arr) {
	if (Array.isArray(arr)) return arr;
}
function DateTimePanel(props) {
	var prefixCls = props.prefixCls, generateConfig$1 = props.generateConfig, showTime = props.showTime, onSelect = props.onSelect, value = props.value, pickerValue = props.pickerValue, onHover = props.onHover;
	var panelPrefixCls = "".concat(prefixCls, "-datetime-panel");
	var getValidTime = _slicedToArray$13(useTimeInfo(generateConfig$1, showTime), 1)[0];
	var mergeTime = function mergeTime$1(date$1) {
		if (value) return fillTime(generateConfig$1, date$1, value);
		return fillTime(generateConfig$1, date$1, pickerValue);
	};
	return /* @__PURE__ */ import_react.createElement("div", { className: panelPrefixCls }, /* @__PURE__ */ import_react.createElement(DatePanel, _extends$66({}, props, {
		onSelect: function onDateSelect(date$1) {
			var cloneDate = mergeTime(date$1);
			onSelect(getValidTime(cloneDate, cloneDate));
		},
		onHover: function onDateHover(date$1) {
			onHover === null || onHover === void 0 || onHover(date$1 ? mergeTime(date$1) : date$1);
		}
	})), /* @__PURE__ */ import_react.createElement(TimePanel, props));
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerPanel/DecadePanel/index.js
function _typeof$16(o$2) {
	"@babel/helpers - typeof";
	return _typeof$16 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$16(o$2);
}
function _extends$65() {
	_extends$65 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$65.apply(this, arguments);
}
function _defineProperty$16(obj, key, value) {
	key = _toPropertyKey$15(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$15(t$1) {
	var i = _toPrimitive$15(t$1, "string");
	return "symbol" == _typeof$16(i) ? i : String(i);
}
function _toPrimitive$15(t$1, r$1) {
	if ("object" != _typeof$16(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$16(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _slicedToArray$12(arr, i) {
	return _arrayWithHoles$11(arr) || _iterableToArrayLimit$11(arr, i) || _unsupportedIterableToArray$12(arr, i) || _nonIterableRest$11();
}
function _nonIterableRest$11() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$12(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$11(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$11(o$2, minLen);
}
function _arrayLikeToArray$11(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$11(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$11(arr) {
	if (Array.isArray(arr)) return arr;
}
function DecadePanel(props) {
	var prefixCls = props.prefixCls, locale$5 = props.locale, generateConfig$1 = props.generateConfig, pickerValue = props.pickerValue, disabledDate = props.disabledDate, onPickerValueChange = props.onPickerValueChange;
	var panelPrefixCls = "".concat(prefixCls, "-decade-panel");
	var info = _slicedToArray$12(useInfo(props, "decade"), 1)[0];
	var getStartYear = function getStartYear$1(date$1) {
		var startYear = Math.floor(generateConfig$1.getYear(date$1) / 100) * 100;
		return generateConfig$1.setYear(date$1, startYear);
	};
	var getEndYear = function getEndYear$1(date$1) {
		var startYear = getStartYear(date$1);
		return generateConfig$1.addYear(startYear, 99);
	};
	var startYearDate = getStartYear(pickerValue);
	var endYearDate = getEndYear(pickerValue);
	var baseDate = generateConfig$1.addYear(startYearDate, -10);
	var getCellDate = function getCellDate$1(date$1, offset$2) {
		return generateConfig$1.addYear(date$1, offset$2 * 10);
	};
	var getCellText = function getCellText$1(date$1) {
		var cellYearFormat = locale$5.cellYearFormat;
		var startYearStr = formatValue(date$1, {
			locale: locale$5,
			format: cellYearFormat,
			generateConfig: generateConfig$1
		});
		var endYearStr = formatValue(generateConfig$1.addYear(date$1, 9), {
			locale: locale$5,
			format: cellYearFormat,
			generateConfig: generateConfig$1
		});
		return "".concat(startYearStr, "-").concat(endYearStr);
	};
	var getCellClassName = function getCellClassName$1(date$1) {
		return _defineProperty$16({}, "".concat(prefixCls, "-cell-in-view"), isSameDecade(generateConfig$1, date$1, startYearDate) || isSameDecade(generateConfig$1, date$1, endYearDate) || isInRange(generateConfig$1, startYearDate, endYearDate, date$1));
	};
	var mergedDisabledDate = disabledDate ? function(currentDate, disabledInfo) {
		var baseStartDate = generateConfig$1.setDate(currentDate, 1);
		var baseStartMonth = generateConfig$1.setMonth(baseStartDate, 0);
		var baseStartYear = generateConfig$1.setYear(baseStartMonth, Math.floor(generateConfig$1.getYear(baseStartMonth) / 10) * 10);
		var baseEndYear = generateConfig$1.addYear(baseStartYear, 10);
		var baseEndDate = generateConfig$1.addDate(baseEndYear, -1);
		return disabledDate(baseStartYear, disabledInfo) && disabledDate(baseEndDate, disabledInfo);
	} : null;
	var yearNode = "".concat(formatValue(startYearDate, {
		locale: locale$5,
		format: locale$5.yearFormat,
		generateConfig: generateConfig$1
	}), "-").concat(formatValue(endYearDate, {
		locale: locale$5,
		format: locale$5.yearFormat,
		generateConfig: generateConfig$1
	}));
	return /* @__PURE__ */ import_react.createElement(PanelContext.Provider, { value: info }, /* @__PURE__ */ import_react.createElement("div", { className: panelPrefixCls }, /* @__PURE__ */ import_react.createElement(PanelHeader_default, {
		superOffset: function superOffset(distance) {
			return generateConfig$1.addYear(pickerValue, distance * 100);
		},
		onChange: onPickerValueChange,
		getStart: getStartYear,
		getEnd: getEndYear
	}, yearNode), /* @__PURE__ */ import_react.createElement(PanelBody, _extends$65({}, props, {
		disabledDate: mergedDisabledDate,
		colNum: 3,
		rowNum: 4,
		baseDate,
		getCellDate,
		getCellText,
		getCellClassName
	}))));
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerPanel/MonthPanel/index.js
function _typeof$15(o$2) {
	"@babel/helpers - typeof";
	return _typeof$15 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$15(o$2);
}
function _extends$64() {
	_extends$64 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$64.apply(this, arguments);
}
function _defineProperty$15(obj, key, value) {
	key = _toPropertyKey$14(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$14(t$1) {
	var i = _toPrimitive$14(t$1, "string");
	return "symbol" == _typeof$15(i) ? i : String(i);
}
function _toPrimitive$14(t$1, r$1) {
	if ("object" != _typeof$15(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$15(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _slicedToArray$11(arr, i) {
	return _arrayWithHoles$10(arr) || _iterableToArrayLimit$10(arr, i) || _unsupportedIterableToArray$11(arr, i) || _nonIterableRest$10();
}
function _nonIterableRest$10() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$11(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$10(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$10(o$2, minLen);
}
function _arrayLikeToArray$10(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$10(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$10(arr) {
	if (Array.isArray(arr)) return arr;
}
function MonthPanel(props) {
	var prefixCls = props.prefixCls, locale$5 = props.locale, generateConfig$1 = props.generateConfig, pickerValue = props.pickerValue, disabledDate = props.disabledDate, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange;
	var panelPrefixCls = "".concat(prefixCls, "-month-panel");
	var info = _slicedToArray$11(useInfo(props, "month"), 1)[0];
	var baseDate = generateConfig$1.setMonth(pickerValue, 0);
	var monthsLocale = locale$5.shortMonths || (generateConfig$1.locale.getShortMonths ? generateConfig$1.locale.getShortMonths(locale$5.locale) : []);
	var getCellDate = function getCellDate$1(date$1, offset$2) {
		return generateConfig$1.addMonth(date$1, offset$2);
	};
	var getCellText = function getCellText$1(date$1) {
		var month = generateConfig$1.getMonth(date$1);
		return locale$5.monthFormat ? formatValue(date$1, {
			locale: locale$5,
			format: locale$5.monthFormat,
			generateConfig: generateConfig$1
		}) : monthsLocale[month];
	};
	var getCellClassName = function getCellClassName$1() {
		return _defineProperty$15({}, "".concat(prefixCls, "-cell-in-view"), true);
	};
	var mergedDisabledDate = disabledDate ? function(currentDate, disabledInfo) {
		var startDate = generateConfig$1.setDate(currentDate, 1);
		var nextMonthStartDate = generateConfig$1.setMonth(startDate, generateConfig$1.getMonth(startDate) + 1);
		var endDate = generateConfig$1.addDate(nextMonthStartDate, -1);
		return disabledDate(startDate, disabledInfo) && disabledDate(endDate, disabledInfo);
	} : null;
	var yearNode = /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		key: "year",
		"aria-label": locale$5.yearSelect,
		onClick: function onClick() {
			onModeChange("year");
		},
		tabIndex: -1,
		className: "".concat(prefixCls, "-year-btn")
	}, formatValue(pickerValue, {
		locale: locale$5,
		format: locale$5.yearFormat,
		generateConfig: generateConfig$1
	}));
	return /* @__PURE__ */ import_react.createElement(PanelContext.Provider, { value: info }, /* @__PURE__ */ import_react.createElement("div", { className: panelPrefixCls }, /* @__PURE__ */ import_react.createElement(PanelHeader_default, {
		superOffset: function superOffset(distance) {
			return generateConfig$1.addYear(pickerValue, distance);
		},
		onChange: onPickerValueChange,
		getStart: function getStart(date$1) {
			return generateConfig$1.setMonth(date$1, 0);
		},
		getEnd: function getEnd(date$1) {
			return generateConfig$1.setMonth(date$1, 11);
		}
	}, yearNode), /* @__PURE__ */ import_react.createElement(PanelBody, _extends$64({}, props, {
		disabledDate: mergedDisabledDate,
		titleFormat: locale$5.fieldMonthFormat,
		colNum: 3,
		rowNum: 4,
		baseDate,
		getCellDate,
		getCellText,
		getCellClassName
	}))));
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerPanel/QuarterPanel/index.js
function _typeof$14(o$2) {
	"@babel/helpers - typeof";
	return _typeof$14 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$14(o$2);
}
function _extends$63() {
	_extends$63 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$63.apply(this, arguments);
}
function _defineProperty$14(obj, key, value) {
	key = _toPropertyKey$13(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$13(t$1) {
	var i = _toPrimitive$13(t$1, "string");
	return "symbol" == _typeof$14(i) ? i : String(i);
}
function _toPrimitive$13(t$1, r$1) {
	if ("object" != _typeof$14(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$14(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _slicedToArray$10(arr, i) {
	return _arrayWithHoles$9(arr) || _iterableToArrayLimit$9(arr, i) || _unsupportedIterableToArray$10(arr, i) || _nonIterableRest$9();
}
function _nonIterableRest$9() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$10(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$9(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$9(o$2, minLen);
}
function _arrayLikeToArray$9(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$9(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$9(arr) {
	if (Array.isArray(arr)) return arr;
}
function QuarterPanel(props) {
	var prefixCls = props.prefixCls, locale$5 = props.locale, generateConfig$1 = props.generateConfig, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange;
	var panelPrefixCls = "".concat(prefixCls, "-quarter-panel");
	var info = _slicedToArray$10(useInfo(props, "quarter"), 1)[0];
	var baseDate = generateConfig$1.setMonth(pickerValue, 0);
	var getCellDate = function getCellDate$1(date$1, offset$2) {
		return generateConfig$1.addMonth(date$1, offset$2 * 3);
	};
	var getCellText = function getCellText$1(date$1) {
		return formatValue(date$1, {
			locale: locale$5,
			format: locale$5.cellQuarterFormat,
			generateConfig: generateConfig$1
		});
	};
	var getCellClassName = function getCellClassName$1() {
		return _defineProperty$14({}, "".concat(prefixCls, "-cell-in-view"), true);
	};
	var yearNode = /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		key: "year",
		"aria-label": locale$5.yearSelect,
		onClick: function onClick() {
			onModeChange("year");
		},
		tabIndex: -1,
		className: "".concat(prefixCls, "-year-btn")
	}, formatValue(pickerValue, {
		locale: locale$5,
		format: locale$5.yearFormat,
		generateConfig: generateConfig$1
	}));
	return /* @__PURE__ */ import_react.createElement(PanelContext.Provider, { value: info }, /* @__PURE__ */ import_react.createElement("div", { className: panelPrefixCls }, /* @__PURE__ */ import_react.createElement(PanelHeader_default, {
		superOffset: function superOffset(distance) {
			return generateConfig$1.addYear(pickerValue, distance);
		},
		onChange: onPickerValueChange,
		getStart: function getStart(date$1) {
			return generateConfig$1.setMonth(date$1, 0);
		},
		getEnd: function getEnd(date$1) {
			return generateConfig$1.setMonth(date$1, 11);
		}
	}, yearNode), /* @__PURE__ */ import_react.createElement(PanelBody, _extends$63({}, props, {
		titleFormat: locale$5.fieldQuarterFormat,
		colNum: 4,
		rowNum: 1,
		baseDate,
		getCellDate,
		getCellText,
		getCellClassName
	}))));
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerPanel/WeekPanel/index.js
function _typeof$13(o$2) {
	"@babel/helpers - typeof";
	return _typeof$13 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$13(o$2);
}
function _extends$62() {
	_extends$62 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$62.apply(this, arguments);
}
function _defineProperty$13(obj, key, value) {
	key = _toPropertyKey$12(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$12(t$1) {
	var i = _toPrimitive$12(t$1, "string");
	return "symbol" == _typeof$13(i) ? i : String(i);
}
function _toPrimitive$12(t$1, r$1) {
	if ("object" != _typeof$13(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$13(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _slicedToArray$9(arr, i) {
	return _arrayWithHoles$8(arr) || _iterableToArrayLimit$8(arr, i) || _unsupportedIterableToArray$9(arr, i) || _nonIterableRest$8();
}
function _nonIterableRest$8() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$9(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$8(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$8(o$2, minLen);
}
function _arrayLikeToArray$8(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$8(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$8(arr) {
	if (Array.isArray(arr)) return arr;
}
function WeekPanel(props) {
	var prefixCls = props.prefixCls, generateConfig$1 = props.generateConfig, locale$5 = props.locale, value = props.value, hoverValue = props.hoverValue, hoverRangeValue = props.hoverRangeValue;
	var localeName = locale$5.locale;
	var rowPrefixCls = "".concat(prefixCls, "-week-panel-row");
	return /* @__PURE__ */ import_react.createElement(DatePanel, _extends$62({}, props, {
		mode: "week",
		panelName: "week",
		rowClassName: function rowClassName(currentDate) {
			var rangeCls = {};
			if (hoverRangeValue) {
				var _hoverRangeValue = _slicedToArray$9(hoverRangeValue, 2), rangeStart = _hoverRangeValue[0], rangeEnd = _hoverRangeValue[1];
				var isRangeStart = isSameWeek(generateConfig$1, localeName, rangeStart, currentDate);
				var isRangeEnd = isSameWeek(generateConfig$1, localeName, rangeEnd, currentDate);
				rangeCls["".concat(rowPrefixCls, "-range-start")] = isRangeStart;
				rangeCls["".concat(rowPrefixCls, "-range-end")] = isRangeEnd;
				rangeCls["".concat(rowPrefixCls, "-range-hover")] = !isRangeStart && !isRangeEnd && isInRange(generateConfig$1, rangeStart, rangeEnd, currentDate);
			}
			if (hoverValue) rangeCls["".concat(rowPrefixCls, "-hover")] = hoverValue.some(function(date$1) {
				return isSameWeek(generateConfig$1, localeName, currentDate, date$1);
			});
			return clsx(rowPrefixCls, _defineProperty$13({}, "".concat(rowPrefixCls, "-selected"), !hoverRangeValue && isSameWeek(generateConfig$1, localeName, value, currentDate)), rangeCls);
		}
	}));
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerPanel/YearPanel/index.js
function _typeof$12(o$2) {
	"@babel/helpers - typeof";
	return _typeof$12 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$12(o$2);
}
function _extends$61() {
	_extends$61 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$61.apply(this, arguments);
}
function _defineProperty$12(obj, key, value) {
	key = _toPropertyKey$11(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$11(t$1) {
	var i = _toPrimitive$11(t$1, "string");
	return "symbol" == _typeof$12(i) ? i : String(i);
}
function _toPrimitive$11(t$1, r$1) {
	if ("object" != _typeof$12(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$12(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _slicedToArray$8(arr, i) {
	return _arrayWithHoles$7(arr) || _iterableToArrayLimit$7(arr, i) || _unsupportedIterableToArray$8(arr, i) || _nonIterableRest$7();
}
function _nonIterableRest$7() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$8(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$7(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$7(o$2, minLen);
}
function _arrayLikeToArray$7(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$7(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$7(arr) {
	if (Array.isArray(arr)) return arr;
}
function YearPanel(props) {
	var prefixCls = props.prefixCls, locale$5 = props.locale, generateConfig$1 = props.generateConfig, pickerValue = props.pickerValue, disabledDate = props.disabledDate, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange;
	var panelPrefixCls = "".concat(prefixCls, "-year-panel");
	var info = _slicedToArray$8(useInfo(props, "year"), 1)[0];
	var getStartYear = function getStartYear$1(date$1) {
		var startYear = Math.floor(generateConfig$1.getYear(date$1) / 10) * 10;
		return generateConfig$1.setYear(date$1, startYear);
	};
	var getEndYear = function getEndYear$1(date$1) {
		var startYear = getStartYear(date$1);
		return generateConfig$1.addYear(startYear, 9);
	};
	var startYearDate = getStartYear(pickerValue);
	var endYearDate = getEndYear(pickerValue);
	var baseDate = generateConfig$1.addYear(startYearDate, -1);
	var getCellDate = function getCellDate$1(date$1, offset$2) {
		return generateConfig$1.addYear(date$1, offset$2);
	};
	var getCellText = function getCellText$1(date$1) {
		return formatValue(date$1, {
			locale: locale$5,
			format: locale$5.cellYearFormat,
			generateConfig: generateConfig$1
		});
	};
	var getCellClassName = function getCellClassName$1(date$1) {
		return _defineProperty$12({}, "".concat(prefixCls, "-cell-in-view"), isSameYear$1(generateConfig$1, date$1, startYearDate) || isSameYear$1(generateConfig$1, date$1, endYearDate) || isInRange(generateConfig$1, startYearDate, endYearDate, date$1));
	};
	var mergedDisabledDate = disabledDate ? function(currentDate, disabledInfo) {
		var startMonth = generateConfig$1.setMonth(currentDate, 0);
		var startDate = generateConfig$1.setDate(startMonth, 1);
		var endMonth = generateConfig$1.addYear(startDate, 1);
		var endDate = generateConfig$1.addDate(endMonth, -1);
		return disabledDate(startDate, disabledInfo) && disabledDate(endDate, disabledInfo);
	} : null;
	var yearNode = /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		key: "decade",
		"aria-label": locale$5.decadeSelect,
		onClick: function onClick() {
			onModeChange("decade");
		},
		tabIndex: -1,
		className: "".concat(prefixCls, "-decade-btn")
	}, formatValue(startYearDate, {
		locale: locale$5,
		format: locale$5.yearFormat,
		generateConfig: generateConfig$1
	}), "-", formatValue(endYearDate, {
		locale: locale$5,
		format: locale$5.yearFormat,
		generateConfig: generateConfig$1
	}));
	return /* @__PURE__ */ import_react.createElement(PanelContext.Provider, { value: info }, /* @__PURE__ */ import_react.createElement("div", { className: panelPrefixCls }, /* @__PURE__ */ import_react.createElement(PanelHeader_default, {
		superOffset: function superOffset(distance) {
			return generateConfig$1.addYear(pickerValue, distance * 10);
		},
		onChange: onPickerValueChange,
		getStart: getStartYear,
		getEnd: getEndYear
	}, yearNode), /* @__PURE__ */ import_react.createElement(PanelBody, _extends$61({}, props, {
		disabledDate: mergedDisabledDate,
		titleFormat: locale$5.fieldYearFormat,
		colNum: 3,
		rowNum: 4,
		baseDate,
		getCellDate,
		getCellText,
		getCellClassName
	}))));
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerPanel/index.js
function _typeof$11(o$2) {
	"@babel/helpers - typeof";
	return _typeof$11 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$11(o$2);
}
function _extends$60() {
	_extends$60 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$60.apply(this, arguments);
}
function ownKeys$8(e$2, r$1) {
	var t$1 = Object.keys(e$2);
	if (Object.getOwnPropertySymbols) {
		var o$2 = Object.getOwnPropertySymbols(e$2);
		r$1 && (o$2 = o$2.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e$2, r$2).enumerable;
		})), t$1.push.apply(t$1, o$2);
	}
	return t$1;
}
function _objectSpread$8(e$2) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$8(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$11(e$2, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$2, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$8(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e$2, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e$2;
}
function _defineProperty$11(obj, key, value) {
	key = _toPropertyKey$10(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$10(t$1) {
	var i = _toPrimitive$10(t$1, "string");
	return "symbol" == _typeof$11(i) ? i : String(i);
}
function _toPrimitive$10(t$1, r$1) {
	if ("object" != _typeof$11(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$11(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _toConsumableArray$3(arr) {
	return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _unsupportedIterableToArray$7(arr) || _nonIterableSpread$2();
}
function _nonIterableSpread$2() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$2(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$2(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$6(arr);
}
function _slicedToArray$7(arr, i) {
	return _arrayWithHoles$6(arr) || _iterableToArrayLimit$6(arr, i) || _unsupportedIterableToArray$7(arr, i) || _nonIterableRest$6();
}
function _nonIterableRest$6() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$7(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$6(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$6(o$2, minLen);
}
function _arrayLikeToArray$6(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$6(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$6(arr) {
	if (Array.isArray(arr)) return arr;
}
var DefaultComponents = {
	date: DatePanel,
	datetime: DateTimePanel,
	week: WeekPanel,
	month: MonthPanel,
	quarter: QuarterPanel,
	year: YearPanel,
	decade: DecadePanel,
	time: TimePanel
};
function PickerPanel(props, ref) {
	var panelClassNames = props.classNames, panelStyles = props.styles, locale$5 = props.locale, generateConfig$1 = props.generateConfig, direction = props.direction, prefixCls = props.prefixCls, _props$tabIndex = props.tabIndex, tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex, multiple = props.multiple, defaultValue = props.defaultValue, value = props.value, onChange = props.onChange, onSelect = props.onSelect, defaultPickerValue = props.defaultPickerValue, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, mode = props.mode, onPanelChange = props.onPanelChange, _props$picker = props.picker, picker = _props$picker === void 0 ? "date" : _props$picker, showTime = props.showTime, hoverValue = props.hoverValue, hoverRangeValue = props.hoverRangeValue, cellRender = props.cellRender, dateRender = props.dateRender, monthCellRender = props.monthCellRender, _props$components = props.components, components$1 = _props$components === void 0 ? {} : _props$components, hideHeader = props.hideHeader;
	var _ref = import_react.useContext(context_default$5) || {}, contextPrefixCls = _ref.prefixCls, pickerClassNames = _ref.classNames, pickerStyles = _ref.styles;
	var mergedPrefixCls = contextPrefixCls || prefixCls || "rc-picker";
	var rootRef = import_react.useRef();
	import_react.useImperativeHandle(ref, function() {
		return { nativeElement: rootRef.current };
	});
	var _getTimeProps2 = _slicedToArray$7(getTimeProps(props), 4), timeProps = _getTimeProps2[0], localeTimeProps = _getTimeProps2[1], showTimeFormat = _getTimeProps2[2], propFormat = _getTimeProps2[3];
	var filledLocale = useLocale(locale$5, localeTimeProps);
	var internalPicker = picker === "date" && showTime ? "datetime" : picker;
	var mergedShowTime = import_react.useMemo(function() {
		return fillShowTimeConfig(internalPicker, showTimeFormat, propFormat, timeProps, filledLocale);
	}, [
		internalPicker,
		showTimeFormat,
		propFormat,
		timeProps,
		filledLocale
	]);
	var now$1 = generateConfig$1.getNow();
	var _useControlledState2 = _slicedToArray$7(useControlledState(picker || "date", mode), 2), mergedMode = _useControlledState2[0], setMergedMode = _useControlledState2[1];
	var internalMode = mergedMode === "date" && mergedShowTime ? "datetime" : mergedMode;
	var toggleDates = useToggleDates(generateConfig$1, locale$5, internalPicker);
	var _useControlledState4 = _slicedToArray$7(useControlledState(defaultValue, value), 2), innerValue = _useControlledState4[0], setMergedValue = _useControlledState4[1];
	var mergedValue = import_react.useMemo(function() {
		var values = toArray$5(innerValue).filter(function(val) {
			return val;
		});
		return multiple ? values : values.slice(0, 1);
	}, [innerValue, multiple]);
	var triggerChange = useEvent_default(function(nextValue) {
		setMergedValue(nextValue);
		if (onChange && (nextValue === null || mergedValue.length !== nextValue.length || mergedValue.some(function(ori, index$1) {
			return !isSame(generateConfig$1, locale$5, ori, nextValue[index$1], internalPicker);
		}))) onChange === null || onChange === void 0 || onChange(multiple ? nextValue : nextValue[0]);
	});
	var onInternalSelect = useEvent_default(function(newDate) {
		onSelect === null || onSelect === void 0 || onSelect(newDate);
		if (mergedMode === picker) triggerChange(multiple ? toggleDates(mergedValue, newDate) : [newDate]);
	});
	var _useControlledState6 = _slicedToArray$7(useControlledState(defaultPickerValue || mergedValue[0] || now$1, pickerValue), 2), mergedPickerValue = _useControlledState6[0], setInternalPickerValue = _useControlledState6[1];
	import_react.useEffect(function() {
		if (mergedValue[0] && !pickerValue) setInternalPickerValue(mergedValue[0]);
	}, [mergedValue[0]]);
	var triggerPanelChange = function triggerPanelChange$1(viewDate, nextMode) {
		onPanelChange === null || onPanelChange === void 0 || onPanelChange(viewDate || pickerValue, nextMode || mergedMode);
	};
	var setPickerValue = function setPickerValue$1(nextPickerValue) {
		var triggerPanelEvent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
		setInternalPickerValue(nextPickerValue);
		onPickerValueChange === null || onPickerValueChange === void 0 || onPickerValueChange(nextPickerValue);
		if (triggerPanelEvent) triggerPanelChange(nextPickerValue);
	};
	var triggerModeChange = function triggerModeChange$1(nextMode, viewDate) {
		setMergedMode(nextMode);
		if (viewDate) setPickerValue(viewDate);
		triggerPanelChange(viewDate, nextMode);
	};
	var onPanelValueSelect = function onPanelValueSelect$1(nextValue) {
		onInternalSelect(nextValue);
		setPickerValue(nextValue);
		if (mergedMode !== picker) {
			var decadeYearQueue = ["decade", "year"];
			var decadeYearMonthQueue = [].concat(decadeYearQueue, ["month"]);
			var queue = {
				quarter: [].concat(decadeYearQueue, ["quarter"]),
				week: [].concat(_toConsumableArray$3(decadeYearMonthQueue), ["week"]),
				date: [].concat(_toConsumableArray$3(decadeYearMonthQueue), ["date"])
			}[picker] || decadeYearMonthQueue;
			var nextMode = queue[queue.indexOf(mergedMode) + 1];
			if (nextMode) triggerModeChange(nextMode, nextValue);
		}
	};
	var hoverRangeDate = import_react.useMemo(function() {
		var start;
		var end;
		if (Array.isArray(hoverRangeValue)) {
			var _hoverRangeValue = _slicedToArray$7(hoverRangeValue, 2);
			start = _hoverRangeValue[0];
			end = _hoverRangeValue[1];
		} else start = hoverRangeValue;
		if (!start && !end) return null;
		start = start || end;
		end = end || start;
		return generateConfig$1.isAfter(start, end) ? [end, start] : [start, end];
	}, [hoverRangeValue, generateConfig$1]);
	var onInternalCellRender = useCellRender$1(cellRender, dateRender, monthCellRender);
	var PanelComponent = components$1[internalMode] || DefaultComponents[internalMode] || DatePanel;
	var sharedPanelContext = import_react.useMemo(function() {
		var _ref2, _pickerClassNames$pop, _ref3, _pickerStyles$popup;
		return {
			classNames: (_ref2 = (_pickerClassNames$pop = pickerClassNames === null || pickerClassNames === void 0 ? void 0 : pickerClassNames.popup) !== null && _pickerClassNames$pop !== void 0 ? _pickerClassNames$pop : panelClassNames) !== null && _ref2 !== void 0 ? _ref2 : {},
			styles: (_ref3 = (_pickerStyles$popup = pickerStyles === null || pickerStyles === void 0 ? void 0 : pickerStyles.popup) !== null && _pickerStyles$popup !== void 0 ? _pickerStyles$popup : panelStyles) !== null && _ref3 !== void 0 ? _ref3 : {}
		};
	}, [
		pickerClassNames,
		panelClassNames,
		pickerStyles,
		panelStyles
	]);
	var parentHackContext = import_react.useContext(PickerHackContext);
	var pickerPanelContext = import_react.useMemo(function() {
		return _objectSpread$8(_objectSpread$8({}, parentHackContext), {}, { hideHeader });
	}, [parentHackContext, hideHeader]);
	warning_default$1(!mergedValue || mergedValue.every(function(val) {
		return generateConfig$1.isValidate(val);
	}), "Invalidate date pass to `value` or `defaultValue`.");
	var panelCls = "".concat(mergedPrefixCls, "-panel");
	var panelProps = pickProps(props, [
		"showWeek",
		"prevIcon",
		"nextIcon",
		"superPrevIcon",
		"superNextIcon",
		"disabledDate",
		"minDate",
		"maxDate",
		"onHover"
	]);
	return /* @__PURE__ */ import_react.createElement(SharedPanelContext.Provider, { value: sharedPanelContext }, /* @__PURE__ */ import_react.createElement(PickerHackContext.Provider, { value: pickerPanelContext }, /* @__PURE__ */ import_react.createElement("div", {
		ref: rootRef,
		tabIndex,
		className: clsx(panelCls, _defineProperty$11({}, "".concat(panelCls, "-rtl"), direction === "rtl"))
	}, /* @__PURE__ */ import_react.createElement(PanelComponent, _extends$60({}, panelProps, {
		showTime: mergedShowTime,
		prefixCls: mergedPrefixCls,
		locale: filledLocale,
		generateConfig: generateConfig$1,
		onModeChange: triggerModeChange,
		pickerValue: mergedPickerValue,
		onPickerValueChange: function onPickerValueChange$1(nextPickerValue) {
			setPickerValue(nextPickerValue, true);
		},
		value: mergedValue[0],
		onSelect: onPanelValueSelect,
		values: mergedValue,
		cellRender: onInternalCellRender,
		hoverRangeValue: hoverRangeDate,
		hoverValue
	})))));
}
var RefPanelPicker = /* @__PURE__ */ import_react.memo(/* @__PURE__ */ import_react.forwardRef(PickerPanel));
RefPanelPicker.displayName = "PanelPicker";
var PickerPanel_default = RefPanelPicker;

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/Popup/PopupPanel.js
function _typeof$10(o$2) {
	"@babel/helpers - typeof";
	return _typeof$10 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$10(o$2);
}
function _extends$59() {
	_extends$59 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$59.apply(this, arguments);
}
function ownKeys$7(e$2, r$1) {
	var t$1 = Object.keys(e$2);
	if (Object.getOwnPropertySymbols) {
		var o$2 = Object.getOwnPropertySymbols(e$2);
		r$1 && (o$2 = o$2.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e$2, r$2).enumerable;
		})), t$1.push.apply(t$1, o$2);
	}
	return t$1;
}
function _objectSpread$7(e$2) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$7(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$10(e$2, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$2, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$7(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e$2, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e$2;
}
function _defineProperty$10(obj, key, value) {
	key = _toPropertyKey$9(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$9(t$1) {
	var i = _toPrimitive$9(t$1, "string");
	return "symbol" == _typeof$10(i) ? i : String(i);
}
function _toPrimitive$9(t$1, r$1) {
	if ("object" != _typeof$10(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$10(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function PopupPanel(props) {
	var picker = props.picker, multiplePanel = props.multiplePanel, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, needConfirm = props.needConfirm, onSubmit = props.onSubmit, range$1 = props.range, hoverValue = props.hoverValue;
	var _React$useContext = import_react.useContext(context_default$5), prefixCls = _React$useContext.prefixCls, generateConfig$1 = _React$useContext.generateConfig;
	var internalOffsetDate = import_react.useCallback(function(date$1, offset$2) {
		return offsetPanelDate(generateConfig$1, picker, date$1, offset$2);
	}, [generateConfig$1, picker]);
	var nextPickerValue = import_react.useMemo(function() {
		return internalOffsetDate(pickerValue, 1);
	}, [pickerValue, internalOffsetDate]);
	var onSecondPickerValueChange = function onSecondPickerValueChange$1(nextDate) {
		onPickerValueChange(internalOffsetDate(nextDate, -1));
	};
	var sharedContext = { onCellDblClick: function onCellDblClick() {
		if (needConfirm) onSubmit();
	} };
	var hideHeader = picker === "time";
	var pickerProps = _objectSpread$7(_objectSpread$7({}, props), {}, {
		hoverValue: null,
		hoverRangeValue: null,
		hideHeader
	});
	if (range$1) pickerProps.hoverRangeValue = hoverValue;
	else pickerProps.hoverValue = hoverValue;
	if (multiplePanel) return /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-panels") }, /* @__PURE__ */ import_react.createElement(PickerHackContext.Provider, { value: _objectSpread$7(_objectSpread$7({}, sharedContext), {}, { hideNext: true }) }, /* @__PURE__ */ import_react.createElement(PickerPanel_default, pickerProps)), /* @__PURE__ */ import_react.createElement(PickerHackContext.Provider, { value: _objectSpread$7(_objectSpread$7({}, sharedContext), {}, { hidePrev: true }) }, /* @__PURE__ */ import_react.createElement(PickerPanel_default, _extends$59({}, pickerProps, {
		pickerValue: nextPickerValue,
		onPickerValueChange: onSecondPickerValueChange
	}))));
	return /* @__PURE__ */ import_react.createElement(PickerHackContext.Provider, { value: _objectSpread$7({}, sharedContext) }, /* @__PURE__ */ import_react.createElement(PickerPanel_default, pickerProps));
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/Popup/PresetPanel.js
function executeValue(value) {
	return typeof value === "function" ? value() : value;
}
function PresetPanel(props) {
	var prefixCls = props.prefixCls, presets = props.presets, _onClick = props.onClick, onHover = props.onHover;
	if (!presets.length) return null;
	return /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-presets") }, /* @__PURE__ */ import_react.createElement("ul", null, presets.map(function(_ref, index$1) {
		var label = _ref.label, value = _ref.value;
		return /* @__PURE__ */ import_react.createElement("li", {
			key: index$1,
			onClick: function onClick() {
				_onClick(executeValue(value));
			},
			onMouseEnter: function onMouseEnter() {
				onHover(executeValue(value));
			},
			onMouseLeave: function onMouseLeave() {
				onHover(null);
			}
		}, label);
	})));
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/Popup/index.js
function _typeof$9(o$2) {
	"@babel/helpers - typeof";
	return _typeof$9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$9(o$2);
}
function ownKeys$6(e$2, r$1) {
	var t$1 = Object.keys(e$2);
	if (Object.getOwnPropertySymbols) {
		var o$2 = Object.getOwnPropertySymbols(e$2);
		r$1 && (o$2 = o$2.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e$2, r$2).enumerable;
		})), t$1.push.apply(t$1, o$2);
	}
	return t$1;
}
function _objectSpread$6(e$2) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$6(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$9(e$2, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$2, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$6(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e$2, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e$2;
}
function _defineProperty$9(obj, key, value) {
	key = _toPropertyKey$8(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$8(t$1) {
	var i = _toPrimitive$8(t$1, "string");
	return "symbol" == _typeof$9(i) ? i : String(i);
}
function _toPrimitive$8(t$1, r$1) {
	if ("object" != _typeof$9(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$9(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _extends$58() {
	_extends$58 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$58.apply(this, arguments);
}
function _slicedToArray$6(arr, i) {
	return _arrayWithHoles$5(arr) || _iterableToArrayLimit$5(arr, i) || _unsupportedIterableToArray$6(arr, i) || _nonIterableRest$5();
}
function _nonIterableRest$5() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$6(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$5(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$5(o$2, minLen);
}
function _arrayLikeToArray$5(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$5(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$5(arr) {
	if (Array.isArray(arr)) return arr;
}
function Popup(props) {
	var _classNames$popup, _styles$popup;
	var panelRender = props.panelRender, internalMode = props.internalMode, picker = props.picker, showNow = props.showNow, range$1 = props.range, multiple = props.multiple, _props$activeInfo = props.activeInfo, activeInfo = _props$activeInfo === void 0 ? [
		0,
		0,
		0
	] : _props$activeInfo, presets = props.presets, onPresetHover = props.onPresetHover, onPresetSubmit = props.onPresetSubmit, onFocus = props.onFocus, onBlur = props.onBlur, onPanelMouseDown = props.onPanelMouseDown, direction = props.direction, value = props.value, onSelect = props.onSelect, isInvalid = props.isInvalid, defaultOpenValue = props.defaultOpenValue, onOk = props.onOk, onSubmit = props.onSubmit, classNames = props.classNames, styles = props.styles;
	var prefixCls = import_react.useContext(context_default$5).prefixCls;
	var panelPrefixCls = "".concat(prefixCls, "-panel");
	var rtl = direction === "rtl";
	var arrowRef = import_react.useRef(null);
	var wrapperRef = import_react.useRef(null);
	var _React$useState2 = _slicedToArray$6(import_react.useState(0), 2), containerWidth = _React$useState2[0], setContainerWidth = _React$useState2[1];
	var _React$useState4 = _slicedToArray$6(import_react.useState(0), 2), containerOffset = _React$useState4[0], setContainerOffset = _React$useState4[1];
	var _React$useState6 = _slicedToArray$6(import_react.useState(0), 2), arrowOffset = _React$useState6[0], setArrowOffset = _React$useState6[1];
	var onResize$1 = function onResize$2(info) {
		if (info.width) setContainerWidth(info.width);
	};
	var _activeInfo = _slicedToArray$6(activeInfo, 3), activeInputLeft = _activeInfo[0], activeInputRight = _activeInfo[1], selectorWidth = _activeInfo[2];
	var _React$useState8 = _slicedToArray$6(import_react.useState(0), 2), retryTimes = _React$useState8[0], setRetryTimes = _React$useState8[1];
	import_react.useEffect(function() {
		setRetryTimes(10);
	}, [activeInputLeft]);
	import_react.useEffect(function() {
		if (range$1 && wrapperRef.current) {
			var _arrowRef$current;
			var arrowWidth = ((_arrowRef$current = arrowRef.current) === null || _arrowRef$current === void 0 ? void 0 : _arrowRef$current.offsetWidth) || 0;
			var wrapperRect = wrapperRef.current.getBoundingClientRect();
			if (!wrapperRect.height || wrapperRect.right < 0) {
				setRetryTimes(function(times) {
					return Math.max(0, times - 1);
				});
				return;
			}
			setArrowOffset((rtl ? activeInputRight - arrowWidth : activeInputLeft) - wrapperRect.left);
			if (containerWidth && containerWidth < selectorWidth) {
				var offset$2 = rtl ? wrapperRect.right - (activeInputRight - arrowWidth + containerWidth) : activeInputLeft + arrowWidth - wrapperRect.left - containerWidth;
				setContainerOffset(Math.max(0, offset$2));
			} else setContainerOffset(0);
		}
	}, [
		retryTimes,
		rtl,
		containerWidth,
		activeInputLeft,
		activeInputRight,
		selectorWidth,
		range$1
	]);
	function filterEmpty(list) {
		return list.filter(function(item) {
			return item;
		});
	}
	var valueList = import_react.useMemo(function() {
		return filterEmpty(toArray$5(value));
	}, [value]);
	var isTimePickerEmptyValue = picker === "time" && !valueList.length;
	var footerSubmitValue = import_react.useMemo(function() {
		if (isTimePickerEmptyValue) return filterEmpty([defaultOpenValue]);
		return valueList;
	}, [
		isTimePickerEmptyValue,
		valueList,
		defaultOpenValue
	]);
	var popupPanelValue = isTimePickerEmptyValue ? defaultOpenValue : valueList;
	var disableSubmit = import_react.useMemo(function() {
		if (!footerSubmitValue.length) return true;
		return footerSubmitValue.some(function(val) {
			return isInvalid(val);
		});
	}, [footerSubmitValue, isInvalid]);
	var mergedNodes = /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-panel-layout") }, /* @__PURE__ */ import_react.createElement(PresetPanel, {
		prefixCls,
		presets,
		onClick: onPresetSubmit,
		onHover: onPresetHover
	}), /* @__PURE__ */ import_react.createElement("div", null, /* @__PURE__ */ import_react.createElement(PopupPanel, _extends$58({}, props, { value: popupPanelValue })), /* @__PURE__ */ import_react.createElement(Footer$4, _extends$58({}, props, {
		showNow: multiple ? false : showNow,
		invalid: disableSubmit,
		onSubmit: function onFooterSubmit() {
			if (isTimePickerEmptyValue) onSelect(defaultOpenValue);
			onOk();
			onSubmit();
		}
	}))));
	if (panelRender) mergedNodes = panelRender(mergedNodes);
	var containerPrefixCls = "".concat(panelPrefixCls, "-container");
	var marginLeft = "marginLeft";
	var marginRight = "marginRight";
	var renderNode = /* @__PURE__ */ import_react.createElement("div", {
		onMouseDown: onPanelMouseDown,
		tabIndex: -1,
		className: clsx(containerPrefixCls, "".concat(prefixCls, "-").concat(internalMode, "-panel-container"), classNames === null || classNames === void 0 || (_classNames$popup = classNames.popup) === null || _classNames$popup === void 0 ? void 0 : _classNames$popup.container),
		style: _objectSpread$6(_defineProperty$9(_defineProperty$9({}, rtl ? marginRight : marginLeft, containerOffset), rtl ? marginLeft : marginRight, "auto"), styles === null || styles === void 0 || (_styles$popup = styles.popup) === null || _styles$popup === void 0 ? void 0 : _styles$popup.container),
		onFocus,
		onBlur
	}, mergedNodes);
	if (range$1) renderNode = /* @__PURE__ */ import_react.createElement("div", {
		onMouseDown: onPanelMouseDown,
		ref: wrapperRef,
		className: clsx("".concat(prefixCls, "-range-wrapper"), "".concat(prefixCls, "-").concat(picker, "-range-wrapper"))
	}, /* @__PURE__ */ import_react.createElement("div", {
		ref: arrowRef,
		className: "".concat(prefixCls, "-range-arrow"),
		style: { left: arrowOffset }
	}), /* @__PURE__ */ import_react.createElement(es_default$2, { onResize: onResize$1 }, renderNode));
	return renderNode;
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/Selector/hooks/useInputProps.js
function _typeof$8(o$2) {
	"@babel/helpers - typeof";
	return _typeof$8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$8(o$2);
}
function ownKeys$5(e$2, r$1) {
	var t$1 = Object.keys(e$2);
	if (Object.getOwnPropertySymbols) {
		var o$2 = Object.getOwnPropertySymbols(e$2);
		r$1 && (o$2 = o$2.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e$2, r$2).enumerable;
		})), t$1.push.apply(t$1, o$2);
	}
	return t$1;
}
function _objectSpread$5(e$2) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$5(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$8(e$2, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$2, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$5(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e$2, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e$2;
}
function _defineProperty$8(obj, key, value) {
	key = _toPropertyKey$7(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$7(t$1) {
	var i = _toPrimitive$7(t$1, "string");
	return "symbol" == _typeof$8(i) ? i : String(i);
}
function _toPrimitive$7(t$1, r$1) {
	if ("object" != _typeof$8(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$8(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function useInputProps(props, postProps) {
	var format$1 = props.format, maskFormat = props.maskFormat, generateConfig$1 = props.generateConfig, locale$5 = props.locale, preserveInvalidOnBlur = props.preserveInvalidOnBlur, inputReadOnly = props.inputReadOnly, required$2 = props.required, ariaRequired = props["aria-required"], onSubmit = props.onSubmit, _onFocus = props.onFocus, _onBlur = props.onBlur, onInputChange = props.onInputChange, onInvalid = props.onInvalid, open$2 = props.open, onOpenChange = props.onOpenChange, _onKeyDown = props.onKeyDown, _onChange = props.onChange, activeHelp = props.activeHelp, name = props.name, autoComplete = props.autoComplete, id = props.id, value = props.value, invalid = props.invalid, placeholder = props.placeholder, disabled = props.disabled, activeIndex = props.activeIndex, allHelp = props.allHelp, picker = props.picker;
	var parseDate = function parseDate$1(str, formatStr) {
		var parsed = generateConfig$1.locale.parse(locale$5.locale, str, [formatStr]);
		return parsed && generateConfig$1.isValidate(parsed) ? parsed : null;
	};
	var firstFormat = format$1[0];
	var getText = import_react.useCallback(function(date$1) {
		return formatValue(date$1, {
			locale: locale$5,
			format: firstFormat,
			generateConfig: generateConfig$1
		});
	}, [
		locale$5,
		generateConfig$1,
		firstFormat
	]);
	var valueTexts = import_react.useMemo(function() {
		return value.map(getText);
	}, [value, getText]);
	var size = import_react.useMemo(function() {
		var defaultSize = picker === "time" ? 8 : 10;
		var length$1 = typeof firstFormat === "function" ? firstFormat(generateConfig$1.getNow()).length : firstFormat.length;
		return Math.max(defaultSize, length$1) + 2;
	}, [
		firstFormat,
		picker,
		generateConfig$1
	]);
	var _validateFormat = function validateFormat(text) {
		for (var i = 0; i < format$1.length; i += 1) {
			var singleFormat = format$1[i];
			if (typeof singleFormat === "string") {
				var parsed = parseDate(text, singleFormat);
				if (parsed) return parsed;
			}
		}
		return false;
	};
	return [function getInputProps(index$1) {
		function getProp(propValue) {
			return index$1 !== void 0 ? propValue[index$1] : propValue;
		}
		var inputProps = _objectSpread$5(_objectSpread$5({}, pickAttrs(props, {
			aria: true,
			data: true
		})), {}, {
			format: maskFormat,
			validateFormat: function validateFormat(text) {
				return !!_validateFormat(text);
			},
			preserveInvalidOnBlur,
			readOnly: inputReadOnly,
			required: required$2,
			"aria-required": ariaRequired,
			name,
			autoComplete,
			size,
			id: getProp(id),
			value: getProp(valueTexts) || "",
			invalid: getProp(invalid),
			placeholder: getProp(placeholder),
			active: activeIndex === index$1,
			helped: allHelp || activeHelp && activeIndex === index$1,
			disabled: getProp(disabled),
			onFocus: function onFocus(event) {
				_onFocus(event, index$1);
			},
			onBlur: function onBlur(event) {
				_onBlur(event, index$1);
			},
			onSubmit,
			onChange: function onChange(text) {
				onInputChange();
				var parsed = _validateFormat(text);
				if (parsed) {
					onInvalid(false, index$1);
					_onChange(parsed, index$1);
					return;
				}
				onInvalid(!!text, index$1);
			},
			onHelp: function onHelp() {
				onOpenChange(true, { index: index$1 });
			},
			onKeyDown: function onKeyDown$1(event) {
				var prevented = false;
				_onKeyDown === null || _onKeyDown === void 0 || _onKeyDown(event, function() {
					warning_default$1(false, "`preventDefault` callback is deprecated. Please call `event.preventDefault` directly.");
					prevented = true;
				});
				if (!event.defaultPrevented && !prevented) switch (event.key) {
					case "Escape":
						onOpenChange(false, { index: index$1 });
						break;
					case "Enter":
						if (!open$2) onOpenChange(true);
						break;
				}
			}
		}, postProps === null || postProps === void 0 ? void 0 : postProps({ valueTexts }));
		Object.keys(inputProps).forEach(function(key) {
			if (inputProps[key] === void 0) delete inputProps[key];
		});
		return inputProps;
	}, getText];
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/Selector/hooks/useRootProps.js
var propNames = ["onMouseEnter", "onMouseLeave"];
function useRootProps(props) {
	return import_react.useMemo(function() {
		return pickProps(props, propNames);
	}, [props]);
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/Selector/Icon.js
var _excluded$6 = ["icon", "type"], _excluded2$1 = ["onClear"];
function _extends$57() {
	_extends$57 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$57.apply(this, arguments);
}
function _objectWithoutProperties$4(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$4(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$4(source, excluded) {
	if (source == null) return {};
	var target = {};
	var sourceKeys = Object.keys(source);
	var key, i;
	for (i = 0; i < sourceKeys.length; i++) {
		key = sourceKeys[i];
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function Icon$1(props) {
	var icon = props.icon, type$2 = props.type, restProps = _objectWithoutProperties$4(props, _excluded$6);
	var _React$useContext = import_react.useContext(context_default$5), prefixCls = _React$useContext.prefixCls, classNames = _React$useContext.classNames, styles = _React$useContext.styles;
	return icon ? /* @__PURE__ */ import_react.createElement("span", _extends$57({
		className: clsx("".concat(prefixCls, "-").concat(type$2), classNames.suffix),
		style: styles.suffix
	}, restProps), icon) : null;
}
function ClearIcon(_ref) {
	var onClear = _ref.onClear, restProps = _objectWithoutProperties$4(_ref, _excluded2$1);
	return /* @__PURE__ */ import_react.createElement(Icon$1, _extends$57({}, restProps, {
		type: "clear",
		role: "button",
		onMouseDown: function onMouseDown(e$2) {
			e$2.preventDefault();
		},
		onClick: function onClick(e$2) {
			e$2.stopPropagation();
			onClear();
		}
	}));
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/Selector/MaskFormat.js
function _typeof$7(o$2) {
	"@babel/helpers - typeof";
	return _typeof$7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$7(o$2);
}
function _classCallCheck$1(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
	for (var i = 0; i < props.length; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$6(descriptor.key), descriptor);
	}
}
function _createClass$1(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _defineProperty$7(obj, key, value) {
	key = _toPropertyKey$6(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$6(t$1) {
	var i = _toPrimitive$6(t$1, "string");
	return "symbol" == _typeof$7(i) ? i : String(i);
}
function _toPrimitive$6(t$1, r$1) {
	if ("object" != _typeof$7(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$7(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var FORMAT_KEYS = [
	"YYYY",
	"MM",
	"DD",
	"HH",
	"mm",
	"ss",
	"SSS"
];
var REPLACE_KEY = "";
var MaskFormat = /* @__PURE__ */ function() {
	function MaskFormat$1(format$1) {
		_classCallCheck$1(this, MaskFormat$1);
		_defineProperty$7(this, "format", void 0);
		_defineProperty$7(this, "maskFormat", void 0);
		_defineProperty$7(this, "cells", void 0);
		_defineProperty$7(this, "maskCells", void 0);
		this.format = format$1;
		var replaceKeys = FORMAT_KEYS.map(function(key) {
			return "(".concat(key, ")");
		}).join("|");
		var replaceReg = new RegExp(replaceKeys, "g");
		this.maskFormat = format$1.replace(replaceReg, function(key) {
			return REPLACE_KEY.repeat(key.length);
		});
		var cellReg = new RegExp("(".concat(FORMAT_KEYS.join("|"), ")"));
		var strCells = (format$1.split(cellReg) || []).filter(function(str) {
			return str;
		});
		var offset$2 = 0;
		this.cells = strCells.map(function(text) {
			var mask = FORMAT_KEYS.includes(text);
			var start = offset$2;
			var end = offset$2 + text.length;
			offset$2 = end;
			return {
				text,
				mask,
				start,
				end
			};
		});
		this.maskCells = this.cells.filter(function(cell) {
			return cell.mask;
		});
	}
	_createClass$1(MaskFormat$1, [
		{
			key: "getSelection",
			value: function getSelection(maskCellIndex) {
				var _ref = this.maskCells[maskCellIndex] || {}, start = _ref.start, end = _ref.end;
				return [start || 0, end || 0];
			}
		},
		{
			key: "match",
			value: function match$2(text) {
				for (var i = 0; i < this.maskFormat.length; i += 1) {
					var maskChar = this.maskFormat[i];
					var textChar = text[i];
					if (!textChar || maskChar !== REPLACE_KEY && maskChar !== textChar) return false;
				}
				return true;
			}
		},
		{
			key: "size",
			value: function size() {
				return this.maskCells.length;
			}
		},
		{
			key: "getMaskCellIndex",
			value: function getMaskCellIndex(anchorIndex) {
				var closetDist = Number.MAX_SAFE_INTEGER;
				var closetIndex = 0;
				for (var i = 0; i < this.maskCells.length; i += 1) {
					var _this$maskCells$i = this.maskCells[i], start = _this$maskCells$i.start, end = _this$maskCells$i.end;
					if (anchorIndex >= start && anchorIndex <= end) return i;
					var dist = Math.min(Math.abs(anchorIndex - start), Math.abs(anchorIndex - end));
					if (dist < closetDist) {
						closetDist = dist;
						closetIndex = i;
					}
				}
				return closetIndex;
			}
		}
	]);
	return MaskFormat$1;
}();

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/Selector/util.js
function getMaskRange(key) {
	return {
		YYYY: [
			0,
			9999,
			(/* @__PURE__ */ new Date()).getFullYear()
		],
		MM: [1, 12],
		DD: [1, 31],
		HH: [0, 23],
		mm: [0, 59],
		ss: [0, 59],
		SSS: [0, 999]
	}[key];
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/Selector/Input.js
function _typeof$6(o$2) {
	"@babel/helpers - typeof";
	return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$6(o$2);
}
var _excluded$5 = [
	"className",
	"active",
	"showActiveCls",
	"suffixIcon",
	"format",
	"validateFormat",
	"onChange",
	"onInput",
	"helped",
	"onHelp",
	"onSubmit",
	"onKeyDown",
	"preserveInvalidOnBlur",
	"invalid",
	"clearIcon"
];
function _extends$56() {
	_extends$56 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$56.apply(this, arguments);
}
function _defineProperty$6(obj, key, value) {
	key = _toPropertyKey$5(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$5(t$1) {
	var i = _toPrimitive$5(t$1, "string");
	return "symbol" == _typeof$6(i) ? i : String(i);
}
function _toPrimitive$5(t$1, r$1) {
	if ("object" != _typeof$6(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$6(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _slicedToArray$5(arr, i) {
	return _arrayWithHoles$4(arr) || _iterableToArrayLimit$4(arr, i) || _unsupportedIterableToArray$5(arr, i) || _nonIterableRest$4();
}
function _nonIterableRest$4() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$5(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$4(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$4(o$2, minLen);
}
function _arrayLikeToArray$4(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$4(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$4(arr) {
	if (Array.isArray(arr)) return arr;
}
function _objectWithoutProperties$3(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$3(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$3(source, excluded) {
	if (source == null) return {};
	var target = {};
	var sourceKeys = Object.keys(source);
	var key, i;
	for (i = 0; i < sourceKeys.length; i++) {
		key = sourceKeys[i];
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
var Input$3 = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var className = props.className, active = props.active, _props$showActiveCls = props.showActiveCls, showActiveCls = _props$showActiveCls === void 0 ? true : _props$showActiveCls, suffixIcon = props.suffixIcon, format$1 = props.format, validateFormat = props.validateFormat, onChange = props.onChange;
	props.onInput;
	var helped = props.helped, onHelp = props.onHelp, onSubmit = props.onSubmit, onKeyDown$1 = props.onKeyDown, _props$preserveInvali = props.preserveInvalidOnBlur, preserveInvalidOnBlur = _props$preserveInvali === void 0 ? false : _props$preserveInvali, invalid = props.invalid, clearIcon = props.clearIcon, restProps = _objectWithoutProperties$3(props, _excluded$5);
	var value = props.value, onFocus = props.onFocus, onBlur = props.onBlur, onMouseUp = props.onMouseUp;
	var _React$useContext = import_react.useContext(context_default$5), prefixCls = _React$useContext.prefixCls, _React$useContext$inp = _React$useContext.input, Component$2 = _React$useContext$inp === void 0 ? "input" : _React$useContext$inp, classNames = _React$useContext.classNames, styles = _React$useContext.styles;
	var inputPrefixCls = "".concat(prefixCls, "-input");
	var _React$useState2 = _slicedToArray$5(import_react.useState(false), 2), focused = _React$useState2[0], setFocused = _React$useState2[1];
	var _React$useState4 = _slicedToArray$5(import_react.useState(value), 2), internalInputValue = _React$useState4[0], setInputValue = _React$useState4[1];
	var _React$useState6 = _slicedToArray$5(import_react.useState(""), 2), focusCellText = _React$useState6[0], setFocusCellText = _React$useState6[1];
	var _React$useState8 = _slicedToArray$5(import_react.useState(null), 2), focusCellIndex = _React$useState8[0], setFocusCellIndex = _React$useState8[1];
	var _React$useState10 = _slicedToArray$5(import_react.useState(null), 2), forceSelectionSyncMark = _React$useState10[0], forceSelectionSync = _React$useState10[1];
	var inputValue = internalInputValue || "";
	import_react.useEffect(function() {
		setInputValue(value);
	}, [value]);
	var holderRef = import_react.useRef(null);
	var inputRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, function() {
		return {
			nativeElement: holderRef.current,
			inputElement: inputRef.current,
			focus: function focus(options) {
				inputRef.current.focus(options);
			},
			blur: function blur() {
				inputRef.current.blur();
			}
		};
	});
	var maskFormat = import_react.useMemo(function() {
		return new MaskFormat(format$1 || "");
	}, [format$1]);
	var _React$useMemo2 = _slicedToArray$5(import_react.useMemo(function() {
		if (helped) return [0, 0];
		return maskFormat.getSelection(focusCellIndex);
	}, [
		maskFormat,
		focusCellIndex,
		helped
	]), 2), selectionStart = _React$useMemo2[0], selectionEnd = _React$useMemo2[1];
	var onModify = function onModify$1(text) {
		if (text && text !== format$1 && text !== value) onHelp();
	};
	/**
	* Triggered by paste, keyDown and focus to show format
	*/
	var triggerInputChange = useEvent_default(function(text) {
		if (validateFormat(text)) onChange(text);
		setInputValue(text);
		onModify(text);
	});
	var onInternalChange = function onInternalChange$1(event) {
		if (!format$1) {
			var text = event.target.value;
			onModify(text);
			setInputValue(text);
			onChange(text);
		}
	};
	var onFormatPaste = function onFormatPaste$1(event) {
		var pasteText = event.clipboardData.getData("text");
		if (validateFormat(pasteText)) triggerInputChange(pasteText);
	};
	var mouseDownRef = import_react.useRef(false);
	var onFormatMouseDown = function onFormatMouseDown$1() {
		mouseDownRef.current = true;
	};
	var onFormatMouseUp = function onFormatMouseUp$1(event) {
		var start = event.target.selectionStart;
		setFocusCellIndex(maskFormat.getMaskCellIndex(start));
		forceSelectionSync({});
		onMouseUp === null || onMouseUp === void 0 || onMouseUp(event);
		mouseDownRef.current = false;
	};
	var onFormatFocus = function onFormatFocus$1(event) {
		setFocused(true);
		setFocusCellIndex(0);
		setFocusCellText("");
		onFocus(event);
	};
	var onSharedBlur = function onSharedBlur$1(event) {
		onBlur(event);
	};
	var onFormatBlur = function onFormatBlur$1(event) {
		setFocused(false);
		onSharedBlur(event);
	};
	useLockEffect(active, function() {
		if (!active && !preserveInvalidOnBlur) setInputValue(value);
	});
	var onSharedKeyDown = function onSharedKeyDown$1(event) {
		if (event.key === "Enter" && validateFormat(inputValue)) onSubmit();
		onKeyDown$1 === null || onKeyDown$1 === void 0 || onKeyDown$1(event);
	};
	var onFormatKeyDown = function onFormatKeyDown$1(event) {
		onSharedKeyDown(event);
		var key = event.key;
		var nextCellText = null;
		var nextFillText = null;
		var maskCellLen = selectionEnd - selectionStart;
		var cellFormat = format$1.slice(selectionStart, selectionEnd);
		var offsetCellIndex = function offsetCellIndex$1(offset$2) {
			setFocusCellIndex(function(idx) {
				var nextIndex = idx + offset$2;
				nextIndex = Math.max(nextIndex, 0);
				nextIndex = Math.min(nextIndex, maskFormat.size() - 1);
				return nextIndex;
			});
		};
		var offsetCellValue = function offsetCellValue$1(offset$2) {
			var _getMaskRange2 = _slicedToArray$5(getMaskRange(cellFormat), 3), rangeStart = _getMaskRange2[0], rangeEnd = _getMaskRange2[1], rangeDefault = _getMaskRange2[2];
			var currentText = inputValue.slice(selectionStart, selectionEnd);
			var currentTextNum = Number(currentText);
			if (isNaN(currentTextNum)) return String(rangeDefault ? rangeDefault : offset$2 > 0 ? rangeStart : rangeEnd);
			var num = currentTextNum + offset$2;
			var range$1 = rangeEnd - rangeStart + 1;
			return String(rangeStart + (range$1 + num - rangeStart) % range$1);
		};
		switch (key) {
			case "Backspace":
			case "Delete":
				nextCellText = "";
				nextFillText = cellFormat;
				break;
			case "ArrowLeft":
				nextCellText = "";
				offsetCellIndex(-1);
				break;
			case "ArrowRight":
				nextCellText = "";
				offsetCellIndex(1);
				break;
			case "ArrowUp":
				nextCellText = "";
				nextFillText = offsetCellValue(1);
				break;
			case "ArrowDown":
				nextCellText = "";
				nextFillText = offsetCellValue(-1);
				break;
			default:
				if (!isNaN(Number(key))) {
					nextCellText = focusCellText + key;
					nextFillText = nextCellText;
				}
				break;
		}
		if (nextCellText !== null) {
			setFocusCellText(nextCellText);
			if (nextCellText.length >= maskCellLen) {
				offsetCellIndex(1);
				setFocusCellText("");
			}
		}
		if (nextFillText !== null) triggerInputChange((inputValue.slice(0, selectionStart) + leftPad(nextFillText, maskCellLen) + inputValue.slice(selectionEnd)).slice(0, format$1.length));
		forceSelectionSync({});
	};
	var rafRef = import_react.useRef();
	useLayoutEffect_default(function() {
		if (!focused || !format$1 || mouseDownRef.current) return;
		if (!maskFormat.match(inputValue)) {
			triggerInputChange(format$1);
			return;
		}
		inputRef.current.setSelectionRange(selectionStart, selectionEnd);
		rafRef.current = raf_default(function() {
			inputRef.current.setSelectionRange(selectionStart, selectionEnd);
		});
		return function() {
			raf_default.cancel(rafRef.current);
		};
	}, [
		maskFormat,
		format$1,
		focused,
		inputValue,
		focusCellIndex,
		selectionStart,
		selectionEnd,
		forceSelectionSyncMark,
		triggerInputChange
	]);
	var inputProps = format$1 ? {
		onFocus: onFormatFocus,
		onBlur: onFormatBlur,
		onKeyDown: onFormatKeyDown,
		onMouseDown: onFormatMouseDown,
		onMouseUp: onFormatMouseUp,
		onPaste: onFormatPaste
	} : {};
	return /* @__PURE__ */ import_react.createElement("div", {
		ref: holderRef,
		className: clsx(inputPrefixCls, _defineProperty$6(_defineProperty$6({}, "".concat(inputPrefixCls, "-active"), active && showActiveCls), "".concat(inputPrefixCls, "-placeholder"), helped), className)
	}, /* @__PURE__ */ import_react.createElement(Component$2, _extends$56({
		ref: inputRef,
		"aria-invalid": invalid,
		autoComplete: "off"
	}, restProps, {
		onKeyDown: onSharedKeyDown,
		onBlur: onSharedBlur
	}, inputProps, {
		value: inputValue,
		onChange: onInternalChange,
		className: classNames.input,
		style: styles.input
	})), /* @__PURE__ */ import_react.createElement(Icon$1, {
		type: "suffix",
		icon: suffixIcon
	}), clearIcon);
});
Input$3.displayName = "Input";
var Input_default$2 = Input$3;

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/Selector/RangeSelector.js
var _excluded$4 = [
	"id",
	"prefix",
	"clearIcon",
	"suffixIcon",
	"separator",
	"activeIndex",
	"activeHelp",
	"allHelp",
	"focused",
	"onFocus",
	"onBlur",
	"onKeyDown",
	"locale",
	"generateConfig",
	"placeholder",
	"className",
	"style",
	"onClick",
	"onClear",
	"value",
	"onChange",
	"onSubmit",
	"onInputChange",
	"format",
	"maskFormat",
	"preserveInvalidOnBlur",
	"onInvalid",
	"disabled",
	"invalid",
	"inputReadOnly",
	"direction",
	"onOpenChange",
	"onActiveInfo",
	"placement",
	"onMouseDown",
	"required",
	"aria-required",
	"autoFocus",
	"tabIndex"
], _excluded2 = ["index"];
function _extends$55() {
	_extends$55 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$55.apply(this, arguments);
}
function ownKeys$4(e$2, r$1) {
	var t$1 = Object.keys(e$2);
	if (Object.getOwnPropertySymbols) {
		var o$2 = Object.getOwnPropertySymbols(e$2);
		r$1 && (o$2 = o$2.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e$2, r$2).enumerable;
		})), t$1.push.apply(t$1, o$2);
	}
	return t$1;
}
function _objectSpread$4(e$2) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$4(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$5(e$2, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$2, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$4(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e$2, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e$2;
}
function _defineProperty$5(obj, key, value) {
	key = _toPropertyKey$4(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$4(t$1) {
	var i = _toPrimitive$4(t$1, "string");
	return "symbol" == _typeof$5(i) ? i : String(i);
}
function _toPrimitive$4(t$1, r$1) {
	if ("object" != _typeof$5(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$5(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _slicedToArray$4(arr, i) {
	return _arrayWithHoles$3(arr) || _iterableToArrayLimit$3(arr, i) || _unsupportedIterableToArray$4(arr, i) || _nonIterableRest$3();
}
function _nonIterableRest$3() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$4(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$3(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$3(o$2, minLen);
}
function _arrayLikeToArray$3(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$3(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$3(arr) {
	if (Array.isArray(arr)) return arr;
}
function _typeof$5(o$2) {
	"@babel/helpers - typeof";
	return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$5(o$2);
}
function _objectWithoutProperties$2(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$2(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$2(source, excluded) {
	if (source == null) return {};
	var target = {};
	var sourceKeys = Object.keys(source);
	var key, i;
	for (i = 0; i < sourceKeys.length; i++) {
		key = sourceKeys[i];
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function RangeSelector(props, ref) {
	var id = props.id, prefix$1 = props.prefix, clearIcon = props.clearIcon, suffixIcon = props.suffixIcon, _props$separator = props.separator, separator = _props$separator === void 0 ? "~" : _props$separator, activeIndex = props.activeIndex;
	props.activeHelp;
	props.allHelp;
	var focused = props.focused;
	props.onFocus;
	props.onBlur;
	props.onKeyDown;
	props.locale;
	props.generateConfig;
	var placeholder = props.placeholder, className = props.className, style$1 = props.style, onClick = props.onClick, onClear = props.onClear, value = props.value;
	props.onChange;
	props.onSubmit;
	props.onInputChange;
	props.format;
	props.maskFormat;
	props.preserveInvalidOnBlur;
	props.onInvalid;
	var disabled = props.disabled, invalid = props.invalid;
	props.inputReadOnly;
	var direction = props.direction;
	props.onOpenChange;
	var onActiveInfo = props.onActiveInfo;
	props.placement;
	var _onMouseDown = props.onMouseDown;
	props.required;
	props["aria-required"];
	var autoFocus = props.autoFocus, tabIndex = props.tabIndex, restProps = _objectWithoutProperties$2(props, _excluded$4);
	var rtl = direction === "rtl";
	var _React$useContext = import_react.useContext(context_default$5), prefixCls = _React$useContext.prefixCls, classNames = _React$useContext.classNames, styles = _React$useContext.styles;
	var ids = import_react.useMemo(function() {
		if (typeof id === "string") return [id];
		var mergedId = id || {};
		return [mergedId.start, mergedId.end];
	}, [id]);
	var rootRef = import_react.useRef();
	var inputStartRef = import_react.useRef();
	var inputEndRef = import_react.useRef();
	var getInput = function getInput$1(index$1) {
		var _index;
		return (_index = [inputStartRef, inputEndRef][index$1]) === null || _index === void 0 ? void 0 : _index.current;
	};
	import_react.useImperativeHandle(ref, function() {
		return {
			nativeElement: rootRef.current,
			focus: function focus(options) {
				if (_typeof$5(options) === "object") {
					var _getInput;
					var _ref = options || {}, _ref$index = _ref.index, _index2 = _ref$index === void 0 ? 0 : _ref$index, rest = _objectWithoutProperties$2(_ref, _excluded2);
					(_getInput = getInput(_index2)) === null || _getInput === void 0 || _getInput.focus(rest);
				} else {
					var _getInput2;
					(_getInput2 = getInput(options !== null && options !== void 0 ? options : 0)) === null || _getInput2 === void 0 || _getInput2.focus();
				}
			},
			blur: function blur() {
				var _getInput3, _getInput4;
				(_getInput3 = getInput(0)) === null || _getInput3 === void 0 || _getInput3.blur();
				(_getInput4 = getInput(1)) === null || _getInput4 === void 0 || _getInput4.blur();
			}
		};
	});
	var rootProps = useRootProps(restProps);
	var mergedPlaceholder = import_react.useMemo(function() {
		return Array.isArray(placeholder) ? placeholder : [placeholder, placeholder];
	}, [placeholder]);
	var getInputProps = _slicedToArray$4(useInputProps(_objectSpread$4(_objectSpread$4({}, props), {}, {
		id: ids,
		placeholder: mergedPlaceholder
	})), 1)[0];
	var _React$useState2 = _slicedToArray$4(import_react.useState({
		position: "absolute",
		width: 0
	}), 2), activeBarStyle = _React$useState2[0], setActiveBarStyle = _React$useState2[1];
	var syncActiveOffset = useEvent_default(function() {
		var input = getInput(activeIndex);
		if (input) {
			var inputRect = input.nativeElement.getBoundingClientRect();
			var parentRect = rootRef.current.getBoundingClientRect();
			var rectOffset = inputRect.left - parentRect.left;
			setActiveBarStyle(function(ori) {
				return _objectSpread$4(_objectSpread$4({}, ori), {}, {
					width: inputRect.width,
					left: rectOffset
				});
			});
			onActiveInfo([
				inputRect.left,
				inputRect.right,
				parentRect.width
			]);
		}
	});
	import_react.useEffect(function() {
		syncActiveOffset();
	}, [activeIndex]);
	var showClear = clearIcon && (value[0] && !disabled[0] || value[1] && !disabled[1]);
	var startAutoFocus = autoFocus && !disabled[0];
	var endAutoFocus = autoFocus && !startAutoFocus && !disabled[1];
	return /* @__PURE__ */ import_react.createElement(es_default$2, { onResize: syncActiveOffset }, /* @__PURE__ */ import_react.createElement("div", _extends$55({}, rootProps, {
		className: clsx(prefixCls, "".concat(prefixCls, "-range"), _defineProperty$5(_defineProperty$5(_defineProperty$5(_defineProperty$5({}, "".concat(prefixCls, "-focused"), focused), "".concat(prefixCls, "-disabled"), disabled.every(function(i) {
			return i;
		})), "".concat(prefixCls, "-invalid"), invalid.some(function(i) {
			return i;
		})), "".concat(prefixCls, "-rtl"), rtl), className),
		style: style$1,
		ref: rootRef,
		onClick,
		onMouseDown: function onMouseDown(e$2) {
			var target = e$2.target;
			if (target !== inputStartRef.current.inputElement && target !== inputEndRef.current.inputElement) e$2.preventDefault();
			_onMouseDown === null || _onMouseDown === void 0 || _onMouseDown(e$2);
		}
	}), prefix$1 && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx("".concat(prefixCls, "-prefix"), classNames.prefix),
		style: styles.prefix
	}, prefix$1), /* @__PURE__ */ import_react.createElement(Input_default$2, _extends$55({ ref: inputStartRef }, getInputProps(0), {
		className: "".concat(prefixCls, "-input-start"),
		autoFocus: startAutoFocus,
		tabIndex,
		"date-range": "start"
	})), /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-range-separator") }, separator), /* @__PURE__ */ import_react.createElement(Input_default$2, _extends$55({ ref: inputEndRef }, getInputProps(1), {
		className: "".concat(prefixCls, "-input-end"),
		autoFocus: endAutoFocus,
		tabIndex,
		"date-range": "end"
	})), /* @__PURE__ */ import_react.createElement("div", {
		className: "".concat(prefixCls, "-active-bar"),
		style: activeBarStyle
	}), /* @__PURE__ */ import_react.createElement(Icon$1, {
		type: "suffix",
		icon: suffixIcon
	}), showClear && /* @__PURE__ */ import_react.createElement(ClearIcon, {
		icon: clearIcon,
		onClear
	})));
}
var RefRangeSelector = /* @__PURE__ */ import_react.forwardRef(RangeSelector);
RefRangeSelector.displayName = "RangeSelector";
var RangeSelector_default = RefRangeSelector;

//#endregion
//#region node_modules/@rc-component/picker/es/hooks/useSemantic.js
function _typeof$4(o$2) {
	"@babel/helpers - typeof";
	return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$4(o$2);
}
function ownKeys$3(e$2, r$1) {
	var t$1 = Object.keys(e$2);
	if (Object.getOwnPropertySymbols) {
		var o$2 = Object.getOwnPropertySymbols(e$2);
		r$1 && (o$2 = o$2.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e$2, r$2).enumerable;
		})), t$1.push.apply(t$1, o$2);
	}
	return t$1;
}
function _objectSpread$3(e$2) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$3(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$4(e$2, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$2, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$3(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e$2, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e$2;
}
function _defineProperty$4(obj, key, value) {
	key = _toPropertyKey$3(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$3(t$1) {
	var i = _toPrimitive$3(t$1, "string");
	return "symbol" == _typeof$4(i) ? i : String(i);
}
function _toPrimitive$3(t$1, r$1) {
	if ("object" != _typeof$4(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$4(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
/**
* Convert `classNames` & `styles` to a fully filled object
*/
function useSemantic(classNames, styles) {
	return (0, import_react.useMemo)(function() {
		return [_objectSpread$3(_objectSpread$3({}, classNames), {}, { popup: (classNames === null || classNames === void 0 ? void 0 : classNames.popup) || {} }), _objectSpread$3(_objectSpread$3({}, styles), {}, { popup: (styles === null || styles === void 0 ? void 0 : styles.popup) || {} })];
	}, [classNames, styles]);
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/RangePicker.js
function _typeof$3(o$2) {
	"@babel/helpers - typeof";
	return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$3(o$2);
}
function _extends$54() {
	_extends$54 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$54.apply(this, arguments);
}
function _toConsumableArray$2(arr) {
	return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$3(arr) || _nonIterableSpread$1();
}
function _nonIterableSpread$1() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$1(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$1(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$2(arr);
}
function ownKeys$2(e$2, r$1) {
	var t$1 = Object.keys(e$2);
	if (Object.getOwnPropertySymbols) {
		var o$2 = Object.getOwnPropertySymbols(e$2);
		r$1 && (o$2 = o$2.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e$2, r$2).enumerable;
		})), t$1.push.apply(t$1, o$2);
	}
	return t$1;
}
function _objectSpread$2(e$2) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$2(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$3(e$2, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$2, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$2(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e$2, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e$2;
}
function _defineProperty$3(obj, key, value) {
	key = _toPropertyKey$2(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$2(t$1) {
	var i = _toPrimitive$2(t$1, "string");
	return "symbol" == _typeof$3(i) ? i : String(i);
}
function _toPrimitive$2(t$1, r$1) {
	if ("object" != _typeof$3(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$3(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _slicedToArray$3(arr, i) {
	return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i) || _unsupportedIterableToArray$3(arr, i) || _nonIterableRest$2();
}
function _nonIterableRest$2() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$3(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$2(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$2(o$2, minLen);
}
function _arrayLikeToArray$2(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$2(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$2(arr) {
	if (Array.isArray(arr)) return arr;
}
function separateConfig(config, defaultConfig$1) {
	var singleConfig = config !== null && config !== void 0 ? config : defaultConfig$1;
	if (Array.isArray(singleConfig)) return singleConfig;
	return [singleConfig, singleConfig];
}
/** Used for change event, it should always be not undefined */
function getActiveRange(activeIndex) {
	return activeIndex === 1 ? "end" : "start";
}
function RangePicker$1(props, ref) {
	var _useFilledProps2 = _slicedToArray$3(useFilledProps(props, function() {
		var disabled$1 = props.disabled, allowEmpty$1 = props.allowEmpty;
		return {
			disabled: separateConfig(disabled$1, false),
			allowEmpty: separateConfig(allowEmpty$1, false)
		};
	}), 6), filledProps = _useFilledProps2[0], internalPicker = _useFilledProps2[1], complexPicker = _useFilledProps2[2], formatList = _useFilledProps2[3], maskFormat = _useFilledProps2[4], isInvalidateDate = _useFilledProps2[5];
	var prefixCls = filledProps.prefixCls, rootClassName = filledProps.rootClassName, propStyles = filledProps.styles, propClassNames = filledProps.classNames, previewValue = filledProps.previewValue, defaultValue = filledProps.defaultValue, value = filledProps.value, needConfirm = filledProps.needConfirm, onKeyDown$1 = filledProps.onKeyDown, disabled = filledProps.disabled, allowEmpty = filledProps.allowEmpty, disabledDate = filledProps.disabledDate, minDate = filledProps.minDate, maxDate = filledProps.maxDate, defaultOpen = filledProps.defaultOpen, open$2 = filledProps.open, onOpenChange = filledProps.onOpenChange, locale$5 = filledProps.locale, generateConfig$1 = filledProps.generateConfig, picker = filledProps.picker, showNow = filledProps.showNow, showToday = filledProps.showToday, showTime = filledProps.showTime, mode = filledProps.mode, onPanelChange = filledProps.onPanelChange, onCalendarChange = filledProps.onCalendarChange, onOk = filledProps.onOk, defaultPickerValue = filledProps.defaultPickerValue, pickerValue = filledProps.pickerValue, onPickerValueChange = filledProps.onPickerValueChange, inputReadOnly = filledProps.inputReadOnly, suffixIcon = filledProps.suffixIcon, onFocus = filledProps.onFocus, onBlur = filledProps.onBlur, presets = filledProps.presets, ranges = filledProps.ranges, components$1 = filledProps.components, cellRender = filledProps.cellRender, dateRender = filledProps.dateRender, monthCellRender = filledProps.monthCellRender, onClick = filledProps.onClick;
	var selectorRef = usePickerRef(ref);
	var _useSemantic2 = _slicedToArray$3(useSemantic(propClassNames, propStyles), 2), mergedClassNames = _useSemantic2[0], mergedStyles = _useSemantic2[1];
	var _useOpen2 = _slicedToArray$3(useOpen(open$2, defaultOpen, disabled, onOpenChange), 2), mergedOpen = _useOpen2[0], setMergeOpen = _useOpen2[1];
	var triggerOpen = function triggerOpen$1(nextOpen, config) {
		if (disabled.some(function(fieldDisabled) {
			return !fieldDisabled;
		}) || !nextOpen) setMergeOpen(nextOpen, config);
	};
	var _useInnerValue2 = _slicedToArray$3(useInnerValue(generateConfig$1, locale$5, formatList, true, false, defaultValue, value, onCalendarChange, onOk), 5), mergedValue = _useInnerValue2[0], setInnerValue = _useInnerValue2[1], getCalendarValue = _useInnerValue2[2], triggerCalendarChange = _useInnerValue2[3], triggerOk = _useInnerValue2[4];
	var calendarValue = getCalendarValue();
	var _useRangeActive2 = _slicedToArray$3(useRangeActive(disabled, allowEmpty, mergedOpen), 9), focused = _useRangeActive2[0], triggerFocus$1 = _useRangeActive2[1], lastOperation = _useRangeActive2[2], activeIndex = _useRangeActive2[3], setActiveIndex = _useRangeActive2[4], nextActiveIndex = _useRangeActive2[5], activeIndexList = _useRangeActive2[6], updateSubmitIndex = _useRangeActive2[7], hasActiveSubmitValue = _useRangeActive2[8];
	var onSharedFocus = function onSharedFocus$1(event, index$1) {
		triggerFocus$1(true);
		onFocus === null || onFocus === void 0 || onFocus(event, { range: getActiveRange(index$1 !== null && index$1 !== void 0 ? index$1 : activeIndex) });
	};
	var onSharedBlur = function onSharedBlur$1(event, index$1) {
		triggerFocus$1(false);
		onBlur === null || onBlur === void 0 || onBlur(event, { range: getActiveRange(index$1 !== null && index$1 !== void 0 ? index$1 : activeIndex) });
	};
	/** Used for Popup panel */
	var mergedShowTime = import_react.useMemo(function() {
		if (!showTime) return null;
		var disabledTime = showTime.disabledTime;
		var proxyDisabledTime = disabledTime ? function(date$1) {
			return disabledTime(date$1, getActiveRange(activeIndex), { from: getFromDate(calendarValue, activeIndexList, activeIndex) });
		} : void 0;
		return _objectSpread$2(_objectSpread$2({}, showTime), {}, { disabledTime: proxyDisabledTime });
	}, [
		showTime,
		activeIndex,
		calendarValue,
		activeIndexList
	]);
	var _useControlledState2 = _slicedToArray$3(useControlledState([picker, picker], mode), 2), modes = _useControlledState2[0], setModes = _useControlledState2[1];
	var mergedMode = modes[activeIndex] || picker;
	/** Extends from `mergedMode` to patch `datetime` mode */
	var internalMode = mergedMode === "date" && mergedShowTime ? "datetime" : mergedMode;
	var multiplePanel = internalMode === picker && internalMode !== "time";
	var mergedShowNow = useShowNow(picker, mergedMode, showNow, showToday, true);
	var _useRangeValue2 = _slicedToArray$3(useRangeValue(filledProps, mergedValue, setInnerValue, getCalendarValue, triggerCalendarChange, disabled, formatList, focused, mergedOpen, isInvalidateDate), 2), flushSubmit = _useRangeValue2[0], triggerSubmitChange = _useRangeValue2[1];
	var mergedDisabledDate = useRangeDisabledDate(calendarValue, disabled, activeIndexList, generateConfig$1, locale$5, disabledDate);
	var _useFieldsInvalidate2 = _slicedToArray$3(useFieldsInvalidate(calendarValue, isInvalidateDate, allowEmpty), 2), submitInvalidates = _useFieldsInvalidate2[0], onSelectorInvalid = _useFieldsInvalidate2[1];
	var _useRangePickerValue2 = _slicedToArray$3(useRangePickerValue(generateConfig$1, locale$5, calendarValue, modes, mergedOpen, activeIndex, internalPicker, multiplePanel, defaultPickerValue, pickerValue, mergedShowTime === null || mergedShowTime === void 0 ? void 0 : mergedShowTime.defaultOpenValue, onPickerValueChange, minDate, maxDate), 2), currentPickerValue = _useRangePickerValue2[0], setCurrentPickerValue = _useRangePickerValue2[1];
	var triggerModeChange = useEvent_default(function(nextPickerValue, nextMode, triggerEvent) {
		var clone = fillIndex(modes, activeIndex, nextMode);
		if (clone[0] !== modes[0] || clone[1] !== modes[1]) setModes(clone);
		if (onPanelChange && triggerEvent !== false) {
			var clonePickerValue = _toConsumableArray$2(calendarValue);
			if (nextPickerValue) clonePickerValue[activeIndex] = nextPickerValue;
			onPanelChange(clonePickerValue, clone);
		}
	});
	var fillCalendarValue = function fillCalendarValue$1(date$1, index$1) {
		return fillIndex(calendarValue, index$1, date$1);
	};
	/**
	* Trigger by confirm operation.
	* This function has already handle the `needConfirm` check logic.
	* - Selector: enter key
	* - Panel: OK button
	*/
	var triggerPartConfirm = function triggerPartConfirm$1(date$1, skipFocus) {
		var nextValue = calendarValue;
		if (date$1) nextValue = fillCalendarValue(date$1, activeIndex);
		updateSubmitIndex(activeIndex);
		var nextIndex = nextActiveIndex(nextValue);
		triggerCalendarChange(nextValue);
		flushSubmit(activeIndex, nextIndex === null);
		if (nextIndex === null) triggerOpen(false, { force: true });
		else if (!skipFocus) selectorRef.current.focus({ index: nextIndex });
	};
	var onSelectorClick = function onSelectorClick$1(event) {
		var _activeElement;
		var rootNode = event.target.getRootNode();
		if (!selectorRef.current.nativeElement.contains((_activeElement = rootNode.activeElement) !== null && _activeElement !== void 0 ? _activeElement : document.activeElement)) {
			var enabledIndex = disabled.findIndex(function(d) {
				return !d;
			});
			if (enabledIndex >= 0) selectorRef.current.focus({ index: enabledIndex });
		}
		triggerOpen(true);
		onClick === null || onClick === void 0 || onClick(event);
	};
	var onSelectorClear = function onSelectorClear$1() {
		triggerSubmitChange(null);
		triggerOpen(false, { force: true });
	};
	var _React$useState2 = _slicedToArray$3(import_react.useState(null), 2), hoverSource = _React$useState2[0], setHoverSource = _React$useState2[1];
	var _React$useState4 = _slicedToArray$3(import_react.useState(null), 2), internalHoverValues = _React$useState4[0], setInternalHoverValues = _React$useState4[1];
	var hoverValues = import_react.useMemo(function() {
		return internalHoverValues || calendarValue;
	}, [calendarValue, internalHoverValues]);
	import_react.useEffect(function() {
		if (!mergedOpen) setInternalHoverValues(null);
	}, [mergedOpen]);
	var _React$useState6 = _slicedToArray$3(import_react.useState([
		0,
		0,
		0
	]), 2), activeInfo = _React$useState6[0], setActiveInfo = _React$useState6[1];
	var onSetHover = function onSetHover$1(date$1, source) {
		if (previewValue !== "hover") return;
		setInternalHoverValues(date$1);
		setHoverSource(source);
	};
	var presetList = usePresets(presets, ranges);
	var onPresetHover = function onPresetHover$1(nextValues) {
		onSetHover(nextValues, "preset");
	};
	var onPresetSubmit = function onPresetSubmit$1(nextValues) {
		if (triggerSubmitChange(nextValues)) triggerOpen(false, { force: true });
	};
	var onNow = function onNow$1(now$1) {
		triggerPartConfirm(now$1);
	};
	var onPanelHover = function onPanelHover$1(date$1) {
		onSetHover(date$1 ? fillCalendarValue(date$1, activeIndex) : null, "cell");
	};
	var onPanelFocus = function onPanelFocus$1(event) {
		triggerOpen(true);
		onSharedFocus(event);
	};
	var onPanelMouseDown = function onPanelMouseDown$1() {
		lastOperation("panel");
	};
	var onPanelSelect = function onPanelSelect$1(date$1) {
		triggerCalendarChange(fillIndex(calendarValue, activeIndex, date$1));
		if (!needConfirm && !complexPicker && internalPicker === internalMode) triggerPartConfirm(date$1);
	};
	var onPopupClose = function onPopupClose$1() {
		triggerOpen(false);
	};
	var onInternalCellRender = useCellRender$1(cellRender, dateRender, monthCellRender, getActiveRange(activeIndex));
	var panelValue = calendarValue[activeIndex] || null;
	var isPopupInvalidateDate = useEvent_default(function(date$1) {
		return isInvalidateDate(date$1, { activeIndex });
	});
	var panelProps = import_react.useMemo(function() {
		var domProps = pickAttrs(filledProps, false);
		return omit(filledProps, [].concat(_toConsumableArray$2(Object.keys(domProps)), [
			"onChange",
			"onCalendarChange",
			"style",
			"className",
			"onPanelChange",
			"disabledTime",
			"classNames",
			"styles"
		]));
	}, [filledProps]);
	var panel = /* @__PURE__ */ import_react.createElement(Popup, _extends$54({}, panelProps, {
		showNow: mergedShowNow,
		showTime: mergedShowTime,
		range: true,
		multiplePanel,
		activeInfo,
		disabledDate: mergedDisabledDate,
		onFocus: onPanelFocus,
		onBlur: onSharedBlur,
		onPanelMouseDown,
		picker,
		mode: mergedMode,
		internalMode,
		onPanelChange: triggerModeChange,
		format: maskFormat,
		value: panelValue,
		isInvalid: isPopupInvalidateDate,
		onChange: null,
		onSelect: onPanelSelect,
		pickerValue: currentPickerValue,
		defaultOpenValue: toArray$5(showTime === null || showTime === void 0 ? void 0 : showTime.defaultOpenValue)[activeIndex],
		onPickerValueChange: setCurrentPickerValue,
		hoverValue: hoverValues,
		onHover: onPanelHover,
		needConfirm,
		onSubmit: triggerPartConfirm,
		onOk: triggerOk,
		presets: presetList,
		onPresetHover,
		onPresetSubmit,
		onNow,
		cellRender: onInternalCellRender,
		classNames: mergedClassNames,
		styles: mergedStyles
	}));
	var onSelectorChange = function onSelectorChange$1(date$1, index$1) {
		triggerCalendarChange(fillCalendarValue(date$1, index$1));
	};
	var onSelectorInputChange = function onSelectorInputChange$1() {
		lastOperation("input");
	};
	var onSelectorFocus = function onSelectorFocus$1(event, index$1) {
		var activeListLen = activeIndexList.length;
		var lastActiveIndex = activeIndexList[activeListLen - 1];
		if (activeListLen && lastActiveIndex !== index$1 && needConfirm && !allowEmpty[lastActiveIndex] && !hasActiveSubmitValue(lastActiveIndex) && calendarValue[lastActiveIndex]) {
			selectorRef.current.focus({ index: lastActiveIndex });
			return;
		}
		lastOperation("input");
		triggerOpen(true, { inherit: true });
		if (activeIndex !== index$1 && mergedOpen && !needConfirm && complexPicker) triggerPartConfirm(null, true);
		setActiveIndex(index$1);
		onSharedFocus(event, index$1);
	};
	var onSelectorBlur = function onSelectorBlur$1(event, index$1) {
		triggerOpen(false);
		if (!needConfirm && lastOperation() === "input") flushSubmit(activeIndex, nextActiveIndex(calendarValue) === null);
		onSharedBlur(event, index$1);
	};
	var onSelectorKeyDown = function onSelectorKeyDown$1(event, preventDefault) {
		if (event.key === "Tab") triggerPartConfirm(null, true);
		onKeyDown$1 === null || onKeyDown$1 === void 0 || onKeyDown$1(event, preventDefault);
	};
	var context = import_react.useMemo(function() {
		return {
			prefixCls,
			locale: locale$5,
			generateConfig: generateConfig$1,
			button: components$1.button,
			input: components$1.input,
			classNames: mergedClassNames,
			styles: mergedStyles
		};
	}, [
		prefixCls,
		locale$5,
		generateConfig$1,
		components$1.button,
		components$1.input,
		mergedClassNames,
		mergedStyles
	]);
	useLayoutEffect_default(function() {
		if (mergedOpen && activeIndex !== void 0) triggerModeChange(null, picker, false);
	}, [
		mergedOpen,
		activeIndex,
		picker
	]);
	useLayoutEffect_default(function() {
		var lastOp = lastOperation();
		if (!mergedOpen && lastOp === "input") {
			triggerOpen(false);
			triggerPartConfirm(null, true);
		}
		if (!mergedOpen && complexPicker && !needConfirm && lastOp === "panel") {
			triggerOpen(true);
			triggerPartConfirm();
		}
	}, [mergedOpen]);
	var isIndexEmpty = function isIndexEmpty$1(index$1) {
		return !(value !== null && value !== void 0 && value[index$1]) && !(defaultValue !== null && defaultValue !== void 0 && defaultValue[index$1]);
	};
	if (disabled.some(function(fieldDisabled, index$1) {
		return fieldDisabled && isIndexEmpty(index$1) && !allowEmpty[index$1];
	})) warning_default$1(false, "`disabled` should not set with empty `value`. You should set `allowEmpty` or `value` instead.");
	return /* @__PURE__ */ import_react.createElement(context_default$5.Provider, { value: context }, /* @__PURE__ */ import_react.createElement(PickerTrigger_default, _extends$54({}, pickTriggerProps(filledProps), {
		popupElement: panel,
		popupStyle: mergedStyles.popup.root,
		popupClassName: clsx(rootClassName, mergedClassNames.popup.root),
		visible: mergedOpen,
		onClose: onPopupClose,
		range: true
	}), /* @__PURE__ */ import_react.createElement(RangeSelector_default, _extends$54({}, filledProps, {
		ref: selectorRef,
		className: clsx(filledProps.className, rootClassName, mergedClassNames.root),
		style: _objectSpread$2(_objectSpread$2({}, mergedStyles.root), filledProps.style),
		suffixIcon,
		activeIndex: focused || mergedOpen ? activeIndex : null,
		activeHelp: !!internalHoverValues,
		allHelp: !!internalHoverValues && hoverSource === "preset",
		focused,
		onFocus: onSelectorFocus,
		onBlur: onSelectorBlur,
		onKeyDown: onSelectorKeyDown,
		onSubmit: triggerPartConfirm,
		value: hoverValues,
		maskFormat,
		onChange: onSelectorChange,
		onInputChange: onSelectorInputChange,
		format: formatList,
		inputReadOnly,
		disabled,
		open: mergedOpen,
		onOpenChange: triggerOpen,
		onClick: onSelectorClick,
		onClear: onSelectorClear,
		invalid: submitInvalidates,
		onInvalid: onSelectorInvalid,
		onActiveInfo: setActiveInfo
	}))));
}
var RefRangePicker = /* @__PURE__ */ import_react.forwardRef(RangePicker$1);
RefRangePicker.displayName = "RefRangePicker";
var RangePicker_default = RefRangePicker;

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/Selector/SingleSelector/MultipleDates.js
function MultipleDates(props) {
	var prefixCls = props.prefixCls, value = props.value, onRemove = props.onRemove, _props$removeIcon = props.removeIcon, removeIcon = _props$removeIcon === void 0 ? "" : _props$removeIcon, formatDate = props.formatDate, disabled = props.disabled, maxTagCount = props.maxTagCount, placeholder = props.placeholder;
	var selectorCls = "".concat(prefixCls, "-selector");
	var selectionCls = "".concat(prefixCls, "-selection");
	var overflowCls = "".concat(selectionCls, "-overflow");
	function renderSelector(content, onClose) {
		return /* @__PURE__ */ import_react.createElement("span", {
			className: clsx("".concat(selectionCls, "-item")),
			title: typeof content === "string" ? content : null
		}, /* @__PURE__ */ import_react.createElement("span", { className: "".concat(selectionCls, "-item-content") }, content), !disabled && onClose && /* @__PURE__ */ import_react.createElement("span", {
			onMouseDown: function onMouseDown(e$2) {
				e$2.preventDefault();
			},
			onClick: onClose,
			className: "".concat(selectionCls, "-item-remove")
		}, removeIcon));
	}
	function renderItem$1(date$1) {
		return renderSelector(formatDate(date$1), function onClose(event) {
			if (event) event.stopPropagation();
			onRemove(date$1);
		});
	}
	function renderRest(omittedValues) {
		return renderSelector("+ ".concat(omittedValues.length, " ..."));
	}
	return /* @__PURE__ */ import_react.createElement("div", { className: selectorCls }, /* @__PURE__ */ import_react.createElement(es_default$30, {
		prefixCls: overflowCls,
		data: value,
		renderItem: renderItem$1,
		renderRest,
		itemKey: function itemKey$2(date$1) {
			return formatDate(date$1);
		},
		maxCount: maxTagCount
	}), !value.length && /* @__PURE__ */ import_react.createElement("span", { className: "".concat(prefixCls, "-selection-placeholder") }, placeholder));
}

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/Selector/SingleSelector/index.js
function _typeof$2(o$2) {
	"@babel/helpers - typeof";
	return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$2(o$2);
}
var _excluded$3 = [
	"id",
	"open",
	"prefix",
	"clearIcon",
	"suffixIcon",
	"activeHelp",
	"allHelp",
	"focused",
	"onFocus",
	"onBlur",
	"onKeyDown",
	"locale",
	"generateConfig",
	"placeholder",
	"className",
	"style",
	"onClick",
	"onClear",
	"internalPicker",
	"value",
	"onChange",
	"onSubmit",
	"onInputChange",
	"multiple",
	"maxTagCount",
	"format",
	"maskFormat",
	"preserveInvalidOnBlur",
	"onInvalid",
	"disabled",
	"invalid",
	"inputReadOnly",
	"direction",
	"onOpenChange",
	"onMouseDown",
	"required",
	"aria-required",
	"autoFocus",
	"tabIndex",
	"removeIcon"
];
function _extends$53() {
	_extends$53 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$53.apply(this, arguments);
}
function ownKeys$1(e$2, r$1) {
	var t$1 = Object.keys(e$2);
	if (Object.getOwnPropertySymbols) {
		var o$2 = Object.getOwnPropertySymbols(e$2);
		r$1 && (o$2 = o$2.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e$2, r$2).enumerable;
		})), t$1.push.apply(t$1, o$2);
	}
	return t$1;
}
function _objectSpread$1(e$2) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$1(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$2(e$2, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$2, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$1(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e$2, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e$2;
}
function _defineProperty$2(obj, key, value) {
	key = _toPropertyKey$1(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$1(t$1) {
	var i = _toPrimitive$1(t$1, "string");
	return "symbol" == _typeof$2(i) ? i : String(i);
}
function _toPrimitive$1(t$1, r$1) {
	if ("object" != _typeof$2(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$2(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _slicedToArray$2(arr, i) {
	return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$2(arr, i) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$2(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray$1(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$1(o$2, minLen);
}
function _arrayLikeToArray$1(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$1(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles$1(arr) {
	if (Array.isArray(arr)) return arr;
}
function _objectWithoutProperties$1(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$1(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
	if (source == null) return {};
	var target = {};
	var sourceKeys = Object.keys(source);
	var key, i;
	for (i = 0; i < sourceKeys.length; i++) {
		key = sourceKeys[i];
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function SingleSelector(props, ref) {
	props.id;
	var open$2 = props.open, prefix$1 = props.prefix, clearIcon = props.clearIcon, suffixIcon = props.suffixIcon;
	props.activeHelp;
	props.allHelp;
	var focused = props.focused;
	props.onFocus;
	props.onBlur;
	props.onKeyDown;
	var locale$5 = props.locale, generateConfig$1 = props.generateConfig, placeholder = props.placeholder, className = props.className, style$1 = props.style, onClick = props.onClick, onClear = props.onClear, internalPicker = props.internalPicker, value = props.value, onChange = props.onChange, onSubmit = props.onSubmit;
	props.onInputChange;
	var multiple = props.multiple, maxTagCount = props.maxTagCount;
	props.format;
	props.maskFormat;
	props.preserveInvalidOnBlur;
	props.onInvalid;
	var disabled = props.disabled, invalid = props.invalid;
	props.inputReadOnly;
	var direction = props.direction;
	props.onOpenChange;
	var _onMouseDown = props.onMouseDown;
	props.required;
	props["aria-required"];
	var autoFocus = props.autoFocus, tabIndex = props.tabIndex, removeIcon = props.removeIcon, restProps = _objectWithoutProperties$1(props, _excluded$3);
	var rtl = direction === "rtl";
	var _React$useContext = import_react.useContext(context_default$5), prefixCls = _React$useContext.prefixCls, classNames = _React$useContext.classNames, styles = _React$useContext.styles;
	var rootRef = import_react.useRef();
	var inputRef = import_react.useRef();
	import_react.useImperativeHandle(ref, function() {
		return {
			nativeElement: rootRef.current,
			focus: function focus(options) {
				var _inputRef$current;
				(_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.focus(options);
			},
			blur: function blur() {
				var _inputRef$current2;
				(_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.blur();
			}
		};
	});
	var rootProps = useRootProps(restProps);
	var onSingleChange = function onSingleChange$1(date$1) {
		onChange([date$1]);
	};
	var onMultipleRemove = function onMultipleRemove$1(date$1) {
		onChange(value.filter(function(oriDate) {
			return oriDate && !isSame(generateConfig$1, locale$5, oriDate, date$1, internalPicker);
		}));
		if (!open$2) onSubmit();
	};
	var _useInputProps2 = _slicedToArray$2(useInputProps(_objectSpread$1(_objectSpread$1({}, props), {}, { onChange: onSingleChange }), function(_ref) {
		return {
			value: _ref.valueTexts[0] || "",
			active: focused
		};
	}), 2), getInputProps = _useInputProps2[0], getText = _useInputProps2[1];
	var showClear = !!(clearIcon && value.length && !disabled);
	var selectorNode = multiple ? /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(MultipleDates, {
		prefixCls,
		value,
		onRemove: onMultipleRemove,
		formatDate: getText,
		maxTagCount,
		disabled,
		removeIcon,
		placeholder
	}), /* @__PURE__ */ import_react.createElement("input", {
		className: "".concat(prefixCls, "-multiple-input"),
		value: value.map(getText).join(","),
		ref: inputRef,
		readOnly: true,
		autoFocus,
		tabIndex
	}), /* @__PURE__ */ import_react.createElement(Icon$1, {
		type: "suffix",
		icon: suffixIcon
	}), showClear && /* @__PURE__ */ import_react.createElement(ClearIcon, {
		icon: clearIcon,
		onClear
	})) : /* @__PURE__ */ import_react.createElement(Input_default$2, _extends$53({ ref: inputRef }, getInputProps(), {
		autoFocus,
		tabIndex,
		suffixIcon,
		clearIcon: showClear && /* @__PURE__ */ import_react.createElement(ClearIcon, {
			icon: clearIcon,
			onClear
		}),
		showActiveCls: false
	}));
	return /* @__PURE__ */ import_react.createElement("div", _extends$53({}, rootProps, {
		className: clsx(prefixCls, _defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2({}, "".concat(prefixCls, "-multiple"), multiple), "".concat(prefixCls, "-focused"), focused), "".concat(prefixCls, "-disabled"), disabled), "".concat(prefixCls, "-invalid"), invalid), "".concat(prefixCls, "-rtl"), rtl), className),
		style: style$1,
		ref: rootRef,
		onClick,
		onMouseDown: function onMouseDown(e$2) {
			var _inputRef$current3;
			if (e$2.target !== ((_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 ? void 0 : _inputRef$current3.inputElement)) e$2.preventDefault();
			_onMouseDown === null || _onMouseDown === void 0 || _onMouseDown(e$2);
		}
	}), prefix$1 && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx("".concat(prefixCls, "-prefix"), classNames.prefix),
		style: styles.prefix
	}, prefix$1), selectorNode);
}
var RefSingleSelector = /* @__PURE__ */ import_react.forwardRef(SingleSelector);
RefSingleSelector.displayName = "SingleSelector";
var SingleSelector_default = RefSingleSelector;

//#endregion
//#region node_modules/@rc-component/picker/es/PickerInput/SinglePicker.js
function _typeof$1(o$2) {
	"@babel/helpers - typeof";
	return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof$1(o$2);
}
function _extends$52() {
	_extends$52 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$52.apply(this, arguments);
}
function _toConsumableArray$1(arr) {
	return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function ownKeys(e$2, r$1) {
	var t$1 = Object.keys(e$2);
	if (Object.getOwnPropertySymbols) {
		var o$2 = Object.getOwnPropertySymbols(e$2);
		r$1 && (o$2 = o$2.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e$2, r$2).enumerable;
		})), t$1.push.apply(t$1, o$2);
	}
	return t$1;
}
function _objectSpread(e$2) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$1(e$2, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$2, Object.getOwnPropertyDescriptors(t$1)) : ownKeys(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e$2, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e$2;
}
function _defineProperty$1(obj, key, value) {
	key = _toPropertyKey(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey(t$1) {
	var i = _toPrimitive(t$1, "string");
	return "symbol" == _typeof$1(i) ? i : String(i);
}
function _toPrimitive(t$1, r$1) {
	if ("object" != _typeof$1(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof$1(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _slicedToArray$1(arr, i) {
	return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(o$2, minLen) {
	if (!o$2) return;
	if (typeof o$2 === "string") return _arrayLikeToArray(o$2, minLen);
	var n$1 = Object.prototype.toString.call(o$2).slice(8, -1);
	if (n$1 === "Object" && o$2.constructor) n$1 = o$2.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$2);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray(o$2, minLen);
}
function _arrayLikeToArray(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}
function _arrayWithHoles(arr) {
	if (Array.isArray(arr)) return arr;
}
/** Internal usage. For cross function get same aligned props */
function Picker(props, ref) {
	var _useFilledProps2 = _slicedToArray$1(useFilledProps(props), 6), filledProps = _useFilledProps2[0], internalPicker = _useFilledProps2[1], complexPicker = _useFilledProps2[2], formatList = _useFilledProps2[3], maskFormat = _useFilledProps2[4], isInvalidateDate = _useFilledProps2[5];
	var _ref = filledProps, prefixCls = _ref.prefixCls, rootClassName = _ref.rootClassName, propStyles = _ref.styles, propClassNames = _ref.classNames, previewValue = _ref.previewValue, order = _ref.order, defaultValue = _ref.defaultValue, value = _ref.value, needConfirm = _ref.needConfirm, onChange = _ref.onChange, onKeyDown$1 = _ref.onKeyDown, disabled = _ref.disabled, disabledDate = _ref.disabledDate, minDate = _ref.minDate, maxDate = _ref.maxDate, defaultOpen = _ref.defaultOpen, open$2 = _ref.open, onOpenChange = _ref.onOpenChange, locale$5 = _ref.locale, generateConfig$1 = _ref.generateConfig, picker = _ref.picker, showNow = _ref.showNow, showToday = _ref.showToday, showTime = _ref.showTime, mode = _ref.mode, onPanelChange = _ref.onPanelChange, onCalendarChange = _ref.onCalendarChange, onOk = _ref.onOk, multiple = _ref.multiple, defaultPickerValue = _ref.defaultPickerValue, pickerValue = _ref.pickerValue, onPickerValueChange = _ref.onPickerValueChange, inputReadOnly = _ref.inputReadOnly, suffixIcon = _ref.suffixIcon, removeIcon = _ref.removeIcon, onFocus = _ref.onFocus, onBlur = _ref.onBlur, presets = _ref.presets, components$1 = _ref.components, cellRender = _ref.cellRender, dateRender = _ref.dateRender, monthCellRender = _ref.monthCellRender, onClick = _ref.onClick;
	var selectorRef = usePickerRef(ref);
	function pickerParam(values) {
		if (values === null) return null;
		return multiple ? values : values[0];
	}
	var toggleDates = useToggleDates(generateConfig$1, locale$5, internalPicker);
	var _useSemantic2 = _slicedToArray$1(useSemantic(propClassNames, propStyles), 2), mergedClassNames = _useSemantic2[0], mergedStyles = _useSemantic2[1];
	var _useOpen2 = _slicedToArray$1(useOpen(open$2, defaultOpen, [disabled], onOpenChange), 2), mergedOpen = _useOpen2[0], triggerOpen = _useOpen2[1];
	var _useInnerValue2 = _slicedToArray$1(useInnerValue(generateConfig$1, locale$5, formatList, false, order, defaultValue, value, function onInternalCalendarChange(dates, dateStrings, info) {
		if (onCalendarChange) {
			var filteredInfo = _objectSpread({}, info);
			delete filteredInfo.range;
			onCalendarChange(pickerParam(dates), pickerParam(dateStrings), filteredInfo);
		}
	}, function onInternalOk(dates) {
		onOk === null || onOk === void 0 || onOk(pickerParam(dates));
	}), 5), mergedValue = _useInnerValue2[0], setInnerValue = _useInnerValue2[1], getCalendarValue = _useInnerValue2[2], triggerCalendarChange = _useInnerValue2[3], triggerOk = _useInnerValue2[4];
	var calendarValue = getCalendarValue();
	var _useRangeActive2 = _slicedToArray$1(useRangeActive([disabled]), 4), focused = _useRangeActive2[0], triggerFocus$1 = _useRangeActive2[1], lastOperation = _useRangeActive2[2], activeIndex = _useRangeActive2[3];
	var onSharedFocus = function onSharedFocus$1(event) {
		triggerFocus$1(true);
		onFocus === null || onFocus === void 0 || onFocus(event, {});
	};
	var onSharedBlur = function onSharedBlur$1(event) {
		triggerFocus$1(false);
		onBlur === null || onBlur === void 0 || onBlur(event, {});
	};
	var _useControlledState2 = _slicedToArray$1(useControlledState(picker, mode), 2), mergedMode = _useControlledState2[0], setMode = _useControlledState2[1];
	/** Extends from `mergedMode` to patch `datetime` mode */
	var internalMode = mergedMode === "date" && showTime ? "datetime" : mergedMode;
	var mergedShowNow = useShowNow(picker, mergedMode, showNow, showToday);
	var onInternalChange = onChange && function(dates, dateStrings) {
		onChange(pickerParam(dates), pickerParam(dateStrings));
	};
	var triggerSubmitChange = _slicedToArray$1(useRangeValue(_objectSpread(_objectSpread({}, filledProps), {}, { onChange: onInternalChange }), mergedValue, setInnerValue, getCalendarValue, triggerCalendarChange, [], formatList, focused, mergedOpen, isInvalidateDate), 2)[1];
	var _useFieldsInvalidate2 = _slicedToArray$1(useFieldsInvalidate(calendarValue, isInvalidateDate), 2), submitInvalidates = _useFieldsInvalidate2[0], onSelectorInvalid = _useFieldsInvalidate2[1];
	var submitInvalidate = import_react.useMemo(function() {
		return submitInvalidates.some(function(invalidated) {
			return invalidated;
		});
	}, [submitInvalidates]);
	var _useRangePickerValue2 = _slicedToArray$1(useRangePickerValue(generateConfig$1, locale$5, calendarValue, [mergedMode], mergedOpen, activeIndex, internalPicker, false, defaultPickerValue, pickerValue, toArray$5(showTime === null || showTime === void 0 ? void 0 : showTime.defaultOpenValue), function onInternalPickerValueChange(dates, info) {
		if (onPickerValueChange) {
			var cleanInfo = _objectSpread(_objectSpread({}, info), {}, { mode: info.mode[0] });
			delete cleanInfo.range;
			onPickerValueChange(dates[0], cleanInfo);
		}
	}, minDate, maxDate), 2), currentPickerValue = _useRangePickerValue2[0], setCurrentPickerValue = _useRangePickerValue2[1];
	var triggerModeChange = useEvent_default(function(nextPickerValue, nextMode, triggerEvent) {
		setMode(nextMode);
		if (onPanelChange && triggerEvent !== false) onPanelChange(nextPickerValue || calendarValue[calendarValue.length - 1], nextMode);
	});
	/**
	* Different with RangePicker, confirm should check `multiple` logic.
	* This will never provide `date` instead.
	*/
	var triggerConfirm = function triggerConfirm$1() {
		triggerSubmitChange(getCalendarValue());
		triggerOpen(false, { force: true });
	};
	var onSelectorClick = function onSelectorClick$1(event) {
		if (!disabled && !selectorRef.current.nativeElement.contains(document.activeElement)) selectorRef.current.focus();
		triggerOpen(true);
		onClick === null || onClick === void 0 || onClick(event);
	};
	var onSelectorClear = function onSelectorClear$1() {
		triggerSubmitChange(null);
		triggerOpen(false, { force: true });
	};
	var _React$useState2 = _slicedToArray$1(import_react.useState(null), 2), hoverSource = _React$useState2[0], setHoverSource = _React$useState2[1];
	var _React$useState4 = _slicedToArray$1(import_react.useState(null), 2), internalHoverValue = _React$useState4[0], setInternalHoverValue = _React$useState4[1];
	var hoverValues = import_react.useMemo(function() {
		var values = [internalHoverValue].concat(_toConsumableArray$1(calendarValue)).filter(function(date$1) {
			return date$1;
		});
		return multiple ? values : values.slice(0, 1);
	}, [
		calendarValue,
		internalHoverValue,
		multiple
	]);
	var selectorValues = import_react.useMemo(function() {
		if (!multiple && internalHoverValue) return [internalHoverValue];
		return calendarValue.filter(function(date$1) {
			return date$1;
		});
	}, [
		calendarValue,
		internalHoverValue,
		multiple
	]);
	import_react.useEffect(function() {
		if (!mergedOpen) setInternalHoverValue(null);
	}, [mergedOpen]);
	var onSetHover = function onSetHover$1(date$1, source) {
		if (previewValue !== "hover") return;
		setInternalHoverValue(date$1);
		setHoverSource(source);
	};
	var presetList = usePresets(presets);
	var onPresetHover = function onPresetHover$1(nextValue) {
		onSetHover(nextValue, "preset");
	};
	var onPresetSubmit = function onPresetSubmit$1(nextValue) {
		if (triggerSubmitChange(multiple ? toggleDates(getCalendarValue(), nextValue) : [nextValue]) && !multiple) triggerOpen(false, { force: true });
	};
	var onNow = function onNow$1(now$1) {
		onPresetSubmit(now$1);
	};
	var onPanelHover = function onPanelHover$1(date$1) {
		onSetHover(date$1, "cell");
	};
	var onPanelFocus = function onPanelFocus$1(event) {
		triggerOpen(true);
		onSharedFocus(event);
	};
	var onPanelSelect = function onPanelSelect$1(date$1) {
		lastOperation("panel");
		if (multiple && internalMode !== picker) return;
		triggerCalendarChange(multiple ? toggleDates(getCalendarValue(), date$1) : [date$1]);
		if (!needConfirm && !complexPicker && internalPicker === internalMode) triggerConfirm();
	};
	var onPopupClose = function onPopupClose$1() {
		triggerOpen(false);
	};
	var onInternalCellRender = useCellRender$1(cellRender, dateRender, monthCellRender);
	var panelProps = import_react.useMemo(function() {
		var domProps = pickAttrs(filledProps, false);
		return _objectSpread(_objectSpread({}, omit(filledProps, [].concat(_toConsumableArray$1(Object.keys(domProps)), [
			"onChange",
			"onCalendarChange",
			"style",
			"className",
			"onPanelChange",
			"classNames",
			"styles"
		]))), {}, { multiple: filledProps.multiple });
	}, [filledProps]);
	var panel = /* @__PURE__ */ import_react.createElement(Popup, _extends$52({}, panelProps, {
		showNow: mergedShowNow,
		showTime,
		disabledDate,
		onFocus: onPanelFocus,
		onBlur: onSharedBlur,
		picker,
		mode: mergedMode,
		internalMode,
		onPanelChange: triggerModeChange,
		format: maskFormat,
		value: calendarValue,
		isInvalid: isInvalidateDate,
		onChange: null,
		onSelect: onPanelSelect,
		pickerValue: currentPickerValue,
		defaultOpenValue: showTime === null || showTime === void 0 ? void 0 : showTime.defaultOpenValue,
		onPickerValueChange: setCurrentPickerValue,
		hoverValue: hoverValues,
		onHover: onPanelHover,
		needConfirm,
		onSubmit: triggerConfirm,
		onOk: triggerOk,
		presets: presetList,
		onPresetHover,
		onPresetSubmit,
		onNow,
		cellRender: onInternalCellRender,
		classNames: mergedClassNames,
		styles: mergedStyles
	}));
	var onSelectorChange = function onSelectorChange$1(date$1) {
		triggerCalendarChange(date$1);
	};
	var onSelectorInputChange = function onSelectorInputChange$1() {
		lastOperation("input");
	};
	var onSelectorFocus = function onSelectorFocus$1(event) {
		lastOperation("input");
		triggerOpen(true, { inherit: true });
		onSharedFocus(event);
	};
	var onSelectorBlur = function onSelectorBlur$1(event) {
		triggerOpen(false);
		onSharedBlur(event);
	};
	var onSelectorKeyDown = function onSelectorKeyDown$1(event, preventDefault) {
		if (event.key === "Tab") triggerConfirm();
		onKeyDown$1 === null || onKeyDown$1 === void 0 || onKeyDown$1(event, preventDefault);
	};
	var context = import_react.useMemo(function() {
		return {
			prefixCls,
			locale: locale$5,
			generateConfig: generateConfig$1,
			button: components$1.button,
			input: components$1.input,
			classNames: mergedClassNames,
			styles: mergedStyles
		};
	}, [
		prefixCls,
		locale$5,
		generateConfig$1,
		components$1.button,
		components$1.input,
		mergedClassNames,
		mergedStyles
	]);
	useLayoutEffect_default(function() {
		if (mergedOpen && activeIndex !== void 0) triggerModeChange(null, picker, false);
	}, [
		mergedOpen,
		activeIndex,
		picker
	]);
	useLayoutEffect_default(function() {
		var lastOp = lastOperation();
		if (!mergedOpen && lastOp === "input") {
			triggerOpen(false);
			triggerConfirm();
		}
		if (!mergedOpen && complexPicker && !needConfirm && lastOp === "panel") triggerConfirm();
	}, [mergedOpen]);
	return /* @__PURE__ */ import_react.createElement(context_default$5.Provider, { value: context }, /* @__PURE__ */ import_react.createElement(PickerTrigger_default, _extends$52({}, pickTriggerProps(filledProps), {
		popupElement: panel,
		popupStyle: mergedStyles.popup.root,
		popupClassName: clsx(rootClassName, mergedClassNames.popup.root),
		visible: mergedOpen,
		onClose: onPopupClose
	}), /* @__PURE__ */ import_react.createElement(SingleSelector_default, _extends$52({}, filledProps, {
		ref: selectorRef,
		className: clsx(filledProps.className, rootClassName, mergedClassNames.root),
		style: _objectSpread(_objectSpread({}, mergedStyles.root), filledProps.style),
		suffixIcon,
		removeIcon,
		activeHelp: !!internalHoverValue,
		allHelp: !!internalHoverValue && hoverSource === "preset",
		focused,
		onFocus: onSelectorFocus,
		onBlur: onSelectorBlur,
		onKeyDown: onSelectorKeyDown,
		onSubmit: triggerConfirm,
		value: selectorValues,
		maskFormat,
		onChange: onSelectorChange,
		onInputChange: onSelectorInputChange,
		internalPicker,
		format: formatList,
		inputReadOnly,
		disabled,
		open: mergedOpen,
		onOpenChange: triggerOpen,
		onClick: onSelectorClick,
		onClear: onSelectorClear,
		invalid: submitInvalidate,
		onInvalid: function onInvalid(invalid) {
			onSelectorInvalid(invalid, 0);
		}
	}))));
}
var RefPicker = /* @__PURE__ */ import_react.forwardRef(Picker);
RefPicker.displayName = "RefPicker";
var SinglePicker_default = RefPicker;

//#endregion
//#region node_modules/@rc-component/picker/es/index.js
/**
* What's new?
* - Common
*  - [Break] Support special year format, all the year will follow the locale config.
*  - Blur all of field will trigger `onChange` if validate
*  - Support `preserveInvalidOnBlur` to not to clean input if invalid and remove `changeOnBlur`
*  - `pickerValue` is now full controlled
*    - `defaultPickerValue` will take effect on every field active with popup opening.
*  - [Break] clear button return the event with `onClick`
*
* - Locale
*  - Remove `dateFormat` since it's never used
*  - Remove `dateTimeFormat` since it's never used
*
* - Picker
*  - TimePicker support `changeOnScroll`
*  - TimePicker support `millisecond`
*  - Support cellMeridiemFormat for AM/PM
*  - Get correct `disabledHours` when set `use12Hours`
*  - Support `showWeek`
*
* - RangePicker
*  - [Break] RangePicker is now not limit the range of clicked field.
*  - Trigger `onCalendarChange` when type correct
*  - [Break] Not order `value` if given `value` is wrong order.
*  - Hover `presets` will show date in input field.
*  - [Break] RangePicker go to end field, `pickerValue` will follow the start field if not controlled.
*/
var es_default$18 = SinglePicker_default;

//#endregion
//#region node_modules/antd/es/form/util.js
var formItemNameBlackList = ["parentNode"];
var defaultItemNamePrefixCls = "form_item";
function toArray$4(candidate) {
	if (candidate === void 0 || candidate === false) return [];
	return Array.isArray(candidate) ? candidate : [candidate];
}
function getFieldId(namePath, formName) {
	if (!namePath.length) return;
	const mergedId = namePath.join("_");
	if (formName) return `${formName}_${mergedId}`;
	return formItemNameBlackList.includes(mergedId) ? `${defaultItemNamePrefixCls}_${mergedId}` : mergedId;
}
/**
* Get merged status by meta or passed `validateStatus`.
*/
function getStatus(errors, warnings, meta, defaultValidateStatus, hasFeedback, validateStatus) {
	let status = defaultValidateStatus;
	if (validateStatus !== void 0) status = validateStatus;
	else if (meta.validating) status = "validating";
	else if (errors.length) status = "error";
	else if (warnings.length) status = "warning";
	else if (meta.touched || hasFeedback && meta.validated) status = "success";
	return status;
}

//#endregion
//#region node_modules/antd/es/form/hooks/useForm.js
function toNamePathStr(name) {
	return toArray$4(name).join("_");
}
function getFieldDOMNode(name, wrapForm) {
	const fieldDom = getDOM(wrapForm.getFieldInstance(name));
	if (fieldDom) return fieldDom;
	const fieldId = getFieldId(toArray$4(name), wrapForm.__INTERNAL__.name);
	if (fieldId) return document.getElementById(fieldId);
}
function useForm(form) {
	const [rcForm] = useForm_default();
	const itemsRef = import_react.useRef({});
	const wrapForm = import_react.useMemo(() => form ?? {
		...rcForm,
		__INTERNAL__: { itemRef: (name) => (node$1) => {
			const namePathStr = toNamePathStr(name);
			if (node$1) itemsRef.current[namePathStr] = node$1;
			else delete itemsRef.current[namePathStr];
		} },
		scrollToField: (name, options = {}) => {
			const { focus, ...restOpt } = options;
			const node$1 = getFieldDOMNode(name, wrapForm);
			if (node$1) {
				e(node$1, {
					scrollMode: "if-needed",
					block: "nearest",
					...restOpt
				});
				if (focus) wrapForm.focusField(name);
			}
		},
		focusField: (name) => {
			const itemRef = wrapForm.getFieldInstance(name);
			if (typeof itemRef?.focus === "function") itemRef.focus();
			else getFieldDOMNode(name, wrapForm)?.focus?.();
		},
		getFieldInstance: (name) => {
			const namePathStr = toNamePathStr(name);
			return itemsRef.current[namePathStr];
		}
	}, [form, rcForm]);
	return [wrapForm];
}

//#endregion
//#region node_modules/antd/es/radio/context.js
var RadioGroupContext = /* @__PURE__ */ import_react.createContext(null);
const RadioGroupContextProvider = RadioGroupContext.Provider;
var context_default$4 = RadioGroupContext;
const RadioOptionTypeContext = /* @__PURE__ */ import_react.createContext(null);
const RadioOptionTypeContextProvider = RadioOptionTypeContext.Provider;

//#endregion
//#region node_modules/@rc-component/checkbox/es/index.js
function _extends$51() {
	_extends$51 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$51.apply(this, arguments);
}
const Checkbox$3 = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	const { prefixCls = "rc-checkbox", className, style: style$1, checked, disabled, defaultChecked = false, type: type$2 = "checkbox", title, onChange, ...inputProps } = props;
	const inputRef = (0, import_react.useRef)(null);
	const holderRef = (0, import_react.useRef)(null);
	const [rawValue, setRawValue] = useControlledState(defaultChecked, checked);
	(0, import_react.useImperativeHandle)(ref, () => ({
		focus: (options) => {
			inputRef.current?.focus(options);
		},
		blur: () => {
			inputRef.current?.blur();
		},
		input: inputRef.current,
		nativeElement: holderRef.current
	}));
	const classString = clsx(prefixCls, className, {
		[`${prefixCls}-checked`]: rawValue,
		[`${prefixCls}-disabled`]: disabled
	});
	const handleChange = (e$2) => {
		if (disabled) return;
		if (!("checked" in props)) setRawValue(e$2.target.checked);
		onChange?.({
			target: {
				...props,
				type: type$2,
				checked: e$2.target.checked
			},
			stopPropagation() {
				e$2.stopPropagation();
			},
			preventDefault() {
				e$2.preventDefault();
			},
			nativeEvent: e$2.nativeEvent
		});
	};
	return /* @__PURE__ */ import_react.createElement("span", {
		className: classString,
		title,
		style: style$1,
		ref: holderRef
	}, /* @__PURE__ */ import_react.createElement("input", _extends$51({}, inputProps, {
		className: `${prefixCls}-input`,
		ref: inputRef,
		onChange: handleChange,
		disabled,
		checked: !!rawValue,
		type: type$2
	})), /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-inner` }));
});
var es_default$25 = Checkbox$3;

//#endregion
//#region node_modules/antd/es/checkbox/useBubbleLock.js
/**
* When click on the label,
* the event will be stopped to prevent the label from being clicked twice.
* label click -> input click -> label click again
*/
function useBubbleLock(onOriginInputClick) {
	const labelClickLockRef = import_react.useRef(null);
	const clearLock = () => {
		raf_default.cancel(labelClickLockRef.current);
		labelClickLockRef.current = null;
	};
	const onLabelClick = () => {
		clearLock();
		labelClickLockRef.current = raf_default(() => {
			labelClickLockRef.current = null;
		});
	};
	const onInputClick = (e$2) => {
		if (labelClickLockRef.current) {
			e$2.stopPropagation();
			clearLock();
		}
		onOriginInputClick?.(e$2);
	};
	return [onLabelClick, onInputClick];
}

//#endregion
//#region node_modules/antd/es/radio/style/index.js
var getGroupRadioStyle = (token$1) => {
	const { componentCls, antCls } = token$1;
	const groupPrefixCls = `${componentCls}-group`;
	return { [groupPrefixCls]: {
		...resetComponent(token$1),
		display: "inline-block",
		fontSize: 0,
		[`&${groupPrefixCls}-rtl`]: { direction: "rtl" },
		[`&${groupPrefixCls}-block`]: { display: "flex" },
		[`${antCls}-badge ${antCls}-badge-count`]: { zIndex: 1 },
		[`> ${antCls}-badge:not(:first-child) > ${antCls}-button-wrapper`]: { borderInlineStart: "none" },
		"&-vertical": {
			display: "flex",
			flexDirection: "column",
			rowGap: token$1.marginXS
		}
	} };
};
var getRadioBasicStyle = (token$1) => {
	const { componentCls, wrapperMarginInlineEnd, colorPrimary, radioSize, motionDurationSlow, motionDurationMid, motionEaseInOutCirc, colorBgContainer, colorBorder, lineWidth, colorBgContainerDisabled, colorTextDisabled, paddingXS, dotColorDisabled, lineType, radioColor, radioBgColor, calc } = token$1;
	const radioInnerPrefixCls = `${componentCls}-inner`;
	const radioDotDisabledSize = calc(radioSize).sub(calc(4).mul(2));
	const radioSizeCalc = calc(1).mul(radioSize).equal({ unit: true });
	return { [`${componentCls}-wrapper`]: {
		...resetComponent(token$1),
		display: "inline-flex",
		alignItems: "baseline",
		marginInlineStart: 0,
		marginInlineEnd: wrapperMarginInlineEnd,
		cursor: "pointer",
		"&:last-child": { marginInlineEnd: 0 },
		[`&${componentCls}-wrapper-rtl`]: { direction: "rtl" },
		"&-disabled": {
			cursor: "not-allowed",
			color: token$1.colorTextDisabled
		},
		"&::after": {
			display: "inline-block",
			width: 0,
			overflow: "hidden",
			content: "\"\\a0\""
		},
		"&-block": {
			flex: 1,
			justifyContent: "center"
		},
		[`${componentCls}-checked::after`]: {
			position: "absolute",
			insetBlockStart: 0,
			insetInlineStart: 0,
			width: "100%",
			height: "100%",
			border: `${unit(lineWidth)} ${lineType} ${colorPrimary}`,
			borderRadius: "50%",
			visibility: "hidden",
			opacity: 0,
			content: "\"\""
		},
		[componentCls]: {
			...resetComponent(token$1),
			position: "relative",
			display: "inline-block",
			outline: "none",
			cursor: "pointer",
			alignSelf: "center",
			borderRadius: "50%"
		},
		[`${componentCls}-wrapper:hover &,
        &:hover ${radioInnerPrefixCls}`]: { borderColor: colorPrimary },
		[`${componentCls}-input:focus-visible + ${radioInnerPrefixCls}`]: genFocusOutline(token$1),
		[`${componentCls}:hover::after, ${componentCls}-wrapper:hover &::after`]: { visibility: "visible" },
		[`${componentCls}-inner`]: {
			"&::after": {
				boxSizing: "border-box",
				position: "absolute",
				insetBlockStart: "50%",
				insetInlineStart: "50%",
				display: "block",
				width: radioSizeCalc,
				height: radioSizeCalc,
				marginBlockStart: calc(1).mul(radioSize).div(-2).equal({ unit: true }),
				marginInlineStart: calc(1).mul(radioSize).div(-2).equal({ unit: true }),
				backgroundColor: radioColor,
				borderBlockStart: 0,
				borderInlineStart: 0,
				borderRadius: radioSizeCalc,
				transform: "scale(0)",
				opacity: 0,
				transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`,
				content: "\"\""
			},
			boxSizing: "border-box",
			position: "relative",
			insetBlockStart: 0,
			insetInlineStart: 0,
			display: "block",
			width: radioSizeCalc,
			height: radioSizeCalc,
			backgroundColor: colorBgContainer,
			borderColor: colorBorder,
			borderStyle: "solid",
			borderWidth: lineWidth,
			borderRadius: "50%",
			transition: `all ${motionDurationMid}`
		},
		[`${componentCls}-input`]: {
			position: "absolute",
			inset: 0,
			zIndex: 1,
			cursor: "pointer",
			opacity: 0
		},
		[`${componentCls}-checked`]: { [radioInnerPrefixCls]: {
			borderColor: colorPrimary,
			backgroundColor: radioBgColor,
			"&::after": {
				transform: `scale(${token$1.calc(token$1.dotSize).div(radioSize).equal()})`,
				opacity: 1,
				transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`
			}
		} },
		[`${componentCls}-disabled`]: {
			cursor: "not-allowed",
			[radioInnerPrefixCls]: {
				backgroundColor: colorBgContainerDisabled,
				borderColor: colorBorder,
				cursor: "not-allowed",
				"&::after": { backgroundColor: dotColorDisabled }
			},
			[`${componentCls}-input`]: { cursor: "not-allowed" },
			[`${componentCls}-disabled + span`]: {
				color: colorTextDisabled,
				cursor: "not-allowed"
			},
			[`&${componentCls}-checked`]: { [radioInnerPrefixCls]: { "&::after": { transform: `scale(${calc(radioDotDisabledSize).div(radioSize).equal()})` } } }
		},
		[`span${componentCls} + *`]: {
			paddingInlineStart: paddingXS,
			paddingInlineEnd: paddingXS
		}
	} };
};
var getRadioButtonStyle = (token$1) => {
	const { buttonColor, controlHeight, componentCls, lineWidth, lineType, colorBorder, motionDurationMid, buttonPaddingInline, fontSize, buttonBg, fontSizeLG, controlHeightLG, controlHeightSM, paddingXS, borderRadius, borderRadiusSM, borderRadiusLG, buttonCheckedBg, buttonSolidCheckedColor, colorTextDisabled, colorBgContainerDisabled, buttonCheckedBgDisabled, buttonCheckedColorDisabled, colorPrimary, colorPrimaryHover, colorPrimaryActive, buttonSolidCheckedBg, buttonSolidCheckedHoverBg, buttonSolidCheckedActiveBg, calc } = token$1;
	return { [`${componentCls}-button-wrapper`]: {
		position: "relative",
		display: "inline-block",
		height: controlHeight,
		margin: 0,
		paddingInline: buttonPaddingInline,
		paddingBlock: 0,
		color: buttonColor,
		fontSize,
		lineHeight: unit(calc(controlHeight).sub(calc(lineWidth).mul(2)).equal()),
		background: buttonBg,
		border: `${unit(lineWidth)} ${lineType} ${colorBorder}`,
		borderBlockStartWidth: calc(lineWidth).add(.02).equal(),
		borderInlineEndWidth: lineWidth,
		cursor: "pointer",
		transition: [
			`color ${motionDurationMid}`,
			`background ${motionDurationMid}`,
			`box-shadow ${motionDurationMid}`
		].join(","),
		a: { color: buttonColor },
		[`> ${componentCls}-button`]: {
			position: "absolute",
			insetBlockStart: 0,
			insetInlineStart: 0,
			zIndex: -1,
			width: "100%",
			height: "100%"
		},
		"&:not(:last-child)": { marginInlineEnd: calc(lineWidth).mul(-1).equal() },
		"&:first-child": {
			borderInlineStart: `${unit(lineWidth)} ${lineType} ${colorBorder}`,
			borderStartStartRadius: borderRadius,
			borderEndStartRadius: borderRadius
		},
		"&:last-child": {
			borderStartEndRadius: borderRadius,
			borderEndEndRadius: borderRadius
		},
		"&:first-child:last-child": { borderRadius },
		[`${componentCls}-group-large &`]: {
			height: controlHeightLG,
			fontSize: fontSizeLG,
			lineHeight: unit(calc(controlHeightLG).sub(calc(lineWidth).mul(2)).equal()),
			"&:first-child": {
				borderStartStartRadius: borderRadiusLG,
				borderEndStartRadius: borderRadiusLG
			},
			"&:last-child": {
				borderStartEndRadius: borderRadiusLG,
				borderEndEndRadius: borderRadiusLG
			}
		},
		[`${componentCls}-group-small &`]: {
			height: controlHeightSM,
			paddingInline: calc(paddingXS).sub(lineWidth).equal(),
			paddingBlock: 0,
			lineHeight: unit(calc(controlHeightSM).sub(calc(lineWidth).mul(2)).equal()),
			"&:first-child": {
				borderStartStartRadius: borderRadiusSM,
				borderEndStartRadius: borderRadiusSM
			},
			"&:last-child": {
				borderStartEndRadius: borderRadiusSM,
				borderEndEndRadius: borderRadiusSM
			}
		},
		"&:hover": {
			position: "relative",
			color: colorPrimary
		},
		"&:has(:focus-visible)": genFocusOutline(token$1),
		[`${componentCls}-inner, input[type='checkbox'], input[type='radio']`]: {
			width: 0,
			height: 0,
			opacity: 0,
			pointerEvents: "none"
		},
		[`&-checked:not(${componentCls}-button-wrapper-disabled)`]: {
			zIndex: 1,
			color: colorPrimary,
			background: buttonCheckedBg,
			borderColor: colorPrimary,
			"&::before": { backgroundColor: colorPrimary },
			"&:first-child": { borderColor: colorPrimary },
			"&:hover": {
				color: colorPrimaryHover,
				borderColor: colorPrimaryHover,
				"&::before": { backgroundColor: colorPrimaryHover }
			},
			"&:active": {
				color: colorPrimaryActive,
				borderColor: colorPrimaryActive,
				"&::before": { backgroundColor: colorPrimaryActive }
			}
		},
		[`${componentCls}-group-solid &-checked:not(${componentCls}-button-wrapper-disabled)`]: {
			color: buttonSolidCheckedColor,
			background: buttonSolidCheckedBg,
			borderColor: buttonSolidCheckedBg,
			"&:hover": {
				color: buttonSolidCheckedColor,
				background: buttonSolidCheckedHoverBg,
				borderColor: buttonSolidCheckedHoverBg
			},
			"&:active": {
				color: buttonSolidCheckedColor,
				background: buttonSolidCheckedActiveBg,
				borderColor: buttonSolidCheckedActiveBg
			}
		},
		"&-disabled": {
			color: colorTextDisabled,
			backgroundColor: colorBgContainerDisabled,
			borderColor: colorBorder,
			cursor: "not-allowed",
			"&:first-child, &:hover": {
				color: colorTextDisabled,
				backgroundColor: colorBgContainerDisabled,
				borderColor: colorBorder
			}
		},
		[`&-disabled${componentCls}-button-wrapper-checked`]: {
			color: buttonCheckedColorDisabled,
			backgroundColor: buttonCheckedBgDisabled,
			borderColor: colorBorder,
			boxShadow: "none"
		},
		"&-block": {
			flex: 1,
			textAlign: "center"
		}
	} };
};
const prepareComponentToken$37 = (token$1) => {
	const { wireframe, padding, marginXS, lineWidth, fontSizeLG, colorText, colorBgContainer, colorTextDisabled, controlItemBgActiveDisabled, colorTextLightSolid, colorPrimary, colorPrimaryHover, colorPrimaryActive, colorWhite } = token$1;
	const dotPadding = 4;
	const radioSize = fontSizeLG;
	return {
		radioSize,
		dotSize: wireframe ? radioSize - dotPadding * 2 : radioSize - (dotPadding + lineWidth) * 2,
		dotColorDisabled: colorTextDisabled,
		buttonSolidCheckedColor: colorTextLightSolid,
		buttonSolidCheckedBg: colorPrimary,
		buttonSolidCheckedHoverBg: colorPrimaryHover,
		buttonSolidCheckedActiveBg: colorPrimaryActive,
		buttonBg: colorBgContainer,
		buttonCheckedBg: colorBgContainer,
		buttonColor: colorText,
		buttonCheckedBgDisabled: controlItemBgActiveDisabled,
		buttonCheckedColorDisabled: colorTextDisabled,
		buttonPaddingInline: padding - lineWidth,
		wrapperMarginInlineEnd: marginXS,
		radioColor: wireframe ? colorPrimary : colorWhite,
		radioBgColor: wireframe ? colorBgContainer : colorPrimary
	};
};
var style_default$45 = genStyleHooks("Radio", (token$1) => {
	const { controlOutline, controlOutlineWidth } = token$1;
	const radioFocusShadow = `0 0 0 ${unit(controlOutlineWidth)} ${controlOutline}`;
	const radioToken = merge(token$1, {
		radioFocusShadow,
		radioButtonFocusShadow: radioFocusShadow
	});
	return [
		getGroupRadioStyle(radioToken),
		getRadioBasicStyle(radioToken),
		getRadioButtonStyle(radioToken)
	];
}, prepareComponentToken$37, { unitless: {
	radioSize: true,
	dotSize: true
} });

//#endregion
//#region node_modules/antd/es/radio/radio.js
var InternalRadio = (props, ref) => {
	const groupContext = import_react.useContext(context_default$4);
	const radioOptionTypeContext = import_react.useContext(RadioOptionTypeContext);
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("radio");
	const mergedRef = composeRef(ref, import_react.useRef(null));
	const { isFormItemInput } = import_react.useContext(FormItemInputContext);
	devUseWarning("Radio")(!("optionType" in props), "usage", "`optionType` is only support in Radio.Group.");
	const onChange = (e$2) => {
		props.onChange?.(e$2);
		groupContext?.onChange?.(e$2);
	};
	const { prefixCls: customizePrefixCls, className, rootClassName, children, style: style$1, title, classNames, styles, ...restProps } = props;
	const radioPrefixCls = getPrefixCls("radio", customizePrefixCls);
	const isButtonType = (groupContext?.optionType || radioOptionTypeContext) === "button";
	const prefixCls = isButtonType ? `${radioPrefixCls}-button` : radioPrefixCls;
	const rootCls = useCSSVarCls_default(radioPrefixCls);
	const [hashId, cssVarCls] = style_default$45(radioPrefixCls, rootCls);
	const radioProps = { ...restProps };
	const disabled = import_react.useContext(DisabledContext_default);
	if (groupContext) {
		radioProps.name = groupContext.name;
		radioProps.onChange = onChange;
		radioProps.checked = props.value === groupContext.value;
		radioProps.disabled = radioProps.disabled ?? groupContext.disabled;
	}
	radioProps.disabled = radioProps.disabled ?? disabled;
	const mergedProps = {
		...props,
		...radioProps
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const wrapperClassString = clsx(`${prefixCls}-wrapper`, {
		[`${prefixCls}-wrapper-checked`]: radioProps.checked,
		[`${prefixCls}-wrapper-disabled`]: radioProps.disabled,
		[`${prefixCls}-wrapper-rtl`]: direction === "rtl",
		[`${prefixCls}-wrapper-in-form-item`]: isFormItemInput,
		[`${prefixCls}-wrapper-block`]: !!groupContext?.block
	}, contextClassName, className, rootClassName, mergedClassNames.root, hashId, cssVarCls, rootCls);
	const [onLabelClick, onInputClick] = useBubbleLock(radioProps.onClick);
	return /* @__PURE__ */ import_react.createElement(wave_default, {
		component: "Radio",
		disabled: radioProps.disabled
	}, /* @__PURE__ */ import_react.createElement("label", {
		className: wrapperClassString,
		style: {
			...mergedStyles.root,
			...contextStyle,
			...style$1
		},
		onMouseEnter: props.onMouseEnter,
		onMouseLeave: props.onMouseLeave,
		title,
		onClick: onLabelClick
	}, /* @__PURE__ */ import_react.createElement(es_default$25, {
		...radioProps,
		className: clsx(mergedClassNames.icon, { [TARGET_CLS]: !isButtonType }),
		style: mergedStyles.icon,
		type: "radio",
		prefixCls,
		ref: mergedRef,
		onClick: onInputClick
	}), children !== void 0 ? /* @__PURE__ */ import_react.createElement("span", {
		className: clsx(`${prefixCls}-label`, mergedClassNames.label),
		style: mergedStyles.label
	}, children) : null));
};
var Radio$1 = /* @__PURE__ */ import_react.forwardRef(InternalRadio);
Radio$1.displayName = "Radio";
var radio_default$1 = Radio$1;

//#endregion
//#region node_modules/antd/es/radio/group.js
var RadioGroup = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const { name: formItemName } = import_react.useContext(FormItemInputContext);
	const defaultName = useId_default(toNamePathStr(formItemName));
	const { prefixCls: customizePrefixCls, className, rootClassName, options, buttonStyle = "outline", disabled, children, size: customizeSize, style: style$1, id, optionType, name = defaultName, defaultValue, value: customizedValue, block = false, onChange, onMouseEnter, onMouseLeave, onFocus, onBlur, orientation, vertical } = props;
	const [value, setValue] = useControlledState(defaultValue, customizedValue);
	const onRadioChange = import_react.useCallback((event) => {
		const lastValue = value;
		const val = event.target.value;
		if (!("value" in props)) setValue(val);
		if (val !== lastValue) onChange?.(event);
	}, [
		value,
		setValue,
		onChange
	]);
	const prefixCls = getPrefixCls("radio", customizePrefixCls);
	const groupPrefixCls = `${prefixCls}-group`;
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$45(prefixCls, rootCls);
	let childrenToRender = children;
	if (options && options.length > 0) childrenToRender = options.map((option) => {
		if (typeof option === "string" || typeof option === "number") return /* @__PURE__ */ import_react.createElement(radio_default$1, {
			key: option.toString(),
			prefixCls,
			disabled,
			value: option,
			checked: value === option
		}, option);
		return /* @__PURE__ */ import_react.createElement(radio_default$1, {
			key: `radio-group-value-options-${option.value}`,
			prefixCls,
			disabled: option.disabled || disabled,
			value: option.value,
			checked: value === option.value,
			title: option.title,
			style: option.style,
			className: option.className,
			id: option.id,
			required: option.required
		}, option.label);
	});
	const mergedSize = useSize_default(customizeSize);
	const [, mergedVertical] = useOrientation(orientation, vertical);
	const classString = clsx(groupPrefixCls, `${groupPrefixCls}-${buttonStyle}`, {
		[`${groupPrefixCls}-${mergedSize}`]: mergedSize,
		[`${groupPrefixCls}-rtl`]: direction === "rtl",
		[`${groupPrefixCls}-block`]: block
	}, className, rootClassName, hashId, cssVarCls, rootCls);
	const memoizedValue = import_react.useMemo(() => ({
		onChange: onRadioChange,
		value,
		disabled,
		name,
		optionType,
		block
	}), [
		onRadioChange,
		value,
		disabled,
		name,
		optionType,
		block
	]);
	return /* @__PURE__ */ import_react.createElement("div", {
		...pickAttrs(props, {
			aria: true,
			data: true
		}),
		className: clsx(classString, { [`${prefixCls}-group-vertical`]: mergedVertical }),
		style: style$1,
		onMouseEnter,
		onMouseLeave,
		onFocus,
		onBlur,
		id,
		ref
	}, /* @__PURE__ */ import_react.createElement(RadioGroupContextProvider, { value: memoizedValue }, childrenToRender));
});
var group_default$1 = /* @__PURE__ */ import_react.memo(RadioGroup);

//#endregion
//#region node_modules/antd/es/radio/radioButton.js
var RadioButton = (props, ref) => {
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const { prefixCls: customizePrefixCls, ...radioProps } = props;
	const prefixCls = getPrefixCls("radio", customizePrefixCls);
	return /* @__PURE__ */ import_react.createElement(RadioOptionTypeContextProvider, { value: "button" }, /* @__PURE__ */ import_react.createElement(radio_default$1, {
		prefixCls,
		...radioProps,
		type: "radio",
		ref
	}));
};
var radioButton_default = /* @__PURE__ */ import_react.forwardRef(RadioButton);

//#endregion
//#region node_modules/antd/es/radio/index.js
var Radio = radio_default$1;
Radio.Button = radioButton_default;
Radio.Group = group_default$1;
Radio.__ANT_RADIO = true;
var radio_default = Radio;

//#endregion
//#region node_modules/antd/es/calendar/Header.js
var YEAR_SELECT_OFFSET = 10;
var YEAR_SELECT_TOTAL = 20;
function YearSelect(props) {
	const { fullscreen, validRange, generateConfig: generateConfig$1, locale: locale$5, prefixCls, value, onChange, divRef } = props;
	const year = generateConfig$1.getYear(value || generateConfig$1.getNow());
	let start = year - YEAR_SELECT_OFFSET;
	let end = start + YEAR_SELECT_TOTAL;
	if (validRange) {
		start = generateConfig$1.getYear(validRange[0]);
		end = generateConfig$1.getYear(validRange[1]) + 1;
	}
	const suffix = locale$5 && locale$5.year === "" ? "" : "";
	const options = [];
	for (let index$1 = start; index$1 < end; index$1++) options.push({
		label: `${index$1}${suffix}`,
		value: index$1
	});
	return /* @__PURE__ */ import_react.createElement(select_default, {
		size: fullscreen ? void 0 : "small",
		options,
		value: year,
		className: `${prefixCls}-year-select`,
		onChange: (numYear) => {
			let newDate = generateConfig$1.setYear(value, numYear);
			if (validRange) {
				const [startDate, endDate] = validRange;
				const newYear = generateConfig$1.getYear(newDate);
				const newMonth = generateConfig$1.getMonth(newDate);
				if (newYear === generateConfig$1.getYear(endDate) && newMonth > generateConfig$1.getMonth(endDate)) newDate = generateConfig$1.setMonth(newDate, generateConfig$1.getMonth(endDate));
				if (newYear === generateConfig$1.getYear(startDate) && newMonth < generateConfig$1.getMonth(startDate)) newDate = generateConfig$1.setMonth(newDate, generateConfig$1.getMonth(startDate));
			}
			onChange(newDate);
		},
		getPopupContainer: () => divRef.current
	});
}
function MonthSelect(props) {
	const { prefixCls, fullscreen, validRange, value, generateConfig: generateConfig$1, locale: locale$5, onChange, divRef } = props;
	const month = generateConfig$1.getMonth(value || generateConfig$1.getNow());
	let start = 0;
	let end = 11;
	if (validRange) {
		const [rangeStart, rangeEnd] = validRange;
		const currentYear = generateConfig$1.getYear(value);
		if (generateConfig$1.getYear(rangeEnd) === currentYear) end = generateConfig$1.getMonth(rangeEnd);
		if (generateConfig$1.getYear(rangeStart) === currentYear) start = generateConfig$1.getMonth(rangeStart);
	}
	const months = locale$5.shortMonths || generateConfig$1.locale.getShortMonths(locale$5.locale);
	const options = [];
	for (let index$1 = start; index$1 <= end; index$1 += 1) options.push({
		label: months[index$1],
		value: index$1
	});
	return /* @__PURE__ */ import_react.createElement(select_default, {
		size: fullscreen ? void 0 : "small",
		className: `${prefixCls}-month-select`,
		value: month,
		options,
		onChange: (newMonth) => {
			onChange(generateConfig$1.setMonth(value, newMonth));
		},
		getPopupContainer: () => divRef.current
	});
}
function ModeSwitch(props) {
	const { prefixCls, locale: locale$5, mode, fullscreen, onModeChange } = props;
	return /* @__PURE__ */ import_react.createElement(group_default$1, {
		onChange: ({ target: { value } }) => {
			onModeChange(value);
		},
		value: mode,
		size: fullscreen ? void 0 : "small",
		className: `${prefixCls}-mode-switch`
	}, /* @__PURE__ */ import_react.createElement(radioButton_default, { value: "month" }, locale$5.month), /* @__PURE__ */ import_react.createElement(radioButton_default, { value: "year" }, locale$5.year));
}
function CalendarHeader(props) {
	const { prefixCls, fullscreen, mode, onChange, onModeChange, className, style: style$1 } = props;
	const divRef = import_react.useRef(null);
	const formItemInputContext = (0, import_react.useContext)(FormItemInputContext);
	const mergedFormItemInputContext = (0, import_react.useMemo)(() => ({
		...formItemInputContext,
		isFormItemInput: false
	}), [formItemInputContext]);
	const sharedProps = {
		...props,
		fullscreen,
		divRef
	};
	return /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-header`, className),
		style: style$1,
		ref: divRef
	}, /* @__PURE__ */ import_react.createElement(FormItemInputContext.Provider, { value: mergedFormItemInputContext }, /* @__PURE__ */ import_react.createElement(YearSelect, {
		...sharedProps,
		onChange: (v) => {
			onChange(v, "year");
		}
	}), mode === "month" && /* @__PURE__ */ import_react.createElement(MonthSelect, {
		...sharedProps,
		onChange: (v) => {
			onChange(v, "month");
		}
	})), /* @__PURE__ */ import_react.createElement(ModeSwitch, {
		...sharedProps,
		onModeChange
	}));
}
var Header_default$1 = CalendarHeader;

//#endregion
//#region node_modules/antd/es/input/style/token.js
function initInputToken(token$1) {
	return merge(token$1, { inputAffixPadding: token$1.paddingXXS });
}
const initComponentToken$1 = (token$1) => {
	const { controlHeight, fontSize, lineHeight, lineWidth, controlHeightSM, controlHeightLG, fontSizeLG, lineHeightLG, paddingSM, controlPaddingHorizontalSM, controlPaddingHorizontal, colorFillAlter, colorPrimaryHover, colorPrimary, controlOutlineWidth, controlOutline, colorErrorOutline, colorWarningOutline, colorBgContainer, inputFontSize, inputFontSizeLG, inputFontSizeSM } = token$1;
	const mergedFontSize = inputFontSize || fontSize;
	const mergedFontSizeSM = inputFontSizeSM || mergedFontSize;
	const mergedFontSizeLG = inputFontSizeLG || fontSizeLG;
	const paddingBlock = Math.round((controlHeight - mergedFontSize * lineHeight) / 2 * 10) / 10 - lineWidth;
	const paddingBlockSM = Math.round((controlHeightSM - mergedFontSizeSM * lineHeight) / 2 * 10) / 10 - lineWidth;
	const paddingBlockLG = Math.ceil((controlHeightLG - mergedFontSizeLG * lineHeightLG) / 2 * 10) / 10 - lineWidth;
	return {
		paddingBlock: Math.max(paddingBlock, 0),
		paddingBlockSM: Math.max(paddingBlockSM, 0),
		paddingBlockLG: Math.max(paddingBlockLG, 0),
		paddingInline: paddingSM - lineWidth,
		paddingInlineSM: controlPaddingHorizontalSM - lineWidth,
		paddingInlineLG: controlPaddingHorizontal - lineWidth,
		addonBg: colorFillAlter,
		activeBorderColor: colorPrimary,
		hoverBorderColor: colorPrimaryHover,
		activeShadow: `0 0 0 ${controlOutlineWidth}px ${controlOutline}`,
		errorActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorErrorOutline}`,
		warningActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorWarningOutline}`,
		hoverBg: colorBgContainer,
		activeBg: colorBgContainer,
		inputFontSize: mergedFontSize,
		inputFontSizeLG: mergedFontSizeLG,
		inputFontSizeSM: mergedFontSizeSM
	};
};

//#endregion
//#region node_modules/antd/es/input/style/variants.js
const genHoverStyle = (token$1) => ({
	borderColor: token$1.hoverBorderColor,
	backgroundColor: token$1.hoverBg
});
const genDisabledStyle = (token$1) => ({
	color: token$1.colorTextDisabled,
	backgroundColor: token$1.colorBgContainerDisabled,
	borderColor: token$1.colorBorder,
	boxShadow: "none",
	cursor: "not-allowed",
	opacity: 1,
	"input[disabled], textarea[disabled]": { cursor: "not-allowed" },
	"&:hover:not([disabled])": { ...genHoverStyle(merge(token$1, {
		hoverBorderColor: token$1.colorBorder,
		hoverBg: token$1.colorBgContainerDisabled
	})) }
});
const genBaseOutlinedStyle = (token$1, options) => ({
	background: token$1.colorBgContainer,
	borderWidth: token$1.lineWidth,
	borderStyle: token$1.lineType,
	borderColor: options.borderColor,
	"&:hover": {
		borderColor: options.hoverBorderColor,
		backgroundColor: token$1.hoverBg
	},
	"&:focus, &:focus-within": {
		borderColor: options.activeBorderColor,
		boxShadow: options.activeShadow,
		outline: 0,
		backgroundColor: token$1.activeBg
	}
});
var genOutlinedStatusStyle = (token$1, options) => ({
	[`&${token$1.componentCls}-status-${options.status}:not(${token$1.componentCls}-disabled)`]: {
		...genBaseOutlinedStyle(token$1, options),
		[`${token$1.componentCls}-prefix, ${token$1.componentCls}-suffix`]: { color: options.affixColor }
	},
	[`&${token$1.componentCls}-status-${options.status}${token$1.componentCls}-disabled`]: { borderColor: options.borderColor }
});
const genOutlinedStyle = (token$1, extraStyles) => ({ "&-outlined": {
	...genBaseOutlinedStyle(token$1, {
		borderColor: token$1.colorBorder,
		hoverBorderColor: token$1.hoverBorderColor,
		activeBorderColor: token$1.activeBorderColor,
		activeShadow: token$1.activeShadow
	}),
	[`&${token$1.componentCls}-disabled, &[disabled]`]: { ...genDisabledStyle(token$1) },
	...genOutlinedStatusStyle(token$1, {
		status: "error",
		borderColor: token$1.colorError,
		hoverBorderColor: token$1.colorErrorBorderHover,
		activeBorderColor: token$1.colorError,
		activeShadow: token$1.errorActiveShadow,
		affixColor: token$1.colorError
	}),
	...genOutlinedStatusStyle(token$1, {
		status: "warning",
		borderColor: token$1.colorWarning,
		hoverBorderColor: token$1.colorWarningBorderHover,
		activeBorderColor: token$1.colorWarning,
		activeShadow: token$1.warningActiveShadow,
		affixColor: token$1.colorWarning
	}),
	...extraStyles
} });
var genOutlinedGroupStatusStyle = (token$1, options) => ({ [`&${token$1.componentCls}-group-wrapper-status-${options.status}`]: { [`${token$1.componentCls}-group-addon`]: {
	borderColor: options.addonBorderColor,
	color: options.addonColor
} } });
const genOutlinedGroupStyle = (token$1) => ({ "&-outlined": {
	[`${token$1.componentCls}-group`]: {
		"&-addon": {
			background: token$1.addonBg,
			border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`
		},
		"&-addon:first-child": { borderInlineEnd: 0 },
		"&-addon:last-child": { borderInlineStart: 0 }
	},
	...genOutlinedGroupStatusStyle(token$1, {
		status: "error",
		addonBorderColor: token$1.colorError,
		addonColor: token$1.colorErrorText
	}),
	...genOutlinedGroupStatusStyle(token$1, {
		status: "warning",
		addonBorderColor: token$1.colorWarning,
		addonColor: token$1.colorWarningText
	}),
	[`&${token$1.componentCls}-group-wrapper-disabled`]: { [`${token$1.componentCls}-group-addon`]: { ...genDisabledStyle(token$1) } }
} });
const genBorderlessStyle = (token$1, extraStyles) => {
	const { componentCls } = token$1;
	return { "&-borderless": {
		background: "transparent",
		border: "none",
		"&:focus, &:focus-within": { outline: "none" },
		[`&${componentCls}-disabled, &[disabled]`]: {
			color: token$1.colorTextDisabled,
			cursor: "not-allowed"
		},
		[`&${componentCls}-status-error`]: { "&, & input, & textarea": { color: token$1.colorError } },
		[`&${componentCls}-status-warning`]: { "&, & input, & textarea": { color: token$1.colorWarning } },
		...extraStyles
	} };
};
var genBaseFilledStyle = (token$1, options) => ({
	background: options.bg,
	borderWidth: token$1.lineWidth,
	borderStyle: token$1.lineType,
	borderColor: "transparent",
	"input&, & input, textarea&, & textarea": { color: options?.inputColor ?? "unset" },
	"&:hover": { background: options.hoverBg },
	"&:focus, &:focus-within": {
		outline: 0,
		borderColor: options.activeBorderColor,
		backgroundColor: token$1.activeBg
	}
});
var genFilledStatusStyle = (token$1, options) => ({ [`&${token$1.componentCls}-status-${options.status}:not(${token$1.componentCls}-disabled)`]: {
	...genBaseFilledStyle(token$1, options),
	[`${token$1.componentCls}-prefix, ${token$1.componentCls}-suffix`]: { color: options.affixColor }
} });
const genFilledStyle = (token$1, extraStyles) => ({ "&-filled": {
	...genBaseFilledStyle(token$1, {
		bg: token$1.colorFillTertiary,
		hoverBg: token$1.colorFillSecondary,
		activeBorderColor: token$1.activeBorderColor,
		inputColor: token$1.colorText
	}),
	[`&${token$1.componentCls}-disabled, &[disabled]`]: { ...genDisabledStyle(token$1) },
	...genFilledStatusStyle(token$1, {
		status: "error",
		bg: token$1.colorErrorBg,
		hoverBg: token$1.colorErrorBgHover,
		activeBorderColor: token$1.colorError,
		inputColor: token$1.colorErrorText,
		affixColor: token$1.colorError
	}),
	...genFilledStatusStyle(token$1, {
		status: "warning",
		bg: token$1.colorWarningBg,
		hoverBg: token$1.colorWarningBgHover,
		activeBorderColor: token$1.colorWarning,
		inputColor: token$1.colorWarningText,
		affixColor: token$1.colorWarning
	}),
	...extraStyles
} });
var genFilledGroupStatusStyle = (token$1, options) => ({ [`&${token$1.componentCls}-group-wrapper-status-${options.status}`]: { [`${token$1.componentCls}-group-addon`]: {
	background: options.addonBg,
	color: options.addonColor
} } });
const genFilledGroupStyle = (token$1) => ({ "&-filled": {
	[`${token$1.componentCls}-group-addon`]: {
		background: token$1.colorFillTertiary,
		"&:last-child": { position: "static" }
	},
	...genFilledGroupStatusStyle(token$1, {
		status: "error",
		addonBg: token$1.colorErrorBg,
		addonColor: token$1.colorErrorText
	}),
	...genFilledGroupStatusStyle(token$1, {
		status: "warning",
		addonBg: token$1.colorWarningBg,
		addonColor: token$1.colorWarningText
	}),
	[`&${token$1.componentCls}-group-wrapper-disabled`]: { [`${token$1.componentCls}-group`]: {
		"&-addon": {
			background: token$1.colorFillTertiary,
			color: token$1.colorTextDisabled
		},
		"&-addon:first-child": {
			borderInlineStart: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`,
			borderTop: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`,
			borderBottom: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`
		},
		"&-addon:last-child": {
			borderInlineEnd: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`,
			borderTop: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`,
			borderBottom: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`
		}
	} }
} });
const genBaseUnderlinedStyle = (token$1, options) => ({
	background: token$1.colorBgContainer,
	borderWidth: `${unit(token$1.lineWidth)} 0`,
	borderStyle: `${token$1.lineType} none`,
	borderColor: `transparent transparent ${options.borderColor} transparent`,
	borderRadius: 0,
	"&:hover": {
		borderColor: `transparent transparent ${options.hoverBorderColor} transparent`,
		backgroundColor: token$1.hoverBg
	},
	"&:focus, &:focus-within": {
		borderColor: `transparent transparent ${options.activeBorderColor} transparent`,
		outline: 0,
		backgroundColor: token$1.activeBg
	}
});
var genUnderlinedStatusStyle = (token$1, options) => ({
	[`&${token$1.componentCls}-status-${options.status}:not(${token$1.componentCls}-disabled)`]: {
		...genBaseUnderlinedStyle(token$1, options),
		[`${token$1.componentCls}-prefix, ${token$1.componentCls}-suffix`]: { color: options.affixColor }
	},
	[`&${token$1.componentCls}-status-${options.status}${token$1.componentCls}-disabled`]: { borderColor: `transparent transparent ${options.borderColor} transparent` }
});
const genUnderlinedStyle = (token$1, extraStyles) => ({ "&-underlined": {
	...genBaseUnderlinedStyle(token$1, {
		borderColor: token$1.colorBorder,
		hoverBorderColor: token$1.hoverBorderColor,
		activeBorderColor: token$1.activeBorderColor,
		activeShadow: token$1.activeShadow
	}),
	[`&${token$1.componentCls}-disabled, &[disabled]`]: {
		color: token$1.colorTextDisabled,
		boxShadow: "none",
		cursor: "not-allowed",
		"&:hover": { borderColor: `transparent transparent ${token$1.colorBorder} transparent` }
	},
	"input[disabled], textarea[disabled]": { cursor: "not-allowed" },
	...genUnderlinedStatusStyle(token$1, {
		status: "error",
		borderColor: token$1.colorError,
		hoverBorderColor: token$1.colorErrorBorderHover,
		activeBorderColor: token$1.colorError,
		activeShadow: token$1.errorActiveShadow,
		affixColor: token$1.colorError
	}),
	...genUnderlinedStatusStyle(token$1, {
		status: "warning",
		borderColor: token$1.colorWarning,
		hoverBorderColor: token$1.colorWarningBorderHover,
		activeBorderColor: token$1.colorWarning,
		activeShadow: token$1.warningActiveShadow,
		affixColor: token$1.colorWarning
	}),
	...extraStyles
} });

//#endregion
//#region node_modules/antd/es/input/style/index.js
const genPlaceholderStyle = (color) => ({
	"&::-moz-placeholder": { opacity: 1 },
	"&::placeholder": {
		color,
		userSelect: "none"
	},
	"&:placeholder-shown": { textOverflow: "ellipsis" }
});
var genInputLargeStyle = (token$1) => {
	const { paddingBlockLG, lineHeightLG, borderRadiusLG, paddingInlineLG } = token$1;
	return {
		padding: `${unit(paddingBlockLG)} ${unit(paddingInlineLG)}`,
		fontSize: token$1.inputFontSizeLG,
		lineHeight: lineHeightLG,
		borderRadius: borderRadiusLG
	};
};
const genInputSmallStyle = (token$1) => ({
	padding: `${unit(token$1.paddingBlockSM)} ${unit(token$1.paddingInlineSM)}`,
	fontSize: token$1.inputFontSizeSM,
	borderRadius: token$1.borderRadiusSM
});
const genBasicInputStyle = (token$1, option = {}) => ({
	position: "relative",
	display: "inline-block",
	width: "100%",
	minWidth: 0,
	padding: `${unit(token$1.paddingBlock)} ${unit(token$1.paddingInline)}`,
	color: token$1.colorText,
	fontSize: token$1.inputFontSize,
	lineHeight: token$1.lineHeight,
	borderRadius: token$1.borderRadius,
	transition: `all ${token$1.motionDurationMid}`,
	...genPlaceholderStyle(token$1.colorTextPlaceholder),
	"&-lg": {
		...genInputLargeStyle(token$1),
		...option.largeStyle
	},
	"&-sm": {
		...genInputSmallStyle(token$1),
		...option.smallStyle
	},
	"&-rtl, &-textarea-rtl": { direction: "rtl" }
});
const genInputGroupStyle = (token$1) => {
	const { componentCls, antCls } = token$1;
	return {
		position: "relative",
		display: "table",
		width: "100%",
		borderCollapse: "separate",
		borderSpacing: 0,
		"&[class*='col-']": {
			paddingInlineEnd: token$1.paddingXS,
			"&:last-child": { paddingInlineEnd: 0 }
		},
		[`&-lg ${componentCls}, &-lg > ${componentCls}-group-addon`]: { ...genInputLargeStyle(token$1) },
		[`&-sm ${componentCls}, &-sm > ${componentCls}-group-addon`]: { ...genInputSmallStyle(token$1) },
		[`&-lg ${antCls}-select-single`]: { height: token$1.controlHeightLG },
		[`&-sm ${antCls}-select-single`]: { height: token$1.controlHeightSM },
		[`> ${componentCls}`]: {
			display: "table-cell",
			"&:not(:first-child):not(:last-child)": { borderRadius: 0 }
		},
		[`${componentCls}-group`]: {
			"&-addon, &-wrap": {
				display: "table-cell",
				width: 1,
				whiteSpace: "nowrap",
				verticalAlign: "middle",
				"&:not(:first-child):not(:last-child)": { borderRadius: 0 }
			},
			"&-wrap > *": { display: "block !important" },
			"&-addon": {
				position: "relative",
				padding: `0 ${unit(token$1.paddingInline)}`,
				color: token$1.colorText,
				fontWeight: "normal",
				fontSize: token$1.inputFontSize,
				textAlign: "center",
				borderRadius: token$1.borderRadius,
				transition: `all ${token$1.motionDurationSlow}`,
				lineHeight: 1,
				[`${antCls}-select`]: {
					margin: `${unit(token$1.calc(token$1.paddingBlock).add(1).mul(-1).equal())} ${unit(token$1.calc(token$1.paddingInline).mul(-1).equal())}`,
					[`&${antCls}-select-single:not(${antCls}-select-customize-input):not(${antCls}-pagination-size-changer)`]: {
						backgroundColor: "inherit",
						border: `${unit(token$1.lineWidth)} ${token$1.lineType} transparent`,
						boxShadow: "none"
					}
				},
				[`${antCls}-cascader-picker`]: {
					margin: `-9px ${unit(token$1.calc(token$1.paddingInline).mul(-1).equal())}`,
					backgroundColor: "transparent",
					[`${antCls}-cascader-input`]: {
						textAlign: "start",
						border: 0,
						boxShadow: "none"
					}
				}
			}
		},
		[componentCls]: {
			width: "100%",
			marginBottom: 0,
			textAlign: "inherit",
			"&:focus": {
				zIndex: 1,
				borderInlineEndWidth: 1
			},
			"&:hover": {
				zIndex: 1,
				borderInlineEndWidth: 1
			}
		},
		[`> ${componentCls}:first-child, ${componentCls}-group-addon:first-child`]: {
			borderStartEndRadius: 0,
			borderEndEndRadius: 0,
			[`${antCls}-select`]: {
				borderStartEndRadius: 0,
				borderEndEndRadius: 0
			}
		},
		[`> ${componentCls}-affix-wrapper`]: {
			[`&:not(:first-child) ${componentCls}`]: {
				borderStartStartRadius: 0,
				borderEndStartRadius: 0
			},
			[`&:not(:last-child) ${componentCls}`]: {
				borderStartEndRadius: 0,
				borderEndEndRadius: 0
			}
		},
		[`> ${componentCls}:last-child, ${componentCls}-group-addon:last-child`]: {
			borderStartStartRadius: 0,
			borderEndStartRadius: 0,
			[`${antCls}-select`]: {
				borderStartStartRadius: 0,
				borderEndStartRadius: 0
			}
		},
		[`${componentCls}-affix-wrapper`]: {
			"&:not(:last-child)": {
				borderStartEndRadius: 0,
				borderEndEndRadius: 0
			},
			"&:not(:first-child)": {
				borderStartStartRadius: 0,
				borderEndStartRadius: 0
			}
		},
		[`&${componentCls}-group-compact`]: {
			display: "block",
			...clearFix(),
			[`${componentCls}-group-addon, ${componentCls}-group-wrap, > ${componentCls}`]: { "&:not(:first-child):not(:last-child)": {
				borderInlineEndWidth: token$1.lineWidth,
				"&:hover, &:focus": { zIndex: 1 }
			} },
			"& > *": {
				display: "inline-flex",
				float: "none",
				verticalAlign: "top",
				borderRadius: 0
			},
			[`
        & > ${componentCls}-affix-wrapper,
        & > ${componentCls}-number-affix-wrapper,
        & > ${antCls}-picker-range
      `]: { display: "inline-flex" },
			"& > *:not(:last-child)": {
				marginInlineEnd: token$1.calc(token$1.lineWidth).mul(-1).equal(),
				borderInlineEndWidth: token$1.lineWidth
			},
			[componentCls]: { float: "none" },
			[`& > ${antCls}-select,
      & > ${antCls}-select-auto-complete ${componentCls},
      & > ${antCls}-cascader-picker ${componentCls},
      & > ${componentCls}-group-wrapper ${componentCls}`]: {
				borderInlineEndWidth: token$1.lineWidth,
				borderRadius: 0,
				"&:hover, &:focus": { zIndex: 1 }
			},
			[`& > ${antCls}-select-focused`]: { zIndex: 1 },
			[`& > ${antCls}-select > ${antCls}-select-arrow`]: { zIndex: 1 },
			[`& > *:first-child,
      & > ${antCls}-select:first-child,
      & > ${antCls}-select-auto-complete:first-child ${componentCls},
      & > ${antCls}-cascader-picker:first-child ${componentCls}`]: {
				borderStartStartRadius: token$1.borderRadius,
				borderEndStartRadius: token$1.borderRadius
			},
			[`& > *:last-child,
      & > ${antCls}-select:last-child,
      & > ${antCls}-cascader-picker:last-child ${componentCls},
      & > ${antCls}-cascader-picker-focused:last-child ${componentCls}`]: {
				borderInlineEndWidth: token$1.lineWidth,
				borderStartEndRadius: token$1.borderRadius,
				borderEndEndRadius: token$1.borderRadius
			},
			[`& > ${antCls}-select-auto-complete ${componentCls}`]: { verticalAlign: "top" },
			[`${componentCls}-group-wrapper + ${componentCls}-group-wrapper`]: {
				marginInlineStart: token$1.calc(token$1.lineWidth).mul(-1).equal(),
				[`${componentCls}-affix-wrapper`]: {}
			}
		}
	};
};
const genInputStyle$1 = (token$1) => {
	const { componentCls, controlHeightSM, lineWidth, calc } = token$1;
	const colorSmallPadding = calc(controlHeightSM).sub(calc(lineWidth).mul(2)).sub(16).div(2).equal();
	return { [componentCls]: {
		...resetComponent(token$1),
		...genBasicInputStyle(token$1),
		...genOutlinedStyle(token$1),
		...genFilledStyle(token$1),
		...genBorderlessStyle(token$1),
		...genUnderlinedStyle(token$1),
		"&[type=\"color\"]": {
			height: token$1.controlHeight,
			[`&${componentCls}-lg`]: { height: token$1.controlHeightLG },
			[`&${componentCls}-sm`]: {
				height: controlHeightSM,
				paddingTop: colorSmallPadding,
				paddingBottom: colorSmallPadding
			}
		},
		"&[type=\"search\"]::-webkit-search-cancel-button, &[type=\"search\"]::-webkit-search-decoration": { appearance: "none" }
	} };
};
var genAllowClearStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-clear-icon`]: {
		margin: 0,
		padding: 0,
		lineHeight: 0,
		color: token$1.colorTextQuaternary,
		fontSize: token$1.fontSizeIcon,
		verticalAlign: -1,
		cursor: "pointer",
		transition: `color ${token$1.motionDurationSlow}`,
		border: "none",
		outline: "none",
		backgroundColor: "transparent",
		"&:hover": { color: token$1.colorIcon },
		"&:active": { color: token$1.colorText },
		"&-hidden": { visibility: "hidden" },
		"&-has-suffix": { margin: `0 ${unit(token$1.inputAffixPadding)}` }
	} };
};
const genAffixStyle = (token$1) => {
	const { componentCls, inputAffixPadding, colorTextDescription, motionDurationSlow, colorIcon, colorIconHover, iconCls } = token$1;
	const affixCls = `${componentCls}-affix-wrapper`;
	const affixClsDisabled = `${componentCls}-affix-wrapper-disabled`;
	return {
		[affixCls]: {
			...genBasicInputStyle(token$1),
			display: "inline-flex",
			"&-focused, &:focus": { zIndex: 1 },
			[`> input${componentCls}`]: { padding: 0 },
			[`> input${componentCls}, > textarea${componentCls}`]: {
				fontSize: "inherit",
				border: "none",
				borderRadius: 0,
				outline: "none",
				background: "transparent",
				color: "inherit",
				"&::-ms-reveal": { display: "none" },
				"&:focus": { boxShadow: "none !important" }
			},
			"&::before": {
				display: "inline-block",
				width: 0,
				visibility: "hidden",
				content: "\"\\a0\""
			},
			[componentCls]: {
				"&-prefix, &-suffix": {
					display: "flex",
					flex: "none",
					alignItems: "center",
					"> *:not(:last-child)": { marginInlineEnd: token$1.paddingXS }
				},
				"&-show-count-suffix": {
					color: colorTextDescription,
					direction: "ltr"
				},
				"&-show-count-has-suffix": { marginInlineEnd: token$1.paddingXXS },
				"&-prefix": { marginInlineEnd: inputAffixPadding },
				"&-suffix": { marginInlineStart: inputAffixPadding }
			},
			...genAllowClearStyle(token$1),
			[`${iconCls}${componentCls}-password-icon`]: {
				color: colorIcon,
				cursor: "pointer",
				transition: `all ${motionDurationSlow}`,
				"&:hover": { color: colorIconHover }
			}
		},
		[`${componentCls}-underlined`]: { borderRadius: 0 },
		[affixClsDisabled]: { [`${iconCls}${componentCls}-password-icon`]: {
			color: colorIcon,
			cursor: "not-allowed",
			"&:hover": { color: colorIcon }
		} }
	};
};
var genGroupStyle$1 = (token$1) => {
	const { componentCls, borderRadiusLG, borderRadiusSM } = token$1;
	return { [`${componentCls}-group`]: {
		...resetComponent(token$1),
		...genInputGroupStyle(token$1),
		"&-rtl": { direction: "rtl" },
		"&-wrapper": {
			display: "inline-block",
			width: "100%",
			textAlign: "start",
			verticalAlign: "top",
			"&-rtl": { direction: "rtl" },
			"&-lg": { [`${componentCls}-group-addon`]: {
				borderRadius: borderRadiusLG,
				fontSize: token$1.inputFontSizeLG
			} },
			"&-sm": { [`${componentCls}-group-addon`]: { borderRadius: borderRadiusSM } },
			...genOutlinedGroupStyle(token$1),
			...genFilledGroupStyle(token$1),
			[`&:not(${componentCls}-compact-first-item):not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: { [`${componentCls}, ${componentCls}-group-addon`]: { borderRadius: 0 } },
			[`&:not(${componentCls}-compact-last-item)${componentCls}-compact-first-item`]: { [`${componentCls}, ${componentCls}-group-addon`]: {
				borderStartEndRadius: 0,
				borderEndEndRadius: 0
			} },
			[`&:not(${componentCls}-compact-first-item)${componentCls}-compact-last-item`]: { [`${componentCls}, ${componentCls}-group-addon`]: {
				borderStartStartRadius: 0,
				borderEndStartRadius: 0
			} },
			[`&:not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: { [`${componentCls}-affix-wrapper`]: {
				borderStartEndRadius: 0,
				borderEndEndRadius: 0
			} },
			[`&:not(${componentCls}-compact-first-item)${componentCls}-compact-item`]: { [`${componentCls}-affix-wrapper`]: {
				borderStartStartRadius: 0,
				borderEndStartRadius: 0
			} }
		}
	} };
};
var genRangeStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-out-of-range`]: { [`&, & input, & textarea, ${componentCls}-show-count-suffix, ${componentCls}-data-count`]: { color: token$1.colorError } } };
};
const useSharedStyle = genStyleHooks(["Input", "Shared"], (token$1) => {
	const inputToken = merge(token$1, initInputToken(token$1));
	return [genInputStyle$1(inputToken), genAffixStyle(inputToken)];
}, initComponentToken$1, { resetFont: false });
var style_default$25 = genStyleHooks(["Input", "Component"], (token$1) => {
	const inputToken = merge(token$1, initInputToken(token$1));
	return [
		genGroupStyle$1(inputToken),
		genRangeStyle(inputToken),
		genCompactItemStyle(inputToken, {
			focus: true,
			focusElCls: `${inputToken.componentCls}-affix-wrapper-focused`
		})
	];
}, initComponentToken$1, { resetFont: false });

//#endregion
//#region node_modules/antd/es/date-picker/style/util.js
/**
* Get multiple selector needed style. The calculation:
*
* ContainerPadding = BasePadding - ItemMargin
*
* Border:                                     
* ContainerPadding:                                                      
*                                            
* Item Margin:                                                          
*                                                           
* Item(multipleItemHeight):   BasePadding    Item       Overflow  Container(ControlHeight)
*                                                           
* Item Margin:                                                          
*                                            
* ContainerPadding:                                                      
* Border:                                     
*/
const getMultipleSelectorUnit = (token$1) => {
	const { multipleSelectItemHeight, paddingXXS, lineWidth, INTERNAL_FIXED_ITEM_MARGIN } = token$1;
	const basePadding = token$1.max(token$1.calc(paddingXXS).sub(lineWidth).equal(), 0);
	return {
		basePadding,
		containerPadding: token$1.max(token$1.calc(basePadding).sub(INTERNAL_FIXED_ITEM_MARGIN).equal(), 0),
		itemHeight: unit(multipleSelectItemHeight),
		itemLineHeight: unit(token$1.calc(multipleSelectItemHeight).sub(token$1.calc(token$1.lineWidth).mul(2)).equal())
	};
};
/**
* Get the `@rc-component/overflow` needed style.
* It's a share style which means not affected by `size`.
*/
const genOverflowStyle = (token$1) => {
	const { componentCls, iconCls, borderRadiusSM, motionDurationSlow, paddingXS, multipleItemColorDisabled, multipleItemBorderColorDisabled, colorIcon, colorIconHover, INTERNAL_FIXED_ITEM_MARGIN } = token$1;
	return { [`${componentCls}-selection-overflow`]: {
		position: "relative",
		display: "flex",
		flex: "auto",
		flexWrap: "wrap",
		maxWidth: "100%",
		"&-item": {
			flex: "none",
			alignSelf: "center",
			maxWidth: "calc(100% - 4px)",
			display: "inline-flex"
		},
		[`${componentCls}-selection-item`]: {
			display: "flex",
			alignSelf: "center",
			flex: "none",
			boxSizing: "border-box",
			maxWidth: "100%",
			marginBlock: INTERNAL_FIXED_ITEM_MARGIN,
			borderRadius: borderRadiusSM,
			cursor: "default",
			transition: `font-size ${motionDurationSlow}, line-height ${motionDurationSlow}, height ${motionDurationSlow}`,
			marginInlineEnd: token$1.calc(INTERNAL_FIXED_ITEM_MARGIN).mul(2).equal(),
			paddingInlineStart: paddingXS,
			paddingInlineEnd: token$1.calc(paddingXS).div(2).equal(),
			[`${componentCls}-disabled&`]: {
				color: multipleItemColorDisabled,
				borderColor: multipleItemBorderColorDisabled,
				cursor: "not-allowed"
			},
			"&-content": {
				display: "inline-block",
				marginInlineEnd: token$1.calc(paddingXS).div(2).equal(),
				overflow: "hidden",
				whiteSpace: "pre",
				textOverflow: "ellipsis"
			},
			"&-remove": {
				...resetIcon(),
				display: "inline-flex",
				alignItems: "center",
				color: colorIcon,
				fontWeight: "bold",
				fontSize: 10,
				lineHeight: "inherit",
				cursor: "pointer",
				[`> ${iconCls}`]: { verticalAlign: "-0.2em" },
				"&:hover": { color: colorIconHover }
			}
		}
	} };
};

//#endregion
//#region node_modules/antd/es/date-picker/style/multiple.js
var genSize = (token$1, suffix) => {
	const { componentCls, controlHeight } = token$1;
	const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
	const multipleSelectorUnit = getMultipleSelectorUnit(token$1);
	return [{ [`${componentCls}-multiple${suffixCls}`]: {
		paddingBlock: multipleSelectorUnit.containerPadding,
		paddingInlineStart: multipleSelectorUnit.basePadding,
		minHeight: controlHeight,
		[`${componentCls}-selection-item`]: {
			height: multipleSelectorUnit.itemHeight,
			lineHeight: unit(multipleSelectorUnit.itemLineHeight)
		}
	} }];
};
var genPickerMultipleStyle = (token$1) => {
	const { componentCls, calc, lineWidth } = token$1;
	const smallToken = merge(token$1, {
		fontHeight: token$1.fontSize,
		selectHeight: token$1.controlHeightSM,
		multipleSelectItemHeight: token$1.multipleItemHeightSM,
		borderRadius: token$1.borderRadiusSM,
		borderRadiusSM: token$1.borderRadiusXS,
		controlHeight: token$1.controlHeightSM
	});
	const largeToken = merge(token$1, {
		fontHeight: calc(token$1.multipleItemHeightLG).sub(calc(lineWidth).mul(2).equal()).equal(),
		fontSize: token$1.fontSizeLG,
		selectHeight: token$1.controlHeightLG,
		multipleSelectItemHeight: token$1.multipleItemHeightLG,
		borderRadius: token$1.borderRadiusLG,
		borderRadiusSM: token$1.borderRadius,
		controlHeight: token$1.controlHeightLG
	});
	return [
		genSize(smallToken, "small"),
		genSize(token$1),
		genSize(largeToken, "large"),
		{ [`${componentCls}${componentCls}-multiple`]: {
			width: "100%",
			cursor: "text",
			[`${componentCls}-selector`]: {
				flex: "auto",
				padding: 0,
				position: "relative",
				"&:after": { margin: 0 },
				[`${componentCls}-selection-placeholder`]: {
					position: "absolute",
					top: "50%",
					insetInlineStart: token$1.inputPaddingHorizontalBase,
					insetInlineEnd: 0,
					transform: "translateY(-50%)",
					transition: `all ${token$1.motionDurationSlow}`,
					overflow: "hidden",
					whiteSpace: "nowrap",
					textOverflow: "ellipsis",
					flex: 1,
					color: token$1.colorTextPlaceholder,
					pointerEvents: "none"
				}
			},
			...genOverflowStyle(token$1),
			[`${componentCls}-multiple-input`]: {
				width: 0,
				height: 0,
				border: 0,
				visibility: "hidden",
				position: "absolute",
				zIndex: -1
			}
		} }
	];
};
var multiple_default = genPickerMultipleStyle;

//#endregion
//#region node_modules/antd/es/date-picker/style/panel.js
var genPickerCellInnerStyle = (token$1) => {
	const { pickerCellCls, pickerCellInnerCls, cellHeight, borderRadiusSM, motionDurationMid, cellHoverBg, lineWidth, lineType, colorPrimary, cellActiveWithRangeBg, colorTextLightSolid, colorTextDisabled, cellBgDisabled, colorFillSecondary } = token$1;
	return {
		"&::before": {
			position: "absolute",
			top: "50%",
			insetInlineStart: 0,
			insetInlineEnd: 0,
			zIndex: 1,
			height: cellHeight,
			transform: "translateY(-50%)",
			content: "\"\"",
			pointerEvents: "none"
		},
		[pickerCellInnerCls]: {
			position: "relative",
			zIndex: 2,
			display: "inline-block",
			minWidth: cellHeight,
			height: cellHeight,
			lineHeight: unit(cellHeight),
			borderRadius: borderRadiusSM,
			transition: `background ${motionDurationMid}`
		},
		[`&:hover:not(${pickerCellCls}-in-view):not(${pickerCellCls}-disabled),
    &:hover:not(${pickerCellCls}-selected):not(${pickerCellCls}-range-start):not(${pickerCellCls}-range-end):not(${pickerCellCls}-disabled)`]: { [pickerCellInnerCls]: { background: cellHoverBg } },
		[`&-in-view${pickerCellCls}-today ${pickerCellInnerCls}`]: { "&::before": {
			position: "absolute",
			top: 0,
			insetInlineEnd: 0,
			bottom: 0,
			insetInlineStart: 0,
			zIndex: 1,
			border: `${unit(lineWidth)} ${lineType} ${colorPrimary}`,
			borderRadius: borderRadiusSM,
			content: "\"\""
		} },
		[`&-in-view${pickerCellCls}-in-range,
      &-in-view${pickerCellCls}-range-start,
      &-in-view${pickerCellCls}-range-end`]: {
			position: "relative",
			[`&:not(${pickerCellCls}-disabled):before`]: { background: cellActiveWithRangeBg }
		},
		[`&-in-view${pickerCellCls}-selected,
      &-in-view${pickerCellCls}-range-start,
      &-in-view${pickerCellCls}-range-end`]: {
			[`&:not(${pickerCellCls}-disabled) ${pickerCellInnerCls}`]: {
				color: colorTextLightSolid,
				background: colorPrimary
			},
			[`&${pickerCellCls}-disabled ${pickerCellInnerCls}`]: { background: colorFillSecondary }
		},
		[`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-disabled):before`]: { insetInlineStart: "50%" },
		[`&-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-disabled):before`]: { insetInlineEnd: "50%" },
		[`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-range-end) ${pickerCellInnerCls}`]: {
			borderStartStartRadius: borderRadiusSM,
			borderEndStartRadius: borderRadiusSM,
			borderStartEndRadius: 0,
			borderEndEndRadius: 0
		},
		[`&-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-range-start) ${pickerCellInnerCls}`]: {
			borderStartStartRadius: 0,
			borderEndStartRadius: 0,
			borderStartEndRadius: borderRadiusSM,
			borderEndEndRadius: borderRadiusSM
		},
		"&-disabled": {
			color: colorTextDisabled,
			cursor: "not-allowed",
			[pickerCellInnerCls]: { background: "transparent" },
			"&::before": { background: cellBgDisabled }
		},
		[`&-disabled${pickerCellCls}-today ${pickerCellInnerCls}::before`]: { borderColor: colorTextDisabled }
	};
};
const genPanelStyle$2 = (token$1) => {
	const { componentCls, pickerCellCls, pickerCellInnerCls, pickerYearMonthCellWidth, pickerControlIconSize, cellWidth, paddingSM, paddingXS, paddingXXS, colorBgContainer, lineWidth, lineType, borderRadiusLG, colorPrimary, colorTextHeading, colorSplit, pickerControlIconBorderWidth, colorIcon, textHeight, motionDurationMid, colorIconHover, fontWeightStrong, cellHeight, pickerCellPaddingVertical, colorTextDisabled, colorText, fontSize, motionDurationSlow, withoutTimeCellHeight, pickerQuarterPanelContentHeight, borderRadiusSM, colorTextLightSolid, cellHoverBg, timeColumnHeight, timeColumnWidth, timeCellHeight, controlItemBgActive, marginXXS, pickerDatePanelPaddingHorizontal, pickerControlIconMargin } = token$1;
	const pickerPanelWidth = token$1.calc(cellWidth).mul(7).add(token$1.calc(pickerDatePanelPaddingHorizontal).mul(2)).equal();
	return { [componentCls]: {
		"&-panel": {
			display: "inline-flex",
			flexDirection: "column",
			textAlign: "center",
			background: colorBgContainer,
			borderRadius: borderRadiusLG,
			outline: "none",
			"&-focused": { borderColor: colorPrimary },
			"&-rtl": {
				[`${componentCls}-prev-icon,
              ${componentCls}-super-prev-icon`]: { transform: "rotate(45deg)" },
				[`${componentCls}-next-icon,
              ${componentCls}-super-next-icon`]: { transform: "rotate(-135deg)" },
				[`${componentCls}-time-panel`]: { [`${componentCls}-content`]: {
					direction: "ltr",
					"> *": { direction: "rtl" }
				} }
			}
		},
		[`&-decade-panel,
        &-year-panel,
        &-quarter-panel,
        &-month-panel,
        &-week-panel,
        &-date-panel,
        &-time-panel`]: {
			display: "flex",
			flexDirection: "column",
			width: pickerPanelWidth
		},
		"&-header": {
			display: "flex",
			padding: `0 ${unit(paddingXS)}`,
			color: colorTextHeading,
			borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
			"> *": { flex: "none" },
			button: {
				padding: 0,
				color: colorIcon,
				lineHeight: unit(textHeight),
				background: "transparent",
				border: 0,
				cursor: "pointer",
				transition: `color ${motionDurationMid}`,
				fontSize: "inherit",
				display: "inline-flex",
				alignItems: "center",
				justifyContent: "center",
				"&:empty": { display: "none" }
			},
			"> button": {
				minWidth: "1.6em",
				fontSize,
				"&:hover": { color: colorIconHover },
				"&:disabled": {
					opacity: .25,
					pointerEvents: "none"
				}
			},
			"&-view": {
				flex: "auto",
				fontWeight: fontWeightStrong,
				lineHeight: unit(textHeight),
				"> button": {
					color: "inherit",
					fontWeight: "inherit",
					verticalAlign: "top",
					"&:not(:first-child)": { marginInlineStart: paddingXS },
					"&:hover": { color: colorPrimary }
				}
			}
		},
		[`&-prev-icon,
        &-next-icon,
        &-super-prev-icon,
        &-super-next-icon`]: {
			position: "relative",
			width: pickerControlIconSize,
			height: pickerControlIconSize,
			"&::before": {
				position: "absolute",
				top: 0,
				insetInlineStart: 0,
				width: pickerControlIconSize,
				height: pickerControlIconSize,
				border: `0 solid currentcolor`,
				borderBlockStartWidth: pickerControlIconBorderWidth,
				borderInlineStartWidth: pickerControlIconBorderWidth,
				content: "\"\""
			}
		},
		[`&-super-prev-icon,
        &-super-next-icon`]: { "&::after": {
			position: "absolute",
			top: pickerControlIconMargin,
			insetInlineStart: pickerControlIconMargin,
			display: "inline-block",
			width: pickerControlIconSize,
			height: pickerControlIconSize,
			border: "0 solid currentcolor",
			borderBlockStartWidth: pickerControlIconBorderWidth,
			borderInlineStartWidth: pickerControlIconBorderWidth,
			content: "\"\""
		} },
		"&-prev-icon, &-super-prev-icon": { transform: "rotate(-45deg)" },
		"&-next-icon, &-super-next-icon": { transform: "rotate(135deg)" },
		"&-content": {
			width: "100%",
			tableLayout: "fixed",
			borderCollapse: "collapse",
			"th, td": {
				position: "relative",
				minWidth: cellHeight,
				fontWeight: "normal"
			},
			th: {
				height: token$1.calc(cellHeight).add(token$1.calc(pickerCellPaddingVertical).mul(2)).equal(),
				color: colorText,
				verticalAlign: "middle"
			}
		},
		"&-cell": {
			padding: `${unit(pickerCellPaddingVertical)} 0`,
			color: colorTextDisabled,
			cursor: "pointer",
			"&-in-view": { color: colorText },
			...genPickerCellInnerStyle(token$1)
		},
		[`&-decade-panel,
        &-year-panel,
        &-quarter-panel,
        &-month-panel`]: {
			[`${componentCls}-content`]: { height: token$1.calc(withoutTimeCellHeight).mul(4).equal() },
			[pickerCellInnerCls]: { padding: `0 ${unit(paddingXS)}` }
		},
		"&-quarter-panel": { [`${componentCls}-content`]: { height: pickerQuarterPanelContentHeight } },
		"&-decade-panel": {
			[pickerCellInnerCls]: { padding: `0 ${unit(token$1.calc(paddingXS).div(2).equal())}` },
			[`${componentCls}-cell::before`]: { display: "none" }
		},
		[`&-year-panel,
        &-quarter-panel,
        &-month-panel`]: {
			[`${componentCls}-body`]: { padding: `0 ${unit(paddingXS)}` },
			[pickerCellInnerCls]: { width: pickerYearMonthCellWidth }
		},
		"&-date-panel": {
			[`${componentCls}-body`]: { padding: `${unit(paddingXS)} ${unit(pickerDatePanelPaddingHorizontal)}` },
			[`${componentCls}-content th`]: {
				boxSizing: "border-box",
				padding: 0
			}
		},
		"&-week-panel-row": {
			td: {
				"&:before": { transition: `background ${motionDurationMid}` },
				"&:first-child:before": {
					borderStartStartRadius: borderRadiusSM,
					borderEndStartRadius: borderRadiusSM
				},
				"&:last-child:before": {
					borderStartEndRadius: borderRadiusSM,
					borderEndEndRadius: borderRadiusSM
				}
			},
			"&:hover td:before": { background: cellHoverBg },
			"&-range-start td, &-range-end td, &-selected td, &-hover td": { [`&${pickerCellCls}`]: {
				"&:before": { background: colorPrimary },
				[`&${componentCls}-cell-week`]: { color: new FastColor(colorTextLightSolid).setA(.5).toHexString() },
				[pickerCellInnerCls]: { color: colorTextLightSolid }
			} },
			"&-range-hover td:before": { background: controlItemBgActive }
		},
		"&-week-panel, &-date-panel-show-week": {
			[`${componentCls}-body`]: { padding: `${unit(paddingXS)} ${unit(paddingSM)}` },
			[`${componentCls}-content th`]: { width: "auto" }
		},
		"&-datetime-panel": {
			display: "flex",
			[`${componentCls}-time-panel`]: { borderInlineStart: `${unit(lineWidth)} ${lineType} ${colorSplit}` },
			[`${componentCls}-date-panel,
          ${componentCls}-time-panel`]: { transition: `opacity ${motionDurationSlow}` },
			"&-active": { [`${componentCls}-date-panel,
            ${componentCls}-time-panel`]: {
				opacity: .3,
				"&-active": { opacity: 1 }
			} }
		},
		"&-time-panel": {
			width: "auto",
			minWidth: "auto",
			[`${componentCls}-content`]: {
				display: "flex",
				flex: "auto",
				height: timeColumnHeight
			},
			"&-column": {
				flex: "1 0 auto",
				width: timeColumnWidth,
				margin: `${unit(paddingXXS)} 0`,
				padding: 0,
				overflowY: "hidden",
				textAlign: "start",
				listStyle: "none",
				transition: `background ${motionDurationMid}`,
				overflowX: "hidden",
				"&::-webkit-scrollbar": {
					width: 8,
					backgroundColor: "transparent"
				},
				"&::-webkit-scrollbar-thumb": {
					backgroundColor: token$1.colorTextTertiary,
					borderRadius: token$1.borderRadiusSM
				},
				"&": {
					scrollbarWidth: "thin",
					scrollbarColor: `${token$1.colorTextTertiary} transparent`
				},
				"&::after": {
					display: "block",
					height: `calc(100% - ${unit(timeCellHeight)})`,
					content: "\"\""
				},
				"&:not(:first-child)": { borderInlineStart: `${unit(lineWidth)} ${lineType} ${colorSplit}` },
				"&-active": { background: new FastColor(controlItemBgActive).setA(.2).toHexString() },
				"&:hover": { overflowY: "auto" },
				"> li": {
					margin: 0,
					padding: 0,
					[`&${componentCls}-time-panel-cell`]: {
						marginInline: marginXXS,
						[`${componentCls}-time-panel-cell-inner`]: {
							display: "block",
							width: token$1.calc(timeColumnWidth).sub(token$1.calc(marginXXS).mul(2)).equal(),
							height: timeCellHeight,
							margin: 0,
							paddingBlock: 0,
							paddingInlineEnd: 0,
							paddingInlineStart: token$1.calc(timeColumnWidth).sub(timeCellHeight).div(2).equal(),
							color: colorText,
							lineHeight: unit(timeCellHeight),
							borderRadius: borderRadiusSM,
							cursor: "pointer",
							transition: `background ${motionDurationMid}`,
							"&:hover": { background: cellHoverBg }
						},
						"&-selected": { [`${componentCls}-time-panel-cell-inner`]: { background: controlItemBgActive } },
						"&-disabled": { [`${componentCls}-time-panel-cell-inner`]: {
							color: colorTextDisabled,
							background: "transparent",
							cursor: "not-allowed"
						} }
					}
				}
			}
		}
	} };
};
var genPickerPanelStyle = (token$1) => {
	const { componentCls, textHeight, lineWidth, paddingSM, antCls, colorPrimary, cellActiveWithRangeBg, colorPrimaryBorder, lineType, colorSplit } = token$1;
	return { [`${componentCls}-dropdown`]: {
		[`${componentCls}-footer`]: {
			borderTop: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
			"&-extra": {
				padding: `0 ${unit(paddingSM)}`,
				lineHeight: unit(token$1.calc(textHeight).sub(token$1.calc(lineWidth).mul(2)).equal()),
				textAlign: "start",
				"&:not(:last-child)": { borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}` }
			}
		},
		[`${componentCls}-panels + ${componentCls}-footer ${componentCls}-ranges`]: { justifyContent: "space-between" },
		[`${componentCls}-ranges`]: {
			marginBlock: 0,
			paddingInline: unit(paddingSM),
			overflow: "hidden",
			textAlign: "start",
			listStyle: "none",
			display: "flex",
			justifyContent: "center",
			alignItems: "center",
			"> li": {
				lineHeight: unit(token$1.calc(textHeight).sub(token$1.calc(lineWidth).mul(2)).equal()),
				display: "inline-block"
			},
			[`${componentCls}-now-btn-disabled`]: {
				pointerEvents: "none",
				color: token$1.colorTextDisabled
			},
			[`${componentCls}-preset > ${antCls}-tag-blue`]: {
				color: colorPrimary,
				background: cellActiveWithRangeBg,
				borderColor: colorPrimaryBorder,
				cursor: "pointer"
			},
			[`${componentCls}-ok`]: {
				paddingBlock: token$1.calc(lineWidth).mul(2).equal(),
				marginInlineStart: "auto"
			}
		}
	} };
};
var panel_default$2 = genPickerPanelStyle;

//#endregion
//#region node_modules/antd/es/date-picker/style/token.js
const initPickerPanelToken = (token$1) => {
	const { componentCls, controlHeightLG, paddingXXS, padding } = token$1;
	return {
		pickerCellCls: `${componentCls}-cell`,
		pickerCellInnerCls: `${componentCls}-cell-inner`,
		pickerYearMonthCellWidth: token$1.calc(controlHeightLG).mul(1.5).equal(),
		pickerQuarterPanelContentHeight: token$1.calc(controlHeightLG).mul(1.4).equal(),
		pickerCellPaddingVertical: token$1.calc(paddingXXS).add(token$1.calc(paddingXXS).div(2)).equal(),
		pickerCellBorderGap: 2,
		pickerControlIconSize: 7,
		pickerControlIconMargin: 4,
		pickerControlIconBorderWidth: 1.5,
		pickerDatePanelPaddingHorizontal: token$1.calc(padding).add(token$1.calc(paddingXXS).div(2)).equal()
	};
};
const initPanelComponentToken = (token$1) => {
	const { colorBgContainerDisabled, controlHeight, controlHeightSM, controlHeightLG, paddingXXS, lineWidth } = token$1;
	const dblPaddingXXS = paddingXXS * 2;
	const dblLineWidth = lineWidth * 2;
	const multipleItemHeight = Math.min(controlHeight - dblPaddingXXS, controlHeight - dblLineWidth);
	const multipleItemHeightSM = Math.min(controlHeightSM - dblPaddingXXS, controlHeightSM - dblLineWidth);
	const multipleItemHeightLG = Math.min(controlHeightLG - dblPaddingXXS, controlHeightLG - dblLineWidth);
	return {
		INTERNAL_FIXED_ITEM_MARGIN: Math.floor(paddingXXS / 2),
		cellHoverBg: token$1.controlItemBgHover,
		cellActiveWithRangeBg: token$1.controlItemBgActive,
		cellHoverWithRangeBg: new FastColor(token$1.colorPrimary).lighten(35).toHexString(),
		cellRangeBorderColor: new FastColor(token$1.colorPrimary).lighten(20).toHexString(),
		cellBgDisabled: colorBgContainerDisabled,
		timeColumnWidth: controlHeightLG * 1.4,
		timeColumnHeight: 224,
		timeCellHeight: 28,
		cellWidth: controlHeightSM * 1.5,
		cellHeight: controlHeightSM,
		textHeight: controlHeightLG,
		withoutTimeCellHeight: controlHeightLG * 1.65,
		multipleItemBg: token$1.colorFillSecondary,
		multipleItemBorderColor: "transparent",
		multipleItemHeight,
		multipleItemHeightSM,
		multipleItemHeightLG,
		multipleSelectorBgDisabled: colorBgContainerDisabled,
		multipleItemColorDisabled: token$1.colorTextDisabled,
		multipleItemBorderColorDisabled: "transparent"
	};
};
const prepareComponentToken$36 = (token$1) => ({
	...initComponentToken$1(token$1),
	...initPanelComponentToken(token$1),
	...getArrowToken(token$1),
	presetsWidth: 120,
	presetsMaxWidth: 200,
	zIndexPopup: token$1.zIndexPopupBase + 50
});

//#endregion
//#region node_modules/antd/es/date-picker/style/variants.js
var genVariantsStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: [{
		...genOutlinedStyle(token$1),
		...genUnderlinedStyle(token$1),
		...genFilledStyle(token$1),
		...genBorderlessStyle(token$1)
	}, {
		"&-outlined": { [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
			background: token$1.multipleItemBg,
			border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.multipleItemBorderColor}`
		} },
		"&-filled": { [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
			background: token$1.colorBgContainer,
			border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}`
		} },
		"&-borderless": { [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
			background: token$1.multipleItemBg,
			border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.multipleItemBorderColor}`
		} },
		"&-underlined": { [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
			background: token$1.multipleItemBg,
			border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.multipleItemBorderColor}`
		} }
	}] };
};
var variants_default = genVariantsStyle;

//#endregion
//#region node_modules/antd/es/date-picker/style/index.js
var genPickerPadding = (paddingBlock, paddingInline) => {
	return { padding: `${unit(paddingBlock)} ${unit(paddingInline)}` };
};
var genPickerStatusStyle = (token$1) => {
	const { componentCls, colorError, colorWarning } = token$1;
	return { [`${componentCls}:not(${componentCls}-disabled):not([disabled])`]: {
		[`&${componentCls}-status-error`]: { [`${componentCls}-active-bar`]: { background: colorError } },
		[`&${componentCls}-status-warning`]: { [`${componentCls}-active-bar`]: { background: colorWarning } }
	} };
};
var genPickerStyle$1 = (token$1) => {
	const { componentCls, antCls, paddingInline, lineWidth, lineType, colorBorder, borderRadius, motionDurationMid, colorTextDisabled, colorTextPlaceholder, colorTextQuaternary, fontSizeLG, inputFontSizeLG, fontSizeSM, inputFontSizeSM, controlHeightSM, paddingInlineSM, paddingXS, marginXS, colorIcon, lineWidthBold, colorPrimary, motionDurationSlow, zIndexPopup, paddingXXS, sizePopupArrow, colorBgElevated, borderRadiusLG, boxShadowSecondary, borderRadiusSM, colorSplit, cellHoverBg, presetsWidth, presetsMaxWidth, boxShadowPopoverArrow, fontHeight, lineHeightLG } = token$1;
	return [
		{ [componentCls]: {
			...resetComponent(token$1),
			...genPickerPadding(token$1.paddingBlock, token$1.paddingInline),
			position: "relative",
			display: "inline-flex",
			alignItems: "center",
			lineHeight: 1,
			borderRadius,
			transition: `border ${motionDurationMid}, box-shadow ${motionDurationMid}, background ${motionDurationMid}`,
			[`${componentCls}-prefix`]: {
				flex: "0 0 auto",
				marginInlineEnd: token$1.inputAffixPadding
			},
			[`${componentCls}-input`]: {
				position: "relative",
				display: "inline-flex",
				alignItems: "center",
				width: "100%",
				"> input": {
					position: "relative",
					display: "inline-block",
					width: "100%",
					color: "inherit",
					fontSize: token$1.inputFontSize ?? token$1.fontSize,
					lineHeight: token$1.lineHeight,
					transition: `all ${motionDurationMid}`,
					...genPlaceholderStyle(colorTextPlaceholder),
					flex: "auto",
					minWidth: 1,
					height: "auto",
					padding: 0,
					background: "transparent",
					border: 0,
					fontFamily: "inherit",
					"&:focus": {
						boxShadow: "none",
						outline: 0
					},
					"&[disabled]": {
						background: "transparent",
						color: colorTextDisabled,
						cursor: "not-allowed"
					}
				},
				"&-placeholder": { "> input": { color: colorTextPlaceholder } }
			},
			"&-large": {
				...genPickerPadding(token$1.paddingBlockLG, token$1.paddingInlineLG),
				borderRadius: token$1.borderRadiusLG,
				[`${componentCls}-input > input`]: {
					fontSize: inputFontSizeLG ?? fontSizeLG,
					lineHeight: lineHeightLG
				}
			},
			"&-small": {
				...genPickerPadding(token$1.paddingBlockSM, token$1.paddingInlineSM),
				borderRadius: token$1.borderRadiusSM,
				[`${componentCls}-input > input`]: { fontSize: inputFontSizeSM ?? fontSizeSM }
			},
			[`${componentCls}-suffix`]: {
				display: "flex",
				flex: "none",
				alignSelf: "center",
				marginInlineStart: token$1.calc(paddingXS).div(2).equal(),
				color: colorTextQuaternary,
				lineHeight: 1,
				pointerEvents: "none",
				transition: `opacity ${motionDurationMid}, color ${motionDurationMid}`,
				"> *": {
					verticalAlign: "top",
					"&:not(:last-child)": { marginInlineEnd: marginXS }
				}
			},
			[`${componentCls}-clear`]: {
				position: "absolute",
				top: "50%",
				insetInlineEnd: 0,
				color: colorTextQuaternary,
				lineHeight: 1,
				transform: "translateY(-50%)",
				cursor: "pointer",
				opacity: 0,
				transition: `opacity ${motionDurationMid}, color ${motionDurationMid}`,
				"> *": { verticalAlign: "top" },
				"&:hover": { color: colorIcon }
			},
			"&:hover": {
				[`${componentCls}-clear`]: { opacity: 1 },
				[`${componentCls}-suffix:not(:last-child)`]: { opacity: 0 }
			},
			[`${componentCls}-separator`]: {
				position: "relative",
				display: "inline-block",
				width: "1em",
				height: fontSizeLG,
				color: colorTextQuaternary,
				fontSize: fontSizeLG,
				verticalAlign: "top",
				cursor: "default",
				[`${componentCls}-focused &`]: { color: colorIcon },
				[`${componentCls}-range-separator &`]: { [`${componentCls}-disabled &`]: { cursor: "not-allowed" } }
			},
			"&-range": {
				position: "relative",
				display: "inline-flex",
				[`${componentCls}-active-bar`]: {
					bottom: token$1.calc(lineWidth).mul(-1).equal(),
					height: lineWidthBold,
					background: colorPrimary,
					opacity: 0,
					transition: `all ${motionDurationSlow} ease-out`,
					pointerEvents: "none"
				},
				[`&${componentCls}-focused`]: { [`${componentCls}-active-bar`]: { opacity: 1 } },
				[`${componentCls}-range-separator`]: {
					alignItems: "center",
					padding: `0 ${unit(paddingXS)}`,
					lineHeight: 1
				}
			},
			"&-range, &-multiple": {
				[`${componentCls}-clear`]: { insetInlineEnd: paddingInline },
				[`&${componentCls}-small`]: { [`${componentCls}-clear`]: { insetInlineEnd: paddingInlineSM } }
			},
			"&-dropdown": {
				...resetComponent(token$1),
				...genPanelStyle$2(token$1),
				pointerEvents: "none",
				position: "absolute",
				top: -9999,
				left: {
					_skip_check_: true,
					value: -9999
				},
				zIndex: zIndexPopup,
				[`&${componentCls}-dropdown-hidden`]: { display: "none" },
				"&-rtl": { direction: "rtl" },
				[`&${componentCls}-dropdown-placement-bottomLeft,
            &${componentCls}-dropdown-placement-bottomRight`]: { [`${componentCls}-range-arrow`]: {
					top: 0,
					display: "block",
					transform: "translateY(-100%)"
				} },
				[`&${componentCls}-dropdown-placement-topLeft,
            &${componentCls}-dropdown-placement-topRight`]: { [`${componentCls}-range-arrow`]: {
					bottom: 0,
					display: "block",
					transform: "translateY(100%) rotate(180deg)"
				} },
				[`&${antCls}-slide-up-appear, &${antCls}-slide-up-enter`]: { [`${componentCls}-range-arrow${componentCls}-range-arrow`]: { transition: "none" } },
				[`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topRight`]: { animationName: slideDownIn },
				[`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomRight`]: { animationName: slideUpIn },
				[`&${antCls}-slide-up-leave ${componentCls}-panel-container`]: { pointerEvents: "none" },
				[`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topRight`]: { animationName: slideDownOut },
				[`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomRight`]: { animationName: slideUpOut },
				[`${componentCls}-panel > ${componentCls}-time-panel`]: { paddingTop: paddingXXS },
				[`${componentCls}-range-wrapper`]: {
					display: "flex",
					position: "relative"
				},
				[`${componentCls}-range-arrow`]: {
					position: "absolute",
					zIndex: 1,
					display: "none",
					paddingInline: token$1.calc(paddingInline).mul(1.5).equal(),
					boxSizing: "content-box",
					transition: `all ${motionDurationSlow} ease-out`,
					...genRoundedArrow(token$1, colorBgElevated, boxShadowPopoverArrow),
					"&:before": { insetInlineStart: token$1.calc(paddingInline).mul(1.5).equal() }
				},
				[`${componentCls}-panel-container`]: {
					overflow: "hidden",
					verticalAlign: "top",
					background: colorBgElevated,
					borderRadius: borderRadiusLG,
					boxShadow: boxShadowSecondary,
					transition: `margin ${motionDurationSlow}`,
					display: "inline-block",
					pointerEvents: "auto",
					[`${componentCls}-panel-layout`]: {
						display: "flex",
						flexWrap: "nowrap",
						alignItems: "stretch"
					},
					[`${componentCls}-presets`]: {
						display: "flex",
						flexDirection: "column",
						minWidth: presetsWidth,
						maxWidth: presetsMaxWidth,
						ul: {
							height: 0,
							flex: "auto",
							listStyle: "none",
							overflow: "auto",
							margin: 0,
							padding: paddingXS,
							borderInlineEnd: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
							li: {
								...textEllipsis,
								borderRadius: borderRadiusSM,
								paddingInline: paddingXS,
								paddingBlock: token$1.calc(controlHeightSM).sub(fontHeight).div(2).equal(),
								cursor: "pointer",
								transition: `all ${motionDurationSlow}`,
								"+ li": { marginTop: marginXS },
								"&:hover": { background: cellHoverBg }
							}
						}
					},
					[`${componentCls}-panels`]: {
						display: "inline-flex",
						flexWrap: "nowrap",
						"&:last-child": { [`${componentCls}-panel`]: { borderWidth: 0 } }
					},
					[`${componentCls}-panel`]: {
						verticalAlign: "top",
						background: "transparent",
						borderRadius: 0,
						borderWidth: 0,
						[`${componentCls}-content, table`]: { textAlign: "center" },
						"&-focused": { borderColor: colorBorder }
					}
				}
			},
			"&-dropdown-range": {
				padding: `${unit(token$1.calc(sizePopupArrow).mul(2).div(3).equal())} 0`,
				"&-hidden": { display: "none" }
			},
			"&-rtl": {
				direction: "rtl",
				[`${componentCls}-separator`]: { transform: "scale(-1, 1)" },
				[`${componentCls}-footer`]: { "&-extra": { direction: "rtl" } }
			}
		} },
		initSlideMotion(token$1, "slide-up"),
		initSlideMotion(token$1, "slide-down"),
		initMoveMotion(token$1, "move-up"),
		initMoveMotion(token$1, "move-down")
	];
};
var style_default$33 = genStyleHooks("DatePicker", (token$1) => {
	const pickerToken = merge(initInputToken(token$1), initPickerPanelToken(token$1), {
		inputPaddingHorizontalBase: token$1.calc(token$1.paddingSM).sub(1).equal(),
		multipleSelectItemHeight: token$1.multipleItemHeight,
		selectHeight: token$1.controlHeight
	});
	return [
		panel_default$2(pickerToken),
		genPickerStyle$1(pickerToken),
		variants_default(pickerToken),
		genPickerStatusStyle(pickerToken),
		multiple_default(pickerToken),
		genCompactItemStyle(token$1, { focusElCls: `${token$1.componentCls}-focused` })
	];
}, prepareComponentToken$36);

//#endregion
//#region node_modules/antd/es/calendar/style/index.js
const genCalendarStyles = (token$1) => {
	const { calendarCls, componentCls, fullBg, fullPanelBg, itemActiveBg } = token$1;
	return {
		[calendarCls]: {
			...genPanelStyle$2(token$1),
			...resetComponent(token$1),
			background: fullBg,
			"&-rtl": { direction: "rtl" },
			[`${calendarCls}-header`]: {
				display: "flex",
				justifyContent: "flex-end",
				padding: `${unit(token$1.paddingSM)} 0`,
				[`${calendarCls}-year-select`]: { minWidth: token$1.yearControlWidth },
				[`${calendarCls}-month-select`]: {
					minWidth: token$1.monthControlWidth,
					marginInlineStart: token$1.marginXS
				},
				[`${calendarCls}-mode-switch`]: { marginInlineStart: token$1.marginXS }
			}
		},
		[`${calendarCls} ${componentCls}-panel`]: {
			background: fullPanelBg,
			border: 0,
			borderTop: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}`,
			borderRadius: 0,
			[`${componentCls}-month-panel, ${componentCls}-date-panel`]: { width: "auto" },
			[`${componentCls}-body`]: { padding: `${unit(token$1.paddingXS)} 0` },
			[`${componentCls}-content`]: { width: "100%" }
		},
		[`${calendarCls}-mini`]: {
			borderRadius: token$1.borderRadiusLG,
			[`${calendarCls}-header`]: {
				paddingInlineEnd: token$1.paddingXS,
				paddingInlineStart: token$1.paddingXS
			},
			[`${componentCls}-panel`]: { borderRadius: `0 0 ${unit(token$1.borderRadiusLG)} ${unit(token$1.borderRadiusLG)}` },
			[`${componentCls}-content`]: {
				height: token$1.miniContentHeight,
				th: {
					height: "auto",
					padding: 0,
					lineHeight: unit(token$1.weekHeight)
				}
			},
			[`${componentCls}-cell::before`]: { pointerEvents: "none" }
		},
		[`${calendarCls}${calendarCls}-full`]: {
			[`${componentCls}-panel`]: {
				display: "block",
				width: "100%",
				textAlign: "end",
				background: fullBg,
				border: 0,
				[`${componentCls}-body`]: {
					"th, td": { padding: 0 },
					th: {
						height: "auto",
						paddingInlineEnd: token$1.paddingSM,
						paddingBottom: token$1.paddingXXS,
						lineHeight: unit(token$1.weekHeight)
					}
				}
			},
			[`${componentCls}-cell-week ${componentCls}-cell-inner`]: {
				display: "block",
				borderRadius: 0,
				borderTop: `${unit(token$1.lineWidthBold)} ${token$1.lineType} ${token$1.colorSplit}`,
				width: "100%",
				height: token$1.calc(token$1.dateValueHeight).add(token$1.dateContentHeight).add(token$1.calc(token$1.paddingXS).div(2)).add(token$1.lineWidthBold).equal()
			},
			[`${componentCls}-cell`]: {
				"&::before": { display: "none" },
				"&:hover": { [`${calendarCls}-date`]: { background: token$1.controlItemBgHover } },
				[`${calendarCls}-date-today::before`]: { display: "none" },
				[`&-in-view${componentCls}-cell-selected`]: { [`${calendarCls}-date, ${calendarCls}-date-today`]: { background: itemActiveBg } },
				"&-selected, &-selected:hover": { [`${calendarCls}-date, ${calendarCls}-date-today`]: { [`${calendarCls}-date-value`]: { color: token$1.colorPrimary } } }
			},
			[`${calendarCls}-date`]: {
				display: "block",
				width: "auto",
				height: "auto",
				margin: `0 ${unit(token$1.calc(token$1.marginXS).div(2).equal())}`,
				padding: `${unit(token$1.calc(token$1.paddingXS).div(2).equal())} ${unit(token$1.paddingXS)} 0`,
				border: 0,
				borderTop: `${unit(token$1.lineWidthBold)} ${token$1.lineType} ${token$1.colorSplit}`,
				borderRadius: 0,
				transition: `background ${token$1.motionDurationSlow}`,
				"&-value": {
					lineHeight: unit(token$1.dateValueHeight),
					transition: `color ${token$1.motionDurationSlow}`
				},
				"&-content": {
					position: "static",
					width: "auto",
					height: token$1.dateContentHeight,
					overflowY: "auto",
					color: token$1.colorText,
					lineHeight: token$1.lineHeight,
					textAlign: "start"
				},
				"&-today": {
					borderColor: token$1.colorPrimary,
					[`${calendarCls}-date-value`]: { color: token$1.colorText }
				}
			}
		},
		[`@media only screen and (max-width: ${unit(token$1.screenXS)}) `]: { [calendarCls]: { [`${calendarCls}-header`]: {
			display: "block",
			[`${calendarCls}-year-select`]: { width: "50%" },
			[`${calendarCls}-month-select`]: { width: `calc(50% - ${unit(token$1.paddingXS)})` },
			[`${calendarCls}-mode-switch`]: {
				width: "100%",
				marginTop: token$1.marginXS,
				marginInlineStart: 0,
				"> label": {
					width: "50%",
					textAlign: "center"
				}
			}
		} } }
	};
};
const prepareComponentToken$35 = (token$1) => ({
	fullBg: token$1.colorBgContainer,
	fullPanelBg: token$1.colorBgContainer,
	itemActiveBg: token$1.controlItemBgActive,
	yearControlWidth: 80,
	monthControlWidth: 70,
	miniContentHeight: 256,
	...initPanelComponentToken(token$1)
});
var style_default$44 = genStyleHooks("Calendar", (token$1) => {
	const calendarCls = `${token$1.componentCls}-calendar`;
	return genCalendarStyles(merge(token$1, initPickerPanelToken(token$1), {
		calendarCls,
		pickerCellInnerCls: `${token$1.componentCls}-cell-inner`,
		dateValueHeight: token$1.controlHeightSM,
		weekHeight: token$1.calc(token$1.controlHeightSM).mul(.75).equal(),
		dateContentHeight: token$1.calc(token$1.calc(token$1.fontHeightSM).add(token$1.marginXS)).mul(3).add(token$1.calc(token$1.lineWidth).mul(2)).equal()
	}));
}, prepareComponentToken$35);

//#endregion
//#region node_modules/antd/es/calendar/generateCalendar.js
var isSameYear = (date1, date2, config) => {
	const { getYear } = config;
	return date1 && date2 && getYear(date1) === getYear(date2);
};
var isSameMonth = (date1, date2, config) => {
	const { getMonth } = config;
	return isSameYear(date1, date2, config) && getMonth(date1) === getMonth(date2);
};
var isSameDate = (date1, date2, config) => {
	const { getDate } = config;
	return isSameMonth(date1, date2, config) && getDate(date1) === getDate(date2);
};
var generateCalendar = (generateConfig$1) => {
	const Calendar$1 = (props) => {
		const { prefixCls: customizePrefixCls, className, rootClassName, style: style$1, dateFullCellRender, dateCellRender, monthFullCellRender, monthCellRender, cellRender, fullCellRender, headerRender, value, defaultValue, disabledDate, mode, validRange, fullscreen = true, showWeek, onChange, onPanelChange, onSelect, styles, classNames } = props;
		const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("calendar");
		const mergedProps = {
			...props,
			mode,
			fullscreen,
			showWeek
		};
		const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
		const [rootCls, headerCls, panelClassNames, rootStyle, headerStyle, panelStyles] = import_react.useMemo(() => {
			const { root: nextRootClassName, header: nextHeaderClassName, ...nextPanelClassNames } = mergedClassNames;
			const { root: nextRootStyle, header: nextHeaderStyle, ...nextPanelStyles } = mergedStyles;
			return [
				nextRootClassName,
				nextHeaderClassName,
				nextPanelClassNames,
				nextRootStyle,
				nextHeaderStyle,
				nextPanelStyles
			];
		}, [mergedClassNames, mergedStyles]);
		const prefixCls = getPrefixCls("picker", customizePrefixCls);
		const calendarPrefixCls = `${prefixCls}-calendar`;
		const [hashId, cssVarCls] = style_default$44(prefixCls, calendarPrefixCls);
		const today = generateConfig$1.getNow();
		{
			const warning$3 = devUseWarning("Calendar");
			[
				["dateFullCellRender", "fullCellRender"],
				["dateCellRender", "cellRender"],
				["monthFullCellRender", "fullCellRender"],
				["monthCellRender", "cellRender"]
			].forEach(([deprecatedName, newName]) => {
				warning$3.deprecated(!(deprecatedName in props), deprecatedName, newName);
			});
		}
		const [mergedValue, setMergedValue] = useControlledState(() => defaultValue || generateConfig$1.getNow(), value);
		const [mergedMode, setMergedMode] = useControlledState("month", mode);
		const panelMode = import_react.useMemo(() => mergedMode === "year" ? "month" : "date", [mergedMode]);
		const mergedDisabledDate = import_react.useCallback((date$1) => {
			return (validRange ? generateConfig$1.isAfter(validRange[0], date$1) || generateConfig$1.isAfter(date$1, validRange[1]) : false) || !!disabledDate?.(date$1);
		}, [disabledDate, validRange]);
		const triggerPanelChange = (date$1, newMode) => {
			onPanelChange?.(date$1, newMode);
		};
		const triggerChange = (date$1) => {
			setMergedValue(date$1);
			if (!isSameDate(date$1, mergedValue, generateConfig$1)) {
				if (panelMode === "date" && !isSameMonth(date$1, mergedValue, generateConfig$1) || panelMode === "month" && !isSameYear(date$1, mergedValue, generateConfig$1)) triggerPanelChange(date$1, mergedMode);
				onChange?.(date$1);
			}
		};
		const triggerModeChange = (newMode) => {
			setMergedMode(newMode);
			triggerPanelChange(mergedValue, newMode);
		};
		const onInternalSelect = (date$1, source) => {
			triggerChange(date$1);
			onSelect?.(date$1, { source });
		};
		const dateRender = import_react.useCallback((date$1, info) => {
			if (fullCellRender) return fullCellRender(date$1, info);
			if (dateFullCellRender) return dateFullCellRender(date$1);
			return /* @__PURE__ */ import_react.createElement("div", { className: clsx(`${prefixCls}-cell-inner`, `${calendarPrefixCls}-date`, { [`${calendarPrefixCls}-date-today`]: isSameDate(today, date$1, generateConfig$1) }) }, /* @__PURE__ */ import_react.createElement("div", { className: `${calendarPrefixCls}-date-value` }, String(generateConfig$1.getDate(date$1)).padStart(2, "0")), /* @__PURE__ */ import_react.createElement("div", { className: `${calendarPrefixCls}-date-content` }, typeof cellRender === "function" ? cellRender(date$1, info) : dateCellRender?.(date$1)));
		}, [
			today,
			prefixCls,
			calendarPrefixCls,
			fullCellRender,
			dateFullCellRender,
			cellRender,
			dateCellRender
		]);
		const monthRender = import_react.useCallback((date$1, info) => {
			if (fullCellRender) return fullCellRender(date$1, info);
			if (monthFullCellRender) return monthFullCellRender(date$1);
			const months = info.locale.shortMonths || generateConfig$1.locale.getShortMonths(info.locale.locale);
			return /* @__PURE__ */ import_react.createElement("div", { className: clsx(`${prefixCls}-cell-inner`, `${calendarPrefixCls}-date`, { [`${calendarPrefixCls}-date-today`]: isSameMonth(today, date$1, generateConfig$1) }) }, /* @__PURE__ */ import_react.createElement("div", { className: `${calendarPrefixCls}-date-value` }, months[generateConfig$1.getMonth(date$1)]), /* @__PURE__ */ import_react.createElement("div", { className: `${calendarPrefixCls}-date-content` }, typeof cellRender === "function" ? cellRender(date$1, info) : monthCellRender?.(date$1)));
		}, [
			today,
			prefixCls,
			calendarPrefixCls,
			fullCellRender,
			monthFullCellRender,
			cellRender,
			monthCellRender
		]);
		const [contextLocale] = useLocale_default("Calendar", en_US_default$3);
		const locale$5 = {
			...contextLocale,
			...props.locale
		};
		const mergedCellRender = (current, info) => {
			if (info.type === "date") return dateRender(current, info);
			if (info.type === "month") return monthRender(current, {
				...info,
				locale: locale$5?.lang
			});
		};
		return /* @__PURE__ */ import_react.createElement("div", {
			className: clsx(calendarPrefixCls, {
				[`${calendarPrefixCls}-full`]: fullscreen,
				[`${calendarPrefixCls}-mini`]: !fullscreen,
				[`${calendarPrefixCls}-rtl`]: direction === "rtl"
			}, contextClassName, className, rootClassName, rootCls, hashId, cssVarCls),
			style: {
				...rootStyle,
				...contextStyle,
				...style$1
			}
		}, headerRender ? headerRender({
			value: mergedValue,
			type: mergedMode,
			onChange: (nextDate) => {
				onInternalSelect(nextDate, "customize");
			},
			onTypeChange: triggerModeChange
		}) : /* @__PURE__ */ import_react.createElement(Header_default$1, {
			className: headerCls,
			style: headerStyle,
			prefixCls: calendarPrefixCls,
			value: mergedValue,
			generateConfig: generateConfig$1,
			mode: mergedMode,
			fullscreen,
			locale: locale$5?.lang,
			validRange,
			onChange: onInternalSelect,
			onModeChange: triggerModeChange
		}), /* @__PURE__ */ import_react.createElement(PickerPanel_default, {
			classNames: panelClassNames,
			styles: panelStyles,
			value: mergedValue,
			prefixCls,
			locale: locale$5?.lang,
			generateConfig: generateConfig$1,
			cellRender: mergedCellRender,
			onSelect: (nextDate) => {
				onInternalSelect(nextDate, panelMode);
			},
			mode: panelMode,
			picker: panelMode,
			disabledDate: mergedDisabledDate,
			hideHeader: true,
			showWeek
		}));
	};
	Calendar$1.displayName = "Calendar";
	return Calendar$1;
};
var generateCalendar_default = generateCalendar;

//#endregion
//#region node_modules/antd/es/calendar/index.js
var Calendar = generateCalendar_default(dayjs_default);
Calendar.generateCalendar = generateCalendar_default;
var calendar_default = Calendar;

//#endregion
//#region node_modules/is-mobile/index.js
var require_is_mobile = /* @__PURE__ */ __commonJS({ "node_modules/is-mobile/index.js": ((exports, module) => {
	module.exports = isMobile$1;
	module.exports.isMobile = isMobile$1;
	module.exports.default = isMobile$1;
	var mobileRE = /(android|bb\d+|meego).+mobile|armv7l|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|redmi|series[46]0|samsungbrowser.*mobile|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;
	var notMobileRE = /CrOS/;
	var tabletRE = /android|ipad|playbook|silk/i;
	function isMobile$1(opts) {
		if (!opts) opts = {};
		let ua = opts.ua;
		if (!ua && typeof navigator !== "undefined") ua = navigator.userAgent;
		if (ua && ua.headers && typeof ua.headers["user-agent"] === "string") ua = ua.headers["user-agent"];
		if (typeof ua !== "string") return false;
		let result = mobileRE.test(ua) && !notMobileRE.test(ua) || !!opts.tablet && tabletRE.test(ua);
		if (!result && opts.tablet && opts.featureDetect && navigator && navigator.maxTouchPoints > 1 && ua.indexOf("Macintosh") !== -1 && ua.indexOf("Safari") !== -1) result = true;
		return result;
	}
}) });

//#endregion
//#region node_modules/@rc-component/util/es/isMobile.js
var import_is_mobile = /* @__PURE__ */ __toESM(require_is_mobile());
var cached;
var isMobile_default = (() => {
	if (typeof cached === "undefined") cached = (0, import_is_mobile.default)();
	return cached;
});

//#endregion
//#region node_modules/@rc-component/tabs/es/TabContext.js
var TabContext_default = /* @__PURE__ */ (0, import_react.createContext)(null);

//#endregion
//#region node_modules/@rc-component/tabs/es/hooks/useIndicator.js
var useIndicator = (options) => {
	const { activeTabOffset, horizontal, rtl, indicator = {} } = options;
	const { size, align = "center" } = indicator;
	const [inkStyle, setInkStyle] = (0, import_react.useState)();
	const inkBarRafRef = (0, import_react.useRef)();
	const getLength = import_react.useCallback((origin) => {
		if (typeof size === "function") return size(origin);
		if (typeof size === "number") return size;
		return origin;
	}, [size]);
	function cleanInkBarRaf() {
		raf_default.cancel(inkBarRafRef.current);
	}
	(0, import_react.useEffect)(() => {
		const newInkStyle = {};
		if (activeTabOffset) if (horizontal) {
			newInkStyle.width = getLength(activeTabOffset.width);
			const key = rtl ? "right" : "left";
			if (align === "start") newInkStyle[key] = activeTabOffset[key];
			if (align === "center") {
				newInkStyle[key] = activeTabOffset[key] + activeTabOffset.width / 2;
				newInkStyle.transform = rtl ? "translateX(50%)" : "translateX(-50%)";
			}
			if (align === "end") {
				newInkStyle[key] = activeTabOffset[key] + activeTabOffset.width;
				newInkStyle.transform = "translateX(-100%)";
			}
		} else {
			newInkStyle.height = getLength(activeTabOffset.height);
			if (align === "start") newInkStyle.top = activeTabOffset.top;
			if (align === "center") {
				newInkStyle.top = activeTabOffset.top + activeTabOffset.height / 2;
				newInkStyle.transform = "translateY(-50%)";
			}
			if (align === "end") {
				newInkStyle.top = activeTabOffset.top + activeTabOffset.height;
				newInkStyle.transform = "translateY(-100%)";
			}
		}
		cleanInkBarRaf();
		inkBarRafRef.current = raf_default(() => {
			if (!(inkStyle && newInkStyle && Object.keys(newInkStyle).every((key) => {
				const newValue = newInkStyle[key];
				const oldValue = inkStyle[key];
				return typeof newValue === "number" && typeof oldValue === "number" ? Math.round(newValue) === Math.round(oldValue) : newValue === oldValue;
			}))) setInkStyle(newInkStyle);
		});
		return cleanInkBarRaf;
	}, [
		JSON.stringify(activeTabOffset),
		horizontal,
		rtl,
		align,
		getLength
	]);
	return { style: inkStyle };
};
var useIndicator_default = useIndicator;

//#endregion
//#region node_modules/@rc-component/tabs/es/hooks/useOffsets.js
var DEFAULT_SIZE$3 = {
	width: 0,
	height: 0,
	left: 0,
	top: 0
};
function useOffsets(tabs, tabSizes, holderScrollWidth) {
	return (0, import_react.useMemo)(() => {
		const map = /* @__PURE__ */ new Map();
		const lastOffset = tabSizes.get(tabs[0]?.key) || DEFAULT_SIZE$3;
		const rightOffset = lastOffset.left + lastOffset.width;
		for (let i = 0; i < tabs.length; i += 1) {
			const { key } = tabs[i];
			let data = tabSizes.get(key);
			if (!data) data = tabSizes.get(tabs[i - 1]?.key) || DEFAULT_SIZE$3;
			const entity = map.get(key) || { ...data };
			entity.right = rightOffset - entity.left - entity.width;
			map.set(key, entity);
		}
		return map;
	}, [
		tabs.map((tab) => tab.key).join("_"),
		tabSizes,
		holderScrollWidth
	]);
}

//#endregion
//#region node_modules/@rc-component/tabs/es/hooks/useSyncState.js
function useSyncState$1(defaultState, onChange) {
	const stateRef = import_react.useRef(defaultState);
	const [, forceUpdate] = import_react.useState({});
	function setState(updater) {
		const newValue = typeof updater === "function" ? updater(stateRef.current) : updater;
		if (newValue !== stateRef.current) onChange(newValue, stateRef.current);
		stateRef.current = newValue;
		forceUpdate({});
	}
	return [stateRef.current, setState];
}

//#endregion
//#region node_modules/@rc-component/tabs/es/hooks/useTouchMove.js
var MIN_SWIPE_DISTANCE = .1;
var STOP_SWIPE_DISTANCE = .01;
var REFRESH_INTERVAL = 20;
var SPEED_OFF_MULTIPLE = .995 ** REFRESH_INTERVAL;
function useTouchMove(ref, onOffset) {
	const [touchPosition, setTouchPosition] = (0, import_react.useState)();
	const [lastTimestamp, setLastTimestamp] = (0, import_react.useState)(0);
	const [lastTimeDiff, setLastTimeDiff] = (0, import_react.useState)(0);
	const [lastOffset, setLastOffset] = (0, import_react.useState)();
	const motionRef = (0, import_react.useRef)();
	function onTouchStart(e$2) {
		const { screenX, screenY } = e$2.touches[0];
		setTouchPosition({
			x: screenX,
			y: screenY
		});
		window.clearInterval(motionRef.current);
	}
	function onTouchMove(e$2) {
		if (!touchPosition) return;
		const { screenX, screenY } = e$2.touches[0];
		setTouchPosition({
			x: screenX,
			y: screenY
		});
		const offsetX = screenX - touchPosition.x;
		const offsetY = screenY - touchPosition.y;
		onOffset(offsetX, offsetY);
		const now$1 = Date.now();
		setLastTimestamp(now$1);
		setLastTimeDiff(now$1 - lastTimestamp);
		setLastOffset({
			x: offsetX,
			y: offsetY
		});
	}
	function onTouchEnd() {
		if (!touchPosition) return;
		setTouchPosition(null);
		setLastOffset(null);
		if (lastOffset) {
			const distanceX = lastOffset.x / lastTimeDiff;
			const distanceY = lastOffset.y / lastTimeDiff;
			const absX = Math.abs(distanceX);
			const absY = Math.abs(distanceY);
			if (Math.max(absX, absY) < MIN_SWIPE_DISTANCE) return;
			let currentX = distanceX;
			let currentY = distanceY;
			motionRef.current = window.setInterval(() => {
				if (Math.abs(currentX) < STOP_SWIPE_DISTANCE && Math.abs(currentY) < STOP_SWIPE_DISTANCE) {
					window.clearInterval(motionRef.current);
					return;
				}
				currentX *= SPEED_OFF_MULTIPLE;
				currentY *= SPEED_OFF_MULTIPLE;
				onOffset(currentX * REFRESH_INTERVAL, currentY * REFRESH_INTERVAL);
			}, REFRESH_INTERVAL);
		}
	}
	const lastWheelDirectionRef = (0, import_react.useRef)();
	function onWheel(e$2) {
		const { deltaX, deltaY } = e$2;
		let mixed = 0;
		const absX = Math.abs(deltaX);
		const absY = Math.abs(deltaY);
		if (absX === absY) mixed = lastWheelDirectionRef.current === "x" ? deltaX : deltaY;
		else if (absX > absY) {
			mixed = deltaX;
			lastWheelDirectionRef.current = "x";
		} else {
			mixed = deltaY;
			lastWheelDirectionRef.current = "y";
		}
		if (onOffset(-mixed, -mixed)) e$2.preventDefault();
	}
	const touchEventsRef = (0, import_react.useRef)(null);
	touchEventsRef.current = {
		onTouchStart,
		onTouchMove,
		onTouchEnd,
		onWheel
	};
	import_react.useEffect(() => {
		function onProxyTouchStart(e$2) {
			touchEventsRef.current.onTouchStart(e$2);
		}
		function onProxyTouchMove(e$2) {
			touchEventsRef.current.onTouchMove(e$2);
		}
		function onProxyTouchEnd(e$2) {
			touchEventsRef.current.onTouchEnd(e$2);
		}
		function onProxyWheel(e$2) {
			touchEventsRef.current.onWheel(e$2);
		}
		document.addEventListener("touchmove", onProxyTouchMove, { passive: false });
		document.addEventListener("touchend", onProxyTouchEnd, { passive: true });
		ref.current.addEventListener("touchstart", onProxyTouchStart, { passive: true });
		ref.current.addEventListener("wheel", onProxyWheel, { passive: false });
		return () => {
			document.removeEventListener("touchmove", onProxyTouchMove);
			document.removeEventListener("touchend", onProxyTouchEnd);
		};
	}, []);
}

//#endregion
//#region node_modules/@rc-component/tabs/es/hooks/useUpdate.js
/**
* Help to merge callback with `useLayoutEffect`.
* One time will only trigger once.
*/
function useUpdate(callback) {
	const [count, setCount] = (0, import_react.useState)(0);
	const effectRef = (0, import_react.useRef)(0);
	const callbackRef = (0, import_react.useRef)();
	callbackRef.current = callback;
	useLayoutUpdateEffect(() => {
		callbackRef.current?.();
	}, [count]);
	return () => {
		if (effectRef.current !== count) return;
		effectRef.current += 1;
		setCount(effectRef.current);
	};
}
function useUpdateState(defaultState) {
	const batchRef = (0, import_react.useRef)([]);
	const [, forceUpdate] = (0, import_react.useState)({});
	const state = (0, import_react.useRef)(typeof defaultState === "function" ? defaultState() : defaultState);
	const flushUpdate = useUpdate(() => {
		let current = state.current;
		batchRef.current.forEach((callback) => {
			current = callback(current);
		});
		batchRef.current = [];
		state.current = current;
		forceUpdate({});
	});
	function updater(callback) {
		batchRef.current.push(callback);
		flushUpdate();
	}
	return [state.current, updater];
}

//#endregion
//#region node_modules/@rc-component/tabs/es/hooks/useVisibleRange.js
var DEFAULT_SIZE$2 = {
	width: 0,
	height: 0,
	left: 0,
	top: 0,
	right: 0
};
function useVisibleRange(tabOffsets, visibleTabContentValue, transform, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, { tabs, tabPosition, rtl }) {
	let charUnit;
	let position$2;
	let transformSize;
	if (["top", "bottom"].includes(tabPosition)) {
		charUnit = "width";
		position$2 = rtl ? "right" : "left";
		transformSize = Math.abs(transform);
	} else {
		charUnit = "height";
		position$2 = "top";
		transformSize = -transform;
	}
	return (0, import_react.useMemo)(() => {
		if (!tabs.length) return [0, 0];
		const len = tabs.length;
		let endIndex = len;
		for (let i = 0; i < len; i += 1) {
			const offset$2 = tabOffsets.get(tabs[i].key) || DEFAULT_SIZE$2;
			if (Math.floor(offset$2[position$2] + offset$2[charUnit]) > Math.floor(transformSize + visibleTabContentValue)) {
				endIndex = i - 1;
				break;
			}
		}
		let startIndex = 0;
		for (let i = len - 1; i >= 0; i -= 1) if ((tabOffsets.get(tabs[i].key) || DEFAULT_SIZE$2)[position$2] < transformSize) {
			startIndex = i + 1;
			break;
		}
		return startIndex > endIndex ? [0, -1] : [startIndex, endIndex];
	}, [
		tabOffsets,
		visibleTabContentValue,
		tabContentSizeValue,
		addNodeSizeValue,
		operationNodeSizeValue,
		transformSize,
		tabPosition,
		tabs.map((tab) => tab.key).join("_"),
		rtl
	]);
}

//#endregion
//#region node_modules/@rc-component/tabs/es/util.js
/**
* We trade Map as deps which may change with same value but different ref object.
* We should make it as hash for deps
* */
function stringify(obj) {
	let tgt;
	if (obj instanceof Map) {
		tgt = {};
		obj.forEach((v, k) => {
			tgt[k] = v;
		});
	} else tgt = obj;
	return JSON.stringify(tgt);
}
var RC_TABS_DOUBLE_QUOTE = "TABS_DQ";
function genDataNodeKey(key) {
	return String(key).replace(/"/g, RC_TABS_DOUBLE_QUOTE);
}
function getRemovable(closable, closeIcon, editable, disabled) {
	if (!editable || disabled || closable === false || closable === void 0 && (closeIcon === false || closeIcon === null)) return false;
	return true;
}

//#endregion
//#region node_modules/@rc-component/tabs/es/TabNavList/AddButton.js
var AddButton = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls, editable, locale: locale$5, style: style$1 } = props;
	if (!editable || editable.showAdd === false) return null;
	return /* @__PURE__ */ import_react.createElement("button", {
		ref,
		type: "button",
		className: `${prefixCls}-nav-add`,
		style: style$1,
		"aria-label": locale$5?.addAriaLabel || "Add tab",
		onClick: (event) => {
			editable.onEdit("add", { event });
		}
	}, editable.addIcon || "+");
});
var AddButton_default = AddButton;

//#endregion
//#region node_modules/@rc-component/tabs/es/TabNavList/ExtraContent.js
var ExtraContent = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { position: position$2, prefixCls, extra } = props;
	if (!extra) return null;
	let content;
	let assertExtra = {};
	if (typeof extra === "object" && !/* @__PURE__ */ import_react.isValidElement(extra)) assertExtra = extra;
	else assertExtra.right = extra;
	if (position$2 === "right") content = assertExtra.right;
	if (position$2 === "left") content = assertExtra.left;
	return content ? /* @__PURE__ */ import_react.createElement("div", {
		className: `${prefixCls}-extra-content`,
		ref
	}, content) : null;
});
ExtraContent.displayName = "ExtraContent";
var ExtraContent_default = ExtraContent;

//#endregion
//#region node_modules/@rc-component/tabs/es/TabNavList/OperationNode.js
function _extends$50() {
	_extends$50 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$50.apply(this, arguments);
}
var OperationNode = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls, id, tabs, locale: locale$5, mobile, more: moreProps = {}, style: style$1, className, editable, tabBarGutter, rtl, removeAriaLabel, onTabClick, getPopupContainer, popupClassName, popupStyle } = props;
	const [open$2, setOpen] = (0, import_react.useState)(false);
	const [selectedKey, setSelectedKey] = (0, import_react.useState)(null);
	const { icon: moreIcon = "More" } = moreProps;
	const popupId = `${id}-more-popup`;
	const dropdownPrefix = `${prefixCls}-dropdown`;
	const selectedItemId = selectedKey !== null ? `${popupId}-${selectedKey}` : null;
	const dropdownAriaLabel = locale$5?.dropdownAriaLabel;
	function onRemoveTab(event, key) {
		event.preventDefault();
		event.stopPropagation();
		editable.onEdit("remove", {
			key,
			event
		});
	}
	const menu = /* @__PURE__ */ import_react.createElement(es_default$14, {
		onClick: ({ key, domEvent }) => {
			onTabClick(key, domEvent);
			setOpen(false);
		},
		prefixCls: `${dropdownPrefix}-menu`,
		id: popupId,
		tabIndex: -1,
		role: "listbox",
		"aria-activedescendant": selectedItemId,
		selectedKeys: [selectedKey],
		"aria-label": dropdownAriaLabel !== void 0 ? dropdownAriaLabel : "expanded dropdown"
	}, tabs.map((tab) => {
		const { closable, disabled, closeIcon, key, label } = tab;
		const removable = getRemovable(closable, closeIcon, editable, disabled);
		return /* @__PURE__ */ import_react.createElement(MenuItem_default, {
			key,
			id: `${popupId}-${key}`,
			role: "option",
			"aria-controls": id && `${id}-panel-${key}`,
			disabled
		}, /* @__PURE__ */ import_react.createElement("span", null, label), removable && /* @__PURE__ */ import_react.createElement("button", {
			type: "button",
			"aria-label": removeAriaLabel || "remove",
			tabIndex: 0,
			className: `${dropdownPrefix}-menu-item-remove`,
			onClick: (e$2) => {
				e$2.stopPropagation();
				onRemoveTab(e$2, key);
			}
		}, closeIcon || editable.removeIcon || ""));
	}));
	function selectOffset(offset$2) {
		const enabledTabs = tabs.filter((tab) => !tab.disabled);
		let selectedIndex = enabledTabs.findIndex((tab) => tab.key === selectedKey) || 0;
		const len = enabledTabs.length;
		for (let i = 0; i < len; i += 1) {
			selectedIndex = (selectedIndex + offset$2 + len) % len;
			const tab = enabledTabs[selectedIndex];
			if (!tab.disabled) {
				setSelectedKey(tab.key);
				return;
			}
		}
	}
	function onKeyDown$1(e$2) {
		const { which } = e$2;
		if (!open$2) {
			if ([
				KeyCode_default.DOWN,
				KeyCode_default.SPACE,
				KeyCode_default.ENTER
			].includes(which)) {
				setOpen(true);
				e$2.preventDefault();
			}
			return;
		}
		switch (which) {
			case KeyCode_default.UP:
				selectOffset(-1);
				e$2.preventDefault();
				break;
			case KeyCode_default.DOWN:
				selectOffset(1);
				e$2.preventDefault();
				break;
			case KeyCode_default.ESC:
				setOpen(false);
				break;
			case KeyCode_default.SPACE:
			case KeyCode_default.ENTER:
				if (selectedKey !== null) onTabClick(selectedKey, e$2);
				break;
		}
	}
	(0, import_react.useEffect)(() => {
		const ele = document.getElementById(selectedItemId);
		if (ele?.scrollIntoView) ele.scrollIntoView(false);
	}, [selectedItemId, selectedKey]);
	(0, import_react.useEffect)(() => {
		if (!open$2) setSelectedKey(null);
	}, [open$2]);
	const moreStyle = { marginInlineStart: tabBarGutter };
	if (!tabs.length) {
		moreStyle.visibility = "hidden";
		moreStyle.order = 1;
	}
	const overlayClassName = clsx(popupClassName, { [`${dropdownPrefix}-rtl`]: rtl });
	const moreNode = mobile ? null : /* @__PURE__ */ import_react.createElement(es_default$29, _extends$50({
		prefixCls: dropdownPrefix,
		overlay: menu,
		visible: tabs.length ? open$2 : false,
		onVisibleChange: setOpen,
		overlayClassName,
		overlayStyle: popupStyle,
		mouseEnterDelay: .1,
		mouseLeaveDelay: .1,
		getPopupContainer
	}, moreProps), /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		className: `${prefixCls}-nav-more`,
		style: moreStyle,
		"aria-haspopup": "listbox",
		"aria-controls": popupId,
		id: `${id}-more`,
		"aria-expanded": open$2,
		onKeyDown: onKeyDown$1
	}, moreIcon));
	return /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-nav-operations`, className),
		style: style$1,
		ref
	}, moreNode, /* @__PURE__ */ import_react.createElement(AddButton_default, {
		prefixCls,
		locale: locale$5,
		editable
	}));
});
var OperationNode_default = /* @__PURE__ */ import_react.memo(OperationNode, (_, next$1) => next$1.tabMoving);

//#endregion
//#region node_modules/@rc-component/tabs/es/TabNavList/TabNode.js
var TabNode = (props) => {
	const { prefixCls, id, active, focus, tab: { key, label, disabled, closeIcon, icon }, closable, renderWrapper, removeAriaLabel, editable, onClick, onFocus, onBlur, onKeyDown: onKeyDown$1, onMouseDown, onMouseUp, style: style$1, className, tabCount, currentPosition } = props;
	const tabPrefix = `${prefixCls}-tab`;
	const removable = getRemovable(closable, closeIcon, editable, disabled);
	function onInternalClick(e$2) {
		if (disabled) return;
		onClick(e$2);
	}
	function onRemoveTab(event) {
		event.preventDefault();
		event.stopPropagation();
		editable.onEdit("remove", {
			key,
			event
		});
	}
	const labelNode = import_react.useMemo(() => icon && typeof label === "string" ? /* @__PURE__ */ import_react.createElement("span", null, label) : label, [label, icon]);
	const btnRef = import_react.useRef(null);
	import_react.useEffect(() => {
		if (focus && btnRef.current) btnRef.current.focus();
	}, [focus]);
	const node$1 = /* @__PURE__ */ import_react.createElement("div", {
		key,
		"data-node-key": genDataNodeKey(key),
		className: clsx(tabPrefix, className, {
			[`${tabPrefix}-with-remove`]: removable,
			[`${tabPrefix}-active`]: active,
			[`${tabPrefix}-disabled`]: disabled,
			[`${tabPrefix}-focus`]: focus
		}),
		style: style$1,
		onClick: onInternalClick
	}, /* @__PURE__ */ import_react.createElement("div", {
		ref: btnRef,
		role: "tab",
		"aria-selected": active,
		id: id && `${id}-tab-${key}`,
		className: `${tabPrefix}-btn`,
		"aria-controls": id && `${id}-panel-${key}`,
		"aria-disabled": disabled,
		tabIndex: disabled ? null : active ? 0 : -1,
		onClick: (e$2) => {
			e$2.stopPropagation();
			onInternalClick(e$2);
		},
		onKeyDown: onKeyDown$1,
		onMouseDown,
		onMouseUp,
		onFocus,
		onBlur
	}, focus && /* @__PURE__ */ import_react.createElement("div", {
		"aria-live": "polite",
		style: {
			width: 0,
			height: 0,
			position: "absolute",
			overflow: "hidden",
			opacity: 0
		}
	}, `Tab ${currentPosition} of ${tabCount}`), icon && /* @__PURE__ */ import_react.createElement("span", { className: `${tabPrefix}-icon` }, icon), label && labelNode), removable && /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		"aria-label": removeAriaLabel || "remove",
		tabIndex: active ? 0 : -1,
		className: `${tabPrefix}-remove`,
		onClick: (e$2) => {
			e$2.stopPropagation();
			onRemoveTab(e$2);
		}
	}, closeIcon || editable.removeIcon || ""));
	return renderWrapper ? renderWrapper(node$1) : node$1;
};
var TabNode_default = TabNode;

//#endregion
//#region node_modules/@rc-component/tabs/es/TabNavList/index.js
function _extends$49() {
	_extends$49 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$49.apply(this, arguments);
}
var getTabSize = (tab, containerRect) => {
	const { offsetWidth, offsetHeight, offsetTop, offsetLeft } = tab;
	const { width, height, left, top } = tab.getBoundingClientRect();
	if (Math.abs(width - offsetWidth) < 1) return [
		width,
		height,
		left - containerRect.left,
		top - containerRect.top
	];
	return [
		offsetWidth,
		offsetHeight,
		offsetLeft,
		offsetTop
	];
};
var getSize$1 = (refObj) => {
	const { offsetWidth = 0, offsetHeight = 0 } = refObj.current || {};
	if (refObj.current) {
		const { width, height } = refObj.current.getBoundingClientRect();
		if (Math.abs(width - offsetWidth) < 1) return [width, height];
	}
	return [offsetWidth, offsetHeight];
};
/**
* Convert `SizeInfo` to unit value. Such as [123, 456] with `top` position get `123`
*/
var getUnitValue = (size, tabPositionTopOrBottom) => {
	return size[tabPositionTopOrBottom ? 0 : 1];
};
var TabNavList = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { className, style: style$1, id, animated, activeKey, rtl, extra, editable, locale: locale$5, tabPosition, tabBarGutter, children, onTabClick, onTabScroll, indicator, classNames: tabsClassNames, styles } = props;
	const { prefixCls, tabs } = import_react.useContext(TabContext_default);
	const containerRef = (0, import_react.useRef)(null);
	const extraLeftRef = (0, import_react.useRef)(null);
	const extraRightRef = (0, import_react.useRef)(null);
	const tabsWrapperRef = (0, import_react.useRef)(null);
	const tabListRef = (0, import_react.useRef)(null);
	const operationsRef = (0, import_react.useRef)(null);
	const innerAddButtonRef = (0, import_react.useRef)(null);
	const tabPositionTopOrBottom = tabPosition === "top" || tabPosition === "bottom";
	const [transformLeft, setTransformLeft] = useSyncState$1(0, (next$1, prev$1) => {
		if (tabPositionTopOrBottom && onTabScroll) onTabScroll({ direction: next$1 > prev$1 ? "left" : "right" });
	});
	const [transformTop, setTransformTop] = useSyncState$1(0, (next$1, prev$1) => {
		if (!tabPositionTopOrBottom && onTabScroll) onTabScroll({ direction: next$1 > prev$1 ? "top" : "bottom" });
	});
	const [containerExcludeExtraSize, setContainerExcludeExtraSize] = (0, import_react.useState)([0, 0]);
	const [tabContentSize, setTabContentSize] = (0, import_react.useState)([0, 0]);
	const [addSize, setAddSize] = (0, import_react.useState)([0, 0]);
	const [operationSize, setOperationSize] = (0, import_react.useState)([0, 0]);
	const [tabSizes, setTabSizes] = useUpdateState(/* @__PURE__ */ new Map());
	const tabOffsets = useOffsets(tabs, tabSizes, tabContentSize[0]);
	const containerExcludeExtraSizeValue = getUnitValue(containerExcludeExtraSize, tabPositionTopOrBottom);
	const tabContentSizeValue = getUnitValue(tabContentSize, tabPositionTopOrBottom);
	const addSizeValue = getUnitValue(addSize, tabPositionTopOrBottom);
	const operationSizeValue = getUnitValue(operationSize, tabPositionTopOrBottom);
	const needScroll = Math.floor(containerExcludeExtraSizeValue) < Math.floor(tabContentSizeValue + addSizeValue);
	const visibleTabContentValue = needScroll ? containerExcludeExtraSizeValue - operationSizeValue : containerExcludeExtraSizeValue - addSizeValue;
	const operationsHiddenClassName = `${prefixCls}-nav-operations-hidden`;
	let transformMin = 0;
	let transformMax = 0;
	if (!tabPositionTopOrBottom) {
		transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
		transformMax = 0;
	} else if (rtl) {
		transformMin = 0;
		transformMax = Math.max(0, tabContentSizeValue - visibleTabContentValue);
	} else {
		transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
		transformMax = 0;
	}
	function alignInRange(value) {
		if (value < transformMin) return transformMin;
		if (value > transformMax) return transformMax;
		return value;
	}
	const touchMovingRef = (0, import_react.useRef)(null);
	const [lockAnimation, setLockAnimation] = (0, import_react.useState)();
	function doLockAnimation() {
		setLockAnimation(Date.now());
	}
	function clearTouchMoving() {
		if (touchMovingRef.current) clearTimeout(touchMovingRef.current);
	}
	useTouchMove(tabsWrapperRef, (offsetX, offsetY) => {
		function doMove(setState, offset$2) {
			setState((value) => {
				return alignInRange(value + offset$2);
			});
		}
		if (!needScroll) return false;
		if (tabPositionTopOrBottom) doMove(setTransformLeft, offsetX);
		else doMove(setTransformTop, offsetY);
		clearTouchMoving();
		doLockAnimation();
		return true;
	});
	(0, import_react.useEffect)(() => {
		clearTouchMoving();
		if (lockAnimation) touchMovingRef.current = setTimeout(() => {
			setLockAnimation(0);
		}, 100);
		return clearTouchMoving;
	}, [lockAnimation]);
	const [visibleStart, visibleEnd] = useVisibleRange(tabOffsets, visibleTabContentValue, tabPositionTopOrBottom ? transformLeft : transformTop, tabContentSizeValue, addSizeValue, operationSizeValue, {
		...props,
		tabs
	});
	const scrollToTab = useEvent_default((key = activeKey) => {
		const tabOffset = tabOffsets.get(key) || {
			width: 0,
			height: 0,
			left: 0,
			right: 0,
			top: 0
		};
		if (tabPositionTopOrBottom) {
			let newTransform = transformLeft;
			if (rtl) {
				if (tabOffset.right < transformLeft) newTransform = tabOffset.right;
				else if (tabOffset.right + tabOffset.width > transformLeft + visibleTabContentValue) newTransform = tabOffset.right + tabOffset.width - visibleTabContentValue;
			} else if (tabOffset.left < -transformLeft) newTransform = -tabOffset.left;
			else if (tabOffset.left + tabOffset.width > -transformLeft + visibleTabContentValue) newTransform = -(tabOffset.left + tabOffset.width - visibleTabContentValue);
			setTransformTop(0);
			setTransformLeft(alignInRange(newTransform));
		} else {
			let newTransform = transformTop;
			if (tabOffset.top < -transformTop) newTransform = -tabOffset.top;
			else if (tabOffset.top + tabOffset.height > -transformTop + visibleTabContentValue) newTransform = -(tabOffset.top + tabOffset.height - visibleTabContentValue);
			setTransformLeft(0);
			setTransformTop(alignInRange(newTransform));
		}
	});
	const [focusKey, setFocusKey] = (0, import_react.useState)();
	const [isMouse, setIsMouse] = (0, import_react.useState)(false);
	const enabledTabs = tabs.filter((tab) => !tab.disabled).map((tab) => tab.key);
	const onOffset = (offset$2) => {
		const currentIndex = enabledTabs.indexOf(focusKey || activeKey);
		const len = enabledTabs.length;
		const newKey = enabledTabs[(currentIndex + offset$2 + len) % len];
		setFocusKey(newKey);
	};
	const handleRemoveTab = (removalTabKey, e$2) => {
		const removeIndex = enabledTabs.indexOf(removalTabKey);
		const removeTab = tabs.find((tab) => tab.key === removalTabKey);
		if (getRemovable(removeTab?.closable, removeTab?.closeIcon, editable, removeTab?.disabled)) {
			e$2.preventDefault();
			e$2.stopPropagation();
			editable.onEdit("remove", {
				key: removalTabKey,
				event: e$2
			});
			if (removeIndex === enabledTabs.length - 1) onOffset(-1);
			else onOffset(1);
		}
	};
	const handleMouseDown = (key, e$2) => {
		setIsMouse(true);
		if (e$2.button === 1) handleRemoveTab(key, e$2);
	};
	const handleKeyDown = (e$2) => {
		const { code } = e$2;
		const isRTL = rtl && tabPositionTopOrBottom;
		const firstEnabledTab = enabledTabs[0];
		const lastEnabledTab = enabledTabs[enabledTabs.length - 1];
		switch (code) {
			case "ArrowLeft":
				if (tabPositionTopOrBottom) onOffset(isRTL ? 1 : -1);
				break;
			case "ArrowRight":
				if (tabPositionTopOrBottom) onOffset(isRTL ? -1 : 1);
				break;
			case "ArrowUp":
				e$2.preventDefault();
				if (!tabPositionTopOrBottom) onOffset(-1);
				break;
			case "ArrowDown":
				e$2.preventDefault();
				if (!tabPositionTopOrBottom) onOffset(1);
				break;
			case "Home":
				e$2.preventDefault();
				setFocusKey(firstEnabledTab);
				break;
			case "End":
				e$2.preventDefault();
				setFocusKey(lastEnabledTab);
				break;
			case "Enter":
			case "Space":
				e$2.preventDefault();
				onTabClick(focusKey ?? activeKey, e$2);
				break;
			case "Backspace":
			case "Delete":
				handleRemoveTab(focusKey, e$2);
				break;
		}
	};
	const tabNodeStyle = {};
	if (tabPositionTopOrBottom) tabNodeStyle.marginInlineStart = tabBarGutter;
	else tabNodeStyle.marginTop = tabBarGutter;
	const tabNodes = tabs.map((tab, i) => {
		const { key } = tab;
		return /* @__PURE__ */ import_react.createElement(TabNode_default, {
			id,
			prefixCls,
			key,
			tab,
			className: tabsClassNames?.item,
			style: i === 0 ? styles?.item : {
				...tabNodeStyle,
				...styles?.item
			},
			closable: tab.closable,
			editable,
			active: key === activeKey,
			focus: key === focusKey,
			renderWrapper: children,
			removeAriaLabel: locale$5?.removeAriaLabel,
			tabCount: enabledTabs.length,
			currentPosition: i + 1,
			onClick: (e$2) => {
				onTabClick(key, e$2);
			},
			onKeyDown: handleKeyDown,
			onFocus: () => {
				if (!isMouse) setFocusKey(key);
				scrollToTab(key);
				doLockAnimation();
				if (!tabsWrapperRef.current) return;
				if (!rtl) tabsWrapperRef.current.scrollLeft = 0;
				tabsWrapperRef.current.scrollTop = 0;
			},
			onBlur: () => {
				setFocusKey(void 0);
			},
			onMouseDown: (e$2) => handleMouseDown(key, e$2),
			onMouseUp: () => {
				setIsMouse(false);
			}
		});
	});
	const updateTabSizes = () => setTabSizes(() => {
		const newSizes = /* @__PURE__ */ new Map();
		const listRect = tabListRef.current?.getBoundingClientRect();
		tabs.forEach(({ key }) => {
			const btnNode = tabListRef.current?.querySelector(`[data-node-key="${genDataNodeKey(key)}"]`);
			if (btnNode) {
				const [width, height, left, top] = getTabSize(btnNode, listRect);
				newSizes.set(key, {
					width,
					height,
					left,
					top
				});
			}
		});
		return newSizes;
	});
	(0, import_react.useEffect)(() => {
		updateTabSizes();
	}, [tabs.map((tab) => tab.key).join("_")]);
	const onListHolderResize = useUpdate(() => {
		const containerSize = getSize$1(containerRef);
		const extraLeftSize = getSize$1(extraLeftRef);
		const extraRightSize = getSize$1(extraRightRef);
		setContainerExcludeExtraSize([containerSize[0] - extraLeftSize[0] - extraRightSize[0], containerSize[1] - extraLeftSize[1] - extraRightSize[1]]);
		const newAddSize = getSize$1(innerAddButtonRef);
		setAddSize(newAddSize);
		setOperationSize(getSize$1(operationsRef));
		const tabContentFullSize = getSize$1(tabListRef);
		setTabContentSize([tabContentFullSize[0] - newAddSize[0], tabContentFullSize[1] - newAddSize[1]]);
		updateTabSizes();
	});
	const startHiddenTabs = tabs.slice(0, visibleStart);
	const endHiddenTabs = tabs.slice(visibleEnd + 1);
	const hiddenTabs = [...startHiddenTabs, ...endHiddenTabs];
	const activeTabOffset = tabOffsets.get(activeKey);
	const { style: indicatorStyle } = useIndicator_default({
		activeTabOffset,
		horizontal: tabPositionTopOrBottom,
		indicator,
		rtl
	});
	(0, import_react.useEffect)(() => {
		scrollToTab();
	}, [
		activeKey,
		transformMin,
		transformMax,
		stringify(activeTabOffset),
		stringify(tabOffsets),
		tabPositionTopOrBottom
	]);
	(0, import_react.useEffect)(() => {
		onListHolderResize();
	}, [rtl]);
	const hasDropdown = !!hiddenTabs.length;
	const wrapPrefix = `${prefixCls}-nav-wrap`;
	let pingLeft;
	let pingRight;
	let pingTop;
	let pingBottom;
	if (tabPositionTopOrBottom) if (rtl) {
		pingRight = transformLeft > 0;
		pingLeft = transformLeft !== transformMax;
	} else {
		pingLeft = transformLeft < 0;
		pingRight = transformLeft !== transformMin;
	}
	else {
		pingTop = transformTop < 0;
		pingBottom = transformTop !== transformMin;
	}
	return /* @__PURE__ */ import_react.createElement(es_default$2, { onResize: onListHolderResize }, /* @__PURE__ */ import_react.createElement("div", {
		ref: useComposeRef(ref, containerRef),
		role: "tablist",
		"aria-orientation": tabPositionTopOrBottom ? "horizontal" : "vertical",
		className: clsx(`${prefixCls}-nav`, className, tabsClassNames?.header),
		style: {
			...styles?.header,
			...style$1
		},
		onKeyDown: () => {
			doLockAnimation();
		}
	}, /* @__PURE__ */ import_react.createElement(ExtraContent_default, {
		ref: extraLeftRef,
		position: "left",
		extra,
		prefixCls
	}), /* @__PURE__ */ import_react.createElement(es_default$2, { onResize: onListHolderResize }, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(wrapPrefix, {
			[`${wrapPrefix}-ping-left`]: pingLeft,
			[`${wrapPrefix}-ping-right`]: pingRight,
			[`${wrapPrefix}-ping-top`]: pingTop,
			[`${wrapPrefix}-ping-bottom`]: pingBottom
		}),
		ref: tabsWrapperRef
	}, /* @__PURE__ */ import_react.createElement(es_default$2, { onResize: onListHolderResize }, /* @__PURE__ */ import_react.createElement("div", {
		ref: tabListRef,
		className: `${prefixCls}-nav-list`,
		style: {
			transform: `translate(${transformLeft}px, ${transformTop}px)`,
			transition: lockAnimation ? "none" : void 0
		}
	}, tabNodes, /* @__PURE__ */ import_react.createElement(AddButton_default, {
		ref: innerAddButtonRef,
		prefixCls,
		locale: locale$5,
		editable,
		style: {
			...tabNodes.length === 0 ? void 0 : tabNodeStyle,
			visibility: hasDropdown ? "hidden" : null
		}
	}), /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-ink-bar`, tabsClassNames?.indicator, { [`${prefixCls}-ink-bar-animated`]: animated.inkBar }),
		style: {
			...indicatorStyle,
			...styles?.indicator
		}
	}))))), /* @__PURE__ */ import_react.createElement(OperationNode_default, _extends$49({}, props, {
		removeAriaLabel: locale$5?.removeAriaLabel,
		ref: operationsRef,
		prefixCls,
		tabs: hiddenTabs,
		className: !hasDropdown && operationsHiddenClassName,
		popupStyle: styles?.popup,
		tabMoving: !!lockAnimation
	})), /* @__PURE__ */ import_react.createElement(ExtraContent_default, {
		ref: extraRightRef,
		position: "right",
		extra,
		prefixCls
	})));
});
var TabNavList_default = TabNavList;

//#endregion
//#region node_modules/@rc-component/tabs/es/TabNavList/Wrapper.js
var TabNavListWrapper = ({ renderTabBar, ...restProps }) => {
	if (renderTabBar) return renderTabBar(restProps, TabNavList_default);
	return /* @__PURE__ */ import_react.createElement(TabNavList_default, restProps);
};
TabNavListWrapper.displayName = "TabNavListWrapper";
var Wrapper_default = TabNavListWrapper;

//#endregion
//#region node_modules/@rc-component/tabs/es/TabPanelList/TabPane.js
var TabPane$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls, className, style: style$1, id, active, tabKey, children } = props;
	const hasContent$1 = import_react.Children.count(children) > 0;
	return /* @__PURE__ */ import_react.createElement("div", {
		id: id && `${id}-panel-${tabKey}`,
		role: "tabpanel",
		tabIndex: active && hasContent$1 ? 0 : -1,
		"aria-labelledby": id && `${id}-tab-${tabKey}`,
		"aria-hidden": !active,
		style: style$1,
		className: clsx(prefixCls, active && `${prefixCls}-active`, className),
		ref
	}, children);
});
TabPane$1.displayName = "TabPane";
var TabPane_default$1 = TabPane$1;

//#endregion
//#region node_modules/@rc-component/tabs/es/TabPanelList/index.js
function _extends$48() {
	_extends$48 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$48.apply(this, arguments);
}
var TabPanelList = (props) => {
	const { id, activeKey, animated, tabPosition, destroyOnHidden, contentStyle, contentClassName } = props;
	const { prefixCls, tabs } = import_react.useContext(TabContext_default);
	const tabPaneAnimated = animated.tabPane;
	const tabPanePrefixCls = `${prefixCls}-tabpane`;
	return /* @__PURE__ */ import_react.createElement("div", { className: clsx(`${prefixCls}-content-holder`) }, /* @__PURE__ */ import_react.createElement("div", { className: clsx(`${prefixCls}-content`, `${prefixCls}-content-${tabPosition}`, { [`${prefixCls}-content-animated`]: tabPaneAnimated }) }, tabs.map((item) => {
		const { key, forceRender, style: paneStyle, className: paneClassName, destroyOnHidden: itemDestroyOnHidden, ...restTabProps } = item;
		const active = key === activeKey;
		return /* @__PURE__ */ import_react.createElement(es_default$1, _extends$48({
			key,
			visible: active,
			forceRender,
			removeOnLeave: !!(destroyOnHidden ?? itemDestroyOnHidden),
			leavedClassName: `${tabPanePrefixCls}-hidden`
		}, animated.tabPaneMotion), ({ style: motionStyle, className: motionClassName }, ref) => /* @__PURE__ */ import_react.createElement(TabPane_default$1, _extends$48({}, restTabProps, {
			prefixCls: tabPanePrefixCls,
			id,
			tabKey: key,
			animated: tabPaneAnimated,
			active,
			style: {
				...contentStyle,
				...paneStyle,
				...motionStyle
			},
			className: clsx(contentClassName, paneClassName, motionClassName),
			ref
		})));
	})));
};
var TabPanelList_default = TabPanelList;

//#endregion
//#region node_modules/@rc-component/tabs/es/hooks/useAnimateConfig.js
function useAnimateConfig$1(animated = {
	inkBar: true,
	tabPane: false
}) {
	let mergedAnimated;
	if (animated === false) mergedAnimated = {
		inkBar: false,
		tabPane: false
	};
	else if (animated === true) mergedAnimated = {
		inkBar: true,
		tabPane: false
	};
	else mergedAnimated = {
		inkBar: true,
		...typeof animated === "object" ? animated : {}
	};
	if (mergedAnimated.tabPaneMotion && mergedAnimated.tabPane === void 0) mergedAnimated.tabPane = true;
	if (!mergedAnimated.tabPaneMotion && mergedAnimated.tabPane) {
		warning_default$1(false, "`animated.tabPane` is true but `animated.tabPaneMotion` is not provided. Motion will not work.");
		mergedAnimated.tabPane = false;
	}
	return mergedAnimated;
}

//#endregion
//#region node_modules/@rc-component/tabs/es/Tabs.js
function _extends$47() {
	_extends$47 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$47.apply(this, arguments);
}
/**
* Should added antd:
* - type
*
* Removed:
* - onNextClick
* - onPrevClick
* - keyboard
*/
var uuid = 0;
var Tabs$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { id, prefixCls = "rc-tabs", className, items, direction, activeKey, defaultActiveKey, editable, animated, tabPosition = "top", tabBarGutter, tabBarStyle, tabBarExtraContent, locale: locale$5, more, destroyOnHidden, renderTabBar, onChange, onTabClick, onTabScroll, getPopupContainer, popupClassName, indicator, classNames: tabsClassNames, styles, ...restProps } = props;
	const tabs = import_react.useMemo(() => (items || []).filter((item) => item && typeof item === "object" && "key" in item), [items]);
	const rtl = direction === "rtl";
	const mergedAnimated = useAnimateConfig$1(animated);
	const [mobile, setMobile] = (0, import_react.useState)(false);
	(0, import_react.useEffect)(() => {
		setMobile(isMobile_default());
	}, []);
	const [mergedActiveKey, setMergedActiveKey] = useControlledState(defaultActiveKey ?? tabs[0]?.key, activeKey);
	const [activeIndex, setActiveIndex] = (0, import_react.useState)(() => tabs.findIndex((tab) => tab.key === mergedActiveKey));
	(0, import_react.useEffect)(() => {
		let newActiveIndex = tabs.findIndex((tab) => tab.key === mergedActiveKey);
		if (newActiveIndex === -1) {
			newActiveIndex = Math.max(0, Math.min(activeIndex, tabs.length - 1));
			setMergedActiveKey(tabs[newActiveIndex]?.key);
		}
		setActiveIndex(newActiveIndex);
	}, [
		tabs.map((tab) => tab.key).join("_"),
		mergedActiveKey,
		activeIndex
	]);
	const [mergedId, setMergedId] = useControlledState(null, id);
	(0, import_react.useEffect)(() => {
		if (!id) {
			setMergedId(`rc-tabs-${uuid}`);
			uuid += 1;
		}
	}, []);
	function onInternalTabClick(key, e$2) {
		onTabClick?.(key, e$2);
		const isActiveChanged = key !== mergedActiveKey;
		setMergedActiveKey(key);
		if (isActiveChanged) onChange?.(key);
	}
	const sharedProps = {
		id: mergedId,
		activeKey: mergedActiveKey,
		animated: mergedAnimated,
		tabPosition,
		rtl,
		mobile
	};
	const tabNavBarProps = {
		...sharedProps,
		editable,
		locale: locale$5,
		more,
		tabBarGutter,
		onTabClick: onInternalTabClick,
		onTabScroll,
		extra: tabBarExtraContent,
		style: tabBarStyle,
		getPopupContainer,
		popupClassName: clsx(popupClassName, tabsClassNames?.popup),
		indicator,
		styles,
		classNames: tabsClassNames
	};
	const memoizedValue = import_react.useMemo(() => {
		return {
			tabs,
			prefixCls
		};
	}, [tabs, prefixCls]);
	return /* @__PURE__ */ import_react.createElement(TabContext_default.Provider, { value: memoizedValue }, /* @__PURE__ */ import_react.createElement("div", _extends$47({
		ref,
		id,
		className: clsx(prefixCls, `${prefixCls}-${tabPosition}`, {
			[`${prefixCls}-mobile`]: mobile,
			[`${prefixCls}-editable`]: editable,
			[`${prefixCls}-rtl`]: rtl
		}, className)
	}, restProps), /* @__PURE__ */ import_react.createElement(Wrapper_default, _extends$47({}, tabNavBarProps, { renderTabBar })), /* @__PURE__ */ import_react.createElement(TabPanelList_default, _extends$47({ destroyOnHidden }, sharedProps, {
		contentStyle: styles?.content,
		contentClassName: tabsClassNames?.content,
		animated: mergedAnimated
	}))));
});
Tabs$1.displayName = "Tabs";
var Tabs_default = Tabs$1;

//#endregion
//#region node_modules/@rc-component/tabs/es/index.js
var es_default$28 = Tabs_default;

//#endregion
//#region node_modules/antd/es/tabs/hooks/useAnimateConfig.js
var motion = {
	motionAppear: false,
	motionEnter: true,
	motionLeave: true
};
function useAnimateConfig(prefixCls, animated = {
	inkBar: true,
	tabPane: false
}) {
	let mergedAnimated;
	if (animated === false) mergedAnimated = {
		inkBar: false,
		tabPane: false
	};
	else if (animated === true) mergedAnimated = {
		inkBar: true,
		tabPane: true
	};
	else mergedAnimated = {
		inkBar: true,
		...typeof animated === "object" ? animated : {}
	};
	if (mergedAnimated.tabPane) mergedAnimated.tabPaneMotion = {
		...motion,
		motionName: getTransitionName(prefixCls, "switch")
	};
	return mergedAnimated;
}

//#endregion
//#region node_modules/antd/es/tabs/hooks/useLegacyItems.js
function filter(items) {
	return items.filter((item) => item);
}
function useLegacyItems(items, children) {
	devUseWarning("Tabs").deprecated(!children, "Tabs.TabPane", "items");
	if (items) return items.map((item) => ({
		...item,
		destroyOnHidden: item.destroyOnHidden ?? item.destroyInactiveTabPane
	}));
	return filter(toArray(children).map((node$1) => {
		if (/* @__PURE__ */ import_react.isValidElement(node$1)) {
			const { key, props } = node$1;
			const { tab, ...restProps } = props || {};
			return {
				key: String(key),
				...restProps,
				label: tab
			};
		}
		return null;
	}));
}
var useLegacyItems_default = useLegacyItems;

//#endregion
//#region node_modules/antd/es/tabs/style/motion.js
var genMotionStyle$2 = (token$1) => {
	const { componentCls, motionDurationSlow } = token$1;
	return [{ [componentCls]: { [`${componentCls}-switch`]: {
		"&-appear, &-enter": {
			transition: "none",
			"&-start": { opacity: 0 },
			"&-active": {
				opacity: 1,
				transition: `opacity ${motionDurationSlow}`
			}
		},
		"&-leave": {
			position: "absolute",
			transition: "none",
			inset: 0,
			"&-start": { opacity: 1 },
			"&-active": {
				opacity: 0,
				transition: `opacity ${motionDurationSlow}`
			}
		}
	} } }, [initSlideMotion(token$1, "slide-up"), initSlideMotion(token$1, "slide-down")]];
};
var motion_default$3 = genMotionStyle$2;

//#endregion
//#region node_modules/antd/es/tabs/style/index.js
var genCardStyle$1 = (token$1) => {
	const { componentCls, tabsCardPadding, cardBg, cardGutter, colorBorderSecondary, itemSelectedColor } = token$1;
	return { [`${componentCls}-card`]: {
		[`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
			[`${componentCls}-tab`]: {
				margin: 0,
				padding: tabsCardPadding,
				background: cardBg,
				border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${colorBorderSecondary}`,
				transition: `all ${token$1.motionDurationSlow} ${token$1.motionEaseInOut}`
			},
			[`${componentCls}-tab-active`]: {
				color: itemSelectedColor,
				background: token$1.colorBgContainer
			},
			[`${componentCls}-tab-focus:has(${componentCls}-tab-btn:focus-visible)`]: genFocusOutline(token$1, -3),
			[`& ${componentCls}-tab${componentCls}-tab-focus ${componentCls}-tab-btn:focus-visible`]: { outline: "none" },
			[`${componentCls}-ink-bar`]: { visibility: "hidden" }
		},
		[`&${componentCls}-top, &${componentCls}-bottom`]: { [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: { [`${componentCls}-tab + ${componentCls}-tab`]: { marginLeft: {
			_skip_check_: true,
			value: unit(cardGutter)
		} } } },
		[`&${componentCls}-top`]: { [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
			[`${componentCls}-tab`]: { borderRadius: `${unit(token$1.borderRadiusLG)} ${unit(token$1.borderRadiusLG)} 0 0` },
			[`${componentCls}-tab-active`]: { borderBottomColor: token$1.colorBgContainer }
		} },
		[`&${componentCls}-bottom`]: { [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
			[`${componentCls}-tab`]: { borderRadius: `0 0 ${unit(token$1.borderRadiusLG)} ${unit(token$1.borderRadiusLG)}` },
			[`${componentCls}-tab-active`]: { borderTopColor: token$1.colorBgContainer }
		} },
		[`&${componentCls}-left, &${componentCls}-right`]: { [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: { [`${componentCls}-tab + ${componentCls}-tab`]: { marginTop: unit(cardGutter) } } },
		[`&${componentCls}-left`]: { [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
			[`${componentCls}-tab`]: { borderRadius: {
				_skip_check_: true,
				value: `${unit(token$1.borderRadiusLG)} 0 0 ${unit(token$1.borderRadiusLG)}`
			} },
			[`${componentCls}-tab-active`]: { borderRightColor: {
				_skip_check_: true,
				value: token$1.colorBgContainer
			} }
		} },
		[`&${componentCls}-right`]: { [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
			[`${componentCls}-tab`]: { borderRadius: {
				_skip_check_: true,
				value: `0 ${unit(token$1.borderRadiusLG)} ${unit(token$1.borderRadiusLG)} 0`
			} },
			[`${componentCls}-tab-active`]: { borderLeftColor: {
				_skip_check_: true,
				value: token$1.colorBgContainer
			} }
		} }
	} };
};
var genDropdownStyle$1 = (token$1) => {
	const { componentCls, itemHoverColor, dropdownEdgeChildVerticalPadding } = token$1;
	return { [`${componentCls}-dropdown`]: {
		...resetComponent(token$1),
		position: "absolute",
		top: -9999,
		left: {
			_skip_check_: true,
			value: -9999
		},
		zIndex: token$1.zIndexPopup,
		display: "block",
		"&-hidden": { display: "none" },
		[`${componentCls}-dropdown-menu`]: {
			maxHeight: token$1.tabsDropdownHeight,
			margin: 0,
			padding: `${unit(dropdownEdgeChildVerticalPadding)} 0`,
			overflowX: "hidden",
			overflowY: "auto",
			textAlign: {
				_skip_check_: true,
				value: "left"
			},
			listStyleType: "none",
			backgroundColor: token$1.colorBgContainer,
			backgroundClip: "padding-box",
			borderRadius: token$1.borderRadiusLG,
			outline: "none",
			boxShadow: token$1.boxShadowSecondary,
			"&-item": {
				...textEllipsis,
				display: "flex",
				alignItems: "center",
				minWidth: token$1.tabsDropdownWidth,
				margin: 0,
				padding: `${unit(token$1.paddingXXS)} ${unit(token$1.paddingSM)}`,
				color: token$1.colorText,
				fontWeight: "normal",
				fontSize: token$1.fontSize,
				lineHeight: token$1.lineHeight,
				cursor: "pointer",
				transition: `all ${token$1.motionDurationSlow}`,
				"> span": {
					flex: 1,
					whiteSpace: "nowrap"
				},
				"&-remove": {
					flex: "none",
					marginLeft: {
						_skip_check_: true,
						value: token$1.marginSM
					},
					color: token$1.colorIcon,
					fontSize: token$1.fontSizeSM,
					background: "transparent",
					border: 0,
					cursor: "pointer",
					"&:hover": { color: itemHoverColor }
				},
				"&:hover": { background: token$1.controlItemBgHover },
				"&-disabled": { "&, &:hover": {
					color: token$1.colorTextDisabled,
					background: "transparent",
					cursor: "not-allowed"
				} }
			}
		}
	} };
};
var genPositionStyle = (token$1) => {
	const { componentCls, margin, colorBorderSecondary, horizontalMargin, verticalItemPadding, verticalItemMargin, calc } = token$1;
	return {
		[`${componentCls}-top, ${componentCls}-bottom`]: {
			flexDirection: "column",
			[`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
				margin: horizontalMargin,
				"&::before": {
					position: "absolute",
					right: {
						_skip_check_: true,
						value: 0
					},
					left: {
						_skip_check_: true,
						value: 0
					},
					borderBottom: `${unit(token$1.lineWidth)} ${token$1.lineType} ${colorBorderSecondary}`,
					content: "''"
				},
				[`${componentCls}-ink-bar`]: {
					height: token$1.lineWidthBold,
					"&-animated": { transition: `width ${token$1.motionDurationSlow}, left ${token$1.motionDurationSlow},
            right ${token$1.motionDurationSlow}` }
				},
				[`${componentCls}-nav-wrap`]: {
					"&::before, &::after": {
						top: 0,
						bottom: 0,
						width: token$1.controlHeight
					},
					"&::before": {
						left: {
							_skip_check_: true,
							value: 0
						},
						boxShadow: token$1.boxShadowTabsOverflowLeft
					},
					"&::after": {
						right: {
							_skip_check_: true,
							value: 0
						},
						boxShadow: token$1.boxShadowTabsOverflowRight
					},
					[`&${componentCls}-nav-wrap-ping-left::before`]: { opacity: 1 },
					[`&${componentCls}-nav-wrap-ping-right::after`]: { opacity: 1 }
				}
			}
		},
		[`${componentCls}-top`]: { [`> ${componentCls}-nav,
        > div > ${componentCls}-nav`]: {
			"&::before": { bottom: 0 },
			[`${componentCls}-ink-bar`]: { bottom: 0 }
		} },
		[`${componentCls}-bottom`]: {
			[`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
				order: 1,
				marginTop: margin,
				marginBottom: 0,
				"&::before": { top: 0 },
				[`${componentCls}-ink-bar`]: { top: 0 }
			},
			[`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: { order: 0 }
		},
		[`${componentCls}-left, ${componentCls}-right`]: { [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
			flexDirection: "column",
			minWidth: calc(token$1.controlHeight).mul(1.25).equal(),
			[`${componentCls}-tab`]: {
				padding: verticalItemPadding,
				textAlign: "center"
			},
			[`${componentCls}-tab + ${componentCls}-tab`]: { margin: verticalItemMargin },
			[`${componentCls}-nav-wrap`]: {
				flexDirection: "column",
				"&::before, &::after": {
					right: {
						_skip_check_: true,
						value: 0
					},
					left: {
						_skip_check_: true,
						value: 0
					},
					height: token$1.controlHeight
				},
				"&::before": {
					top: 0,
					boxShadow: token$1.boxShadowTabsOverflowTop
				},
				"&::after": {
					bottom: 0,
					boxShadow: token$1.boxShadowTabsOverflowBottom
				},
				[`&${componentCls}-nav-wrap-ping-top::before`]: { opacity: 1 },
				[`&${componentCls}-nav-wrap-ping-bottom::after`]: { opacity: 1 }
			},
			[`${componentCls}-ink-bar`]: {
				width: token$1.lineWidthBold,
				"&-animated": { transition: `height ${token$1.motionDurationSlow}, top ${token$1.motionDurationSlow}` }
			},
			[`${componentCls}-nav-list, ${componentCls}-nav-operations`]: {
				flex: "1 0 auto",
				flexDirection: "column"
			}
		} },
		[`${componentCls}-left`]: {
			[`> ${componentCls}-nav, > div > ${componentCls}-nav`]: { [`${componentCls}-ink-bar`]: { right: {
				_skip_check_: true,
				value: 0
			} } },
			[`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
				marginLeft: {
					_skip_check_: true,
					value: unit(calc(token$1.lineWidth).mul(-1).equal())
				},
				borderLeft: {
					_skip_check_: true,
					value: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`
				},
				[`> ${componentCls}-content > ${componentCls}-tabpane`]: { paddingLeft: {
					_skip_check_: true,
					value: token$1.paddingLG
				} }
			}
		},
		[`${componentCls}-right`]: {
			[`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
				order: 1,
				[`${componentCls}-ink-bar`]: { left: {
					_skip_check_: true,
					value: 0
				} }
			},
			[`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
				order: 0,
				marginRight: {
					_skip_check_: true,
					value: calc(token$1.lineWidth).mul(-1).equal()
				},
				borderRight: {
					_skip_check_: true,
					value: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`
				},
				[`> ${componentCls}-content > ${componentCls}-tabpane`]: { paddingRight: {
					_skip_check_: true,
					value: token$1.paddingLG
				} }
			}
		}
	};
};
var genSizeStyle$2 = (token$1) => {
	const { componentCls, cardPaddingSM, cardPaddingLG, cardHeightSM, cardHeightLG, horizontalItemPaddingSM, horizontalItemPaddingLG } = token$1;
	return {
		[componentCls]: {
			"&-small": { [`> ${componentCls}-nav`]: { [`${componentCls}-tab`]: {
				padding: horizontalItemPaddingSM,
				fontSize: token$1.titleFontSizeSM
			} } },
			"&-large": { [`> ${componentCls}-nav`]: { [`${componentCls}-tab`]: {
				padding: horizontalItemPaddingLG,
				fontSize: token$1.titleFontSizeLG,
				lineHeight: token$1.lineHeightLG
			} } }
		},
		[`${componentCls}-card`]: {
			[`&${componentCls}-small`]: {
				[`> ${componentCls}-nav`]: {
					[`${componentCls}-tab`]: { padding: cardPaddingSM },
					[`${componentCls}-nav-add`]: {
						minWidth: cardHeightSM,
						minHeight: cardHeightSM
					}
				},
				[`&${componentCls}-bottom`]: { [`> ${componentCls}-nav ${componentCls}-tab`]: { borderRadius: `0 0 ${unit(token$1.borderRadius)} ${unit(token$1.borderRadius)}` } },
				[`&${componentCls}-top`]: { [`> ${componentCls}-nav ${componentCls}-tab`]: { borderRadius: `${unit(token$1.borderRadius)} ${unit(token$1.borderRadius)} 0 0` } },
				[`&${componentCls}-right`]: { [`> ${componentCls}-nav ${componentCls}-tab`]: { borderRadius: {
					_skip_check_: true,
					value: `0 ${unit(token$1.borderRadius)} ${unit(token$1.borderRadius)} 0`
				} } },
				[`&${componentCls}-left`]: { [`> ${componentCls}-nav ${componentCls}-tab`]: { borderRadius: {
					_skip_check_: true,
					value: `${unit(token$1.borderRadius)} 0 0 ${unit(token$1.borderRadius)}`
				} } }
			},
			[`&${componentCls}-large`]: { [`> ${componentCls}-nav`]: {
				[`${componentCls}-tab`]: { padding: cardPaddingLG },
				[`${componentCls}-nav-add`]: {
					minWidth: cardHeightLG,
					minHeight: cardHeightLG
				}
			} }
		}
	};
};
var genTabStyle = (token$1) => {
	const { componentCls, itemActiveColor, itemHoverColor, iconCls, tabsHorizontalItemMargin, horizontalItemPadding, itemSelectedColor, itemColor } = token$1;
	const tabCls = `${componentCls}-tab`;
	return {
		[tabCls]: {
			position: "relative",
			WebkitTouchCallout: "none",
			WebkitTapHighlightColor: "transparent",
			display: "inline-flex",
			alignItems: "center",
			padding: horizontalItemPadding,
			fontSize: token$1.titleFontSize,
			background: "transparent",
			border: 0,
			outline: "none",
			cursor: "pointer",
			color: itemColor,
			"&-btn, &-remove": { "&:focus:not(:focus-visible), &:active": { color: itemActiveColor } },
			"&-btn": {
				outline: "none",
				transition: `all ${token$1.motionDurationSlow}`,
				[`${tabCls}-icon:not(:last-child)`]: { marginInlineEnd: token$1.marginSM }
			},
			"&-remove": {
				flex: "none",
				lineHeight: 1,
				marginRight: {
					_skip_check_: true,
					value: token$1.calc(token$1.marginXXS).mul(-1).equal()
				},
				marginLeft: {
					_skip_check_: true,
					value: token$1.marginXS
				},
				color: token$1.colorIcon,
				fontSize: token$1.fontSizeSM,
				background: "transparent",
				border: "none",
				outline: "none",
				cursor: "pointer",
				transition: `all ${token$1.motionDurationSlow}`,
				"&:hover": { color: token$1.colorTextHeading },
				...genFocusStyle(token$1)
			},
			"&:hover": { color: itemHoverColor },
			[`&${tabCls}-active ${tabCls}-btn`]: { color: itemSelectedColor },
			[`&${tabCls}-focus ${tabCls}-btn:focus-visible`]: genFocusOutline(token$1),
			[`&${tabCls}-disabled`]: {
				color: token$1.colorTextDisabled,
				cursor: "not-allowed"
			},
			[`&${tabCls}-disabled ${tabCls}-btn, &${tabCls}-disabled ${componentCls}-remove`]: { "&:focus, &:active": { color: token$1.colorTextDisabled } },
			[`& ${tabCls}-remove ${iconCls}`]: {
				margin: 0,
				verticalAlign: "middle"
			},
			[`${iconCls}:not(:last-child)`]: { marginRight: {
				_skip_check_: true,
				value: token$1.marginSM
			} }
		},
		[`${tabCls} + ${tabCls}`]: { margin: {
			_skip_check_: true,
			value: tabsHorizontalItemMargin
		} }
	};
};
var genRtlStyle$2 = (token$1) => {
	const { componentCls, tabsHorizontalItemMarginRTL, iconCls, cardGutter, calc } = token$1;
	return {
		[`${componentCls}-rtl`]: {
			direction: "rtl",
			[`${componentCls}-nav`]: { [`${componentCls}-tab`]: {
				margin: {
					_skip_check_: true,
					value: tabsHorizontalItemMarginRTL
				},
				[`${componentCls}-tab:last-of-type`]: { marginLeft: {
					_skip_check_: true,
					value: 0
				} },
				[iconCls]: {
					marginRight: {
						_skip_check_: true,
						value: 0
					},
					marginLeft: {
						_skip_check_: true,
						value: unit(token$1.marginSM)
					}
				},
				[`${componentCls}-tab-remove`]: {
					marginRight: {
						_skip_check_: true,
						value: unit(token$1.marginXS)
					},
					marginLeft: {
						_skip_check_: true,
						value: unit(calc(token$1.marginXXS).mul(-1).equal())
					},
					[iconCls]: { margin: 0 }
				}
			} },
			[`&${componentCls}-left`]: {
				[`> ${componentCls}-nav`]: { order: 1 },
				[`> ${componentCls}-content-holder`]: { order: 0 }
			},
			[`&${componentCls}-right`]: {
				[`> ${componentCls}-nav`]: { order: 0 },
				[`> ${componentCls}-content-holder`]: { order: 1 }
			},
			[`&${componentCls}-card${componentCls}-top, &${componentCls}-card${componentCls}-bottom`]: { [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: { [`${componentCls}-tab + ${componentCls}-tab`]: {
				marginRight: {
					_skip_check_: true,
					value: cardGutter
				},
				marginLeft: {
					_skip_check_: true,
					value: 0
				}
			} } }
		},
		[`${componentCls}-dropdown-rtl`]: { direction: "rtl" },
		[`${componentCls}-menu-item`]: { [`${componentCls}-dropdown-rtl`]: { textAlign: {
			_skip_check_: true,
			value: "right"
		} } }
	};
};
var genTabsStyle = (token$1) => {
	const { componentCls, tabsCardPadding, cardHeight, cardGutter, itemHoverColor, itemActiveColor, colorBorderSecondary } = token$1;
	return {
		[componentCls]: {
			...resetComponent(token$1),
			display: "flex",
			[`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
				position: "relative",
				display: "flex",
				flex: "none",
				alignItems: "center",
				[`${componentCls}-nav-wrap`]: {
					position: "relative",
					display: "flex",
					flex: "auto",
					alignSelf: "stretch",
					overflow: "hidden",
					whiteSpace: "nowrap",
					transform: "translate(0)",
					"&::before, &::after": {
						position: "absolute",
						zIndex: 1,
						opacity: 0,
						transition: `opacity ${token$1.motionDurationSlow}`,
						content: "''",
						pointerEvents: "none"
					}
				},
				[`${componentCls}-nav-list`]: {
					position: "relative",
					display: "flex",
					transition: `opacity ${token$1.motionDurationSlow}`
				},
				[`${componentCls}-nav-operations`]: {
					display: "flex",
					alignSelf: "stretch"
				},
				[`${componentCls}-nav-operations-hidden`]: {
					position: "absolute",
					visibility: "hidden",
					pointerEvents: "none"
				},
				[`${componentCls}-nav-more`]: {
					position: "relative",
					padding: tabsCardPadding,
					background: "transparent",
					border: 0,
					color: token$1.colorText,
					"&::after": {
						position: "absolute",
						right: {
							_skip_check_: true,
							value: 0
						},
						bottom: 0,
						left: {
							_skip_check_: true,
							value: 0
						},
						height: token$1.calc(token$1.controlHeightLG).div(8).equal(),
						transform: "translateY(100%)",
						content: "''"
					}
				},
				[`${componentCls}-nav-add`]: {
					minWidth: cardHeight,
					minHeight: cardHeight,
					marginLeft: {
						_skip_check_: true,
						value: cardGutter
					},
					background: "transparent",
					border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${colorBorderSecondary}`,
					borderRadius: `${unit(token$1.borderRadiusLG)} ${unit(token$1.borderRadiusLG)} 0 0`,
					outline: "none",
					cursor: "pointer",
					color: token$1.colorText,
					transition: `all ${token$1.motionDurationSlow} ${token$1.motionEaseInOut}`,
					"&:hover": { color: itemHoverColor },
					"&:active, &:focus:not(:focus-visible)": { color: itemActiveColor },
					...genFocusStyle(token$1, -3)
				}
			},
			[`${componentCls}-extra-content`]: { flex: "none" },
			[`${componentCls}-ink-bar`]: {
				position: "absolute",
				background: token$1.inkBarColor,
				pointerEvents: "none"
			},
			...genTabStyle(token$1),
			[`${componentCls}-content`]: {
				position: "relative",
				width: "100%"
			},
			[`${componentCls}-content-holder`]: {
				flex: "auto",
				minWidth: 0,
				minHeight: 0
			},
			[`${componentCls}-tabpane`]: {
				...genFocusStyle(token$1),
				"&-hidden": { display: "none" }
			}
		},
		[`${componentCls}-centered`]: { [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: { [`${componentCls}-nav-wrap`]: { [`&:not([class*='${componentCls}-nav-wrap-ping']) > ${componentCls}-nav-list`]: { margin: "auto" } } } }
	};
};
const prepareComponentToken$34 = (token$1) => {
	const { cardHeight, cardHeightSM, cardHeightLG, controlHeight, controlHeightLG } = token$1;
	const mergedCardHeight = cardHeight || controlHeightLG;
	const mergedCardHeightSM = cardHeightSM || controlHeight;
	const mergedCardHeightLG = cardHeightLG || controlHeightLG + 8;
	return {
		zIndexPopup: token$1.zIndexPopupBase + 50,
		cardBg: token$1.colorFillAlter,
		cardHeight: mergedCardHeight,
		cardHeightSM: mergedCardHeightSM,
		cardHeightLG: mergedCardHeightLG,
		cardPadding: `${(mergedCardHeight - token$1.fontHeight) / 2 - token$1.lineWidth}px ${token$1.padding}px`,
		cardPaddingSM: `${(mergedCardHeightSM - token$1.fontHeight) / 2 - token$1.lineWidth}px ${token$1.paddingXS}px`,
		cardPaddingLG: `${(mergedCardHeightLG - token$1.fontHeightLG) / 2 - token$1.lineWidth}px ${token$1.padding}px`,
		titleFontSize: token$1.fontSize,
		titleFontSizeLG: token$1.fontSizeLG,
		titleFontSizeSM: token$1.fontSize,
		inkBarColor: token$1.colorPrimary,
		horizontalMargin: `0 0 ${token$1.margin}px 0`,
		horizontalItemGutter: 32,
		horizontalItemMargin: ``,
		horizontalItemMarginRTL: ``,
		horizontalItemPadding: `${token$1.paddingSM}px 0`,
		horizontalItemPaddingSM: `${token$1.paddingXS}px 0`,
		horizontalItemPaddingLG: `${token$1.padding}px 0`,
		verticalItemPadding: `${token$1.paddingXS}px ${token$1.paddingLG}px`,
		verticalItemMargin: `${token$1.margin}px 0 0 0`,
		itemColor: token$1.colorText,
		itemSelectedColor: token$1.colorPrimary,
		itemHoverColor: token$1.colorPrimaryHover,
		itemActiveColor: token$1.colorPrimaryActive,
		cardGutter: token$1.marginXXS / 2
	};
};
var style_default$43 = genStyleHooks("Tabs", (token$1) => {
	const tabsToken = merge(token$1, {
		tabsCardPadding: token$1.cardPadding,
		dropdownEdgeChildVerticalPadding: token$1.paddingXXS,
		tabsDropdownHeight: 200,
		tabsDropdownWidth: 120,
		tabsHorizontalItemMargin: `0 0 0 ${unit(token$1.horizontalItemGutter)}`,
		tabsHorizontalItemMarginRTL: `0 0 0 ${unit(token$1.horizontalItemGutter)}`
	});
	return [
		genSizeStyle$2(tabsToken),
		genRtlStyle$2(tabsToken),
		genPositionStyle(tabsToken),
		genDropdownStyle$1(tabsToken),
		genCardStyle$1(tabsToken),
		genTabsStyle(tabsToken),
		motion_default$3(tabsToken)
	];
}, prepareComponentToken$34);

//#endregion
//#region node_modules/antd/es/tabs/TabPane.js
var TabPane = () => null;
TabPane.displayName = "DeprecatedTabPane";
var TabPane_default = TabPane;

//#endregion
//#region node_modules/antd/es/tabs/index.js
var Tabs = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { type: type$2, className, rootClassName, size: customSize, onEdit, hideAdd, centered, addIcon, removeIcon, moreIcon, more, popupClassName, children, items, animated, style: style$1, indicatorSize, indicator, classNames, styles, destroyInactiveTabPane, destroyOnHidden, tabPlacement, tabPosition, ...restProps } = props;
	const { prefixCls: customizePrefixCls } = restProps;
	const { getPrefixCls, direction, getPopupContainer, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("tabs");
	const { tabs } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("tabs", customizePrefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$43(prefixCls, rootCls);
	const tabsRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => ({ nativeElement: tabsRef.current }));
	let editable;
	if (type$2 === "editable-card") editable = {
		onEdit: (editType, { key, event }) => {
			onEdit?.(editType === "add" ? event : key, editType);
		},
		removeIcon: removeIcon ?? tabs?.removeIcon ?? /* @__PURE__ */ import_react.createElement(CloseOutlined_default, null),
		addIcon: (addIcon ?? tabs?.addIcon) || /* @__PURE__ */ import_react.createElement(PlusOutlined_default, null),
		showAdd: hideAdd !== true
	};
	const rootPrefixCls = getPrefixCls();
	{
		const warning$3 = devUseWarning("Tabs");
		[["popupClassName", "classNames.popup"], ["tabPosition", "tabPlacement"]].forEach(([deprecatedName, newName]) => {
			warning$3.deprecated(!(deprecatedName in props), deprecatedName, newName);
		});
		warning$3(!("onPrevClick" in props) && !("onNextClick" in props), "breaking", "`onPrevClick` and `onNextClick` has been removed. Please use `onTabScroll` instead.");
		warning$3(!(indicatorSize || tabs?.indicatorSize), "deprecated", "`indicatorSize` has been deprecated. Please use `indicator={{ size: ... }}` instead.");
		warning$3.deprecated(!("destroyInactiveTabPane" in props || items?.some((item) => "destroyInactiveTabPane" in item)), "destroyInactiveTabPane", "destroyOnHidden");
	}
	const size = useSize_default(customSize);
	const mergedItems = useLegacyItems_default(items, children);
	const mergedAnimated = useAnimateConfig(prefixCls, animated);
	const mergedIndicator = {
		align: indicator?.align ?? tabs?.indicator?.align,
		size: indicator?.size ?? indicatorSize ?? tabs?.indicator?.size ?? tabs?.indicatorSize
	};
	const mergedPlacement = import_react.useMemo(() => {
		const placement = tabPlacement ?? tabPosition ?? void 0;
		const isRTL = direction === "rtl";
		switch (placement) {
			case "start": return isRTL ? "right" : "left";
			case "end": return isRTL ? "left" : "right";
			default: return placement;
		}
	}, [
		tabPlacement,
		tabPosition,
		direction
	]);
	const mergedProps = {
		...props,
		size,
		tabPlacement: mergedPlacement,
		items: mergedItems
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps }, { popup: { _default: "root" } });
	return /* @__PURE__ */ import_react.createElement(es_default$28, {
		ref: tabsRef,
		direction,
		getPopupContainer,
		...restProps,
		items: mergedItems,
		className: clsx({
			[`${prefixCls}-${size}`]: size,
			[`${prefixCls}-card`]: ["card", "editable-card"].includes(type$2),
			[`${prefixCls}-editable-card`]: type$2 === "editable-card",
			[`${prefixCls}-centered`]: centered
		}, contextClassName, className, rootClassName, mergedClassNames.root, hashId, cssVarCls, rootCls),
		classNames: {
			...mergedClassNames,
			popup: clsx(popupClassName, hashId, cssVarCls, rootCls, mergedClassNames.popup?.root)
		},
		styles: mergedStyles,
		style: {
			...mergedStyles.root,
			...contextStyle,
			...style$1
		},
		editable,
		more: {
			icon: tabs?.more?.icon ?? tabs?.moreIcon ?? moreIcon ?? /* @__PURE__ */ import_react.createElement(EllipsisOutlined_default, null),
			transitionName: `${rootPrefixCls}-slide-up`,
			...more
		},
		prefixCls,
		animated: mergedAnimated,
		indicator: mergedIndicator,
		destroyOnHidden: destroyOnHidden ?? destroyInactiveTabPane,
		tabPosition: mergedPlacement
	});
});
Tabs.TabPane = TabPane_default;
Tabs.displayName = "Tabs";
var tabs_default = Tabs;

//#endregion
//#region node_modules/antd/es/card/CardGrid.js
var CardGrid = ({ prefixCls, className, hoverable = true, ...props }) => {
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefix$1 = getPrefixCls("card", prefixCls);
	const classString = clsx(`${prefix$1}-grid`, className, { [`${prefix$1}-grid-hoverable`]: hoverable });
	return /* @__PURE__ */ import_react.createElement("div", {
		...props,
		className: classString
	});
};
CardGrid.displayName = "CardGrid";
var CardGrid_default = CardGrid;

//#endregion
//#region node_modules/antd/es/card/style/index.js
var genCardHeadStyle = (token$1) => {
	const { antCls, componentCls, headerHeight, headerPadding, tabsMarginBottom } = token$1;
	return {
		display: "flex",
		justifyContent: "center",
		flexDirection: "column",
		minHeight: headerHeight,
		marginBottom: -1,
		padding: `0 ${unit(headerPadding)}`,
		color: token$1.colorTextHeading,
		fontWeight: token$1.fontWeightStrong,
		fontSize: token$1.headerFontSize,
		background: token$1.headerBg,
		borderBottom: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorderSecondary}`,
		borderRadius: `${unit(token$1.borderRadiusLG)} ${unit(token$1.borderRadiusLG)} 0 0`,
		...clearFix(),
		"&-wrapper": {
			width: "100%",
			display: "flex",
			alignItems: "center"
		},
		"&-title": {
			display: "inline-block",
			flex: 1,
			...textEllipsis,
			[`
          > ${componentCls}-typography,
          > ${componentCls}-typography-edit-content
        `]: {
				insetInlineStart: 0,
				marginTop: 0,
				marginBottom: 0
			}
		},
		[`${antCls}-tabs-top`]: {
			clear: "both",
			marginBottom: tabsMarginBottom,
			color: token$1.colorText,
			fontWeight: "normal",
			fontSize: token$1.fontSize,
			"&-bar": { borderBottom: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorderSecondary}` }
		}
	};
};
var genCardGridStyle = (token$1) => {
	const { cardPaddingBase, colorBorderSecondary, cardShadow, lineWidth } = token$1;
	return {
		width: "33.33%",
		padding: cardPaddingBase,
		border: 0,
		borderRadius: 0,
		boxShadow: `
      ${unit(lineWidth)} 0 0 0 ${colorBorderSecondary},
      0 ${unit(lineWidth)} 0 0 ${colorBorderSecondary},
      ${unit(lineWidth)} ${unit(lineWidth)} 0 0 ${colorBorderSecondary},
      ${unit(lineWidth)} 0 0 0 ${colorBorderSecondary} inset,
      0 ${unit(lineWidth)} 0 0 ${colorBorderSecondary} inset;
    `,
		transition: `all ${token$1.motionDurationMid}`,
		"&-hoverable:hover": {
			position: "relative",
			zIndex: 1,
			boxShadow: cardShadow
		}
	};
};
var genCardActionsStyle = (token$1) => {
	const { componentCls, iconCls, actionsLiMargin, cardActionsIconSize, colorBorderSecondary, actionsBg } = token$1;
	return {
		margin: 0,
		padding: 0,
		listStyle: "none",
		background: actionsBg,
		borderTop: `${unit(token$1.lineWidth)} ${token$1.lineType} ${colorBorderSecondary}`,
		display: "flex",
		borderRadius: `0 0 ${unit(token$1.borderRadiusLG)} ${unit(token$1.borderRadiusLG)}`,
		...clearFix(),
		"& > li": {
			margin: actionsLiMargin,
			color: token$1.colorTextDescription,
			textAlign: "center",
			"> span": {
				position: "relative",
				display: "block",
				minWidth: token$1.calc(token$1.cardActionsIconSize).mul(2).equal(),
				fontSize: token$1.fontSize,
				lineHeight: token$1.lineHeight,
				cursor: "pointer",
				"&:hover": {
					color: token$1.colorPrimary,
					transition: `color ${token$1.motionDurationMid}`
				},
				[`a:not(${componentCls}-btn), > ${iconCls}`]: {
					display: "inline-block",
					width: "100%",
					color: token$1.colorIcon,
					lineHeight: unit(token$1.fontHeight),
					transition: `color ${token$1.motionDurationMid}`,
					"&:hover": { color: token$1.colorPrimary }
				},
				[`> ${iconCls}`]: {
					fontSize: cardActionsIconSize,
					lineHeight: unit(token$1.calc(cardActionsIconSize).mul(token$1.lineHeight).equal())
				}
			},
			"&:not(:last-child)": { borderInlineEnd: `${unit(token$1.lineWidth)} ${token$1.lineType} ${colorBorderSecondary}` }
		}
	};
};
var genCardMetaStyle = (token$1) => ({
	margin: `${unit(token$1.calc(token$1.marginXXS).mul(-1).equal())} 0`,
	display: "flex",
	...clearFix(),
	"&-avatar": { paddingInlineEnd: token$1.padding },
	"&-section": {
		overflow: "hidden",
		flex: 1,
		"> div:not(:last-child)": { marginBottom: token$1.marginXS }
	},
	"&-title": {
		color: token$1.colorTextHeading,
		fontWeight: token$1.fontWeightStrong,
		fontSize: token$1.fontSizeLG,
		...textEllipsis
	},
	"&-description": { color: token$1.colorTextDescription }
});
var genCardTypeInnerStyle = (token$1) => {
	const { componentCls, colorFillAlter, headerPadding, bodyPadding } = token$1;
	return {
		[`${componentCls}-head`]: {
			padding: `0 ${unit(headerPadding)}`,
			background: colorFillAlter,
			"&-title": { fontSize: token$1.fontSize }
		},
		[`${componentCls}-body`]: { padding: `${unit(token$1.padding)} ${unit(bodyPadding)}` }
	};
};
var genCardLoadingStyle = (token$1) => {
	const { componentCls } = token$1;
	return {
		overflow: "hidden",
		[`${componentCls}-body`]: { userSelect: "none" }
	};
};
var genCardStyle = (token$1) => {
	const { componentCls, cardShadow, cardHeadPadding, colorBorderSecondary, boxShadowTertiary, bodyPadding, extraColor } = token$1;
	return {
		[componentCls]: {
			...resetComponent(token$1),
			position: "relative",
			background: token$1.colorBgContainer,
			borderRadius: token$1.borderRadiusLG,
			[`&:not(${componentCls}-bordered)`]: { boxShadow: boxShadowTertiary },
			[`${componentCls}-head`]: genCardHeadStyle(token$1),
			[`${componentCls}-extra`]: {
				marginInlineStart: "auto",
				color: extraColor,
				fontWeight: "normal",
				fontSize: token$1.fontSize
			},
			[`${componentCls}-body`]: {
				padding: bodyPadding,
				borderRadius: `0 0 ${unit(token$1.borderRadiusLG)} ${unit(token$1.borderRadiusLG)}`
			},
			[`${componentCls}-grid`]: genCardGridStyle(token$1),
			[`${componentCls}-cover`]: { "> *": {
				display: "block",
				width: "100%",
				borderRadius: `${unit(token$1.borderRadiusLG)} ${unit(token$1.borderRadiusLG)} 0 0`
			} },
			[`${componentCls}-actions`]: genCardActionsStyle(token$1),
			[`${componentCls}-meta`]: genCardMetaStyle(token$1)
		},
		[`${componentCls}-bordered`]: {
			border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${colorBorderSecondary}`,
			[`${componentCls}-cover`]: {
				marginTop: -1,
				marginInlineStart: -1,
				marginInlineEnd: -1
			}
		},
		[`${componentCls}-hoverable`]: {
			cursor: "pointer",
			transition: `box-shadow ${token$1.motionDurationMid}, border-color ${token$1.motionDurationMid}`,
			"&:hover": {
				borderColor: "transparent",
				boxShadow: cardShadow
			}
		},
		[`${componentCls}-contain-grid`]: {
			borderRadius: `${unit(token$1.borderRadiusLG)} ${unit(token$1.borderRadiusLG)} 0 0 `,
			[`&:not(:has(> ${componentCls}-head))`]: { borderRadius: 0 },
			[`${componentCls}-body`]: {
				display: "flex",
				flexWrap: "wrap"
			},
			[`&:not(${componentCls}-loading) ${componentCls}-body`]: {
				marginBlockStart: token$1.calc(token$1.lineWidth).mul(-1).equal(),
				marginInlineStart: token$1.calc(token$1.lineWidth).mul(-1).equal(),
				padding: 0
			}
		},
		[`${componentCls}-contain-tabs`]: { [`> div${componentCls}-head`]: {
			minHeight: 0,
			[`${componentCls}-head-title, ${componentCls}-extra`]: { paddingTop: cardHeadPadding }
		} },
		[`${componentCls}-type-inner`]: genCardTypeInnerStyle(token$1),
		[`${componentCls}-loading`]: genCardLoadingStyle(token$1),
		[`${componentCls}-rtl`]: { direction: "rtl" }
	};
};
var genCardSizeStyle = (token$1) => {
	const { componentCls, bodyPaddingSM, headerPaddingSM, headerHeightSM, headerFontSizeSM } = token$1;
	return {
		[`${componentCls}-small`]: {
			[`> ${componentCls}-head`]: {
				minHeight: headerHeightSM,
				padding: `0 ${unit(headerPaddingSM)}`,
				fontSize: headerFontSizeSM,
				[`> ${componentCls}-head-wrapper`]: { [`> ${componentCls}-extra`]: { fontSize: token$1.fontSize } }
			},
			[`> ${componentCls}-body`]: { padding: bodyPaddingSM }
		},
		[`${componentCls}-small${componentCls}-contain-tabs`]: { [`> ${componentCls}-head`]: { [`${componentCls}-head-title, ${componentCls}-extra`]: {
			paddingTop: 0,
			display: "flex",
			alignItems: "center"
		} } }
	};
};
const prepareComponentToken$33 = (token$1) => ({
	headerBg: "transparent",
	headerFontSize: token$1.fontSizeLG,
	headerFontSizeSM: token$1.fontSize,
	headerHeight: token$1.fontSizeLG * token$1.lineHeightLG + token$1.padding * 2,
	headerHeightSM: token$1.fontSize * token$1.lineHeight + token$1.paddingXS * 2,
	actionsBg: token$1.colorBgContainer,
	actionsLiMargin: `${token$1.paddingSM}px 0`,
	tabsMarginBottom: -token$1.padding - token$1.lineWidth,
	extraColor: token$1.colorText,
	bodyPaddingSM: 12,
	headerPaddingSM: 12,
	bodyPadding: token$1.bodyPadding ?? token$1.paddingLG,
	headerPadding: token$1.headerPadding ?? token$1.paddingLG
});
var style_default$42 = genStyleHooks("Card", (token$1) => {
	const cardToken = merge(token$1, {
		cardShadow: token$1.boxShadowCard,
		cardHeadPadding: token$1.padding,
		cardPaddingBase: token$1.paddingLG,
		cardActionsIconSize: token$1.fontSize
	});
	return [genCardStyle(cardToken), genCardSizeStyle(cardToken)];
}, prepareComponentToken$33);

//#endregion
//#region node_modules/antd/es/card/Card.js
var ActionNode = (props) => {
	const { actionClasses, actions = [], actionStyle } = props;
	return /* @__PURE__ */ import_react.createElement("ul", {
		className: actionClasses,
		style: actionStyle
	}, actions.map((action, index$1) => {
		const key = `action-${index$1}`;
		return /* @__PURE__ */ import_react.createElement("li", {
			style: { width: `${100 / actions.length}%` },
			key
		}, /* @__PURE__ */ import_react.createElement("span", null, action));
	}));
};
var Card$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, style: style$1, extra, headStyle = {}, bodyStyle = {}, title, loading, bordered, variant: customVariant, size: customizeSize, type: type$2, cover, actions, tabList, children, activeTabKey, defaultActiveTabKey, tabBarExtraContent, hoverable, tabProps = {}, classNames, styles, ...rest } = props;
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("card");
	const [variant] = useVariants_default("card", customVariant, bordered);
	const mergedSize = useSize_default(customizeSize);
	const mergedProps = {
		...props,
		size: mergedSize,
		variant,
		loading
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	{
		const warning$3 = devUseWarning("Card");
		[
			["headStyle", "styles.header"],
			["bodyStyle", "styles.body"],
			["bordered", "variant"]
		].forEach(([deprecatedName, newName]) => {
			warning$3.deprecated(!(deprecatedName in props), deprecatedName, newName);
		});
	}
	const onTabChange = (key) => {
		props.onTabChange?.(key);
	};
	const isContainGrid = import_react.useMemo(() => {
		return toArray(children).some((child) => /* @__PURE__ */ import_react.isValidElement(child) && child.type === CardGrid_default);
	}, [children]);
	const prefixCls = getPrefixCls("card", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$42(prefixCls);
	const loadingBlock = /* @__PURE__ */ import_react.createElement(skeleton_default, {
		loading: true,
		active: true,
		paragraph: { rows: 4 },
		title: false
	}, children);
	const hasActiveTabKey = activeTabKey !== void 0;
	const extraProps = {
		...tabProps,
		[hasActiveTabKey ? "activeKey" : "defaultActiveKey"]: hasActiveTabKey ? activeTabKey : defaultActiveTabKey,
		tabBarExtraContent
	};
	let head;
	const tabSize = !mergedSize || mergedSize === "default" ? "large" : mergedSize;
	const tabs = tabList ? /* @__PURE__ */ import_react.createElement(tabs_default, {
		size: tabSize,
		...extraProps,
		className: `${prefixCls}-head-tabs`,
		onChange: onTabChange,
		items: tabList.map(({ tab, ...item }) => ({
			label: tab,
			...item
		}))
	}) : null;
	if (title || extra || tabs) {
		const headClasses = clsx(`${prefixCls}-head`, mergedClassNames.header);
		const titleClasses = clsx(`${prefixCls}-head-title`, mergedClassNames.title);
		const extraClasses = clsx(`${prefixCls}-extra`, mergedClassNames.extra);
		const mergedHeadStyle = {
			...headStyle,
			...mergedStyles.header
		};
		head = /* @__PURE__ */ import_react.createElement("div", {
			className: headClasses,
			style: mergedHeadStyle
		}, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-head-wrapper` }, title && /* @__PURE__ */ import_react.createElement("div", {
			className: titleClasses,
			style: mergedStyles.title
		}, title), extra && /* @__PURE__ */ import_react.createElement("div", {
			className: extraClasses,
			style: mergedStyles.extra
		}, extra)), tabs);
	}
	const coverClasses = clsx(`${prefixCls}-cover`, mergedClassNames.cover);
	const coverDom = cover ? /* @__PURE__ */ import_react.createElement("div", {
		className: coverClasses,
		style: mergedStyles.cover
	}, cover) : null;
	const bodyClasses = clsx(`${prefixCls}-body`, mergedClassNames.body);
	const mergedBodyStyle = {
		...bodyStyle,
		...mergedStyles.body
	};
	const body = /* @__PURE__ */ import_react.createElement("div", {
		className: bodyClasses,
		style: mergedBodyStyle
	}, loading ? loadingBlock : children);
	const actionClasses = clsx(`${prefixCls}-actions`, mergedClassNames.actions);
	const actionDom = actions?.length ? /* @__PURE__ */ import_react.createElement(ActionNode, {
		actionClasses,
		actionStyle: mergedStyles.actions,
		actions
	}) : null;
	const divProps = omit(rest, ["onTabChange"]);
	const classString = clsx(prefixCls, contextClassName, {
		[`${prefixCls}-loading`]: loading,
		[`${prefixCls}-bordered`]: variant !== "borderless",
		[`${prefixCls}-hoverable`]: hoverable,
		[`${prefixCls}-contain-grid`]: isContainGrid,
		[`${prefixCls}-contain-tabs`]: tabList?.length,
		[`${prefixCls}-${mergedSize}`]: mergedSize,
		[`${prefixCls}-type-${type$2}`]: !!type$2,
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, className, rootClassName, hashId, cssVarCls, mergedClassNames.root);
	const mergedStyle = {
		...mergedStyles.root,
		...contextStyle,
		...style$1
	};
	return /* @__PURE__ */ import_react.createElement("div", {
		ref,
		...divProps,
		className: classString,
		style: mergedStyle
	}, head, coverDom, body, actionDom);
});
Card$1.displayName = "Card";
var Card_default = Card$1;

//#endregion
//#region node_modules/antd/es/card/CardMeta.js
var CardMeta = (props) => {
	const { prefixCls: customizePrefixCls, className, avatar, title, description, style: style$1, classNames: cardMetaClassNames, styles, ...restProps } = props;
	const { getPrefixCls, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("cardMeta");
	const metaPrefixCls = `${getPrefixCls("card", customizePrefixCls)}-meta`;
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, cardMetaClassNames], [contextStyles, styles], { props });
	const rootClassNames = clsx(metaPrefixCls, className, contextClassName, mergedClassNames.root);
	const rootStyles = {
		...contextStyle,
		...mergedStyles.root,
		...style$1
	};
	const avatarClassNames = clsx(`${metaPrefixCls}-avatar`, mergedClassNames.avatar);
	const titleClassNames = clsx(`${metaPrefixCls}-title`, mergedClassNames.title);
	const descriptionClassNames = clsx(`${metaPrefixCls}-description`, mergedClassNames.description);
	const sectionClassNames = clsx(`${metaPrefixCls}-section`, mergedClassNames.section);
	const avatarDom = avatar ? /* @__PURE__ */ import_react.createElement("div", {
		className: avatarClassNames,
		style: mergedStyles.avatar
	}, avatar) : null;
	const titleDom = title ? /* @__PURE__ */ import_react.createElement("div", {
		className: titleClassNames,
		style: mergedStyles.title
	}, title) : null;
	const descriptionDom = description ? /* @__PURE__ */ import_react.createElement("div", {
		className: descriptionClassNames,
		style: mergedStyles.description
	}, description) : null;
	const MetaDetail = titleDom || descriptionDom ? /* @__PURE__ */ import_react.createElement("div", {
		className: sectionClassNames,
		style: mergedStyles.section
	}, titleDom, descriptionDom) : null;
	return /* @__PURE__ */ import_react.createElement("div", {
		...restProps,
		className: rootClassNames,
		style: rootStyles
	}, avatarDom, MetaDetail);
};
CardMeta.displayName = "CardMeta";
var CardMeta_default = CardMeta;

//#endregion
//#region node_modules/antd/es/card/index.js
var Card = Card_default;
Card.Grid = CardGrid_default;
Card.Meta = CardMeta_default;
var card_default = Card;

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r$1, e$2) {
	if (null == r$1) return {};
	var t$1 = {};
	for (var n$1 in r$1) if ({}.hasOwnProperty.call(r$1, n$1)) {
		if (-1 !== e$2.indexOf(n$1)) continue;
		t$1[n$1] = r$1[n$1];
	}
	return t$1;
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties(e$2, t$1) {
	if (null == e$2) return {};
	var o$2, r$1, i = _objectWithoutPropertiesLoose(e$2, t$1);
	if (Object.getOwnPropertySymbols) {
		var n$1 = Object.getOwnPropertySymbols(e$2);
		for (r$1 = 0; r$1 < n$1.length; r$1++) o$2 = n$1[r$1], -1 === t$1.indexOf(o$2) && {}.propertyIsEnumerable.call(e$2, o$2) && (i[o$2] = e$2[o$2]);
	}
	return i;
}

//#endregion
//#region node_modules/@ant-design/react-slick/es/initial-state.js
var initialState = {
	animating: false,
	autoplaying: null,
	currentDirection: 0,
	currentLeft: null,
	currentSlide: 0,
	direction: 1,
	dragging: false,
	edgeDragged: false,
	initialized: false,
	lazyLoadedList: [],
	listHeight: null,
	listWidth: null,
	scrolling: false,
	slideCount: null,
	slideHeight: null,
	slideWidth: null,
	swipeLeft: null,
	swiped: false,
	swiping: false,
	touchObject: {
		startX: 0,
		startY: 0,
		curX: 0,
		curY: 0
	},
	trackStyle: {},
	trackWidth: 0,
	targetSlide: 0
};
var initial_state_default = initialState;

//#endregion
//#region node_modules/throttle-debounce/esm/index.js
/**
* Throttle execution of a function. Especially useful for rate limiting
* execution of handlers on events like resize and scroll.
*
* @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)
*                                            are most useful.
* @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,
*                                            as-is, to `callback` when the throttled-function is executed.
* @param {object} [options] -              An object to configure options.
* @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds
*                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed
*                                            one final time after the last throttled-function call. (After the throttled-function has not been called for
*                                            `delay` milliseconds, the internal counter is reset).
* @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback
*                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that
*                                            callback will never executed if both noLeading = true and noTrailing = true.
* @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is
*                                            false (at end), schedule `callback` to execute after `delay` ms.
*
* @returns {Function} A new, throttled, function.
*/
function throttle(delay, callback, options) {
	var _ref = options || {}, _ref$noTrailing = _ref.noTrailing, noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing, _ref$noLeading = _ref.noLeading, noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading, _ref$debounceMode = _ref.debounceMode, debounceMode = _ref$debounceMode === void 0 ? void 0 : _ref$debounceMode;
	var timeoutID;
	var cancelled = false;
	var lastExec = 0;
	function clearExistingTimeout() {
		if (timeoutID) clearTimeout(timeoutID);
	}
	function cancel(options$1) {
		var _ref2$upcomingOnly = (options$1 || {}).upcomingOnly, upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;
		clearExistingTimeout();
		cancelled = !upcomingOnly;
	}
	function wrapper() {
		for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) arguments_[_key] = arguments[_key];
		var self$1 = this;
		var elapsed = Date.now() - lastExec;
		if (cancelled) return;
		function exec() {
			lastExec = Date.now();
			callback.apply(self$1, arguments_);
		}
		function clear() {
			timeoutID = void 0;
		}
		if (!noLeading && debounceMode && !timeoutID) exec();
		clearExistingTimeout();
		if (debounceMode === void 0 && elapsed > delay) if (noLeading) {
			lastExec = Date.now();
			if (!noTrailing) timeoutID = setTimeout(debounceMode ? clear : exec, delay);
		} else exec();
		else if (noTrailing !== true) timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
	}
	wrapper.cancel = cancel;
	return wrapper;
}
/**
* Debounce execution of a function. Debouncing, unlike throttling,
* guarantees that a function is only executed a single time, either at the
* very beginning of a series of calls, or at the very end.
*
* @param {number} delay -               A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
* @param {Function} callback -          A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
*                                        to `callback` when the debounced-function is executed.
* @param {object} [options] -           An object to configure options.
* @param {boolean} [options.atBegin] -  Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
*                                        after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
*                                        (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
*
* @returns {Function} A new, debounced function.
*/
function debounce(delay, callback, options) {
	var _ref$atBegin = (options || {}).atBegin;
	return throttle(delay, callback, { debounceMode: (_ref$atBegin === void 0 ? false : _ref$atBegin) !== false });
}

//#endregion
//#region node_modules/@ant-design/react-slick/es/default-props.js
var defaultProps$1 = {
	accessibility: true,
	adaptiveHeight: false,
	afterChange: null,
	appendDots: function appendDots(dots) {
		return /* @__PURE__ */ import_react.createElement("ul", { style: { display: "block" } }, dots);
	},
	arrows: true,
	autoplay: false,
	autoplaySpeed: 3e3,
	beforeChange: null,
	centerMode: false,
	centerPadding: "50px",
	className: "",
	cssEase: "ease",
	customPaging: function customPaging(i) {
		return /* @__PURE__ */ import_react.createElement("button", null, i + 1);
	},
	dots: false,
	dotsClass: "slick-dots",
	draggable: true,
	easing: "linear",
	edgeFriction: .35,
	fade: false,
	focusOnSelect: false,
	infinite: true,
	initialSlide: 0,
	lazyLoad: null,
	nextArrow: null,
	onEdge: null,
	onInit: null,
	onLazyLoadError: null,
	onReInit: null,
	pauseOnDotsHover: false,
	pauseOnFocus: false,
	pauseOnHover: true,
	prevArrow: null,
	responsive: null,
	rows: 1,
	rtl: false,
	slide: "div",
	slidesPerRow: 1,
	slidesToScroll: 1,
	slidesToShow: 1,
	speed: 500,
	swipe: true,
	swipeEvent: null,
	swipeToSlide: false,
	touchMove: true,
	touchThreshold: 5,
	useCSS: true,
	useTransform: true,
	variableWidth: false,
	vertical: false,
	verticalSwiping: false,
	waitForAnimate: true,
	asNavFor: null,
	unslick: false
};
var default_props_default = defaultProps$1;

//#endregion
//#region node_modules/@ant-design/react-slick/es/utils/innerSliderUtils.js
function clamp(number$1, lowerBound, upperBound) {
	return Math.max(lowerBound, Math.min(number$1, upperBound));
}
var safePreventDefault = function safePreventDefault$1(event) {
	if (![
		"onTouchStart",
		"onTouchMove",
		"onWheel"
	].includes(event._reactName)) event.preventDefault();
};
var getOnDemandLazySlides = function getOnDemandLazySlides$1(spec) {
	var onDemandSlides = [];
	var startIndex = lazyStartIndex(spec);
	var endIndex = lazyEndIndex(spec);
	for (var slideIndex = startIndex; slideIndex < endIndex; slideIndex++) if (spec.lazyLoadedList.indexOf(slideIndex) < 0) onDemandSlides.push(slideIndex);
	return onDemandSlides;
};
var lazyStartIndex = function lazyStartIndex$1(spec) {
	return spec.currentSlide - lazySlidesOnLeft(spec);
};
var lazyEndIndex = function lazyEndIndex$1(spec) {
	return spec.currentSlide + lazySlidesOnRight(spec);
};
var lazySlidesOnLeft = function lazySlidesOnLeft$1(spec) {
	return spec.centerMode ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : 0;
};
var lazySlidesOnRight = function lazySlidesOnRight$1(spec) {
	return spec.centerMode ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : spec.slidesToShow;
};
var getWidth = function getWidth$2(elem) {
	return elem && elem.offsetWidth || 0;
};
var getHeight = function getHeight$1(elem) {
	return elem && elem.offsetHeight || 0;
};
var getSwipeDirection = function getSwipeDirection$1(touchObject) {
	var verticalSwiping = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
	var xDist = touchObject.startX - touchObject.curX, yDist = touchObject.startY - touchObject.curY, r$1 = Math.atan2(yDist, xDist), swipeAngle = Math.round(r$1 * 180 / Math.PI);
	if (swipeAngle < 0) swipeAngle = 360 - Math.abs(swipeAngle);
	if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) return "left";
	if (swipeAngle >= 135 && swipeAngle <= 225) return "right";
	if (verticalSwiping === true) if (swipeAngle >= 35 && swipeAngle <= 135) return "up";
	else return "down";
	return "vertical";
};
var canGoNext = function canGoNext$1(spec) {
	var canGo = true;
	if (!spec.infinite) {
		if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) canGo = false;
		else if (spec.slideCount <= spec.slidesToShow || spec.currentSlide >= spec.slideCount - spec.slidesToShow) canGo = false;
	}
	return canGo;
};
var extractObject = function extractObject$1(spec, keys$1) {
	var newObject = {};
	keys$1.forEach(function(key) {
		return newObject[key] = spec[key];
	});
	return newObject;
};
var initializedState = function initializedState$1(spec) {
	var slideCount = import_react.Children.count(spec.children);
	var listNode = spec.listRef;
	var listWidth = Math.ceil(getWidth(listNode));
	var trackNode = spec.trackRef && spec.trackRef.node;
	var trackWidth = Math.ceil(getWidth(trackNode));
	var slideWidth;
	if (!spec.vertical) {
		var centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;
		if (typeof spec.centerPadding === "string" && spec.centerPadding.slice(-1) === "%") centerPaddingAdj *= listWidth / 100;
		slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);
	} else slideWidth = listWidth;
	var slideHeight = listNode && getHeight(listNode.querySelector("[data-index=\"0\"]"));
	var listHeight = slideHeight * spec.slidesToShow;
	var currentSlide = spec.currentSlide === void 0 ? spec.initialSlide : spec.currentSlide;
	if (spec.rtl && spec.currentSlide === void 0) currentSlide = slideCount - 1 - spec.initialSlide;
	var lazyLoadedList = spec.lazyLoadedList || [];
	var slidesToLoad = getOnDemandLazySlides(_objectSpread2(_objectSpread2({}, spec), {}, {
		currentSlide,
		lazyLoadedList
	}));
	lazyLoadedList = lazyLoadedList.concat(slidesToLoad);
	var state = {
		slideCount,
		slideWidth,
		listWidth,
		trackWidth,
		currentSlide,
		slideHeight,
		listHeight,
		lazyLoadedList
	};
	if (spec.autoplaying === null && spec.autoplay) state["autoplaying"] = "playing";
	return state;
};
var slideHandler = function slideHandler$1(spec) {
	var waitForAnimate = spec.waitForAnimate, animating = spec.animating, fade = spec.fade, infinite = spec.infinite, index$1 = spec.index, slideCount = spec.slideCount, lazyLoad = spec.lazyLoad, currentSlide = spec.currentSlide, centerMode = spec.centerMode, slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, useCSS = spec.useCSS;
	var lazyLoadedList = spec.lazyLoadedList;
	if (waitForAnimate && animating) return {};
	var animationSlide = index$1, finalSlide, animationLeft, finalLeft;
	var state = {}, nextState = {};
	var targetSlide = infinite ? index$1 : clamp(index$1, 0, slideCount - 1);
	if (fade) {
		if (!infinite && (index$1 < 0 || index$1 >= slideCount)) return {};
		if (index$1 < 0) animationSlide = index$1 + slideCount;
		else if (index$1 >= slideCount) animationSlide = index$1 - slideCount;
		if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) lazyLoadedList = lazyLoadedList.concat(animationSlide);
		state = {
			animating: true,
			currentSlide: animationSlide,
			lazyLoadedList,
			targetSlide: animationSlide
		};
		nextState = {
			animating: false,
			targetSlide: animationSlide
		};
	} else {
		finalSlide = animationSlide;
		if (animationSlide < 0) {
			finalSlide = animationSlide + slideCount;
			if (!infinite) finalSlide = 0;
			else if (slideCount % slidesToScroll !== 0) finalSlide = slideCount - slideCount % slidesToScroll;
		} else if (!canGoNext(spec) && animationSlide > currentSlide) animationSlide = finalSlide = currentSlide;
		else if (centerMode && animationSlide >= slideCount) {
			animationSlide = infinite ? slideCount : slideCount - 1;
			finalSlide = infinite ? 0 : slideCount - 1;
		} else if (animationSlide >= slideCount) {
			finalSlide = animationSlide - slideCount;
			if (!infinite) finalSlide = slideCount - slidesToShow;
			else if (slideCount % slidesToScroll !== 0) finalSlide = 0;
		}
		if (!infinite && animationSlide + slidesToShow >= slideCount) finalSlide = slideCount - slidesToShow;
		animationLeft = getTrackLeft(_objectSpread2(_objectSpread2({}, spec), {}, { slideIndex: animationSlide }));
		finalLeft = getTrackLeft(_objectSpread2(_objectSpread2({}, spec), {}, { slideIndex: finalSlide }));
		if (!infinite) {
			if (animationLeft === finalLeft) animationSlide = finalSlide;
			animationLeft = finalLeft;
		}
		if (lazyLoad) lazyLoadedList = lazyLoadedList.concat(getOnDemandLazySlides(_objectSpread2(_objectSpread2({}, spec), {}, { currentSlide: animationSlide })));
		if (!useCSS) state = {
			currentSlide: finalSlide,
			trackStyle: getTrackCSS(_objectSpread2(_objectSpread2({}, spec), {}, { left: finalLeft })),
			lazyLoadedList,
			targetSlide
		};
		else {
			state = {
				animating: true,
				currentSlide: finalSlide,
				trackStyle: getTrackAnimateCSS(_objectSpread2(_objectSpread2({}, spec), {}, { left: animationLeft })),
				lazyLoadedList,
				targetSlide
			};
			nextState = {
				animating: false,
				currentSlide: finalSlide,
				trackStyle: getTrackCSS(_objectSpread2(_objectSpread2({}, spec), {}, { left: finalLeft })),
				swipeLeft: null,
				targetSlide
			};
		}
	}
	return {
		state,
		nextState
	};
};
var changeSlide = function changeSlide$1(spec, options) {
	var indexOffset, previousInt, slideOffset, unevenOffset, targetSlide;
	var slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, slideCount = spec.slideCount, currentSlide = spec.currentSlide, previousTargetSlide = spec.targetSlide, lazyLoad = spec.lazyLoad, infinite = spec.infinite;
	unevenOffset = slideCount % slidesToScroll !== 0;
	indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll;
	if (options.message === "previous") {
		slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;
		targetSlide = currentSlide - slideOffset;
		if (lazyLoad && !infinite) {
			previousInt = currentSlide - slideOffset;
			targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;
		}
		if (!infinite) targetSlide = previousTargetSlide - slidesToScroll;
	} else if (options.message === "next") {
		slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;
		targetSlide = currentSlide + slideOffset;
		if (lazyLoad && !infinite) targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;
		if (!infinite) targetSlide = previousTargetSlide + slidesToScroll;
	} else if (options.message === "dots") targetSlide = options.index * options.slidesToScroll;
	else if (options.message === "children") {
		targetSlide = options.index;
		if (infinite) {
			var direction = siblingDirection(_objectSpread2(_objectSpread2({}, spec), {}, { targetSlide }));
			if (targetSlide > options.currentSlide && direction === "left") targetSlide = targetSlide - slideCount;
			else if (targetSlide < options.currentSlide && direction === "right") targetSlide = targetSlide + slideCount;
		}
	} else if (options.message === "index") targetSlide = Number(options.index);
	return targetSlide;
};
var keyHandler = function keyHandler$1(e$2, accessibility, rtl) {
	if (e$2.target.tagName.match("TEXTAREA|INPUT|SELECT") || !accessibility) return "";
	if (e$2.keyCode === 37) return rtl ? "next" : "previous";
	if (e$2.keyCode === 39) return rtl ? "previous" : "next";
	return "";
};
var swipeStart = function swipeStart$1(e$2, swipe, draggable) {
	e$2.target.tagName === "IMG" && safePreventDefault(e$2);
	if (!swipe || !draggable && e$2.type.indexOf("mouse") !== -1) return "";
	return {
		dragging: true,
		touchObject: {
			startX: e$2.touches ? e$2.touches[0].pageX : e$2.clientX,
			startY: e$2.touches ? e$2.touches[0].pageY : e$2.clientY,
			curX: e$2.touches ? e$2.touches[0].pageX : e$2.clientX,
			curY: e$2.touches ? e$2.touches[0].pageY : e$2.clientY
		}
	};
};
var swipeMove = function swipeMove$1(e$2, spec) {
	var scrolling = spec.scrolling, animating = spec.animating, vertical = spec.vertical, swipeToSlide = spec.swipeToSlide, verticalSwiping = spec.verticalSwiping, rtl = spec.rtl, currentSlide = spec.currentSlide, edgeFriction = spec.edgeFriction, edgeDragged = spec.edgeDragged, onEdge = spec.onEdge, swiped = spec.swiped, swiping = spec.swiping, slideCount = spec.slideCount, slidesToScroll = spec.slidesToScroll, infinite = spec.infinite, touchObject = spec.touchObject, swipeEvent = spec.swipeEvent, listHeight = spec.listHeight, listWidth = spec.listWidth;
	if (scrolling) return;
	if (animating) return safePreventDefault(e$2);
	if (vertical && swipeToSlide && verticalSwiping) safePreventDefault(e$2);
	var swipeLeft, state = {};
	var curLeft = getTrackLeft(spec);
	touchObject.curX = e$2.touches ? e$2.touches[0].pageX : e$2.clientX;
	touchObject.curY = e$2.touches ? e$2.touches[0].pageY : e$2.clientY;
	touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2)));
	var verticalSwipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2)));
	if (!verticalSwiping && !swiping && verticalSwipeLength > 10) return { scrolling: true };
	if (verticalSwiping) touchObject.swipeLength = verticalSwipeLength;
	var positionOffset = (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);
	if (verticalSwiping) positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;
	var dotCount = Math.ceil(slideCount / slidesToScroll);
	var swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);
	var touchSwipeLength = touchObject.swipeLength;
	if (!infinite) {
		if (currentSlide === 0 && (swipeDirection === "right" || swipeDirection === "down") || currentSlide + 1 >= dotCount && (swipeDirection === "left" || swipeDirection === "up") || !canGoNext(spec) && (swipeDirection === "left" || swipeDirection === "up")) {
			touchSwipeLength = touchObject.swipeLength * edgeFriction;
			if (edgeDragged === false && onEdge) {
				onEdge(swipeDirection);
				state["edgeDragged"] = true;
			}
		}
	}
	if (!swiped && swipeEvent) {
		swipeEvent(swipeDirection);
		state["swiped"] = true;
	}
	if (!vertical) if (!rtl) swipeLeft = curLeft + touchSwipeLength * positionOffset;
	else swipeLeft = curLeft - touchSwipeLength * positionOffset;
	else swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;
	if (verticalSwiping) swipeLeft = curLeft + touchSwipeLength * positionOffset;
	state = _objectSpread2(_objectSpread2({}, state), {}, {
		touchObject,
		swipeLeft,
		trackStyle: getTrackCSS(_objectSpread2(_objectSpread2({}, spec), {}, { left: swipeLeft }))
	});
	if (Math.abs(touchObject.curX - touchObject.startX) < Math.abs(touchObject.curY - touchObject.startY) * .8) return state;
	if (touchObject.swipeLength > 10) {
		state["swiping"] = true;
		safePreventDefault(e$2);
	}
	return state;
};
var swipeEnd = function swipeEnd$1(e$2, spec) {
	var dragging = spec.dragging, swipe = spec.swipe, touchObject = spec.touchObject, listWidth = spec.listWidth, touchThreshold = spec.touchThreshold, verticalSwiping = spec.verticalSwiping, listHeight = spec.listHeight, swipeToSlide = spec.swipeToSlide, scrolling = spec.scrolling, onSwipe = spec.onSwipe, targetSlide = spec.targetSlide, currentSlide = spec.currentSlide, infinite = spec.infinite;
	if (!dragging) {
		if (swipe) safePreventDefault(e$2);
		return {};
	}
	var minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold;
	var swipeDirection = getSwipeDirection(touchObject, verticalSwiping);
	var state = {
		dragging: false,
		edgeDragged: false,
		scrolling: false,
		swiping: false,
		swiped: false,
		swipeLeft: null,
		touchObject: {}
	};
	if (scrolling) return state;
	if (!touchObject.swipeLength) return state;
	if (touchObject.swipeLength > minSwipe) {
		safePreventDefault(e$2);
		if (onSwipe) onSwipe(swipeDirection);
		var slideCount, newSlide;
		var activeSlide = infinite ? currentSlide : targetSlide;
		switch (swipeDirection) {
			case "left":
			case "up":
				newSlide = activeSlide + getSlideCount(spec);
				slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
				state["currentDirection"] = 0;
				break;
			case "right":
			case "down":
				newSlide = activeSlide - getSlideCount(spec);
				slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
				state["currentDirection"] = 1;
				break;
			default: slideCount = activeSlide;
		}
		state["triggerSlideHandler"] = slideCount;
	} else {
		var currentLeft = getTrackLeft(spec);
		state["trackStyle"] = getTrackAnimateCSS(_objectSpread2(_objectSpread2({}, spec), {}, { left: currentLeft }));
	}
	return state;
};
var getNavigableIndexes = function getNavigableIndexes$1(spec) {
	var max = spec.infinite ? spec.slideCount * 2 : spec.slideCount;
	var breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;
	var counter = spec.infinite ? spec.slidesToShow * -1 : 0;
	var indexes = [];
	while (breakpoint < max) {
		indexes.push(breakpoint);
		breakpoint = counter + spec.slidesToScroll;
		counter += Math.min(spec.slidesToScroll, spec.slidesToShow);
	}
	return indexes;
};
var checkNavigable = function checkNavigable$1(spec, index$1) {
	var navigables = getNavigableIndexes(spec);
	var prevNavigable = 0;
	if (index$1 > navigables[navigables.length - 1]) index$1 = navigables[navigables.length - 1];
	else for (var n$1 in navigables) {
		if (index$1 < navigables[n$1]) {
			index$1 = prevNavigable;
			break;
		}
		prevNavigable = navigables[n$1];
	}
	return index$1;
};
var getSlideCount = function getSlideCount$1(spec) {
	var centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0;
	if (spec.swipeToSlide) {
		var swipedSlide;
		var slickList = spec.listRef;
		var slides = slickList.querySelectorAll && slickList.querySelectorAll(".slick-slide") || [];
		Array.from(slides).every(function(slide) {
			if (!spec.vertical) {
				if (slide.offsetLeft - centerOffset + getWidth(slide) / 2 > spec.swipeLeft * -1) {
					swipedSlide = slide;
					return false;
				}
			} else if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {
				swipedSlide = slide;
				return false;
			}
			return true;
		});
		if (!swipedSlide) return 0;
		var currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide;
		return Math.abs(swipedSlide.dataset.index - currentIndex) || 1;
	} else return spec.slidesToScroll;
};
var checkSpecKeys = function checkSpecKeys$1(spec, keysArray) {
	return keysArray.reduce(function(value, key) {
		return value && spec.hasOwnProperty(key);
	}, true) ? null : console.error("Keys Missing:", spec);
};
var getTrackCSS = function getTrackCSS$1(spec) {
	checkSpecKeys(spec, [
		"left",
		"variableWidth",
		"slideCount",
		"slidesToShow",
		"slideWidth"
	]);
	var trackWidth, trackHeight;
	if (!spec.vertical) trackWidth = getTotalSlides(spec) * spec.slideWidth;
	else trackHeight = (spec.unslick ? spec.slideCount : spec.slideCount + 2 * spec.slidesToShow) * spec.slideHeight;
	var style$1 = {
		opacity: 1,
		transition: "",
		WebkitTransition: ""
	};
	if (spec.useTransform) {
		var WebkitTransform = !spec.vertical ? "translate3d(" + spec.left + "px, 0px, 0px)" : "translate3d(0px, " + spec.left + "px, 0px)";
		var transform = !spec.vertical ? "translate3d(" + spec.left + "px, 0px, 0px)" : "translate3d(0px, " + spec.left + "px, 0px)";
		var msTransform = !spec.vertical ? "translateX(" + spec.left + "px)" : "translateY(" + spec.left + "px)";
		style$1 = _objectSpread2(_objectSpread2({}, style$1), {}, {
			WebkitTransform,
			transform,
			msTransform
		});
	} else if (spec.vertical) style$1["top"] = spec.left;
	else style$1["left"] = spec.left;
	if (spec.fade) style$1 = { opacity: 1 };
	if (trackWidth) style$1.width = trackWidth;
	if (trackHeight) style$1.height = trackHeight;
	if (window && !window.addEventListener && window.attachEvent) if (!spec.vertical) style$1.marginLeft = spec.left + "px";
	else style$1.marginTop = spec.left + "px";
	return style$1;
};
var getTrackAnimateCSS = function getTrackAnimateCSS$1(spec) {
	checkSpecKeys(spec, [
		"left",
		"variableWidth",
		"slideCount",
		"slidesToShow",
		"slideWidth",
		"speed",
		"cssEase"
	]);
	var style$1 = getTrackCSS(spec);
	if (spec.useTransform) {
		style$1.WebkitTransition = "-webkit-transform " + spec.speed + "ms " + spec.cssEase;
		style$1.transition = "transform " + spec.speed + "ms " + spec.cssEase;
	} else if (spec.vertical) style$1.transition = "top " + spec.speed + "ms " + spec.cssEase;
	else style$1.transition = "left " + spec.speed + "ms " + spec.cssEase;
	return style$1;
};
var getTrackLeft = function getTrackLeft$1(spec) {
	if (spec.unslick) return 0;
	checkSpecKeys(spec, [
		"slideIndex",
		"trackRef",
		"infinite",
		"centerMode",
		"slideCount",
		"slidesToShow",
		"slidesToScroll",
		"slideWidth",
		"listWidth",
		"variableWidth",
		"slideHeight"
	]);
	var slideIndex = spec.slideIndex, trackRef = spec.trackRef, infinite = spec.infinite, centerMode = spec.centerMode, slideCount = spec.slideCount, slidesToShow = spec.slidesToShow, slidesToScroll = spec.slidesToScroll, slideWidth = spec.slideWidth, listWidth = spec.listWidth, variableWidth = spec.variableWidth, slideHeight = spec.slideHeight, fade = spec.fade, vertical = spec.vertical;
	var slideOffset = 0;
	var targetLeft;
	var targetSlide;
	var verticalOffset = 0;
	if (fade || spec.slideCount === 1) return 0;
	var slidesToOffset = 0;
	if (infinite) {
		slidesToOffset = -getPreClones(spec);
		if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) slidesToOffset = -(slideIndex > slideCount ? slidesToShow - (slideIndex - slideCount) : slideCount % slidesToScroll);
		if (centerMode) slidesToOffset += parseInt(slidesToShow / 2);
	} else {
		if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) slidesToOffset = slidesToShow - slideCount % slidesToScroll;
		if (centerMode) slidesToOffset = parseInt(slidesToShow / 2);
	}
	slideOffset = slidesToOffset * slideWidth;
	verticalOffset = slidesToOffset * slideHeight;
	if (!vertical) targetLeft = slideIndex * slideWidth * -1 + slideOffset;
	else targetLeft = slideIndex * slideHeight * -1 + verticalOffset;
	if (variableWidth === true) {
		var targetSlideIndex;
		var trackElem = trackRef && trackRef.node;
		targetSlideIndex = slideIndex + getPreClones(spec);
		targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];
		targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;
		if (centerMode === true) {
			targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex;
			targetSlide = trackElem && trackElem.children[targetSlideIndex];
			targetLeft = 0;
			for (var slide = 0; slide < targetSlideIndex; slide++) targetLeft -= trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth;
			targetLeft -= parseInt(spec.centerPadding);
			targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;
		}
	}
	return targetLeft;
};
var getPreClones = function getPreClones$1(spec) {
	if (spec.unslick || !spec.infinite) return 0;
	if (spec.variableWidth) return spec.slideCount;
	return spec.slidesToShow + (spec.centerMode ? 1 : 0);
};
var getPostClones = function getPostClones$1(spec) {
	if (spec.unslick || !spec.infinite) return 0;
	if (spec.variableWidth) return spec.slideCount;
	return spec.slidesToShow + (spec.centerMode ? 1 : 0);
};
var getTotalSlides = function getTotalSlides$1(spec) {
	return spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec);
};
var siblingDirection = function siblingDirection$1(spec) {
	if (spec.targetSlide > spec.currentSlide) {
		if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) return "left";
		return "right";
	} else {
		if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) return "right";
		return "left";
	}
};
var slidesOnRight = function slidesOnRight$1(_ref) {
	var slidesToShow = _ref.slidesToShow, centerMode = _ref.centerMode, rtl = _ref.rtl, centerPadding = _ref.centerPadding;
	if (centerMode) {
		var right = (slidesToShow - 1) / 2 + 1;
		if (parseInt(centerPadding) > 0) right += 1;
		if (rtl && slidesToShow % 2 === 0) right += 1;
		return right;
	}
	if (rtl) return 0;
	return slidesToShow - 1;
};
var slidesOnLeft = function slidesOnLeft$1(_ref2) {
	var slidesToShow = _ref2.slidesToShow, centerMode = _ref2.centerMode, rtl = _ref2.rtl, centerPadding = _ref2.centerPadding;
	if (centerMode) {
		var left = (slidesToShow - 1) / 2 + 1;
		if (parseInt(centerPadding) > 0) left += 1;
		if (!rtl && slidesToShow % 2 === 0) left += 1;
		return left;
	}
	if (rtl) return slidesToShow - 1;
	return 0;
};
var canUseDOM = function canUseDOM$1() {
	return !!(typeof window !== "undefined" && window.document && window.document.createElement);
};
var validSettings = Object.keys(default_props_default);
function filterSettings(settings) {
	return validSettings.reduce(function(acc, settingName) {
		if (settings.hasOwnProperty(settingName)) acc[settingName] = settings[settingName];
		return acc;
	}, {});
}

//#endregion
//#region node_modules/@ant-design/react-slick/es/track.js
function _callSuper$4(t$1, o$2, e$2) {
	return o$2 = _getPrototypeOf(o$2), _possibleConstructorReturn(t$1, _isNativeReflectConstruct() ? Reflect.construct(o$2, e$2 || [], _getPrototypeOf(t$1).constructor) : o$2.apply(t$1, e$2));
}
var getSlideClasses = function getSlideClasses$1(spec) {
	var slickActive, slickCenter, slickCloned;
	var centerOffset, index$1;
	if (spec.rtl) index$1 = spec.slideCount - 1 - spec.index;
	else index$1 = spec.index;
	slickCloned = index$1 < 0 || index$1 >= spec.slideCount;
	if (spec.centerMode) {
		centerOffset = Math.floor(spec.slidesToShow / 2);
		slickCenter = (index$1 - spec.currentSlide) % spec.slideCount === 0;
		if (index$1 > spec.currentSlide - centerOffset - 1 && index$1 <= spec.currentSlide + centerOffset) slickActive = true;
	} else slickActive = spec.currentSlide <= index$1 && index$1 < spec.currentSlide + spec.slidesToShow;
	var focusedSlide;
	if (spec.targetSlide < 0) focusedSlide = spec.targetSlide + spec.slideCount;
	else if (spec.targetSlide >= spec.slideCount) focusedSlide = spec.targetSlide - spec.slideCount;
	else focusedSlide = spec.targetSlide;
	var slickCurrent = index$1 === focusedSlide;
	return {
		"slick-slide": true,
		"slick-active": slickActive,
		"slick-center": slickCenter,
		"slick-cloned": slickCloned,
		"slick-current": slickCurrent
	};
};
var getSlideStyle = function getSlideStyle$1(spec) {
	var style$1 = {};
	if (spec.variableWidth === void 0 || spec.variableWidth === false) style$1.width = spec.slideWidth;
	if (spec.fade) {
		style$1.position = "relative";
		if (spec.vertical && spec.slideHeight) style$1.top = -spec.index * parseInt(spec.slideHeight);
		else style$1.left = -spec.index * parseInt(spec.slideWidth);
		style$1.opacity = spec.currentSlide === spec.index ? 1 : 0;
		style$1.zIndex = spec.currentSlide === spec.index ? 999 : 998;
		if (spec.useCSS) style$1.transition = "opacity " + spec.speed + "ms " + spec.cssEase + ", visibility " + spec.speed + "ms " + spec.cssEase;
	}
	return style$1;
};
var getKey$1 = function getKey$3(child, fallbackKey) {
	return child.key + "-" + fallbackKey;
};
var renderSlides = function renderSlides$1(spec) {
	var key;
	var slides = [];
	var preCloneSlides = [];
	var postCloneSlides = [];
	var childrenCount = import_react.Children.count(spec.children);
	var startIndex = lazyStartIndex(spec);
	var endIndex = lazyEndIndex(spec);
	import_react.Children.forEach(spec.children, function(elem, index$1) {
		var child;
		var childOnClickOptions = {
			message: "children",
			index: index$1,
			slidesToScroll: spec.slidesToScroll,
			currentSlide: spec.currentSlide
		};
		if (!spec.lazyLoad || spec.lazyLoad && spec.lazyLoadedList.indexOf(index$1) >= 0) child = elem;
		else child = /* @__PURE__ */ import_react.createElement("div", null);
		var childStyle = getSlideStyle(_objectSpread2(_objectSpread2({}, spec), {}, { index: index$1 }));
		var slideClass = child.props.className || "";
		var slideClasses = getSlideClasses(_objectSpread2(_objectSpread2({}, spec), {}, { index: index$1 }));
		slides.push(/* @__PURE__ */ import_react.cloneElement(child, {
			key: "original" + getKey$1(child, index$1),
			"data-index": index$1,
			className: clsx(slideClasses, slideClass),
			tabIndex: "-1",
			"aria-hidden": !slideClasses["slick-active"],
			style: _objectSpread2(_objectSpread2({ outline: "none" }, child.props.style || {}), childStyle),
			onClick: function onClick(e$2) {
				child.props && child.props.onClick && child.props.onClick(e$2);
				if (spec.focusOnSelect) spec.focusOnSelect(childOnClickOptions);
			}
		}));
		if (spec.infinite && childrenCount > 1 && spec.fade === false && !spec.unslick) {
			var preCloneNo = childrenCount - index$1;
			if (preCloneNo <= getPreClones(spec)) {
				key = -preCloneNo;
				if (key >= startIndex) child = elem;
				slideClasses = getSlideClasses(_objectSpread2(_objectSpread2({}, spec), {}, { index: key }));
				preCloneSlides.push(/* @__PURE__ */ import_react.cloneElement(child, {
					key: "precloned" + getKey$1(child, key),
					"data-index": key,
					tabIndex: "-1",
					className: clsx(slideClasses, slideClass),
					"aria-hidden": !slideClasses["slick-active"],
					style: _objectSpread2(_objectSpread2({}, child.props.style || {}), childStyle),
					onClick: function onClick(e$2) {
						child.props && child.props.onClick && child.props.onClick(e$2);
						if (spec.focusOnSelect) spec.focusOnSelect(childOnClickOptions);
					}
				}));
			}
			if (index$1 < getPostClones(spec)) {
				key = childrenCount + index$1;
				if (key < endIndex) child = elem;
				slideClasses = getSlideClasses(_objectSpread2(_objectSpread2({}, spec), {}, { index: key }));
				postCloneSlides.push(/* @__PURE__ */ import_react.cloneElement(child, {
					key: "postcloned" + getKey$1(child, key),
					"data-index": key,
					tabIndex: "-1",
					className: clsx(slideClasses, slideClass),
					"aria-hidden": !slideClasses["slick-active"],
					style: _objectSpread2(_objectSpread2({}, child.props.style || {}), childStyle),
					onClick: function onClick(e$2) {
						child.props && child.props.onClick && child.props.onClick(e$2);
						if (spec.focusOnSelect) spec.focusOnSelect(childOnClickOptions);
					}
				}));
			}
		}
	});
	if (spec.rtl) return preCloneSlides.concat(slides, postCloneSlides).reverse();
	else return preCloneSlides.concat(slides, postCloneSlides);
};
var Track$1 = /* @__PURE__ */ function(_React$PureComponent) {
	function Track$2() {
		var _this;
		_classCallCheck(this, Track$2);
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		_this = _callSuper$4(this, Track$2, [].concat(args));
		_defineProperty(_this, "node", null);
		_defineProperty(_this, "handleRef", function(ref) {
			_this.node = ref;
		});
		return _this;
	}
	_inherits(Track$2, _React$PureComponent);
	return _createClass(Track$2, [{
		key: "render",
		value: function render$1() {
			var slides = renderSlides(this.props);
			var _this$props = this.props;
			var mouseEvents = {
				onMouseEnter: _this$props.onMouseEnter,
				onMouseOver: _this$props.onMouseOver,
				onMouseLeave: _this$props.onMouseLeave
			};
			return /* @__PURE__ */ import_react.createElement("div", _extends$26({
				ref: this.handleRef,
				className: "slick-track",
				style: this.props.trackStyle
			}, mouseEvents), slides);
		}
	}]);
}(import_react.PureComponent);

//#endregion
//#region node_modules/@ant-design/react-slick/es/dots.js
function _callSuper$3(t$1, o$2, e$2) {
	return o$2 = _getPrototypeOf(o$2), _possibleConstructorReturn(t$1, _isNativeReflectConstruct() ? Reflect.construct(o$2, e$2 || [], _getPrototypeOf(t$1).constructor) : o$2.apply(t$1, e$2));
}
var getDotCount = function getDotCount$1(spec) {
	var dots;
	if (spec.infinite) dots = Math.ceil(spec.slideCount / spec.slidesToScroll);
	else dots = Math.ceil((spec.slideCount - spec.slidesToShow) / spec.slidesToScroll) + 1;
	return dots;
};
var Dots = /* @__PURE__ */ function(_React$PureComponent) {
	function Dots$1() {
		_classCallCheck(this, Dots$1);
		return _callSuper$3(this, Dots$1, arguments);
	}
	_inherits(Dots$1, _React$PureComponent);
	return _createClass(Dots$1, [{
		key: "clickHandler",
		value: function clickHandler(options, e$2) {
			e$2.preventDefault();
			this.props.clickHandler(options);
		}
	}, {
		key: "render",
		value: function render$1() {
			var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, onMouseOver = _this$props.onMouseOver, onMouseLeave = _this$props.onMouseLeave, infinite = _this$props.infinite, slidesToScroll = _this$props.slidesToScroll, slidesToShow = _this$props.slidesToShow, slideCount = _this$props.slideCount, currentSlide = _this$props.currentSlide;
			var dotCount = getDotCount({
				slideCount,
				slidesToScroll,
				slidesToShow,
				infinite
			});
			var mouseEvents = {
				onMouseEnter,
				onMouseOver,
				onMouseLeave
			};
			var dots = [];
			for (var i = 0; i < dotCount; i++) {
				var _rightBound = (i + 1) * slidesToScroll - 1;
				var rightBound = infinite ? _rightBound : clamp(_rightBound, 0, slideCount - 1);
				var _leftBound = rightBound - (slidesToScroll - 1);
				var leftBound = infinite ? _leftBound : clamp(_leftBound, 0, slideCount - 1);
				var className = clsx({ "slick-active": infinite ? currentSlide >= leftBound && currentSlide <= rightBound : currentSlide === leftBound });
				var dotOptions = {
					message: "dots",
					index: i,
					slidesToScroll,
					currentSlide
				};
				var onClick = this.clickHandler.bind(this, dotOptions);
				dots = dots.concat(/* @__PURE__ */ import_react.createElement("li", {
					key: i,
					className
				}, /* @__PURE__ */ import_react.cloneElement(this.props.customPaging(i), { onClick })));
			}
			return /* @__PURE__ */ import_react.cloneElement(this.props.appendDots(dots), _objectSpread2({ className: this.props.dotsClass }, mouseEvents));
		}
	}]);
}(import_react.PureComponent);

//#endregion
//#region node_modules/@ant-design/react-slick/es/arrows.js
function _callSuper$2(t$1, o$2, e$2) {
	return o$2 = _getPrototypeOf(o$2), _possibleConstructorReturn(t$1, _isNativeReflectConstruct() ? Reflect.construct(o$2, e$2 || [], _getPrototypeOf(t$1).constructor) : o$2.apply(t$1, e$2));
}
var PrevArrow = /* @__PURE__ */ function(_React$PureComponent) {
	function PrevArrow$1() {
		_classCallCheck(this, PrevArrow$1);
		return _callSuper$2(this, PrevArrow$1, arguments);
	}
	_inherits(PrevArrow$1, _React$PureComponent);
	return _createClass(PrevArrow$1, [{
		key: "clickHandler",
		value: function clickHandler(options, e$2) {
			if (e$2) e$2.preventDefault();
			this.props.clickHandler(options, e$2);
		}
	}, {
		key: "render",
		value: function render$1() {
			var prevClasses = {
				"slick-arrow": true,
				"slick-prev": true
			};
			var prevHandler = this.clickHandler.bind(this, { message: "previous" });
			if (!this.props.infinite && (this.props.currentSlide === 0 || this.props.slideCount <= this.props.slidesToShow)) {
				prevClasses["slick-disabled"] = true;
				prevHandler = null;
			}
			var prevArrowProps = {
				key: "0",
				"data-role": "none",
				className: clsx(prevClasses),
				style: { display: "block" },
				onClick: prevHandler
			};
			var customProps = {
				currentSlide: this.props.currentSlide,
				slideCount: this.props.slideCount
			};
			var prevArrow;
			if (this.props.prevArrow) prevArrow = /* @__PURE__ */ import_react.cloneElement(this.props.prevArrow, _objectSpread2(_objectSpread2({}, prevArrowProps), customProps));
			else prevArrow = /* @__PURE__ */ import_react.createElement("button", _extends$26({
				key: "0",
				type: "button"
			}, prevArrowProps), " ", "Previous");
			return prevArrow;
		}
	}]);
}(import_react.PureComponent);
var NextArrow = /* @__PURE__ */ function(_React$PureComponent2) {
	function NextArrow$1() {
		_classCallCheck(this, NextArrow$1);
		return _callSuper$2(this, NextArrow$1, arguments);
	}
	_inherits(NextArrow$1, _React$PureComponent2);
	return _createClass(NextArrow$1, [{
		key: "clickHandler",
		value: function clickHandler(options, e$2) {
			if (e$2) e$2.preventDefault();
			this.props.clickHandler(options, e$2);
		}
	}, {
		key: "render",
		value: function render$1() {
			var nextClasses = {
				"slick-arrow": true,
				"slick-next": true
			};
			var nextHandler = this.clickHandler.bind(this, { message: "next" });
			if (!canGoNext(this.props)) {
				nextClasses["slick-disabled"] = true;
				nextHandler = null;
			}
			var nextArrowProps = {
				key: "1",
				"data-role": "none",
				className: clsx(nextClasses),
				style: { display: "block" },
				onClick: nextHandler
			};
			var customProps = {
				currentSlide: this.props.currentSlide,
				slideCount: this.props.slideCount
			};
			var nextArrow;
			if (this.props.nextArrow) nextArrow = /* @__PURE__ */ import_react.cloneElement(this.props.nextArrow, _objectSpread2(_objectSpread2({}, nextArrowProps), customProps));
			else nextArrow = /* @__PURE__ */ import_react.createElement("button", _extends$26({
				key: "1",
				type: "button"
			}, nextArrowProps), " ", "Next");
			return nextArrow;
		}
	}]);
}(import_react.PureComponent);

//#endregion
//#region node_modules/@ant-design/react-slick/es/inner-slider.js
var _excluded$2 = ["animating"];
function _callSuper$1(t$1, o$2, e$2) {
	return o$2 = _getPrototypeOf(o$2), _possibleConstructorReturn(t$1, _isNativeReflectConstruct() ? Reflect.construct(o$2, e$2 || [], _getPrototypeOf(t$1).constructor) : o$2.apply(t$1, e$2));
}
var InnerSlider = /* @__PURE__ */ function(_React$Component) {
	function InnerSlider$1(props) {
		var _this;
		_classCallCheck(this, InnerSlider$1);
		_this = _callSuper$1(this, InnerSlider$1, [props]);
		_defineProperty(_this, "listRefHandler", function(ref) {
			return _this.list = ref;
		});
		_defineProperty(_this, "trackRefHandler", function(ref) {
			return _this.track = ref;
		});
		_defineProperty(_this, "adaptHeight", function() {
			if (_this.props.adaptiveHeight && _this.list) {
				var elem = _this.list.querySelector("[data-index=\"".concat(_this.state.currentSlide, "\"]"));
				_this.list.style.height = getHeight(elem) + "px";
			}
		});
		_defineProperty(_this, "componentDidMount", function() {
			_this.props.onInit && _this.props.onInit();
			if (_this.props.lazyLoad) {
				var slidesToLoad = getOnDemandLazySlides(_objectSpread2(_objectSpread2({}, _this.props), _this.state));
				if (slidesToLoad.length > 0) {
					_this.setState(function(prevState) {
						return { lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad) };
					});
					if (_this.props.onLazyLoad) _this.props.onLazyLoad(slidesToLoad);
				}
			}
			var spec = _objectSpread2({
				listRef: _this.list,
				trackRef: _this.track
			}, _this.props);
			_this.updateState(spec, true, function() {
				_this.adaptHeight();
				_this.props.autoplay && _this.autoPlay("playing");
			});
			if (_this.props.lazyLoad === "progressive") _this.lazyLoadTimer = setInterval(_this.progressiveLazyLoad, 1e3);
			if (typeof ResizeObserver !== "undefined") {
				_this.ro = new ResizeObserver(function() {
					if (_this.state.animating) {
						_this.onWindowResized(false);
						_this.callbackTimers.push(setTimeout(function() {
							return _this.onWindowResized();
						}, _this.props.speed));
					} else _this.onWindowResized();
				});
				_this.ro.observe(_this.list);
			}
			document.querySelectorAll && Array.prototype.forEach.call(document.querySelectorAll(".slick-slide"), function(slide) {
				slide.onfocus = _this.props.pauseOnFocus ? _this.onSlideFocus : null;
				slide.onblur = _this.props.pauseOnFocus ? _this.onSlideBlur : null;
			});
			if (window.addEventListener) window.addEventListener("resize", _this.onWindowResized);
			else window.attachEvent("onresize", _this.onWindowResized);
		});
		_defineProperty(_this, "componentWillUnmount", function() {
			var _this$ro;
			if (_this.animationEndCallback) clearTimeout(_this.animationEndCallback);
			if (_this.lazyLoadTimer) clearInterval(_this.lazyLoadTimer);
			if (_this.callbackTimers.length) {
				_this.callbackTimers.forEach(function(timer) {
					return clearTimeout(timer);
				});
				_this.callbackTimers = [];
			}
			if (window.addEventListener) window.removeEventListener("resize", _this.onWindowResized);
			else window.detachEvent("onresize", _this.onWindowResized);
			if (_this.autoplayTimer) clearInterval(_this.autoplayTimer);
			(_this$ro = _this.ro) === null || _this$ro === void 0 || _this$ro.disconnect();
		});
		_defineProperty(_this, "componentDidUpdate", function(prevProps) {
			_this.checkImagesLoad();
			_this.props.onReInit && _this.props.onReInit();
			if (_this.props.lazyLoad) {
				var slidesToLoad = getOnDemandLazySlides(_objectSpread2(_objectSpread2({}, _this.props), _this.state));
				if (slidesToLoad.length > 0) {
					_this.setState(function(prevState) {
						return { lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad) };
					});
					if (_this.props.onLazyLoad) _this.props.onLazyLoad(slidesToLoad);
				}
			}
			_this.adaptHeight();
			var spec = _objectSpread2(_objectSpread2({
				listRef: _this.list,
				trackRef: _this.track
			}, _this.props), _this.state);
			var setTrackStyle = _this.didPropsChange(prevProps);
			setTrackStyle && _this.updateState(spec, setTrackStyle, function() {
				if (_this.state.currentSlide >= import_react.Children.count(_this.props.children)) _this.changeSlide({
					message: "index",
					index: import_react.Children.count(_this.props.children) - _this.props.slidesToShow,
					currentSlide: _this.state.currentSlide
				});
				if (prevProps.autoplay !== _this.props.autoplay || prevProps.autoplaySpeed !== _this.props.autoplaySpeed) if (!prevProps.autoplay && _this.props.autoplay) _this.autoPlay("playing");
				else if (_this.props.autoplay) _this.autoPlay("update");
				else _this.pause("paused");
			});
		});
		_defineProperty(_this, "onWindowResized", function(setTrackStyle) {
			if (_this.debouncedResize) _this.debouncedResize.cancel();
			_this.debouncedResize = debounce(50, function() {
				return _this.resizeWindow(setTrackStyle);
			});
			_this.debouncedResize();
		});
		_defineProperty(_this, "resizeWindow", function() {
			var setTrackStyle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
			if (!Boolean(_this.track && _this.track.node)) return;
			var spec = _objectSpread2(_objectSpread2({
				listRef: _this.list,
				trackRef: _this.track
			}, _this.props), _this.state);
			_this.updateState(spec, setTrackStyle, function() {
				if (_this.props.autoplay) _this.autoPlay("update");
				else _this.pause("paused");
			});
			_this.setState({ animating: false });
			clearTimeout(_this.animationEndCallback);
			delete _this.animationEndCallback;
		});
		_defineProperty(_this, "updateState", function(spec, setTrackStyle, callback) {
			var updatedState = initializedState(spec);
			spec = _objectSpread2(_objectSpread2(_objectSpread2({}, spec), updatedState), {}, { slideIndex: updatedState.currentSlide });
			var targetLeft = getTrackLeft(spec);
			spec = _objectSpread2(_objectSpread2({}, spec), {}, { left: targetLeft });
			var trackStyle = getTrackCSS(spec);
			if (setTrackStyle || import_react.Children.count(_this.props.children) !== import_react.Children.count(spec.children)) updatedState["trackStyle"] = trackStyle;
			_this.setState(updatedState, callback);
		});
		_defineProperty(_this, "ssrInit", function() {
			if (_this.props.variableWidth) {
				var _trackWidth = 0, _trackLeft = 0;
				var childrenWidths = [];
				var preClones = getPreClones(_objectSpread2(_objectSpread2(_objectSpread2({}, _this.props), _this.state), {}, { slideCount: _this.props.children.length }));
				var postClones = getPostClones(_objectSpread2(_objectSpread2(_objectSpread2({}, _this.props), _this.state), {}, { slideCount: _this.props.children.length }));
				_this.props.children.forEach(function(child) {
					childrenWidths.push(child.props.style.width);
					_trackWidth += child.props.style.width;
				});
				for (var i = 0; i < preClones; i++) {
					_trackLeft += childrenWidths[childrenWidths.length - 1 - i];
					_trackWidth += childrenWidths[childrenWidths.length - 1 - i];
				}
				for (var _i = 0; _i < postClones; _i++) _trackWidth += childrenWidths[_i];
				for (var _i2 = 0; _i2 < _this.state.currentSlide; _i2++) _trackLeft += childrenWidths[_i2];
				var _trackStyle = {
					width: _trackWidth + "px",
					left: -_trackLeft + "px"
				};
				if (_this.props.centerMode) {
					var currentWidth = "".concat(childrenWidths[_this.state.currentSlide], "px");
					_trackStyle.left = "calc(".concat(_trackStyle.left, " + (100% - ").concat(currentWidth, ") / 2 ) ");
				}
				return { trackStyle: _trackStyle };
			}
			var childrenCount = import_react.Children.count(_this.props.children);
			var spec = _objectSpread2(_objectSpread2(_objectSpread2({}, _this.props), _this.state), {}, { slideCount: childrenCount });
			var slideCount = getPreClones(spec) + getPostClones(spec) + childrenCount;
			var trackWidth = 100 / _this.props.slidesToShow * slideCount;
			var slideWidth = 100 / slideCount;
			var trackLeft = -slideWidth * (getPreClones(spec) + _this.state.currentSlide) * trackWidth / 100;
			if (_this.props.centerMode) trackLeft += (100 - slideWidth * trackWidth / 100) / 2;
			var trackStyle = {
				width: trackWidth + "%",
				left: trackLeft + "%"
			};
			return {
				slideWidth: slideWidth + "%",
				trackStyle
			};
		});
		_defineProperty(_this, "checkImagesLoad", function() {
			var images = _this.list && _this.list.querySelectorAll && _this.list.querySelectorAll(".slick-slide img") || [];
			var imagesCount = images.length, loadedCount = 0;
			Array.prototype.forEach.call(images, function(image) {
				var handler = function handler$1() {
					return ++loadedCount && loadedCount >= imagesCount && _this.onWindowResized();
				};
				if (!image.onclick) image.onclick = function() {
					return image.parentNode.focus();
				};
				else {
					var prevClickHandler = image.onclick;
					image.onclick = function(e$2) {
						prevClickHandler(e$2);
						image.parentNode.focus();
					};
				}
				if (!image.onload) if (_this.props.lazyLoad) image.onload = function() {
					_this.adaptHeight();
					_this.callbackTimers.push(setTimeout(_this.onWindowResized, _this.props.speed));
				};
				else {
					image.onload = handler;
					image.onerror = function() {
						handler();
						_this.props.onLazyLoadError && _this.props.onLazyLoadError();
					};
				}
			});
		});
		_defineProperty(_this, "progressiveLazyLoad", function() {
			var slidesToLoad = [];
			var spec = _objectSpread2(_objectSpread2({}, _this.props), _this.state);
			for (var index$1 = _this.state.currentSlide; index$1 < _this.state.slideCount + getPostClones(spec); index$1++) if (_this.state.lazyLoadedList.indexOf(index$1) < 0) {
				slidesToLoad.push(index$1);
				break;
			}
			for (var _index = _this.state.currentSlide - 1; _index >= -getPreClones(spec); _index--) if (_this.state.lazyLoadedList.indexOf(_index) < 0) {
				slidesToLoad.push(_index);
				break;
			}
			if (slidesToLoad.length > 0) {
				_this.setState(function(state) {
					return { lazyLoadedList: state.lazyLoadedList.concat(slidesToLoad) };
				});
				if (_this.props.onLazyLoad) _this.props.onLazyLoad(slidesToLoad);
			} else if (_this.lazyLoadTimer) {
				clearInterval(_this.lazyLoadTimer);
				delete _this.lazyLoadTimer;
			}
		});
		_defineProperty(_this, "slideHandler", function(index$1) {
			var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
			var _this$props = _this.props, asNavFor = _this$props.asNavFor, beforeChange = _this$props.beforeChange, onLazyLoad = _this$props.onLazyLoad, speed = _this$props.speed, afterChange = _this$props.afterChange;
			var currentSlide = _this.state.currentSlide;
			var _slideHandler = slideHandler(_objectSpread2(_objectSpread2(_objectSpread2({ index: index$1 }, _this.props), _this.state), {}, {
				trackRef: _this.track,
				useCSS: _this.props.useCSS && !dontAnimate
			})), state = _slideHandler.state, nextState = _slideHandler.nextState;
			if (!state) return;
			beforeChange && beforeChange(currentSlide, state.currentSlide);
			var slidesToLoad = state.lazyLoadedList.filter(function(value) {
				return _this.state.lazyLoadedList.indexOf(value) < 0;
			});
			onLazyLoad && slidesToLoad.length > 0 && onLazyLoad(slidesToLoad);
			if (!_this.props.waitForAnimate && _this.animationEndCallback) {
				clearTimeout(_this.animationEndCallback);
				afterChange && afterChange(currentSlide);
				delete _this.animationEndCallback;
			}
			_this.setState(state, function() {
				if (asNavFor && _this.asNavForIndex !== index$1) {
					_this.asNavForIndex = index$1;
					asNavFor.innerSlider.slideHandler(index$1);
				}
				if (!nextState) return;
				_this.animationEndCallback = setTimeout(function() {
					var animating = nextState.animating, firstBatch = _objectWithoutProperties(nextState, _excluded$2);
					_this.setState(firstBatch, function() {
						_this.callbackTimers.push(setTimeout(function() {
							return _this.setState({ animating });
						}, 10));
						afterChange && afterChange(state.currentSlide);
						delete _this.animationEndCallback;
					});
				}, speed);
			});
		});
		_defineProperty(_this, "changeSlide", function(options) {
			var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
			var targetSlide = changeSlide(_objectSpread2(_objectSpread2({}, _this.props), _this.state), options);
			if (targetSlide !== 0 && !targetSlide) return;
			if (dontAnimate === true) _this.slideHandler(targetSlide, dontAnimate);
			else _this.slideHandler(targetSlide);
			_this.props.autoplay && _this.autoPlay("update");
			if (_this.props.focusOnSelect) {
				var nodes = _this.list.querySelectorAll(".slick-current");
				nodes[0] && nodes[0].focus();
			}
		});
		_defineProperty(_this, "clickHandler", function(e$2) {
			if (_this.clickable === false) {
				e$2.stopPropagation();
				e$2.preventDefault();
			}
			_this.clickable = true;
		});
		_defineProperty(_this, "keyHandler", function(e$2) {
			var dir = keyHandler(e$2, _this.props.accessibility, _this.props.rtl);
			dir !== "" && _this.changeSlide({ message: dir });
		});
		_defineProperty(_this, "selectHandler", function(options) {
			_this.changeSlide(options);
		});
		_defineProperty(_this, "disableBodyScroll", function() {
			var preventDefault = function preventDefault$1(e$2) {
				e$2 = e$2 || window.event;
				if (e$2.preventDefault) e$2.preventDefault();
				e$2.returnValue = false;
			};
			window.ontouchmove = preventDefault;
		});
		_defineProperty(_this, "enableBodyScroll", function() {
			window.ontouchmove = null;
		});
		_defineProperty(_this, "swipeStart", function(e$2) {
			if (_this.props.verticalSwiping) _this.disableBodyScroll();
			var state = swipeStart(e$2, _this.props.swipe, _this.props.draggable);
			state !== "" && _this.setState(state);
		});
		_defineProperty(_this, "swipeMove", function(e$2) {
			var state = swipeMove(e$2, _objectSpread2(_objectSpread2(_objectSpread2({}, _this.props), _this.state), {}, {
				trackRef: _this.track,
				listRef: _this.list,
				slideIndex: _this.state.currentSlide
			}));
			if (!state) return;
			if (state["swiping"]) _this.clickable = false;
			_this.setState(state);
		});
		_defineProperty(_this, "swipeEnd", function(e$2) {
			var state = swipeEnd(e$2, _objectSpread2(_objectSpread2(_objectSpread2({}, _this.props), _this.state), {}, {
				trackRef: _this.track,
				listRef: _this.list,
				slideIndex: _this.state.currentSlide
			}));
			if (!state) return;
			var triggerSlideHandler = state["triggerSlideHandler"];
			delete state["triggerSlideHandler"];
			_this.setState(state);
			if (triggerSlideHandler === void 0) return;
			_this.slideHandler(triggerSlideHandler);
			if (_this.props.verticalSwiping) _this.enableBodyScroll();
		});
		_defineProperty(_this, "touchEnd", function(e$2) {
			_this.swipeEnd(e$2);
			_this.clickable = true;
		});
		_defineProperty(_this, "slickPrev", function() {
			_this.callbackTimers.push(setTimeout(function() {
				return _this.changeSlide({ message: "previous" });
			}, 0));
		});
		_defineProperty(_this, "slickNext", function() {
			_this.callbackTimers.push(setTimeout(function() {
				return _this.changeSlide({ message: "next" });
			}, 0));
		});
		_defineProperty(_this, "slickGoTo", function(slide) {
			var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
			slide = Number(slide);
			if (isNaN(slide)) return "";
			_this.callbackTimers.push(setTimeout(function() {
				return _this.changeSlide({
					message: "index",
					index: slide,
					currentSlide: _this.state.currentSlide
				}, dontAnimate);
			}, 0));
		});
		_defineProperty(_this, "play", function() {
			var nextIndex;
			if (_this.props.rtl) nextIndex = _this.state.currentSlide - _this.props.slidesToScroll;
			else if (canGoNext(_objectSpread2(_objectSpread2({}, _this.props), _this.state))) nextIndex = _this.state.currentSlide + _this.props.slidesToScroll;
			else return false;
			_this.slideHandler(nextIndex);
		});
		_defineProperty(_this, "autoPlay", function(playType) {
			if (_this.autoplayTimer) clearInterval(_this.autoplayTimer);
			var autoplaying = _this.state.autoplaying;
			if (playType === "update") {
				if (autoplaying === "hovered" || autoplaying === "focused" || autoplaying === "paused") return;
			} else if (playType === "leave") {
				if (autoplaying === "paused" || autoplaying === "focused") return;
			} else if (playType === "blur") {
				if (autoplaying === "paused" || autoplaying === "hovered") return;
			}
			_this.autoplayTimer = setInterval(_this.play, _this.props.autoplaySpeed + 50);
			_this.setState({ autoplaying: "playing" });
		});
		_defineProperty(_this, "pause", function(pauseType) {
			if (_this.autoplayTimer) {
				clearInterval(_this.autoplayTimer);
				_this.autoplayTimer = null;
			}
			var autoplaying = _this.state.autoplaying;
			if (pauseType === "paused") _this.setState({ autoplaying: "paused" });
			else if (pauseType === "focused") {
				if (autoplaying === "hovered" || autoplaying === "playing") _this.setState({ autoplaying: "focused" });
			} else if (autoplaying === "playing") _this.setState({ autoplaying: "hovered" });
		});
		_defineProperty(_this, "onDotsOver", function() {
			return _this.props.autoplay && _this.pause("hovered");
		});
		_defineProperty(_this, "onDotsLeave", function() {
			return _this.props.autoplay && _this.state.autoplaying === "hovered" && _this.autoPlay("leave");
		});
		_defineProperty(_this, "onTrackOver", function() {
			return _this.props.autoplay && _this.pause("hovered");
		});
		_defineProperty(_this, "onTrackLeave", function() {
			return _this.props.autoplay && _this.state.autoplaying === "hovered" && _this.autoPlay("leave");
		});
		_defineProperty(_this, "onSlideFocus", function() {
			return _this.props.autoplay && _this.pause("focused");
		});
		_defineProperty(_this, "onSlideBlur", function() {
			return _this.props.autoplay && _this.state.autoplaying === "focused" && _this.autoPlay("blur");
		});
		_defineProperty(_this, "render", function() {
			var className = clsx("slick-slider", _this.props.className, {
				"slick-vertical": _this.props.vertical,
				"slick-initialized": true
			});
			var spec = _objectSpread2(_objectSpread2({}, _this.props), _this.state);
			var trackProps = extractObject(spec, [
				"fade",
				"cssEase",
				"speed",
				"infinite",
				"centerMode",
				"focusOnSelect",
				"currentSlide",
				"lazyLoad",
				"lazyLoadedList",
				"rtl",
				"slideWidth",
				"slideHeight",
				"listHeight",
				"vertical",
				"slidesToShow",
				"slidesToScroll",
				"slideCount",
				"trackStyle",
				"variableWidth",
				"unslick",
				"centerPadding",
				"targetSlide",
				"useCSS"
			]);
			var pauseOnHover = _this.props.pauseOnHover;
			trackProps = _objectSpread2(_objectSpread2({}, trackProps), {}, {
				onMouseEnter: pauseOnHover ? _this.onTrackOver : null,
				onMouseLeave: pauseOnHover ? _this.onTrackLeave : null,
				onMouseOver: pauseOnHover ? _this.onTrackOver : null,
				focusOnSelect: _this.props.focusOnSelect && _this.clickable ? _this.selectHandler : null
			});
			var dots;
			if (_this.props.dots === true && _this.state.slideCount >= _this.props.slidesToShow) {
				var dotProps = extractObject(spec, [
					"dotsClass",
					"slideCount",
					"slidesToShow",
					"currentSlide",
					"slidesToScroll",
					"clickHandler",
					"children",
					"customPaging",
					"infinite",
					"appendDots"
				]);
				var pauseOnDotsHover = _this.props.pauseOnDotsHover;
				dotProps = _objectSpread2(_objectSpread2({}, dotProps), {}, {
					clickHandler: _this.changeSlide,
					onMouseEnter: pauseOnDotsHover ? _this.onDotsLeave : null,
					onMouseOver: pauseOnDotsHover ? _this.onDotsOver : null,
					onMouseLeave: pauseOnDotsHover ? _this.onDotsLeave : null
				});
				dots = /* @__PURE__ */ import_react.createElement(Dots, dotProps);
			}
			var prevArrow, nextArrow;
			var arrowProps = extractObject(spec, [
				"infinite",
				"centerMode",
				"currentSlide",
				"slideCount",
				"slidesToShow",
				"prevArrow",
				"nextArrow"
			]);
			arrowProps.clickHandler = _this.changeSlide;
			if (_this.props.arrows) {
				prevArrow = /* @__PURE__ */ import_react.createElement(PrevArrow, arrowProps);
				nextArrow = /* @__PURE__ */ import_react.createElement(NextArrow, arrowProps);
			}
			var verticalHeightStyle = null;
			if (_this.props.vertical) verticalHeightStyle = { height: _this.state.listHeight };
			var centerPaddingStyle = null;
			if (_this.props.vertical === false) {
				if (_this.props.centerMode === true) centerPaddingStyle = { padding: "0px " + _this.props.centerPadding };
			} else if (_this.props.centerMode === true) centerPaddingStyle = { padding: _this.props.centerPadding + " 0px" };
			var listStyle = _objectSpread2(_objectSpread2({}, verticalHeightStyle), centerPaddingStyle);
			var touchMove = _this.props.touchMove;
			var listProps = {
				className: "slick-list",
				style: listStyle,
				onClick: _this.clickHandler,
				onMouseDown: touchMove ? _this.swipeStart : null,
				onMouseMove: _this.state.dragging && touchMove ? _this.swipeMove : null,
				onMouseUp: touchMove ? _this.swipeEnd : null,
				onMouseLeave: _this.state.dragging && touchMove ? _this.swipeEnd : null,
				onTouchStart: touchMove ? _this.swipeStart : null,
				onTouchMove: _this.state.dragging && touchMove ? _this.swipeMove : null,
				onTouchEnd: touchMove ? _this.touchEnd : null,
				onTouchCancel: _this.state.dragging && touchMove ? _this.swipeEnd : null,
				onKeyDown: _this.props.accessibility ? _this.keyHandler : null
			};
			var innerSliderProps = {
				className,
				dir: "ltr",
				style: _this.props.style
			};
			if (_this.props.unslick) {
				listProps = { className: "slick-list" };
				innerSliderProps = {
					className,
					style: _this.props.style
				};
			}
			return /* @__PURE__ */ import_react.createElement("div", innerSliderProps, !_this.props.unslick ? prevArrow : "", /* @__PURE__ */ import_react.createElement("div", _extends$26({ ref: _this.listRefHandler }, listProps), /* @__PURE__ */ import_react.createElement(Track$1, _extends$26({ ref: _this.trackRefHandler }, trackProps), _this.props.children)), !_this.props.unslick ? nextArrow : "", !_this.props.unslick ? dots : "");
		});
		_this.list = null;
		_this.track = null;
		_this.state = _objectSpread2(_objectSpread2({}, initial_state_default), {}, {
			currentSlide: _this.props.initialSlide,
			targetSlide: _this.props.initialSlide ? _this.props.initialSlide : 0,
			slideCount: import_react.Children.count(_this.props.children)
		});
		_this.callbackTimers = [];
		_this.clickable = true;
		_this.debouncedResize = null;
		var ssrState = _this.ssrInit();
		_this.state = _objectSpread2(_objectSpread2({}, _this.state), ssrState);
		return _this;
	}
	_inherits(InnerSlider$1, _React$Component);
	return _createClass(InnerSlider$1, [{
		key: "didPropsChange",
		value: function didPropsChange(prevProps) {
			var setTrackStyle = false;
			for (var _i3 = 0, _Object$keys = Object.keys(this.props); _i3 < _Object$keys.length; _i3++) {
				var key = _Object$keys[_i3];
				if (!prevProps.hasOwnProperty(key)) {
					setTrackStyle = true;
					break;
				}
				if (_typeof(prevProps[key]) === "object" || typeof prevProps[key] === "function" || isNaN(prevProps[key])) continue;
				if (prevProps[key] !== this.props[key]) {
					setTrackStyle = true;
					break;
				}
			}
			return setTrackStyle || import_react.Children.count(this.props.children) !== import_react.Children.count(prevProps.children);
		}
	}]);
}(import_react.Component);

//#endregion
//#region node_modules/string-convert/camel2hyphen.js
var require_camel2hyphen = /* @__PURE__ */ __commonJS({ "node_modules/string-convert/camel2hyphen.js": ((exports, module) => {
	var camel2hyphen$1 = function(str) {
		return str.replace(/[A-Z]/g, function(match$2) {
			return "-" + match$2.toLowerCase();
		}).toLowerCase();
	};
	module.exports = camel2hyphen$1;
}) });

//#endregion
//#region node_modules/json2mq/index.js
var require_json2mq = /* @__PURE__ */ __commonJS({ "node_modules/json2mq/index.js": ((exports, module) => {
	var camel2hyphen = require_camel2hyphen();
	var isDimension = function(feature) {
		return /[height|width]$/.test(feature);
	};
	var obj2mq = function(obj) {
		var mq = "";
		var features = Object.keys(obj);
		features.forEach(function(feature, index$1) {
			var value = obj[feature];
			feature = camel2hyphen(feature);
			if (isDimension(feature) && typeof value === "number") value = value + "px";
			if (value === true) mq += feature;
			else if (value === false) mq += "not " + feature;
			else mq += "(" + feature + ": " + value + ")";
			if (index$1 < features.length - 1) mq += " and ";
		});
		return mq;
	};
	var json2mq$1 = function(query) {
		var mq = "";
		if (typeof query === "string") return query;
		if (query instanceof Array) {
			query.forEach(function(q, index$1) {
				mq += obj2mq(q);
				if (index$1 < query.length - 1) mq += ", ";
			});
			return mq;
		}
		return obj2mq(query);
	};
	module.exports = json2mq$1;
}) });

//#endregion
//#region node_modules/@ant-design/react-slick/es/slider.js
var import_json2mq = /* @__PURE__ */ __toESM(require_json2mq());
function _callSuper(t$1, o$2, e$2) {
	return o$2 = _getPrototypeOf(o$2), _possibleConstructorReturn(t$1, _isNativeReflectConstruct() ? Reflect.construct(o$2, e$2 || [], _getPrototypeOf(t$1).constructor) : o$2.apply(t$1, e$2));
}
var Slider$2 = /* @__PURE__ */ function(_React$Component) {
	function Slider$4(props) {
		var _this;
		_classCallCheck(this, Slider$4);
		_this = _callSuper(this, Slider$4, [props]);
		_defineProperty(_this, "innerSliderRefHandler", function(ref) {
			return _this.innerSlider = ref;
		});
		_defineProperty(_this, "slickPrev", function() {
			return _this.innerSlider.slickPrev();
		});
		_defineProperty(_this, "slickNext", function() {
			return _this.innerSlider.slickNext();
		});
		_defineProperty(_this, "slickGoTo", function(slide) {
			var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
			return _this.innerSlider.slickGoTo(slide, dontAnimate);
		});
		_defineProperty(_this, "slickPause", function() {
			return _this.innerSlider.pause("paused");
		});
		_defineProperty(_this, "slickPlay", function() {
			return _this.innerSlider.autoPlay("play");
		});
		_this.state = { breakpoint: null };
		_this._responsiveMediaHandlers = [];
		return _this;
	}
	_inherits(Slider$4, _React$Component);
	return _createClass(Slider$4, [
		{
			key: "media",
			value: function media(query, handler) {
				var mql = window.matchMedia(query);
				var listener = function listener$1(_ref) {
					if (_ref.matches) handler();
				};
				mql.addListener(listener);
				this._responsiveMediaHandlers.push({
					mql,
					query,
					listener
				});
			}
		},
		{
			key: "componentDidMount",
			value: function componentDidMount() {
				var _this2 = this;
				if (this.props.responsive) {
					var breakpoints = this.props.responsive.map(function(breakpt) {
						return breakpt.breakpoint;
					});
					breakpoints.sort(function(x, y) {
						return x - y;
					});
					breakpoints.forEach(function(breakpoint, index$1) {
						var bQuery;
						if (index$1 === 0) bQuery = (0, import_json2mq.default)({
							minWidth: 0,
							maxWidth: breakpoint
						});
						else bQuery = (0, import_json2mq.default)({
							minWidth: breakpoints[index$1 - 1] + 1,
							maxWidth: breakpoint
						});
						canUseDOM() && _this2.media(bQuery, function() {
							_this2.setState({ breakpoint });
						});
					});
					var query = (0, import_json2mq.default)({ minWidth: breakpoints.slice(-1)[0] });
					canUseDOM() && this.media(query, function() {
						_this2.setState({ breakpoint: null });
					});
				}
			}
		},
		{
			key: "componentWillUnmount",
			value: function componentWillUnmount() {
				this._responsiveMediaHandlers.forEach(function(obj) {
					obj.mql.removeListener(obj.listener);
				});
			}
		},
		{
			key: "render",
			value: function render$1() {
				var _this3 = this;
				var settings;
				var newProps;
				if (this.state.breakpoint) {
					newProps = this.props.responsive.filter(function(resp) {
						return resp.breakpoint === _this3.state.breakpoint;
					});
					settings = newProps[0].settings === "unslick" ? "unslick" : _objectSpread2(_objectSpread2(_objectSpread2({}, default_props_default), this.props), newProps[0].settings);
				} else settings = _objectSpread2(_objectSpread2({}, default_props_default), this.props);
				if (settings.centerMode) {
					if (settings.slidesToScroll > 1 && true) console.warn("slidesToScroll should be equal to 1 in centerMode, you are using ".concat(settings.slidesToScroll));
					settings.slidesToScroll = 1;
				}
				if (settings.fade) {
					if (settings.slidesToShow > 1 && true) console.warn("slidesToShow should be equal to 1 when fade is true, you're using ".concat(settings.slidesToShow));
					if (settings.slidesToScroll > 1 && true) console.warn("slidesToScroll should be equal to 1 when fade is true, you're using ".concat(settings.slidesToScroll));
					settings.slidesToShow = 1;
					settings.slidesToScroll = 1;
				}
				var children = import_react.Children.toArray(this.props.children);
				children = children.filter(function(child) {
					if (typeof child === "string") return !!child.trim();
					return !!child;
				});
				if (settings.variableWidth && (settings.rows > 1 || settings.slidesPerRow > 1)) {
					console.warn("variableWidth is not supported in case of rows > 1 or slidesPerRow > 1");
					settings.variableWidth = false;
				}
				var newChildren = [];
				var currentWidth = null;
				for (var i = 0; i < children.length; i += settings.rows * settings.slidesPerRow) {
					var newSlide = [];
					for (var j = i; j < i + settings.rows * settings.slidesPerRow; j += settings.slidesPerRow) {
						var row = [];
						for (var k = j; k < j + settings.slidesPerRow; k += 1) {
							if (settings.variableWidth && children[k].props.style) currentWidth = children[k].props.style.width;
							if (k >= children.length) break;
							row.push(/* @__PURE__ */ import_react.cloneElement(children[k], {
								key: 100 * i + 10 * j + k,
								tabIndex: -1,
								style: {
									width: "".concat(100 / settings.slidesPerRow, "%"),
									display: "inline-block"
								}
							}));
						}
						newSlide.push(/* @__PURE__ */ import_react.createElement("div", { key: 10 * i + j }, row));
					}
					if (settings.variableWidth) newChildren.push(/* @__PURE__ */ import_react.createElement("div", {
						key: i,
						style: { width: currentWidth }
					}, newSlide));
					else newChildren.push(/* @__PURE__ */ import_react.createElement("div", { key: i }, newSlide));
				}
				if (settings === "unslick") {
					var className = "regular slider " + (this.props.className || "");
					return /* @__PURE__ */ import_react.createElement("div", { className }, children);
				} else if (newChildren.length <= settings.slidesToShow) settings.unslick = true;
				return /* @__PURE__ */ import_react.createElement(InnerSlider, _extends$26({
					style: this.props.style,
					ref: this.innerSliderRefHandler
				}, filterSettings(settings)), newChildren);
			}
		}
	]);
}(import_react.Component);

//#endregion
//#region node_modules/@ant-design/react-slick/es/index.js
var es_default$27 = Slider$2;

//#endregion
//#region node_modules/antd/es/carousel/style/index.js
const DotDuration = "--dot-duration";
var genCarouselStyle = (token$1) => {
	const { componentCls, antCls } = token$1;
	return { [componentCls]: {
		...resetComponent(token$1),
		".slick-slider": {
			position: "relative",
			display: "block",
			boxSizing: "border-box",
			touchAction: "pan-y",
			WebkitTouchCallout: "none",
			WebkitTapHighlightColor: "transparent",
			".slick-track, .slick-list": {
				transform: "translate3d(0, 0, 0)",
				touchAction: "pan-y"
			}
		},
		".slick-list": {
			position: "relative",
			display: "block",
			margin: 0,
			padding: 0,
			overflow: "hidden",
			"&:focus": { outline: "none" },
			"&.dragging": { cursor: "pointer" },
			".slick-slide": {
				pointerEvents: "none",
				[`input${antCls}-radio-input, input${antCls}-checkbox-input`]: { visibility: "hidden" },
				"&.slick-active": {
					pointerEvents: "auto",
					[`input${antCls}-radio-input, input${antCls}-checkbox-input`]: { visibility: "visible" }
				},
				"> div > div": { verticalAlign: "bottom" }
			}
		},
		".slick-track": {
			position: "relative",
			top: 0,
			insetInlineStart: 0,
			display: "block",
			"&::before, &::after": {
				display: "table",
				content: "\"\""
			},
			"&::after": { clear: "both" }
		},
		".slick-slide": {
			display: "none",
			float: "left",
			height: "100%",
			minHeight: 1,
			img: { display: "block" },
			"&.dragging img": { pointerEvents: "none" }
		},
		".slick-initialized .slick-slide": { display: "block" },
		".slick-vertical .slick-slide": {
			display: "block",
			height: "auto"
		}
	} };
};
var genArrowsStyle = (token$1) => {
	const { componentCls, motionDurationSlow, arrowSize, arrowOffset } = token$1;
	const arrowLength = token$1.calc(arrowSize).div(Math.SQRT2).equal();
	return { [componentCls]: {
		".slick-prev, .slick-next": {
			position: "absolute",
			top: "50%",
			width: arrowSize,
			height: arrowSize,
			transform: "translateY(-50%)",
			color: "#fff",
			opacity: .4,
			background: "transparent",
			padding: 0,
			lineHeight: 0,
			border: 0,
			outline: "none",
			cursor: "pointer",
			zIndex: 1,
			transition: `opacity ${motionDurationSlow}`,
			"&:hover, &:focus": { opacity: 1 },
			"&.slick-disabled": {
				pointerEvents: "none",
				opacity: 0
			},
			"&::after": {
				boxSizing: "border-box",
				position: "absolute",
				top: token$1.calc(arrowSize).sub(arrowLength).div(2).equal(),
				insetInlineStart: token$1.calc(arrowSize).sub(arrowLength).div(2).equal(),
				display: "inline-block",
				width: arrowLength,
				height: arrowLength,
				border: `0 solid currentcolor`,
				borderInlineStartWidth: 2,
				borderBlockStartWidth: 2,
				borderRadius: 1,
				content: "\"\""
			}
		},
		".slick-prev": {
			insetInlineStart: arrowOffset,
			"&::after": { transform: "rotate(-45deg)" }
		},
		".slick-next": {
			insetInlineEnd: arrowOffset,
			"&::after": { transform: "rotate(135deg)" }
		}
	} };
};
var genDotsStyle = (token$1) => {
	const { componentCls, dotOffset, dotWidth, dotHeight, dotGap, colorBgContainer, motionDurationSlow } = token$1;
	const animation = new Keyframes_default(`${token$1.prefixCls}-dot-animation`, {
		from: { width: 0 },
		to: { width: token$1.dotActiveWidth }
	});
	return { [componentCls]: { ".slick-dots": {
		position: "absolute",
		insetInlineEnd: 0,
		bottom: 0,
		insetInlineStart: 0,
		zIndex: 15,
		display: "flex !important",
		justifyContent: "center",
		paddingInlineStart: 0,
		margin: 0,
		listStyle: "none",
		"&-bottom": { bottom: dotOffset },
		"&-top": {
			top: dotOffset,
			bottom: "auto"
		},
		li: {
			position: "relative",
			display: "inline-block",
			flex: "0 1 auto",
			boxSizing: "content-box",
			width: dotWidth,
			height: dotHeight,
			marginInline: dotGap,
			padding: 0,
			textAlign: "center",
			textIndent: -999,
			verticalAlign: "top",
			transition: `all ${motionDurationSlow}`,
			borderRadius: dotHeight,
			overflow: "hidden",
			"&::after": {
				display: "block",
				position: "absolute",
				top: 0,
				insetInlineStart: 0,
				width: 0,
				height: dotHeight,
				content: "\"\"",
				background: "transparent",
				borderRadius: dotHeight,
				opacity: 1,
				outline: "none",
				cursor: "pointer",
				overflow: "hidden"
			},
			button: {
				position: "relative",
				display: "block",
				width: "100%",
				height: dotHeight,
				padding: 0,
				color: "transparent",
				fontSize: 0,
				background: colorBgContainer,
				border: 0,
				borderRadius: dotHeight,
				outline: "none",
				cursor: "pointer",
				opacity: .2,
				transition: `all ${motionDurationSlow}`,
				overflow: "hidden",
				"&:hover": { opacity: .75 },
				"&::after": {
					position: "absolute",
					inset: token$1.calc(dotGap).mul(-1).equal(),
					content: "\"\""
				}
			},
			"&.slick-active": {
				width: token$1.dotActiveWidth,
				position: "relative",
				"&:hover": { opacity: 1 },
				"&::after": {
					background: colorBgContainer,
					animationName: animation,
					animationDuration: `var(${DotDuration})`,
					animationTimingFunction: "ease-out",
					animationFillMode: "forwards"
				}
			}
		}
	} } };
};
var genCarouselVerticalStyle = (token$1) => {
	const { componentCls, dotOffset, arrowOffset, marginXXS } = token$1;
	const animation = new Keyframes_default(`${token$1.prefixCls}-dot-vertical-animation`, {
		from: { height: 0 },
		to: { height: token$1.dotActiveWidth }
	});
	const reverseSizeOfDot = {
		width: token$1.dotHeight,
		height: token$1.dotWidth
	};
	return { [`${componentCls}-vertical`]: {
		".slick-prev, .slick-next": {
			insetInlineStart: "50%",
			marginBlockStart: "unset",
			transform: "translateX(-50%)"
		},
		".slick-prev": {
			insetBlockStart: arrowOffset,
			insetInlineStart: "50%",
			"&::after": { transform: "rotate(45deg)" }
		},
		".slick-next": {
			insetBlockStart: "auto",
			insetBlockEnd: arrowOffset,
			"&::after": { transform: "rotate(-135deg)" }
		},
		".slick-dots": {
			top: "50%",
			bottom: "auto",
			flexDirection: "column",
			width: token$1.dotHeight,
			height: "auto",
			margin: 0,
			transform: "translateY(-50%)",
			"&-start": {
				insetInlineEnd: "auto",
				insetInlineStart: dotOffset
			},
			"&-end": {
				insetInlineEnd: dotOffset,
				insetInlineStart: "auto"
			},
			li: {
				...reverseSizeOfDot,
				margin: `${unit(marginXXS)} 0`,
				verticalAlign: "baseline",
				button: reverseSizeOfDot,
				"&::after": {
					...reverseSizeOfDot,
					height: 0
				},
				"&.slick-active": {
					...reverseSizeOfDot,
					height: token$1.dotActiveWidth,
					button: {
						...reverseSizeOfDot,
						height: token$1.dotActiveWidth
					},
					"&::after": {
						...reverseSizeOfDot,
						animationName: animation,
						animationDuration: `var(${DotDuration})`,
						animationTimingFunction: "ease-out",
						animationFillMode: "forwards"
					}
				}
			}
		}
	} };
};
var genCarouselRtlStyle = (token$1) => {
	const { componentCls } = token$1;
	return [{ [`${componentCls}-rtl`]: { direction: "rtl" } }, { [`${componentCls}-vertical`]: { ".slick-dots": { [`${componentCls}-rtl&`]: { flexDirection: "column" } } } }];
};
const prepareComponentToken$32 = (token$1) => {
	const dotActiveWidth = 24;
	return {
		arrowSize: 16,
		arrowOffset: token$1.marginXS,
		dotWidth: 16,
		dotHeight: 3,
		dotGap: token$1.marginXXS,
		dotOffset: 12,
		dotWidthActive: dotActiveWidth,
		dotActiveWidth
	};
};
var style_default$41 = genStyleHooks("Carousel", (token$1) => [
	genCarouselStyle(token$1),
	genArrowsStyle(token$1),
	genDotsStyle(token$1),
	genCarouselVerticalStyle(token$1),
	genCarouselRtlStyle(token$1)
], prepareComponentToken$32, { deprecatedTokens: [["dotWidthActive", "dotActiveWidth"]] });

//#endregion
//#region node_modules/antd/es/carousel/index.js
var dotsClass = "slick-dots";
var ArrowButton = ({ currentSlide, slideCount, ...rest }) => /* @__PURE__ */ import_react.createElement("button", {
	type: "button",
	...rest
});
var Carousel = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { dots = true, arrows = false, prevArrow, nextArrow, draggable = false, waitForAnimate = false, dotPosition, dotPlacement, vertical, rootClassName, className: customClassName, style: style$1, id, autoplay = false, autoplaySpeed = 3e3, rtl, ...otherProps } = props;
	const mergedDotPlacement = import_react.useMemo(() => {
		const placement = dotPlacement ?? dotPosition ?? "bottom";
		switch (placement) {
			case "left": return "start";
			case "right": return "end";
			default: return placement;
		}
	}, [dotPosition, dotPlacement]);
	const mergedVertical = vertical ?? (mergedDotPlacement === "start" || mergedDotPlacement === "end");
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle } = useComponentConfig("carousel");
	const slickRef = import_react.useRef(null);
	const goTo = (slide, dontAnimate = false) => {
		slickRef.current.slickGoTo(slide, dontAnimate);
	};
	import_react.useImperativeHandle(ref, () => ({
		goTo,
		autoPlay: slickRef.current.innerSlider.autoPlay,
		innerSlider: slickRef.current.innerSlider,
		prev: slickRef.current.slickPrev,
		next: slickRef.current.slickNext
	}), [slickRef.current]);
	const { children, initialSlide = 0 } = props;
	const count = toArray(children).length;
	const isRTL = (rtl ?? direction === "rtl") && !vertical;
	import_react.useEffect(() => {
		if (count > 0) goTo(isRTL ? count - initialSlide - 1 : initialSlide, false);
	}, [
		count,
		initialSlide,
		isRTL
	]);
	devUseWarning("Carousel").deprecated(!dotPosition, "dotPosition", "dotPlacement");
	const newProps = {
		vertical: mergedVertical,
		className: clsx(customClassName, contextClassName),
		style: {
			...contextStyle,
			...style$1
		},
		autoplay: !!autoplay,
		...otherProps
	};
	if (newProps.effect === "fade") newProps.fade = true;
	const prefixCls = getPrefixCls("carousel", newProps.prefixCls);
	const enableDots = !!dots;
	const dsClass = clsx(dotsClass, `${dotsClass}-${mergedDotPlacement}`, typeof dots === "boolean" ? false : dots?.className);
	const [hashId, cssVarCls] = style_default$41(prefixCls);
	const className = clsx(prefixCls, {
		[`${prefixCls}-rtl`]: isRTL,
		[`${prefixCls}-vertical`]: newProps.vertical
	}, hashId, cssVarCls, rootClassName);
	const dotDurationStyle = autoplay && (typeof autoplay === "object" ? autoplay.dotDuration : false) ? { [DotDuration]: `${autoplaySpeed}ms` } : {};
	return /* @__PURE__ */ import_react.createElement("div", {
		className,
		id,
		style: dotDurationStyle
	}, /* @__PURE__ */ import_react.createElement(es_default$27, {
		ref: slickRef,
		...newProps,
		dots: enableDots,
		dotsClass: dsClass,
		arrows,
		prevArrow: prevArrow ?? /* @__PURE__ */ import_react.createElement(ArrowButton, { "aria-label": isRTL ? "next" : "prev" }),
		nextArrow: nextArrow ?? /* @__PURE__ */ import_react.createElement(ArrowButton, { "aria-label": isRTL ? "prev" : "next" }),
		draggable,
		verticalSwiping: mergedVertical,
		autoplaySpeed,
		waitForAnimate,
		rtl: isRTL
	}));
});
Carousel.displayName = "Carousel";
var carousel_default = Carousel;

//#endregion
//#region node_modules/@rc-component/cascader/es/context.js
var CascaderContext = /* @__PURE__ */ import_react.createContext({});
var context_default$3 = CascaderContext;

//#endregion
//#region node_modules/@rc-component/cascader/es/hooks/useSearchOptions.js
const SEARCH_MARK = "__rc_cascader_search_mark__";
var defaultFilter = (search, options, { label = "" }) => options.some((opt) => String(opt[label]).toLowerCase().includes(search.toLowerCase()));
var defaultRender$1 = (inputValue, path$1, prefixCls, fieldNames) => path$1.map((opt) => opt[fieldNames.label]).join(" / ");
var useSearchOptions = (search, options, fieldNames, prefixCls, config, enableHalfPath) => {
	const { filter: filter$2 = defaultFilter, render: render$1 = defaultRender$1, limit = 50, sort } = config;
	return import_react.useMemo(() => {
		const filteredOptions = [];
		if (!search) return [];
		function dig(list, pathOptions, parentDisabled = false) {
			list.forEach((option) => {
				if (!sort && limit !== false && limit > 0 && filteredOptions.length >= limit) return;
				const connectedPathOptions = [...pathOptions, option];
				const children = option[fieldNames.children];
				const mergedDisabled = parentDisabled || option.disabled;
				if (!children || children.length === 0 || enableHalfPath) {
					if (filter$2(search, connectedPathOptions, { label: fieldNames.label })) filteredOptions.push({
						...option,
						disabled: mergedDisabled,
						[fieldNames.label]: render$1(search, connectedPathOptions, prefixCls, fieldNames),
						[SEARCH_MARK]: connectedPathOptions,
						[fieldNames.children]: void 0
					});
				}
				if (children) dig(option[fieldNames.children], connectedPathOptions, mergedDisabled);
			});
		}
		dig(options, []);
		if (sort) filteredOptions.sort((a, b) => {
			return sort(a[SEARCH_MARK], b[SEARCH_MARK], search, fieldNames);
		});
		return limit !== false && limit > 0 ? filteredOptions.slice(0, limit) : filteredOptions;
	}, [
		search,
		options,
		fieldNames,
		prefixCls,
		render$1,
		enableHalfPath,
		filter$2,
		sort,
		limit
	]);
};
var useSearchOptions_default = useSearchOptions;

//#endregion
//#region node_modules/@rc-component/cascader/es/utils/commonUtil.js
const VALUE_SPLIT = "__RC_CASCADER_SPLIT__";
const SHOW_PARENT$2 = "SHOW_PARENT";
const SHOW_CHILD$2 = "SHOW_CHILD";
/**
* Will convert value to string, and join with `VALUE_SPLIT`
*/
function toPathKey(value) {
	return value.join(VALUE_SPLIT);
}
/**
* Batch convert value to string, and join with `VALUE_SPLIT`
*/
function toPathKeys(value) {
	return value.map(toPathKey);
}
function toPathValueStr(pathKey$1) {
	return pathKey$1.split(VALUE_SPLIT);
}
function fillFieldNames$2(fieldNames) {
	const { label, value, children } = fieldNames || {};
	const val = value || "value";
	return {
		label: label || "label",
		value: val,
		key: val,
		children: children || "children"
	};
}
function isLeaf(option, fieldNames) {
	return option.isLeaf ?? !option[fieldNames.children]?.length;
}
function scrollIntoParentView(element) {
	const parent = element.parentElement;
	if (!parent) return;
	const elementToParent = element.offsetTop - parent.offsetTop;
	if (elementToParent - parent.scrollTop < 0) parent.scrollTo({ top: elementToParent });
	else if (elementToParent + element.offsetHeight - parent.scrollTop > parent.offsetHeight) parent.scrollTo({ top: elementToParent + element.offsetHeight - parent.offsetHeight });
}
function getFullPathKeys(options, fieldNames) {
	return options.map((item) => item[SEARCH_MARK]?.map((opt) => opt[fieldNames.value]));
}
function isMultipleValue(value) {
	return Array.isArray(value) && Array.isArray(value[0]);
}
function toRawValues(value) {
	if (!value) return [];
	if (isMultipleValue(value)) return value;
	return (value.length === 0 ? [] : [value]).map((val) => Array.isArray(val) ? val : [val]);
}

//#endregion
//#region node_modules/@rc-component/cascader/es/utils/treeUtil.js
function formatStrategyValues$1(pathKeys, getKeyPathEntities, showCheckedStrategy) {
	const valueSet = new Set(pathKeys);
	const keyPathEntities = getKeyPathEntities();
	return pathKeys.filter((key) => {
		const entity = keyPathEntities[key];
		const parent = entity ? entity.parent : null;
		const children = entity ? entity.children : null;
		if (entity && entity.node.disabled) return true;
		return showCheckedStrategy === SHOW_CHILD$2 ? !(children && children.some((child) => child.key && valueSet.has(child.key))) : !(parent && !parent.node.disabled && valueSet.has(parent.key));
	});
}
function toPathOptions(valueCells, options, fieldNames, stringMode = false) {
	let currentList = options;
	const valueOptions = [];
	for (let i = 0; i < valueCells.length; i += 1) {
		const valueCell = valueCells[i];
		const foundIndex = currentList?.findIndex((option) => {
			const val = option[fieldNames.value];
			return stringMode ? String(val) === String(valueCell) : val === valueCell;
		});
		const foundOption = foundIndex !== -1 ? currentList?.[foundIndex] : null;
		valueOptions.push({
			value: foundOption?.[fieldNames.value] ?? valueCell,
			index: foundIndex,
			option: foundOption
		});
		currentList = foundOption?.[fieldNames.children];
	}
	return valueOptions;
}

//#endregion
//#region node_modules/@rc-component/cascader/es/hooks/useDisplayValues.js
var useDisplayValues_default = ((rawValues, options, fieldNames, multiple, displayRender) => {
	return import_react.useMemo(() => {
		const mergedDisplayRender = displayRender || ((labels) => {
			const mergedLabels = multiple ? labels.slice(-1) : labels;
			const SPLIT$2 = " / ";
			if (mergedLabels.every((label) => ["string", "number"].includes(typeof label))) return mergedLabels.join(SPLIT$2);
			return mergedLabels.reduce((list, label, index$1) => {
				const keyedLabel = /* @__PURE__ */ import_react.isValidElement(label) ? /* @__PURE__ */ import_react.cloneElement(label, { key: index$1 }) : label;
				if (index$1 === 0) return [keyedLabel];
				return [
					...list,
					SPLIT$2,
					keyedLabel
				];
			}, []);
		});
		return rawValues.map((valueCells) => {
			const valueOptions = toPathOptions(valueCells, options, fieldNames);
			const label = mergedDisplayRender(valueOptions.map(({ option, value: value$1 }) => option?.[fieldNames.label] ?? value$1), valueOptions.map(({ option }) => option));
			const value = toPathKey(valueCells);
			return {
				label,
				value,
				key: value,
				valueCells,
				disabled: valueOptions[valueOptions.length - 1]?.option?.disabled
			};
		});
	}, [
		rawValues,
		options,
		fieldNames,
		displayRender,
		multiple
	]);
});

//#endregion
//#region node_modules/@rc-component/cascader/es/hooks/useMissingValues.js
function useMissingValues(options, fieldNames) {
	return import_react.useCallback((rawValues) => {
		const missingValues = [];
		const existsValues = [];
		rawValues.forEach((valueCell) => {
			if (toPathOptions(valueCell, options, fieldNames).every((opt) => opt.option)) existsValues.push(valueCell);
			else missingValues.push(valueCell);
		});
		return [existsValues, missingValues];
	}, [options, fieldNames]);
}

//#endregion
//#region node_modules/@rc-component/tree/es/utils/keyUtil.js
function getEntity(keyEntities, key) {
	return keyEntities[key];
}

//#endregion
//#region node_modules/@rc-component/tree/es/utils/treeUtil.js
function getPosition$1(level, index$1) {
	return `${level}-${index$1}`;
}
function isTreeNode(node$1) {
	return node$1 && node$1.type && node$1.type.isTreeNode;
}
function getKey(key, pos) {
	if (key !== null && key !== void 0) return key;
	return pos;
}
function fillFieldNames$1(fieldNames) {
	const { title, _title, key, children } = fieldNames || {};
	const mergedTitle = title || "title";
	return {
		title: mergedTitle,
		_title: _title || [mergedTitle],
		key: key || "key",
		children: children || "children"
	};
}
/**
* Warning if TreeNode do not provides key
*/
function warningWithoutKey(treeData, fieldNames) {
	const keys$1 = /* @__PURE__ */ new Map();
	function dig(list, path$1 = "") {
		(list || []).forEach((treeNode) => {
			const key = treeNode[fieldNames.key];
			const children = treeNode[fieldNames.children];
			warning_default$1(key !== null && key !== void 0, `Tree node must have a certain key: [${path$1}${key}]`);
			const recordKey = String(key);
			warning_default$1(!keys$1.has(recordKey) || key === null || key === void 0, `Same 'key' exist in the Tree: ${recordKey}`);
			keys$1.set(recordKey, true);
			dig(children, `${path$1}${recordKey} > `);
		});
	}
	dig(treeData);
}
/**
* Convert `children` of Tree into `treeData` structure.
*/
function convertTreeToData(rootNodes) {
	function dig(node$1) {
		return toArray(node$1).map((treeNode) => {
			if (!isTreeNode(treeNode)) {
				warning_default$1(!treeNode, "Tree/TreeNode can only accept TreeNode as children.");
				return null;
			}
			const { key } = treeNode;
			const { children, ...rest } = treeNode.props;
			const dataNode = {
				key,
				...rest
			};
			const parsedChildren = dig(children);
			if (parsedChildren.length) dataNode.children = parsedChildren;
			return dataNode;
		}).filter((dataNode) => dataNode);
	}
	return dig(rootNodes);
}
/**
* Flat nest tree data into flatten list. This is used for virtual list render.
* @param treeNodeList Origin data node list
* @param expandedKeys
* need expanded keys, provides `true` means all expanded (used in `rc-tree-select`).
*/
function flattenTreeData(treeNodeList, expandedKeys, fieldNames) {
	const { _title: fieldTitles, key: fieldKey, children: fieldChildren } = fillFieldNames$1(fieldNames);
	const expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);
	const flattenList = [];
	function dig(list, parent = null) {
		return list.map((treeNode, index$1) => {
			const pos = getPosition$1(parent ? parent.pos : "0", index$1);
			const mergedKey = getKey(treeNode[fieldKey], pos);
			let mergedTitle;
			for (let i = 0; i < fieldTitles.length; i += 1) {
				const fieldTitle = fieldTitles[i];
				if (treeNode[fieldTitle] !== void 0) {
					mergedTitle = treeNode[fieldTitle];
					break;
				}
			}
			const flattenNode = Object.assign(omit(treeNode, [
				...fieldTitles,
				fieldKey,
				fieldChildren
			]), {
				title: mergedTitle,
				key: mergedKey,
				parent,
				pos,
				children: null,
				data: treeNode,
				isStart: [...parent ? parent.isStart : [], index$1 === 0],
				isEnd: [...parent ? parent.isEnd : [], index$1 === list.length - 1]
			});
			flattenList.push(flattenNode);
			if (expandedKeys === true || expandedKeySet.has(mergedKey)) flattenNode.children = dig(treeNode[fieldChildren] || [], flattenNode);
			else flattenNode.children = [];
			return flattenNode;
		});
	}
	dig(treeNodeList);
	return flattenList;
}
/**
* Traverse all the data by `treeData`.
* Please not use it out of the `rc-tree` since we may refactor this code.
*/
function traverseDataNodes(dataNodes, callback, config) {
	let mergedConfig = {};
	if (typeof config === "object") mergedConfig = config;
	else mergedConfig = { externalGetKey: config };
	mergedConfig = mergedConfig || {};
	const { childrenPropName, externalGetKey, fieldNames } = mergedConfig;
	const { key: fieldKey, children: fieldChildren } = fillFieldNames$1(fieldNames);
	const mergeChildrenPropName = childrenPropName || fieldChildren;
	let syntheticGetKey;
	if (externalGetKey) {
		if (typeof externalGetKey === "string") syntheticGetKey = (node$1) => node$1[externalGetKey];
		else if (typeof externalGetKey === "function") syntheticGetKey = (node$1) => externalGetKey(node$1);
	} else syntheticGetKey = (node$1, pos) => getKey(node$1[fieldKey], pos);
	function processNode(node$1, index$1, parent, pathNodes) {
		const children = node$1 ? node$1[mergeChildrenPropName] : dataNodes;
		const pos = node$1 ? getPosition$1(parent.pos, index$1) : "0";
		const connectNodes = node$1 ? [...pathNodes, node$1] : [];
		if (node$1) callback({
			node: node$1,
			index: index$1,
			pos,
			key: syntheticGetKey(node$1, pos),
			parentPos: parent.node ? parent.pos : null,
			level: parent.level + 1,
			nodes: connectNodes
		});
		if (children) children.forEach((subNode, subIndex) => {
			processNode(subNode, subIndex, {
				node: node$1,
				pos,
				level: parent ? parent.level + 1 : -1
			}, connectNodes);
		});
	}
	processNode(null);
}
/**
* Convert `treeData` into entity records.
*/
function convertDataToEntities(dataNodes, { initWrapper, processEntity, onProcessFinished, externalGetKey, childrenPropName, fieldNames } = {}, legacyExternalGetKey) {
	const mergedExternalGetKey = externalGetKey || legacyExternalGetKey;
	const posEntities = {};
	const keyEntities = {};
	let wrapper = {
		posEntities,
		keyEntities
	};
	if (initWrapper) wrapper = initWrapper(wrapper) || wrapper;
	traverseDataNodes(dataNodes, (item) => {
		const { node: node$1, index: index$1, pos, key, parentPos, level, nodes } = item;
		const entity = {
			node: node$1,
			nodes,
			index: index$1,
			key,
			pos,
			level
		};
		const mergedKey = getKey(key, pos);
		posEntities[pos] = entity;
		keyEntities[mergedKey] = entity;
		entity.parent = posEntities[parentPos];
		if (entity.parent) {
			entity.parent.children = entity.parent.children || [];
			entity.parent.children.push(entity);
		}
		if (processEntity) processEntity(entity, wrapper);
	}, {
		externalGetKey: mergedExternalGetKey,
		childrenPropName,
		fieldNames
	});
	if (onProcessFinished) onProcessFinished(wrapper);
	return wrapper;
}
/**
* Get TreeNode props with Tree props.
*/
function getTreeNodeProps(key, { expandedKeys, selectedKeys, loadedKeys, loadingKeys, checkedKeys, halfCheckedKeys, dragOverNodeKey, dropPosition, keyEntities }) {
	const entity = getEntity(keyEntities, key);
	return {
		eventKey: key,
		expanded: expandedKeys.indexOf(key) !== -1,
		selected: selectedKeys.indexOf(key) !== -1,
		loaded: loadedKeys.indexOf(key) !== -1,
		loading: loadingKeys.indexOf(key) !== -1,
		checked: checkedKeys.indexOf(key) !== -1,
		halfChecked: halfCheckedKeys.indexOf(key) !== -1,
		pos: String(entity ? entity.pos : ""),
		dragOver: dragOverNodeKey === key && dropPosition === 0,
		dragOverGapTop: dragOverNodeKey === key && dropPosition === -1,
		dragOverGapBottom: dragOverNodeKey === key && dropPosition === 1
	};
}
function convertNodePropsToEventData(props) {
	const { data, expanded, selected, checked, loaded, loading, halfChecked, dragOver, dragOverGapTop, dragOverGapBottom, pos, active, eventKey } = props;
	const eventData = {
		...data,
		expanded,
		selected,
		checked,
		loaded,
		loading,
		halfChecked,
		dragOver,
		dragOverGapTop,
		dragOverGapBottom,
		pos,
		active,
		key: eventKey
	};
	if (!("props" in eventData)) Object.defineProperty(eventData, "props", { get() {
		warning_default$1(false, "Second param return from event is node data instead of TreeNode instance. Please read value directly instead of reading from `props`.");
		return props;
	} });
	return eventData;
}

//#endregion
//#region node_modules/@rc-component/cascader/es/hooks/useEntities.js
/** Lazy parse options data into conduct-able info to avoid perf issue in single mode */
var useEntities_default = ((options, fieldNames) => {
	const cacheRef = import_react.useRef({
		options: [],
		info: {
			keyEntities: {},
			pathKeyEntities: {}
		}
	});
	return import_react.useCallback(() => {
		if (cacheRef.current.options !== options) {
			cacheRef.current.options = options;
			cacheRef.current.info = convertDataToEntities(options, {
				fieldNames,
				initWrapper: (wrapper) => ({
					...wrapper,
					pathKeyEntities: {}
				}),
				processEntity: (entity, wrapper) => {
					const pathKey$1 = entity.nodes.map((node$1) => node$1[fieldNames.value]).join(VALUE_SPLIT);
					wrapper.pathKeyEntities[pathKey$1] = entity;
					entity.key = pathKey$1;
				}
			});
		}
		return cacheRef.current.info.pathKeyEntities;
	}, [fieldNames, options]);
});

//#endregion
//#region node_modules/@rc-component/cascader/es/hooks/useOptions.js
function useOptions(mergedFieldNames, options) {
	const mergedOptions = import_react.useMemo(() => options || [], [options]);
	const getPathKeyEntities = useEntities_default(mergedOptions, mergedFieldNames);
	return [
		mergedOptions,
		getPathKeyEntities,
		import_react.useCallback((pathKeys) => {
			const keyPathEntities = getPathKeyEntities();
			return pathKeys.map((pathKey$1) => {
				const { nodes } = keyPathEntities[pathKey$1];
				return nodes.map((node$1) => node$1[mergedFieldNames.value]);
			});
		}, [getPathKeyEntities, mergedFieldNames])
	];
}

//#endregion
//#region node_modules/@rc-component/cascader/es/hooks/useSearchConfig.js
function useSearchConfig$1(showSearch, props) {
	const { autoClearSearchValue, searchValue, onSearch } = props;
	return import_react.useMemo(() => {
		if (!showSearch) return [false, {}];
		let searchConfig = {
			matchInputWidth: true,
			limit: 50,
			autoClearSearchValue,
			searchValue,
			onSearch
		};
		if (showSearch && typeof showSearch === "object") searchConfig = {
			...searchConfig,
			...showSearch
		};
		if (searchConfig.limit <= 0) {
			searchConfig.limit = false;
			warning_default$1(false, "'limit' of showSearch should be positive number or false.");
		}
		return [true, searchConfig];
	}, [
		showSearch,
		autoClearSearchValue,
		searchValue,
		onSearch
	]);
}

//#endregion
//#region node_modules/@rc-component/tree/es/utils/conductUtil.js
function removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {
	const filteredKeys = /* @__PURE__ */ new Set();
	halfCheckedKeys.forEach((key) => {
		if (!checkedKeys.has(key)) filteredKeys.add(key);
	});
	return filteredKeys;
}
function isCheckDisabled$1(node$1) {
	const { disabled, disableCheckbox, checkable } = node$1 || {};
	return !!(disabled || disableCheckbox) || checkable === false;
}
function fillConductCheck(keys$1, levelEntities, maxLevel, syntheticGetCheckDisabled) {
	const checkedKeys = new Set(keys$1);
	const halfCheckedKeys = /* @__PURE__ */ new Set();
	for (let level = 0; level <= maxLevel; level += 1) (levelEntities.get(level) || /* @__PURE__ */ new Set()).forEach((entity) => {
		const { key, node: node$1, children = [] } = entity;
		if (checkedKeys.has(key) && !syntheticGetCheckDisabled(node$1)) children.filter((childEntity) => !syntheticGetCheckDisabled(childEntity.node)).forEach((childEntity) => {
			checkedKeys.add(childEntity.key);
		});
	});
	const visitedKeys = /* @__PURE__ */ new Set();
	for (let level = maxLevel; level >= 0; level -= 1) (levelEntities.get(level) || /* @__PURE__ */ new Set()).forEach((entity) => {
		const { parent, node: node$1 } = entity;
		if (syntheticGetCheckDisabled(node$1) || !entity.parent || visitedKeys.has(entity.parent.key)) return;
		if (syntheticGetCheckDisabled(entity.parent.node)) {
			visitedKeys.add(parent.key);
			return;
		}
		let allChecked = true;
		let partialChecked = false;
		(parent.children || []).filter((childEntity) => !syntheticGetCheckDisabled(childEntity.node)).forEach(({ key }) => {
			const checked = checkedKeys.has(key);
			if (allChecked && !checked) allChecked = false;
			if (!partialChecked && (checked || halfCheckedKeys.has(key))) partialChecked = true;
		});
		if (allChecked) checkedKeys.add(parent.key);
		if (partialChecked) halfCheckedKeys.add(parent.key);
		visitedKeys.add(parent.key);
	});
	return {
		checkedKeys: Array.from(checkedKeys),
		halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
	};
}
function cleanConductCheck(keys$1, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {
	const checkedKeys = new Set(keys$1);
	let halfCheckedKeys = new Set(halfKeys);
	for (let level = 0; level <= maxLevel; level += 1) (levelEntities.get(level) || /* @__PURE__ */ new Set()).forEach((entity) => {
		const { key, node: node$1, children = [] } = entity;
		if (!checkedKeys.has(key) && !halfCheckedKeys.has(key) && !syntheticGetCheckDisabled(node$1)) children.filter((childEntity) => !syntheticGetCheckDisabled(childEntity.node)).forEach((childEntity) => {
			checkedKeys.delete(childEntity.key);
		});
	});
	halfCheckedKeys = /* @__PURE__ */ new Set();
	const visitedKeys = /* @__PURE__ */ new Set();
	for (let level = maxLevel; level >= 0; level -= 1) (levelEntities.get(level) || /* @__PURE__ */ new Set()).forEach((entity) => {
		const { parent, node: node$1 } = entity;
		if (syntheticGetCheckDisabled(node$1) || !entity.parent || visitedKeys.has(entity.parent.key)) return;
		if (syntheticGetCheckDisabled(entity.parent.node)) {
			visitedKeys.add(parent.key);
			return;
		}
		let allChecked = true;
		let partialChecked = false;
		(parent.children || []).filter((childEntity) => !syntheticGetCheckDisabled(childEntity.node)).forEach(({ key }) => {
			const checked = checkedKeys.has(key);
			if (allChecked && !checked) allChecked = false;
			if (!partialChecked && (checked || halfCheckedKeys.has(key))) partialChecked = true;
		});
		if (!allChecked) checkedKeys.delete(parent.key);
		if (partialChecked) halfCheckedKeys.add(parent.key);
		visitedKeys.add(parent.key);
	});
	return {
		checkedKeys: Array.from(checkedKeys),
		halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
	};
}
/**
* Conduct with keys.
* @param keyList current key list
* @param keyEntities key - dataEntity map
* @param mode `fill` to fill missing key, `clean` to remove useless key
*/
function conductCheck(keyList, checked, keyEntities, getCheckDisabled) {
	const warningMissKeys = [];
	let syntheticGetCheckDisabled;
	if (getCheckDisabled) syntheticGetCheckDisabled = getCheckDisabled;
	else syntheticGetCheckDisabled = isCheckDisabled$1;
	const keys$1 = new Set(keyList.filter((key) => {
		const hasEntity = !!getEntity(keyEntities, key);
		if (!hasEntity) warningMissKeys.push(key);
		return hasEntity;
	}));
	const levelEntities = /* @__PURE__ */ new Map();
	let maxLevel = 0;
	Object.keys(keyEntities).forEach((key) => {
		const entity = keyEntities[key];
		const { level } = entity;
		let levelSet = levelEntities.get(level);
		if (!levelSet) {
			levelSet = /* @__PURE__ */ new Set();
			levelEntities.set(level, levelSet);
		}
		levelSet.add(entity);
		maxLevel = Math.max(maxLevel, level);
	});
	warning_default$1(!warningMissKeys.length, `Tree missing follow keys: ${warningMissKeys.slice(0, 100).map((key) => `'${key}'`).join(", ")}`);
	let result;
	if (checked === true) result = fillConductCheck(keys$1, levelEntities, maxLevel, syntheticGetCheckDisabled);
	else result = cleanConductCheck(keys$1, checked.halfCheckedKeys, levelEntities, maxLevel, syntheticGetCheckDisabled);
	return result;
}

//#endregion
//#region node_modules/@rc-component/cascader/es/hooks/useSelect.js
function useSelect(multiple, triggerChange, checkedValues, halfCheckedValues, missingCheckedValues, getPathKeyEntities, getValueByKeyPath, showCheckedStrategy) {
	return (valuePath) => {
		if (!multiple) triggerChange(valuePath);
		else {
			const pathKey$1 = toPathKey(valuePath);
			const checkedPathKeys = toPathKeys(checkedValues);
			const halfCheckedPathKeys = toPathKeys(halfCheckedValues);
			const existInChecked = checkedPathKeys.includes(pathKey$1);
			const existInMissing = missingCheckedValues.some((valueCells) => toPathKey(valueCells) === pathKey$1);
			let nextCheckedValues = checkedValues;
			let nextMissingValues = missingCheckedValues;
			if (existInMissing && !existInChecked) nextMissingValues = missingCheckedValues.filter((valueCells) => toPathKey(valueCells) !== pathKey$1);
			else {
				const nextRawCheckedKeys = existInChecked ? checkedPathKeys.filter((key) => key !== pathKey$1) : [...checkedPathKeys, pathKey$1];
				const pathKeyEntities = getPathKeyEntities();
				let checkedKeys;
				if (existInChecked) ({checkedKeys} = conductCheck(nextRawCheckedKeys, {
					checked: false,
					halfCheckedKeys: halfCheckedPathKeys
				}, pathKeyEntities));
				else ({checkedKeys} = conductCheck(nextRawCheckedKeys, true, pathKeyEntities));
				nextCheckedValues = getValueByKeyPath(formatStrategyValues$1(checkedKeys, getPathKeyEntities, showCheckedStrategy));
			}
			triggerChange([...nextMissingValues, ...nextCheckedValues]);
		}
	};
}

//#endregion
//#region node_modules/@rc-component/cascader/es/hooks/useValues.js
function useValues(multiple, rawValues, getPathKeyEntities, getValueByKeyPath, getMissingValues) {
	return import_react.useMemo(() => {
		const [existValues, missingValues] = getMissingValues(rawValues);
		if (!multiple || !rawValues.length) return [
			existValues,
			[],
			missingValues
		];
		const { checkedKeys, halfCheckedKeys } = conductCheck(toPathKeys(existValues), true, getPathKeyEntities());
		return [
			getValueByKeyPath(checkedKeys),
			getValueByKeyPath(halfCheckedKeys),
			missingValues
		];
	}, [
		multiple,
		rawValues,
		getPathKeyEntities,
		getValueByKeyPath,
		getMissingValues
	]);
}

//#endregion
//#region node_modules/@rc-component/cascader/es/OptionList/CacheContent.js
var CacheContent = /* @__PURE__ */ import_react.memo(({ children }) => children, (_, next$1) => !next$1.open);
CacheContent.displayName = "CacheContent";
var CacheContent_default = CacheContent;

//#endregion
//#region node_modules/@rc-component/cascader/es/OptionList/Checkbox.js
function Checkbox$2({ prefixCls, checked, halfChecked, disabled, onClick, disableCheckbox }) {
	const { checkable } = import_react.useContext(context_default$3);
	const customCheckbox = typeof checkable !== "boolean" ? checkable : null;
	return /* @__PURE__ */ import_react.createElement("span", {
		className: clsx(`${prefixCls}`, {
			[`${prefixCls}-checked`]: checked,
			[`${prefixCls}-indeterminate`]: !checked && halfChecked,
			[`${prefixCls}-disabled`]: disabled || disableCheckbox
		}),
		onClick
	}, customCheckbox);
}

//#endregion
//#region node_modules/@rc-component/cascader/es/OptionList/Column.js
function _extends$46() {
	_extends$46 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$46.apply(this, arguments);
}
const FIX_LABEL = "__cascader_fix_label__";
function Column$2({ prefixCls, multiple, options, activeValue, prevValuePath, onToggleOpen, onSelect, onActive, checkedSet, halfCheckedSet, loadingKeys, isSelectable, disabled: propsDisabled }) {
	const menuPrefixCls = `${prefixCls}-menu`;
	const menuItemPrefixCls = `${prefixCls}-menu-item`;
	const menuRef = import_react.useRef(null);
	const { fieldNames, changeOnSelect, expandTrigger, expandIcon, loadingIcon, popupMenuColumnStyle, optionRender, classNames, styles } = import_react.useContext(context_default$3);
	const hoverOpen = expandTrigger === "hover";
	const isOptionDisabled = (disabled) => propsDisabled || disabled;
	const optionInfoList = import_react.useMemo(() => options.map((option) => {
		const { disabled, disableCheckbox } = option;
		const searchOptions = option[SEARCH_MARK];
		const label = option[FIX_LABEL] ?? option[fieldNames.label];
		const value = option[fieldNames.value];
		const isMergedLeaf = isLeaf(option, fieldNames);
		const fullPath = searchOptions ? searchOptions.map((opt) => opt[fieldNames.value]) : [...prevValuePath, value];
		const fullPathKey = toPathKey(fullPath);
		return {
			disabled,
			label,
			value,
			isLeaf: isMergedLeaf,
			isLoading: loadingKeys.includes(fullPathKey),
			checked: checkedSet.has(fullPathKey),
			halfChecked: halfCheckedSet.has(fullPathKey),
			option,
			disableCheckbox,
			fullPath,
			fullPathKey
		};
	}), [
		options,
		checkedSet,
		fieldNames,
		halfCheckedSet,
		loadingKeys,
		prevValuePath
	]);
	import_react.useEffect(() => {
		if (menuRef.current) {
			const selector = `.${menuItemPrefixCls}-active`;
			const activeElement = menuRef.current.querySelector(selector);
			if (activeElement) scrollIntoParentView(activeElement);
		}
	}, [activeValue, menuItemPrefixCls]);
	return /* @__PURE__ */ import_react.createElement("ul", {
		className: clsx(menuPrefixCls, classNames?.popup?.list),
		style: styles?.popup?.list,
		ref: menuRef,
		role: "menu"
	}, optionInfoList.map(({ disabled, label, value, isLeaf: isMergedLeaf, isLoading, checked, halfChecked, option, fullPath, fullPathKey, disableCheckbox }) => {
		const ariaProps = pickAttrs(option, {
			aria: true,
			data: true
		});
		const triggerOpenPath = () => {
			if (isOptionDisabled(disabled)) return;
			const nextValueCells = [...fullPath];
			if (hoverOpen && isMergedLeaf) nextValueCells.pop();
			onActive(nextValueCells);
		};
		const triggerSelect = () => {
			if (isSelectable(option) && !isOptionDisabled(disabled)) onSelect(fullPath, isMergedLeaf);
		};
		let title;
		if (typeof option.title === "string") title = option.title;
		else if (typeof label === "string") title = label;
		return /* @__PURE__ */ import_react.createElement("li", _extends$46({ key: fullPathKey }, ariaProps, {
			className: clsx(menuItemPrefixCls, classNames?.popup?.listItem, {
				[`${menuItemPrefixCls}-expand`]: !isMergedLeaf,
				[`${menuItemPrefixCls}-active`]: activeValue === value || activeValue === fullPathKey,
				[`${menuItemPrefixCls}-disabled`]: isOptionDisabled(disabled),
				[`${menuItemPrefixCls}-loading`]: isLoading
			}),
			style: {
				...popupMenuColumnStyle,
				...styles?.popup?.listItem
			},
			role: "menuitemcheckbox",
			title,
			"aria-checked": checked,
			"data-path-key": fullPathKey,
			onClick: () => {
				triggerOpenPath();
				if (disableCheckbox) return;
				if (!multiple || isMergedLeaf) triggerSelect();
			},
			onDoubleClick: () => {
				if (changeOnSelect) onToggleOpen(false);
			},
			onMouseEnter: () => {
				if (hoverOpen) triggerOpenPath();
			},
			onMouseDown: (e$2) => {
				e$2.preventDefault();
			}
		}), multiple && /* @__PURE__ */ import_react.createElement(Checkbox$2, {
			prefixCls: `${prefixCls}-checkbox`,
			checked,
			halfChecked,
			disabled: isOptionDisabled(disabled) || disableCheckbox,
			disableCheckbox,
			onClick: (e$2) => {
				if (disableCheckbox) return;
				e$2.stopPropagation();
				triggerSelect();
			}
		}), /* @__PURE__ */ import_react.createElement("div", { className: `${menuItemPrefixCls}-content` }, optionRender ? optionRender(option) : label), !isLoading && expandIcon && !isMergedLeaf && /* @__PURE__ */ import_react.createElement("div", { className: `${menuItemPrefixCls}-expand-icon` }, expandIcon), isLoading && loadingIcon && /* @__PURE__ */ import_react.createElement("div", { className: `${menuItemPrefixCls}-loading-icon` }, loadingIcon));
	}));
}

//#endregion
//#region node_modules/@rc-component/cascader/es/OptionList/useActive.js
/**
* Control the active open options path.
*/
var useActive = (multiple, open$2) => {
	const { values } = import_react.useContext(context_default$3);
	const firstValueCells = values[0];
	const [activeValueCells, setActiveValueCells] = import_react.useState([]);
	import_react.useEffect(() => {
		if (!multiple) setActiveValueCells(firstValueCells || []);
	}, [open$2, firstValueCells]);
	return [activeValueCells, setActiveValueCells];
};
var useActive_default = useActive;

//#endregion
//#region node_modules/@rc-component/cascader/es/OptionList/useKeyboard.js
var useKeyboard_default = ((ref, options, fieldNames, activeValueCells, setActiveValueCells, onKeyBoardSelect, contextProps) => {
	const { direction, searchValue, toggleOpen, open: open$2 } = contextProps;
	const rtl = direction === "rtl";
	const [validActiveValueCells, lastActiveIndex, lastActiveOptions, fullPathKeys] = import_react.useMemo(() => {
		let activeIndex = -1;
		let currentOptions = options;
		const mergedActiveIndexes = [];
		const mergedActiveValueCells = [];
		const len = activeValueCells.length;
		const pathKeys = getFullPathKeys(options, fieldNames);
		for (let i = 0; i < len && currentOptions; i += 1) {
			const nextActiveIndex = currentOptions.findIndex((option, index$1) => (pathKeys[index$1] ? toPathKey(pathKeys[index$1]) : option[fieldNames.value]) === activeValueCells[i]);
			if (nextActiveIndex === -1) break;
			activeIndex = nextActiveIndex;
			mergedActiveIndexes.push(activeIndex);
			mergedActiveValueCells.push(activeValueCells[i]);
			currentOptions = currentOptions[activeIndex][fieldNames.children];
		}
		let activeOptions = options;
		for (let i = 0; i < mergedActiveIndexes.length - 1; i += 1) activeOptions = activeOptions[mergedActiveIndexes[i]][fieldNames.children];
		return [
			mergedActiveValueCells,
			activeIndex,
			activeOptions,
			pathKeys
		];
	}, [
		activeValueCells,
		fieldNames,
		options
	]);
	const internalSetActiveValueCells = (next$1) => {
		setActiveValueCells(next$1);
	};
	const offsetActiveOption = (offset$2) => {
		const len = lastActiveOptions.length;
		let currentIndex = lastActiveIndex;
		if (currentIndex === -1 && offset$2 < 0) currentIndex = len;
		for (let i = 0; i < len; i += 1) {
			currentIndex = (currentIndex + offset$2 + len) % len;
			const option = lastActiveOptions[currentIndex];
			if (option && !option.disabled) {
				internalSetActiveValueCells(validActiveValueCells.slice(0, -1).concat(fullPathKeys[currentIndex] ? toPathKey(fullPathKeys[currentIndex]) : option[fieldNames.value]));
				return;
			}
		}
	};
	const prevColumn = () => {
		if (validActiveValueCells.length > 1) internalSetActiveValueCells(validActiveValueCells.slice(0, -1));
		else toggleOpen(false);
	};
	const nextColumn = () => {
		const nextOption = (lastActiveOptions[lastActiveIndex]?.[fieldNames.children] || []).find((option) => !option.disabled);
		if (nextOption) internalSetActiveValueCells([...validActiveValueCells, nextOption[fieldNames.value]]);
	};
	import_react.useImperativeHandle(ref, () => ({
		onKeyDown: (event) => {
			const { which } = event;
			switch (which) {
				case KeyCode_default.UP:
				case KeyCode_default.DOWN: {
					let offset$2 = 0;
					if (which === KeyCode_default.UP) offset$2 = -1;
					else if (which === KeyCode_default.DOWN) offset$2 = 1;
					if (offset$2 !== 0) offsetActiveOption(offset$2);
					break;
				}
				case KeyCode_default.LEFT:
					if (searchValue) break;
					if (rtl) nextColumn();
					else prevColumn();
					break;
				case KeyCode_default.RIGHT:
					if (searchValue) break;
					if (rtl) prevColumn();
					else nextColumn();
					break;
				case KeyCode_default.BACKSPACE:
					if (!searchValue) prevColumn();
					break;
				case KeyCode_default.ENTER:
					if (validActiveValueCells.length) {
						const originOptions = lastActiveOptions[lastActiveIndex]?.[SEARCH_MARK] || [];
						if (originOptions.length) onKeyBoardSelect(originOptions.map((opt) => opt[fieldNames.value]), originOptions[originOptions.length - 1]);
						else onKeyBoardSelect(validActiveValueCells, lastActiveOptions[lastActiveIndex]);
					}
					break;
				case KeyCode_default.ESC:
					toggleOpen(false);
					if (open$2) event.stopPropagation();
			}
		},
		onKeyUp: () => {}
	}));
});

//#endregion
//#region node_modules/@rc-component/cascader/es/OptionList/List.js
function _extends$45() {
	_extends$45 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$45.apply(this, arguments);
}
var RawOptionList = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls, multiple, searchValue, toggleOpen, notFoundContent, direction, open: open$2, disabled } = props;
	const containerRef = import_react.useRef(null);
	const rtl = direction === "rtl";
	const { options, values, halfValues, fieldNames, changeOnSelect, onSelect, searchOptions, popupPrefixCls, loadData, expandTrigger } = import_react.useContext(context_default$3);
	const mergedPrefixCls = popupPrefixCls || prefixCls;
	const [loadingKeys, setLoadingKeys] = import_react.useState([]);
	const internalLoadData = (valueCells) => {
		if (!loadData || searchValue) return;
		const rawOptions = toPathOptions(valueCells, options, fieldNames).map(({ option }) => option);
		const lastOption = rawOptions[rawOptions.length - 1];
		if (lastOption && !isLeaf(lastOption, fieldNames)) {
			const pathKey$1 = toPathKey(valueCells);
			setLoadingKeys((keys$1) => [...keys$1, pathKey$1]);
			loadData(rawOptions);
		}
	};
	import_react.useEffect(() => {
		if (loadingKeys.length) loadingKeys.forEach((loadingKey) => {
			const optionList = toPathOptions(toPathValueStr(loadingKey), options, fieldNames, true).map(({ option }) => option);
			const lastOption = optionList[optionList.length - 1];
			if (!lastOption || lastOption[fieldNames.children] || isLeaf(lastOption, fieldNames)) setLoadingKeys((keys$1) => keys$1.filter((key) => key !== loadingKey));
		});
	}, [
		options,
		loadingKeys,
		fieldNames
	]);
	const checkedSet = import_react.useMemo(() => new Set(toPathKeys(values)), [values]);
	const halfCheckedSet = import_react.useMemo(() => new Set(toPathKeys(halfValues)), [halfValues]);
	const [activeValueCells, setActiveValueCells] = useActive_default(multiple, open$2);
	const onPathOpen = (nextValueCells) => {
		setActiveValueCells(nextValueCells);
		internalLoadData(nextValueCells);
	};
	const isSelectable = (option) => {
		if (disabled) return false;
		const { disabled: optionDisabled } = option;
		const isMergedLeaf = isLeaf(option, fieldNames);
		return !optionDisabled && (isMergedLeaf || changeOnSelect || multiple);
	};
	const onPathSelect = (valuePath, leaf, fromKeyboard = false) => {
		onSelect(valuePath);
		if (!multiple && (leaf || changeOnSelect && (expandTrigger === "hover" || fromKeyboard))) toggleOpen(false);
	};
	const mergedOptions = import_react.useMemo(() => {
		if (searchValue) return searchOptions;
		return options;
	}, [
		searchValue,
		searchOptions,
		options
	]);
	const optionColumns = import_react.useMemo(() => {
		const optionList = [{ options: mergedOptions }];
		let currentList = mergedOptions;
		const fullPathKeys = getFullPathKeys(currentList, fieldNames);
		for (let i = 0; i < activeValueCells.length; i += 1) {
			const activeValueCell = activeValueCells[i];
			const subOptions = currentList.find((option, index$1) => (fullPathKeys[index$1] ? toPathKey(fullPathKeys[index$1]) : option[fieldNames.value]) === activeValueCell)?.[fieldNames.children];
			if (!subOptions?.length) break;
			currentList = subOptions;
			optionList.push({ options: subOptions });
		}
		return optionList;
	}, [
		mergedOptions,
		activeValueCells,
		fieldNames
	]);
	const onKeyboardSelect = (selectValueCells, option) => {
		if (isSelectable(option)) onPathSelect(selectValueCells, isLeaf(option, fieldNames), true);
	};
	useKeyboard_default(ref, mergedOptions, fieldNames, activeValueCells, onPathOpen, onKeyboardSelect, {
		direction,
		searchValue,
		toggleOpen,
		open: open$2
	});
	import_react.useEffect(() => {
		if (searchValue) return;
		for (let i = 0; i < activeValueCells.length; i += 1) {
			const cellKeyPath = toPathKey(activeValueCells.slice(0, i + 1));
			const ele = containerRef.current?.querySelector(`li[data-path-key="${cellKeyPath.replace(/\\{0,2}"/g, "\\\"")}"]`);
			if (ele) scrollIntoParentView(ele);
		}
	}, [activeValueCells, searchValue]);
	const isEmpty$1 = !optionColumns[0]?.options?.length;
	const emptyList = [{
		[fieldNames.value]: "__EMPTY__",
		[FIX_LABEL]: notFoundContent,
		disabled: true
	}];
	const columnProps = {
		...props,
		multiple: !isEmpty$1 && multiple,
		onSelect: onPathSelect,
		onActive: onPathOpen,
		onToggleOpen: toggleOpen,
		checkedSet,
		halfCheckedSet,
		loadingKeys,
		isSelectable
	};
	const columnNodes = (isEmpty$1 ? [{ options: emptyList }] : optionColumns).map((col, index$1) => {
		const prevValuePath = activeValueCells.slice(0, index$1);
		const activeValue = activeValueCells[index$1];
		return /* @__PURE__ */ import_react.createElement(Column$2, _extends$45({ key: index$1 }, columnProps, {
			prefixCls: mergedPrefixCls,
			options: col.options,
			prevValuePath,
			activeValue
		}));
	});
	return /* @__PURE__ */ import_react.createElement(CacheContent_default, { open: open$2 }, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${mergedPrefixCls}-menus`, {
			[`${mergedPrefixCls}-menu-empty`]: isEmpty$1,
			[`${mergedPrefixCls}-rtl`]: rtl
		}),
		ref: containerRef
	}, columnNodes));
});
RawOptionList.displayName = "RawOptionList";
var List_default$1 = RawOptionList;

//#endregion
//#region node_modules/@rc-component/cascader/es/OptionList/index.js
function _extends$44() {
	_extends$44 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$44.apply(this, arguments);
}
var RefOptionList$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const baseProps = useBaseProps();
	return /* @__PURE__ */ import_react.createElement(List_default$1, _extends$44({}, props, baseProps, { ref }));
});
var OptionList_default$1 = RefOptionList$1;

//#endregion
//#region node_modules/@rc-component/cascader/es/Panel.js
function noop$2() {}
function Panel$2(props) {
	const { prefixCls = "rc-cascader", style: style$1, className, options, checkable, defaultValue, value, fieldNames, changeOnSelect, onChange, showCheckedStrategy, loadData, expandTrigger, expandIcon = ">", loadingIcon, direction, notFoundContent = "Not Found", disabled, optionRender } = props;
	const multiple = !!checkable;
	const [interanlRawValues, setRawValues] = useControlledState(defaultValue, value);
	const rawValues = toRawValues(interanlRawValues);
	const mergedFieldNames = import_react.useMemo(() => fillFieldNames$2(fieldNames), [JSON.stringify(fieldNames)]);
	const [mergedOptions, getPathKeyEntities, getValueByKeyPath] = useOptions(mergedFieldNames, options);
	const [checkedValues, halfCheckedValues, missingCheckedValues] = useValues(multiple, rawValues, getPathKeyEntities, getValueByKeyPath, useMissingValues(mergedOptions, mergedFieldNames));
	const handleSelection = useSelect(multiple, useEvent_default((nextValues) => {
		setRawValues(nextValues);
		if (onChange) {
			const nextRawValues = toRawValues(nextValues);
			const valueOptions = nextRawValues.map((valueCells) => toPathOptions(valueCells, mergedOptions, mergedFieldNames).map((valueOpt) => valueOpt.option));
			onChange(multiple ? nextRawValues : nextRawValues[0], multiple ? valueOptions : valueOptions[0]);
		}
	}), checkedValues, halfCheckedValues, missingCheckedValues, getPathKeyEntities, getValueByKeyPath, showCheckedStrategy);
	const onInternalSelect = useEvent_default((valuePath) => {
		handleSelection(valuePath);
	});
	const cascaderContext = import_react.useMemo(() => ({
		options: mergedOptions,
		fieldNames: mergedFieldNames,
		values: checkedValues,
		halfValues: halfCheckedValues,
		changeOnSelect,
		onSelect: onInternalSelect,
		checkable,
		searchOptions: [],
		popupPrefixCls: void 0,
		loadData,
		expandTrigger,
		expandIcon,
		loadingIcon,
		popupMenuColumnStyle: void 0,
		optionRender
	}), [
		mergedOptions,
		mergedFieldNames,
		checkedValues,
		halfCheckedValues,
		changeOnSelect,
		onInternalSelect,
		checkable,
		loadData,
		expandTrigger,
		expandIcon,
		loadingIcon,
		optionRender
	]);
	const panelPrefixCls = `${prefixCls}-panel`;
	const isEmpty$1 = !mergedOptions.length;
	return /* @__PURE__ */ import_react.createElement(context_default$3.Provider, { value: cascaderContext }, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(panelPrefixCls, {
			[`${panelPrefixCls}-rtl`]: direction === "rtl",
			[`${panelPrefixCls}-empty`]: isEmpty$1
		}, className),
		style: style$1
	}, isEmpty$1 ? notFoundContent : /* @__PURE__ */ import_react.createElement(List_default$1, {
		prefixCls,
		searchValue: "",
		multiple,
		toggleOpen: noop$2,
		open: true,
		direction,
		disabled
	})));
}

//#endregion
//#region node_modules/@rc-component/cascader/es/utils/warningPropsUtil.js
function warningNullOptions(options, fieldNames) {
	if (options) {
		const recursiveOptions = (optionsList) => {
			for (let i = 0; i < optionsList.length; i++) {
				const option = optionsList[i];
				if (option[fieldNames?.value] === null) {
					warning_default$1(false, "`value` in Cascader options should not be `null`.");
					return true;
				}
				if (Array.isArray(option[fieldNames?.children]) && recursiveOptions(option[fieldNames?.children])) return true;
			}
		};
		recursiveOptions(options);
	}
}

//#endregion
//#region node_modules/@rc-component/cascader/es/Cascader.js
function _extends$43() {
	_extends$43 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$43.apply(this, arguments);
}
var Cascader$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { id, prefixCls = "rc-cascader", fieldNames, defaultValue, value, changeOnSelect, onChange, displayRender, checkable, showSearch, expandTrigger, options, popupPrefixCls, loadData, open: open$2, popupClassName, popupMenuColumnStyle, popupStyle: customPopupStyle, classNames, styles, placement, onPopupVisibleChange, expandIcon = ">", loadingIcon, children, popupMatchSelectWidth = false, showCheckedStrategy = SHOW_PARENT$2, optionRender, ...restProps } = props;
	const mergedId = useId_default(id);
	const multiple = !!checkable;
	const [interanlRawValues, setRawValues] = useControlledState(defaultValue, value);
	const rawValues = toRawValues(interanlRawValues);
	const mergedFieldNames = import_react.useMemo(() => fillFieldNames$2(fieldNames), [JSON.stringify(fieldNames)]);
	const [mergedOptions, getPathKeyEntities, getValueByKeyPath] = useOptions(mergedFieldNames, options);
	const [mergedShowSearch, searchConfig] = useSearchConfig$1(showSearch, props);
	const { autoClearSearchValue = true, searchValue, onSearch } = searchConfig;
	const [internalSearchValue, setSearchValue] = useControlledState("", searchValue);
	const mergedSearchValue = internalSearchValue || "";
	const onInternalSearch = (searchText, info) => {
		setSearchValue(searchText);
		if (info.source !== "blur" && onSearch) onSearch(searchText);
	};
	const searchOptions = useSearchOptions_default(mergedSearchValue, mergedOptions, mergedFieldNames, popupPrefixCls || prefixCls, searchConfig, changeOnSelect || multiple);
	const [checkedValues, halfCheckedValues, missingCheckedValues] = useValues(multiple, rawValues, getPathKeyEntities, getValueByKeyPath, useMissingValues(mergedOptions, mergedFieldNames));
	const displayValues = useDisplayValues_default(import_react.useMemo(() => {
		const deduplicateKeys = formatStrategyValues$1(toPathKeys(checkedValues), getPathKeyEntities, showCheckedStrategy);
		return [...missingCheckedValues, ...getValueByKeyPath(deduplicateKeys)];
	}, [
		checkedValues,
		getPathKeyEntities,
		getValueByKeyPath,
		missingCheckedValues,
		showCheckedStrategy
	]), mergedOptions, mergedFieldNames, multiple, displayRender);
	const triggerChange = useEvent_default((nextValues) => {
		setRawValues(nextValues);
		if (onChange) {
			const nextRawValues = toRawValues(nextValues);
			const valueOptions = nextRawValues.map((valueCells) => toPathOptions(valueCells, mergedOptions, mergedFieldNames).map((valueOpt) => valueOpt.option));
			onChange(multiple ? nextRawValues : nextRawValues[0], multiple ? valueOptions : valueOptions[0]);
		}
	});
	const handleSelection = useSelect(multiple, triggerChange, checkedValues, halfCheckedValues, missingCheckedValues, getPathKeyEntities, getValueByKeyPath, showCheckedStrategy);
	const onInternalSelect = useEvent_default((valuePath) => {
		if (!multiple || autoClearSearchValue) setSearchValue("");
		handleSelection(valuePath);
	});
	const onDisplayValuesChange = (_, info) => {
		if (info.type === "clear") {
			triggerChange([]);
			return;
		}
		const { valueCells } = info.values[0];
		onInternalSelect(valueCells);
	};
	const onInternalPopupVisibleChange = (nextVisible) => {
		onPopupVisibleChange?.(nextVisible);
	};
	warningNullOptions(mergedOptions, mergedFieldNames);
	const cascaderContext = import_react.useMemo(() => ({
		classNames,
		styles,
		options: mergedOptions,
		fieldNames: mergedFieldNames,
		values: checkedValues,
		halfValues: halfCheckedValues,
		changeOnSelect,
		onSelect: onInternalSelect,
		checkable,
		searchOptions,
		popupPrefixCls,
		loadData,
		expandTrigger,
		expandIcon,
		loadingIcon,
		popupMenuColumnStyle,
		optionRender
	}), [
		classNames,
		styles,
		mergedOptions,
		mergedFieldNames,
		checkedValues,
		halfCheckedValues,
		changeOnSelect,
		onInternalSelect,
		checkable,
		searchOptions,
		popupPrefixCls,
		loadData,
		expandTrigger,
		expandIcon,
		loadingIcon,
		popupMenuColumnStyle,
		optionRender
	]);
	const emptyOptions = !(mergedSearchValue ? searchOptions : mergedOptions).length;
	const popupStyle = mergedSearchValue && searchConfig.matchInputWidth || emptyOptions ? {} : { minWidth: "auto" };
	return /* @__PURE__ */ import_react.createElement(context_default$3.Provider, { value: cascaderContext }, /* @__PURE__ */ import_react.createElement(BaseSelect_default, _extends$43({}, restProps, {
		ref,
		id: mergedId,
		prefixCls,
		autoClearSearchValue,
		popupMatchSelectWidth,
		classNames,
		styles,
		popupStyle: {
			...popupStyle,
			...customPopupStyle
		},
		displayValues,
		onDisplayValuesChange,
		mode: multiple ? "multiple" : void 0,
		searchValue: mergedSearchValue,
		onSearch: onInternalSearch,
		showSearch: mergedShowSearch,
		OptionList: OptionList_default$1,
		emptyOptions,
		open: open$2,
		popupClassName,
		placement,
		onPopupVisibleChange: onInternalPopupVisibleChange,
		getRawInputElement: () => children
	})));
});
Cascader$1.displayName = "Cascader";
Cascader$1.SHOW_PARENT = SHOW_PARENT$2;
Cascader$1.SHOW_CHILD = SHOW_CHILD$2;
Cascader$1.Panel = Panel$2;
var Cascader_default = Cascader$1;

//#endregion
//#region node_modules/@rc-component/cascader/es/index.js
var es_default$26 = Cascader_default;

//#endregion
//#region node_modules/antd/es/cascader/hooks/useBase.js
function useBase(customizePrefixCls, direction) {
	const { getPrefixCls, direction: rootDirection, renderEmpty } = import_react.useContext(ConfigContext);
	const mergedDirection = direction || rootDirection;
	return [
		getPrefixCls("select", customizePrefixCls),
		getPrefixCls("cascader", customizePrefixCls),
		mergedDirection,
		renderEmpty
	];
}
var useBase_default = useBase;

//#endregion
//#region node_modules/antd/es/cascader/hooks/useCheckable.js
function useCheckable(cascaderPrefixCls, multiple) {
	return import_react.useMemo(() => multiple ? /* @__PURE__ */ import_react.createElement("span", { className: `${cascaderPrefixCls}-checkbox-inner` }) : false, [cascaderPrefixCls, multiple]);
}

//#endregion
//#region node_modules/antd/es/cascader/hooks/useColumnIcons.js
var useColumnIcons = (prefixCls, rtl, expandIcon) => {
	let mergedExpandIcon = expandIcon;
	if (!expandIcon) mergedExpandIcon = rtl ? /* @__PURE__ */ import_react.createElement(LeftOutlined_default, null) : /* @__PURE__ */ import_react.createElement(RightOutlined_default, null);
	const loadingIcon = import_react.useMemo(() => /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-menu-item-loading-icon` }, /* @__PURE__ */ import_react.createElement(LoadingOutlined_default, { spin: true })), [prefixCls]);
	return import_react.useMemo(() => [mergedExpandIcon, loadingIcon], [mergedExpandIcon, loadingIcon]);
};
var useColumnIcons_default = useColumnIcons;

//#endregion
//#region node_modules/antd/es/checkbox/style/index.js
const genCheckboxStyle = (token$1) => {
	const { checkboxCls } = token$1;
	const wrapperCls = `${checkboxCls}-wrapper`;
	return [
		{
			[`${checkboxCls}-group`]: {
				...resetComponent(token$1),
				display: "inline-flex",
				flexWrap: "wrap",
				columnGap: token$1.marginXS,
				[`> ${token$1.antCls}-row`]: { flex: 1 }
			},
			[wrapperCls]: {
				...resetComponent(token$1),
				display: "inline-flex",
				alignItems: "baseline",
				cursor: "pointer",
				"&:after": {
					display: "inline-block",
					width: 0,
					overflow: "hidden",
					content: "'\\a0'"
				},
				[`& + ${wrapperCls}`]: { marginInlineStart: 0 },
				[`&${wrapperCls}-in-form-item`]: { "input[type=\"checkbox\"]": {
					width: 14,
					height: 14
				} }
			},
			[checkboxCls]: {
				...resetComponent(token$1),
				position: "relative",
				whiteSpace: "nowrap",
				lineHeight: 1,
				cursor: "pointer",
				borderRadius: token$1.borderRadiusSM,
				alignSelf: "center",
				[`${checkboxCls}-input`]: {
					position: "absolute",
					inset: 0,
					zIndex: 1,
					cursor: "pointer",
					opacity: 0,
					margin: 0,
					[`&:focus-visible + ${checkboxCls}-inner`]: genFocusOutline(token$1)
				},
				[`${checkboxCls}-inner`]: {
					boxSizing: "border-box",
					display: "block",
					width: token$1.checkboxSize,
					height: token$1.checkboxSize,
					direction: "ltr",
					backgroundColor: token$1.colorBgContainer,
					border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`,
					borderRadius: token$1.borderRadiusSM,
					borderCollapse: "separate",
					transition: `all ${token$1.motionDurationSlow}`,
					"&:after": {
						boxSizing: "border-box",
						position: "absolute",
						top: "50%",
						insetInlineStart: "25%",
						display: "table",
						width: token$1.calc(token$1.checkboxSize).div(14).mul(5).equal(),
						height: token$1.calc(token$1.checkboxSize).div(14).mul(8).equal(),
						border: `${unit(token$1.lineWidthBold)} solid ${token$1.colorWhite}`,
						borderTop: 0,
						borderInlineStart: 0,
						transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
						opacity: 0,
						content: "\"\"",
						transition: `all ${token$1.motionDurationFast} ${token$1.motionEaseInBack}, opacity ${token$1.motionDurationFast}`
					}
				},
				"& + span": {
					paddingInlineStart: token$1.paddingXS,
					paddingInlineEnd: token$1.paddingXS
				}
			}
		},
		{
			[`
        ${wrapperCls}:not(${wrapperCls}-disabled),
        ${checkboxCls}:not(${checkboxCls}-disabled)
      `]: { [`&:hover ${checkboxCls}-inner`]: { borderColor: token$1.colorPrimary } },
			[`${wrapperCls}:not(${wrapperCls}-disabled)`]: {
				[`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled) ${checkboxCls}-inner`]: {
					backgroundColor: token$1.colorPrimaryHover,
					borderColor: "transparent"
				},
				[`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled):after`]: { borderColor: token$1.colorPrimaryHover }
			}
		},
		{
			[`${checkboxCls}-checked`]: { [`${checkboxCls}-inner`]: {
				backgroundColor: token$1.colorPrimary,
				borderColor: token$1.colorPrimary,
				"&:after": {
					opacity: 1,
					transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
					transition: `all ${token$1.motionDurationMid} ${token$1.motionEaseOutBack} ${token$1.motionDurationFast}`
				}
			} },
			[`
        ${wrapperCls}-checked:not(${wrapperCls}-disabled),
        ${checkboxCls}-checked:not(${checkboxCls}-disabled)
      `]: { [`&:hover ${checkboxCls}-inner`]: {
				backgroundColor: token$1.colorPrimaryHover,
				borderColor: "transparent"
			} }
		},
		{ [checkboxCls]: { "&-indeterminate": { "&": {
			[`${checkboxCls}-inner`]: {
				backgroundColor: `${token$1.colorBgContainer}`,
				borderColor: `${token$1.colorBorder}`,
				"&:after": {
					top: "50%",
					insetInlineStart: "50%",
					width: token$1.calc(token$1.fontSizeLG).div(2).equal(),
					height: token$1.calc(token$1.fontSizeLG).div(2).equal(),
					backgroundColor: token$1.colorPrimary,
					border: 0,
					transform: "translate(-50%, -50%) scale(1)",
					opacity: 1,
					content: "\"\""
				}
			},
			[`&:hover ${checkboxCls}-inner`]: {
				backgroundColor: `${token$1.colorBgContainer}`,
				borderColor: `${token$1.colorPrimary}`
			}
		} } } },
		{
			[`${wrapperCls}-disabled`]: { cursor: "not-allowed" },
			[`${checkboxCls}-disabled`]: {
				[`&, ${checkboxCls}-input`]: {
					cursor: "not-allowed",
					pointerEvents: "none"
				},
				[`${checkboxCls}-inner`]: {
					background: token$1.colorBgContainerDisabled,
					borderColor: token$1.colorBorder,
					"&:after": { borderColor: token$1.colorTextDisabled }
				},
				"&:after": { display: "none" },
				"& + span": { color: token$1.colorTextDisabled },
				[`&${checkboxCls}-indeterminate ${checkboxCls}-inner::after`]: { background: token$1.colorTextDisabled }
			}
		}
	];
};
function getStyle(prefixCls, token$1) {
	return genCheckboxStyle(merge(token$1, {
		checkboxCls: `.${prefixCls}`,
		checkboxSize: token$1.controlInteractiveSize
	}));
}
var style_default$39 = genStyleHooks("Checkbox", (token$1, { prefixCls }) => [getStyle(prefixCls, token$1)]);

//#endregion
//#region node_modules/antd/es/cascader/style/columns.js
var getColumnsStyle = (token$1) => {
	const { prefixCls, componentCls } = token$1;
	const cascaderMenuItemCls = `${componentCls}-menu-item`;
	const iconCls = `
  &${cascaderMenuItemCls}-expand ${cascaderMenuItemCls}-expand-icon,
  ${cascaderMenuItemCls}-loading-icon
`;
	return [getStyle(`${prefixCls}-checkbox`, token$1), { [componentCls]: {
		"&-checkbox": {
			top: 0,
			marginInlineEnd: token$1.paddingXS,
			pointerEvents: "unset"
		},
		"&-menus": {
			display: "flex",
			flexWrap: "nowrap",
			alignItems: "flex-start",
			[`&${componentCls}-menu-empty`]: { [`${componentCls}-menu`]: {
				width: "100%",
				height: "auto",
				[cascaderMenuItemCls]: { color: token$1.colorTextDisabled }
			} }
		},
		"&-menu": {
			flexGrow: 1,
			flexShrink: 0,
			minWidth: token$1.controlItemWidth,
			height: token$1.dropdownHeight,
			margin: 0,
			padding: token$1.menuPadding,
			overflow: "auto",
			verticalAlign: "top",
			listStyle: "none",
			"-ms-overflow-style": "-ms-autohiding-scrollbar",
			"&:not(:last-child)": { borderInlineEnd: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}` },
			"&-item": {
				...textEllipsis,
				display: "flex",
				flexWrap: "nowrap",
				alignItems: "center",
				padding: token$1.optionPadding,
				lineHeight: token$1.lineHeight,
				cursor: "pointer",
				transition: `all ${token$1.motionDurationMid}`,
				borderRadius: token$1.borderRadiusSM,
				"&:hover": { background: token$1.controlItemBgHover },
				"&-disabled": {
					color: token$1.colorTextDisabled,
					cursor: "not-allowed",
					"&:hover": { background: "transparent" },
					[iconCls]: { color: token$1.colorTextDisabled }
				},
				[`&-active:not(${cascaderMenuItemCls}-disabled)`]: { "&, &:hover": {
					color: token$1.optionSelectedColor,
					fontWeight: token$1.optionSelectedFontWeight,
					backgroundColor: token$1.optionSelectedBg
				} },
				"&-content": { flex: "auto" },
				[iconCls]: {
					marginInlineStart: token$1.paddingXXS,
					color: token$1.colorIcon,
					fontSize: token$1.fontSizeIcon
				},
				"&-keyword": { color: token$1.colorHighlight }
			}
		}
	} }];
};
var columns_default = getColumnsStyle;

//#endregion
//#region node_modules/antd/es/cascader/style/index.js
var genBaseStyle$10 = (token$1) => {
	const { componentCls, antCls } = token$1;
	return [
		{ [componentCls]: { width: token$1.controlWidth } },
		{ [`${componentCls}-dropdown`]: [{ [`&${antCls}-select-dropdown`]: { padding: 0 } }, columns_default(token$1)] },
		{ [`${componentCls}-dropdown-rtl`]: { direction: "rtl" } },
		genCompactItemStyle(token$1)
	];
};
const prepareComponentToken$31 = (token$1) => {
	const itemPaddingVertical = Math.round((token$1.controlHeight - token$1.fontSize * token$1.lineHeight) / 2);
	return {
		controlWidth: 184,
		controlItemWidth: 111,
		dropdownHeight: 180,
		optionSelectedBg: token$1.controlItemBgActive,
		optionSelectedFontWeight: token$1.fontWeightStrong,
		optionPadding: `${itemPaddingVertical}px ${token$1.paddingSM}px`,
		menuPadding: token$1.paddingXXS,
		optionSelectedColor: token$1.colorText
	};
};
var style_default$40 = genStyleHooks("Cascader", genBaseStyle$10, prepareComponentToken$31, {
	resetFont: false,
	unitless: { optionSelectedFontWeight: true }
});

//#endregion
//#region node_modules/antd/es/cascader/style/panel.js
var genPanelStyle$1 = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-panel`]: [columns_default(token$1), {
		display: "inline-flex",
		border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}`,
		borderRadius: token$1.borderRadiusLG,
		overflowX: "auto",
		maxWidth: "100%",
		[`${componentCls}-menus`]: { alignItems: "stretch" },
		[`${componentCls}-menu`]: { height: "auto" },
		"&-empty": { padding: token$1.paddingXXS }
	}] };
};
var panel_default$1 = genComponentStyleHook(["Cascader", "Panel"], genPanelStyle$1, prepareComponentToken$31, { resetFont: false });

//#endregion
//#region node_modules/antd/es/cascader/Panel.js
function CascaderPanel(props) {
	const { prefixCls: customizePrefixCls, className, multiple, rootClassName, notFoundContent, direction, expandIcon, disabled: customDisabled } = props;
	const disabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = customDisabled ?? disabled;
	const [prefixCls, cascaderPrefixCls, mergedDirection, renderEmpty] = useBase_default(customizePrefixCls, direction);
	const rootCls = useCSSVarCls_default(cascaderPrefixCls);
	const [hashId, cssVarCls] = style_default$40(cascaderPrefixCls, rootCls);
	panel_default$1(cascaderPrefixCls);
	const [mergedExpandIcon, loadingIcon] = useColumnIcons_default(prefixCls, mergedDirection === "rtl", expandIcon);
	const mergedNotFoundContent = notFoundContent || renderEmpty?.("Cascader") || /* @__PURE__ */ import_react.createElement(defaultRenderEmpty_default, { componentName: "Cascader" });
	const checkable = useCheckable(cascaderPrefixCls, multiple);
	return /* @__PURE__ */ import_react.createElement(Panel$2, {
		...props,
		checkable,
		prefixCls: cascaderPrefixCls,
		className: clsx(className, hashId, rootClassName, cssVarCls, rootCls),
		notFoundContent: mergedNotFoundContent,
		direction: mergedDirection,
		expandIcon: mergedExpandIcon,
		loadingIcon,
		disabled: mergedDisabled
	});
}
var Panel_default$3 = CascaderPanel;

//#endregion
//#region node_modules/antd/es/cascader/index.js
var { SHOW_CHILD: SHOW_CHILD$1, SHOW_PARENT: SHOW_PARENT$1 } = es_default$26;
function highlightKeyword(str, lowerKeyword, prefixCls) {
	const cells = str.toLowerCase().split(lowerKeyword).reduce((list, cur, index$1) => index$1 === 0 ? [cur] : [].concat(_toConsumableArray(list), [lowerKeyword, cur]), []);
	const fillCells = [];
	let start = 0;
	cells.forEach((cell, index$1) => {
		const end = start + cell.length;
		let originWorld = str.slice(start, end);
		start = end;
		if (index$1 % 2 === 1) originWorld = /* @__PURE__ */ import_react.createElement("span", {
			className: `${prefixCls}-menu-item-keyword`,
			key: `separator-${index$1}`
		}, originWorld);
		fillCells.push(originWorld);
	});
	return fillCells;
}
var defaultSearchRender = (inputValue, path$1, prefixCls, fieldNames) => {
	const optionList = [];
	const lower$1 = inputValue.toLowerCase();
	path$1.forEach((node$1, index$1) => {
		if (index$1 !== 0) optionList.push(" / ");
		let label = node$1[fieldNames.label];
		const type$2 = typeof label;
		if (type$2 === "string" || type$2 === "number") label = highlightKeyword(String(label), lower$1, prefixCls);
		optionList.push(label);
	});
	return optionList;
};
var Cascader = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, size: customizeSize, disabled: customDisabled, className, rootClassName, multiple, bordered = true, transitionName, choiceTransitionName = "", popupClassName, expandIcon, placement, showSearch, allowClear = true, notFoundContent, direction, getPopupContainer, status: customStatus, showArrow, builtinPlacements, style: style$1, variant: customVariant, dropdownClassName, dropdownRender, onDropdownVisibleChange, onPopupVisibleChange, dropdownMenuColumnStyle, popupRender, dropdownStyle, popupMenuColumnStyle, onOpenChange, styles, classNames, ...rest } = props;
	const restProps = omit(rest, ["suffixIcon"]);
	const { getPrefixCls, getPopupContainer: getContextPopupContainer, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("cascader");
	const { popupOverflow } = import_react.useContext(ConfigContext);
	const { status: contextStatus, hasFeedback, isFormItemInput, feedbackIcon } = import_react.useContext(FormItemInputContext);
	const mergedStatus = getMergedStatus(contextStatus, customStatus);
	{
		const warning$3 = devUseWarning("Cascader");
		Object.entries({
			dropdownClassName: "classNames.popup.root",
			dropdownStyle: "styles.popup.root",
			dropdownRender: "popupRender",
			dropdownMenuColumnStyle: "popupMenuColumnStyle",
			onDropdownVisibleChange: "onOpenChange",
			onPopupVisibleChange: "onOpenChange",
			bordered: "variant"
		}).forEach(([oldProp, newProp]) => {
			warning$3.deprecated(!(oldProp in props), oldProp, newProp);
		});
		warning$3(!("showArrow" in props), "deprecated", "`showArrow` is deprecated which will be removed in next major version. It will be a default behavior, you can hide it by setting `suffixIcon` to null.");
	}
	const [prefixCls, cascaderPrefixCls, mergedDirection, renderEmpty] = useBase_default(customizePrefixCls, direction);
	const isRtl = mergedDirection === "rtl";
	const rootPrefixCls = getPrefixCls();
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$2(prefixCls, rootCls);
	const cascaderRootCls = useCSSVarCls_default(cascaderPrefixCls);
	style_default$40(cascaderPrefixCls, cascaderRootCls);
	const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
	const [variant, enableVariantCls] = useVariants_default("cascader", customVariant, bordered);
	const mergedNotFoundContent = notFoundContent || renderEmpty?.("Cascader") || /* @__PURE__ */ import_react.createElement(defaultRenderEmpty_default, { componentName: "Cascader" });
	const mergedPopupRender = usePopupRender_default(popupRender || dropdownRender);
	const mergedPopupMenuColumnStyle = popupMenuColumnStyle || dropdownMenuColumnStyle;
	const mergedOnOpenChange = onOpenChange || onPopupVisibleChange || onDropdownVisibleChange;
	const mergedShowSearch = import_react.useMemo(() => {
		if (!showSearch) return showSearch;
		let searchConfig = { render: defaultSearchRender };
		if (typeof showSearch === "object") searchConfig = {
			...searchConfig,
			...showSearch
		};
		return searchConfig;
	}, [showSearch]);
	const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
	const disabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = customDisabled ?? disabled;
	const [mergedExpandIcon, loadingIcon] = useColumnIcons_default(prefixCls, isRtl, expandIcon);
	const checkable = useCheckable(cascaderPrefixCls, multiple);
	const showSuffixIcon = useShowArrow(props.suffixIcon, showArrow);
	const { suffixIcon, removeIcon, clearIcon } = useIcons({
		...props,
		hasFeedback,
		feedbackIcon,
		showSuffixIcon,
		multiple,
		prefixCls,
		componentName: "Cascader"
	});
	const memoPlacement = import_react.useMemo(() => {
		if (placement !== void 0) return placement;
		return isRtl ? "bottomRight" : "bottomLeft";
	}, [placement, isRtl]);
	const mergedAllowClear = allowClear === true ? { clearIcon } : allowClear;
	const mergedProps = {
		...props,
		variant,
		size: mergedSize,
		status: mergedStatus,
		disabled: mergedDisabled
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps }, { popup: { _default: "root" } });
	const mergedPopupStyle = {
		...mergedStyles.popup?.root,
		...dropdownStyle
	};
	const [zIndex] = useZIndex("SelectLike", mergedPopupStyle?.zIndex);
	const mergedPopupClassName = clsx(popupClassName || dropdownClassName, `${cascaderPrefixCls}-dropdown`, { [`${cascaderPrefixCls}-dropdown-rtl`]: mergedDirection === "rtl" }, rootClassName, rootCls, mergedClassNames.popup?.root, cascaderRootCls, hashId, cssVarCls);
	return /* @__PURE__ */ import_react.createElement(es_default$26, {
		prefixCls,
		className: clsx(!customizePrefixCls && cascaderPrefixCls, {
			[`${prefixCls}-lg`]: mergedSize === "large",
			[`${prefixCls}-sm`]: mergedSize === "small",
			[`${prefixCls}-rtl`]: isRtl,
			[`${prefixCls}-${variant}`]: enableVariantCls,
			[`${prefixCls}-in-form-item`]: isFormItemInput
		}, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), compactItemClassnames, contextClassName, className, rootClassName, mergedClassNames.root, rootCls, cascaderRootCls, hashId, cssVarCls),
		disabled: mergedDisabled,
		style: {
			...mergedStyles.root,
			...contextStyle,
			...style$1
		},
		classNames: mergedClassNames,
		styles: mergedStyles,
		...restProps,
		builtinPlacements: mergedBuiltinPlacements_default(builtinPlacements, popupOverflow),
		direction: mergedDirection,
		placement: memoPlacement,
		notFoundContent: mergedNotFoundContent,
		allowClear: mergedAllowClear,
		showSearch: mergedShowSearch,
		expandIcon: mergedExpandIcon,
		suffixIcon,
		removeIcon,
		loadingIcon,
		checkable,
		popupClassName: mergedPopupClassName,
		popupPrefixCls: customizePrefixCls || cascaderPrefixCls,
		popupStyle: {
			...mergedPopupStyle,
			zIndex
		},
		popupRender: mergedPopupRender,
		popupMenuColumnStyle: mergedPopupMenuColumnStyle,
		onPopupVisibleChange: mergedOnOpenChange,
		choiceTransitionName: getTransitionName(rootPrefixCls, "", choiceTransitionName),
		transitionName: getTransitionName(rootPrefixCls, "slide-up", transitionName),
		getPopupContainer: getPopupContainer || getContextPopupContainer,
		ref
	});
});
Cascader.displayName = "Cascader";
/* istanbul ignore next */
var PurePanel$7 = PurePanel_default(Cascader, "popupAlign", (props) => omit(props, ["visible"]));
Cascader.SHOW_PARENT = SHOW_PARENT$1;
Cascader.SHOW_CHILD = SHOW_CHILD$1;
Cascader.Panel = Panel_default$3;
Cascader._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$7;
var cascader_default = Cascader;

//#endregion
//#region node_modules/antd/es/checkbox/GroupContext.js
var GroupContext$1 = /* @__PURE__ */ import_react.createContext(null);
var GroupContext_default = GroupContext$1;

//#endregion
//#region node_modules/antd/es/checkbox/Checkbox.js
var InternalCheckbox = (props, ref) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, children, indeterminate = false, style: style$1, onMouseEnter, onMouseLeave, skipGroup = false, disabled, classNames, styles, ...restProps } = props;
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("checkbox");
	const checkboxGroup = import_react.useContext(GroupContext_default);
	const { isFormItemInput } = import_react.useContext(FormItemInputContext);
	const contextDisabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = (checkboxGroup?.disabled || disabled) ?? contextDisabled;
	const mergedProps = {
		...props,
		indeterminate,
		disabled: mergedDisabled
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const prevValue = import_react.useRef(restProps.value);
	const checkboxRef = import_react.useRef(null);
	const mergedRef = composeRef(ref, checkboxRef);
	devUseWarning("Checkbox")("checked" in restProps || !!checkboxGroup || !("value" in restProps), "usage", "`value` is not a valid prop, do you mean `checked`?");
	import_react.useEffect(() => {
		checkboxGroup?.registerValue(restProps.value);
	}, []);
	import_react.useEffect(() => {
		if (skipGroup) return;
		if (restProps.value !== prevValue.current) {
			checkboxGroup?.cancelValue(prevValue.current);
			checkboxGroup?.registerValue(restProps.value);
			prevValue.current = restProps.value;
		}
		return () => checkboxGroup?.cancelValue(restProps.value);
	}, [restProps.value]);
	import_react.useEffect(() => {
		if (checkboxRef.current?.input) checkboxRef.current.input.indeterminate = indeterminate;
	}, [indeterminate]);
	const prefixCls = getPrefixCls("checkbox", customizePrefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$39(prefixCls, rootCls);
	const checkboxProps = { ...restProps };
	if (checkboxGroup && !skipGroup) {
		checkboxProps.onChange = (...args) => {
			if (restProps.onChange) restProps.onChange.apply(restProps, args);
			if (checkboxGroup.toggleOption) checkboxGroup.toggleOption({
				label: children,
				value: restProps.value
			});
		};
		checkboxProps.name = checkboxGroup.name;
		checkboxProps.checked = checkboxGroup.value.includes(restProps.value);
	}
	const classString = clsx(`${prefixCls}-wrapper`, {
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-wrapper-checked`]: checkboxProps.checked,
		[`${prefixCls}-wrapper-disabled`]: mergedDisabled,
		[`${prefixCls}-wrapper-in-form-item`]: isFormItemInput
	}, contextClassName, className, mergedClassNames.root, rootClassName, cssVarCls, rootCls, hashId);
	const checkboxClass = clsx(mergedClassNames.icon, { [`${prefixCls}-indeterminate`]: indeterminate }, TARGET_CLS, hashId);
	const [onLabelClick, onInputClick] = useBubbleLock(checkboxProps.onClick);
	return /* @__PURE__ */ import_react.createElement(wave_default, {
		component: "Checkbox",
		disabled: mergedDisabled
	}, /* @__PURE__ */ import_react.createElement("label", {
		className: classString,
		style: {
			...mergedStyles.root,
			...contextStyle,
			...style$1
		},
		onMouseEnter,
		onMouseLeave,
		onClick: onLabelClick
	}, /* @__PURE__ */ import_react.createElement(es_default$25, {
		...checkboxProps,
		onClick: onInputClick,
		prefixCls,
		className: checkboxClass,
		style: mergedStyles.icon,
		disabled: mergedDisabled,
		ref: mergedRef
	}), isNonNullable_default(children) && /* @__PURE__ */ import_react.createElement("span", {
		className: clsx(`${prefixCls}-label`, mergedClassNames.label),
		style: mergedStyles.label
	}, children)));
};
var Checkbox$1 = /* @__PURE__ */ import_react.forwardRef(InternalCheckbox);
Checkbox$1.displayName = "Checkbox";
var Checkbox_default = Checkbox$1;

//#endregion
//#region node_modules/antd/es/checkbox/Group.js
var CheckboxGroup = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { defaultValue, children, options = [], prefixCls: customizePrefixCls, className, rootClassName, style: style$1, onChange, ...restProps } = props;
	const { getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const [value, setValue] = import_react.useState(restProps.value || defaultValue || []);
	const [registeredValues, setRegisteredValues] = import_react.useState([]);
	import_react.useEffect(() => {
		if ("value" in restProps) setValue(restProps.value || []);
	}, [restProps.value]);
	const memoizedOptions = import_react.useMemo(() => options.map((option) => {
		if (typeof option === "string" || typeof option === "number") return {
			label: option,
			value: option
		};
		return option;
	}), [options]);
	const cancelValue = (val) => {
		setRegisteredValues((prevValues) => prevValues.filter((v) => v !== val));
	};
	const registerValue = (val) => {
		setRegisteredValues((prevValues) => [].concat(_toConsumableArray(prevValues), [val]));
	};
	const toggleOption = (option) => {
		const optionIndex = value.indexOf(option.value);
		const newValue = _toConsumableArray(value);
		if (optionIndex === -1) newValue.push(option.value);
		else newValue.splice(optionIndex, 1);
		if (!("value" in restProps)) setValue(newValue);
		onChange?.(newValue.filter((val) => registeredValues.includes(val)).sort((a, b) => {
			return memoizedOptions.findIndex((opt) => opt.value === a) - memoizedOptions.findIndex((opt) => opt.value === b);
		}));
	};
	const prefixCls = getPrefixCls("checkbox", customizePrefixCls);
	const groupPrefixCls = `${prefixCls}-group`;
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$39(prefixCls, rootCls);
	const domProps = omit(restProps, ["value", "disabled"]);
	const childrenNode = options.length ? memoizedOptions.map((option) => /* @__PURE__ */ import_react.createElement(Checkbox_default, {
		prefixCls,
		key: option.value.toString(),
		disabled: "disabled" in option ? option.disabled : restProps.disabled,
		value: option.value,
		checked: value.includes(option.value),
		onChange: option.onChange,
		className: clsx(`${groupPrefixCls}-item`, option.className),
		style: option.style,
		title: option.title,
		id: option.id,
		required: option.required
	}, option.label)) : children;
	const memoizedContext = import_react.useMemo(() => ({
		toggleOption,
		value,
		disabled: restProps.disabled,
		name: restProps.name,
		registerValue,
		cancelValue
	}), [
		toggleOption,
		value,
		restProps.disabled,
		restProps.name,
		registerValue,
		cancelValue
	]);
	const classString = clsx(groupPrefixCls, { [`${groupPrefixCls}-rtl`]: direction === "rtl" }, className, rootClassName, cssVarCls, rootCls, hashId);
	return /* @__PURE__ */ import_react.createElement("div", {
		className: classString,
		style: style$1,
		...domProps,
		ref
	}, /* @__PURE__ */ import_react.createElement(GroupContext_default.Provider, { value: memoizedContext }, childrenNode));
});
var Group_default$1 = CheckboxGroup;

//#endregion
//#region node_modules/antd/es/checkbox/index.js
var Checkbox = Checkbox_default;
Checkbox.Group = Group_default$1;
Checkbox.__ANT_CHECKBOX = true;
Checkbox.displayName = "Checkbox";
var checkbox_default = Checkbox;

//#endregion
//#region node_modules/antd/es/grid/RowContext.js
var RowContext = /* @__PURE__ */ (0, import_react.createContext)({});
var RowContext_default = RowContext;

//#endregion
//#region node_modules/antd/es/grid/col.js
function parseFlex(flex) {
	if (flex === "auto") return "1 1 auto";
	if (typeof flex === "number") return `${flex} ${flex} auto`;
	if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) return `0 0 ${flex}`;
	return flex;
}
var sizes = [
	"xs",
	"sm",
	"md",
	"lg",
	"xl",
	"xxl"
];
var Col = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const { gutter, wrap } = import_react.useContext(RowContext_default);
	const { prefixCls: customizePrefixCls, span, order, offset: offset$2, push, pull, className, children, flex, style: style$1, ...others } = props;
	const prefixCls = getPrefixCls("col", customizePrefixCls);
	const [hashId, cssVarCls] = useColStyle(prefixCls);
	const sizeStyle = {};
	let sizeClassObj = {};
	sizes.forEach((size) => {
		let sizeProps = {};
		const propSize = props[size];
		if (typeof propSize === "number") sizeProps.span = propSize;
		else if (typeof propSize === "object") sizeProps = propSize || {};
		delete others[size];
		sizeClassObj = {
			...sizeClassObj,
			[`${prefixCls}-${size}-${sizeProps.span}`]: sizeProps.span !== void 0,
			[`${prefixCls}-${size}-order-${sizeProps.order}`]: sizeProps.order || sizeProps.order === 0,
			[`${prefixCls}-${size}-offset-${sizeProps.offset}`]: sizeProps.offset || sizeProps.offset === 0,
			[`${prefixCls}-${size}-push-${sizeProps.push}`]: sizeProps.push || sizeProps.push === 0,
			[`${prefixCls}-${size}-pull-${sizeProps.pull}`]: sizeProps.pull || sizeProps.pull === 0,
			[`${prefixCls}-rtl`]: direction === "rtl"
		};
		if (sizeProps.flex) {
			sizeClassObj[`${prefixCls}-${size}-flex`] = true;
			sizeStyle[`--${prefixCls}-${size}-flex`] = parseFlex(sizeProps.flex);
		}
	});
	const classes = clsx(prefixCls, {
		[`${prefixCls}-${span}`]: span !== void 0,
		[`${prefixCls}-order-${order}`]: order,
		[`${prefixCls}-offset-${offset$2}`]: offset$2,
		[`${prefixCls}-push-${push}`]: push,
		[`${prefixCls}-pull-${pull}`]: pull
	}, className, sizeClassObj, hashId, cssVarCls);
	const mergedStyle = {};
	if (gutter?.[0]) mergedStyle.paddingInline = typeof gutter[0] === "number" ? `${gutter[0] / 2}px` : `calc(${gutter[0]} / 2)`;
	if (flex) {
		mergedStyle.flex = parseFlex(flex);
		if (wrap === false && !mergedStyle.minWidth) mergedStyle.minWidth = 0;
	}
	return /* @__PURE__ */ import_react.createElement("div", {
		...others,
		style: {
			...mergedStyle,
			...style$1,
			...sizeStyle
		},
		className: classes,
		ref
	}, children);
});
Col.displayName = "Col";
var col_default$1 = Col;

//#endregion
//#region node_modules/antd/es/grid/hooks/useGutter.js
function useGutter(gutter, screens) {
	const results = [void 0, void 0];
	const normalizedGutter = Array.isArray(gutter) ? gutter : [gutter, void 0];
	const mergedScreens = screens || {
		xs: true,
		sm: true,
		md: true,
		lg: true,
		xl: true,
		xxl: true
	};
	normalizedGutter.forEach((g, index$1) => {
		if (typeof g === "object" && g !== null) for (let i = 0; i < responsiveArray.length; i++) {
			const breakpoint = responsiveArray[i];
			if (mergedScreens[breakpoint] && g[breakpoint] !== void 0) {
				results[index$1] = g[breakpoint];
				break;
			}
		}
		else results[index$1] = g;
	});
	return results;
}

//#endregion
//#region node_modules/antd/es/grid/row.js
function useMergedPropByScreen(oriProp, screen) {
	const [prop, setProp] = import_react.useState(typeof oriProp === "string" ? oriProp : "");
	const calcMergedAlignOrJustify = () => {
		if (typeof oriProp === "string") setProp(oriProp);
		if (typeof oriProp !== "object") return;
		for (let i = 0; i < responsiveArray.length; i++) {
			const breakpoint = responsiveArray[i];
			if (!screen || !screen[breakpoint]) continue;
			const curVal = oriProp[breakpoint];
			if (curVal !== void 0) {
				setProp(curVal);
				return;
			}
		}
	};
	import_react.useEffect(() => {
		calcMergedAlignOrJustify();
	}, [JSON.stringify(oriProp), screen]);
	return prop;
}
var Row$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, justify, align, className, style: style$1, children, gutter = 0, wrap, ...others } = props;
	const { getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const screens = useBreakpoint_default(true, null);
	const mergedAlign = useMergedPropByScreen(align, screens);
	const mergedJustify = useMergedPropByScreen(justify, screens);
	const prefixCls = getPrefixCls("row", customizePrefixCls);
	const [hashId, cssVarCls] = useRowStyle(prefixCls);
	const gutters = useGutter(gutter, screens);
	const classes = clsx(prefixCls, {
		[`${prefixCls}-no-wrap`]: wrap === false,
		[`${prefixCls}-${mergedJustify}`]: mergedJustify,
		[`${prefixCls}-${mergedAlign}`]: mergedAlign,
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, className, hashId, cssVarCls);
	const rowStyle = {};
	if (gutters?.[0]) rowStyle.marginInline = typeof gutters[0] === "number" ? `${gutters[0] / -2}px` : `calc(${gutters[0]} / -2)`;
	const [gutterH, gutterV] = gutters;
	rowStyle.rowGap = gutterV;
	const rowContext = import_react.useMemo(() => ({
		gutter: [gutterH, gutterV],
		wrap
	}), [
		gutterH,
		gutterV,
		wrap
	]);
	return /* @__PURE__ */ import_react.createElement(RowContext_default.Provider, { value: rowContext }, /* @__PURE__ */ import_react.createElement("div", {
		...others,
		className: classes,
		style: {
			...rowStyle,
			...style$1
		},
		ref
	}, children));
});
Row$1.displayName = "Row";
var row_default$1 = Row$1;

//#endregion
//#region node_modules/antd/es/grid/index.js
function useBreakpoint() {
	return useBreakpoint_default();
}
var grid_default = { useBreakpoint };

//#endregion
//#region node_modules/antd/es/col/index.js
var col_default = col_default$1;

//#endregion
//#region node_modules/antd/es/divider/style/index.js
var genSizeDividerStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: { "&-horizontal": { [`&${componentCls}`]: {
		"&-sm": { marginBlock: token$1.marginXS },
		"&-md": { marginBlock: token$1.margin }
	} } } };
};
var genSharedDividerStyle = (token$1) => {
	const { componentCls, sizePaddingEdgeHorizontal, colorSplit, lineWidth, textPaddingInline, orientationMargin, verticalMarginInline } = token$1;
	const railCls = `${componentCls}-rail`;
	return { [componentCls]: {
		...resetComponent(token$1),
		borderBlockStart: `${unit(lineWidth)} solid ${colorSplit}`,
		[railCls]: { borderBlockStart: `${unit(lineWidth)} solid ${colorSplit}` },
		"&-vertical": {
			position: "relative",
			top: "-0.06em",
			display: "inline-block",
			height: "0.9em",
			marginInline: verticalMarginInline,
			marginBlock: 0,
			verticalAlign: "middle",
			borderTop: 0,
			borderInlineStart: `${unit(lineWidth)} solid ${colorSplit}`
		},
		"&-horizontal": {
			display: "flex",
			clear: "both",
			width: "100%",
			minWidth: "100%",
			margin: `${unit(token$1.marginLG)} 0`
		},
		[`&-horizontal${componentCls}-with-text`]: {
			display: "flex",
			alignItems: "center",
			margin: `${unit(token$1.dividerHorizontalWithTextGutterMargin)} 0`,
			color: token$1.colorTextHeading,
			fontWeight: 500,
			fontSize: token$1.fontSizeLG,
			whiteSpace: "nowrap",
			textAlign: "center",
			borderBlockStart: `0 ${colorSplit}`,
			[`${railCls}-start, ${railCls}-end`]: {
				width: "50%",
				borderBlockStartColor: "inherit",
				borderBlockEnd: 0,
				content: "''"
			}
		},
		[`&-horizontal${componentCls}-with-text-start`]: {
			[`${railCls}-start`]: { width: `calc(${orientationMargin} * 100%)` },
			[`${railCls}-end`]: { width: `calc(100% - ${orientationMargin} * 100%)` }
		},
		[`&-horizontal${componentCls}-with-text-end`]: {
			[`${railCls}-start`]: { width: `calc(100% - ${orientationMargin} * 100%)` },
			[`${railCls}-end`]: { width: `calc(${orientationMargin} * 100%)` }
		},
		[`${componentCls}-inner-text`]: {
			display: "inline-block",
			paddingBlock: 0,
			paddingInline: textPaddingInline
		},
		"&-dashed": {
			background: "none",
			borderColor: colorSplit,
			borderStyle: "dashed",
			borderWidth: `${unit(lineWidth)} 0 0`,
			[railCls]: { borderBlockStart: `${unit(lineWidth)} dashed ${colorSplit}` }
		},
		[`&-horizontal${componentCls}-with-text${componentCls}-dashed`]: { [`${railCls}-start, ${railCls}-end`]: { borderStyle: "dashed none none" } },
		[`&-vertical${componentCls}-dashed`]: {
			borderInlineStartWidth: lineWidth,
			borderInlineEnd: 0,
			borderBlockStart: 0,
			borderBlockEnd: 0
		},
		"&-dotted": {
			background: "none",
			borderColor: colorSplit,
			borderStyle: "dotted",
			borderWidth: `${unit(lineWidth)} 0 0`,
			[railCls]: { borderBlockStart: `${unit(lineWidth)} dotted ${colorSplit}` }
		},
		[`&-horizontal${componentCls}-with-text${componentCls}-dotted`]: { "&::before, &::after": { borderStyle: "dotted none none" } },
		[`&-vertical${componentCls}-dotted`]: {
			borderInlineStartWidth: lineWidth,
			borderInlineEnd: 0,
			borderBlockStart: 0,
			borderBlockEnd: 0
		},
		[`&-plain${componentCls}-with-text`]: {
			color: token$1.colorText,
			fontWeight: "normal",
			fontSize: token$1.fontSize
		},
		[`&-horizontal${componentCls}-with-text-start${componentCls}-no-default-orientation-margin-start`]: {
			[`${railCls}-start`]: { width: 0 },
			[`${railCls}-end`]: { width: "100%" },
			[`${componentCls}-inner-text`]: { paddingInlineStart: sizePaddingEdgeHorizontal }
		},
		[`&-horizontal${componentCls}-with-text-end${componentCls}-no-default-orientation-margin-end`]: {
			[`${railCls}-start`]: { width: "100%" },
			[`${railCls}-end`]: { width: 0 },
			[`${componentCls}-inner-text`]: { paddingInlineEnd: sizePaddingEdgeHorizontal }
		}
	} };
};
const prepareComponentToken$30 = (token$1) => ({
	textPaddingInline: "1em",
	orientationMargin: .05,
	verticalMarginInline: token$1.marginXS
});
var style_default$38 = genStyleHooks("Divider", (token$1) => {
	const dividerToken = merge(token$1, {
		dividerHorizontalWithTextGutterMargin: token$1.margin,
		sizePaddingEdgeHorizontal: 0
	});
	return [genSharedDividerStyle(dividerToken), genSizeDividerStyle(dividerToken)];
}, prepareComponentToken$30, { unitless: { orientationMargin: true } });

//#endregion
//#region node_modules/antd/es/divider/index.js
var titlePlacementList = [
	"left",
	"right",
	"center",
	"start",
	"end"
];
var sizeClassNameMap = {
	small: "sm",
	middle: "md"
};
var Divider = (props) => {
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("divider");
	const { prefixCls: customizePrefixCls, type: type$2, orientation, vertical, titlePlacement, orientationMargin, className, rootClassName, children, dashed, variant = "solid", plain, style: style$1, size: customSize, classNames, styles, ...restProps } = props;
	const prefixCls = getPrefixCls("divider", customizePrefixCls);
	const railCls = `${prefixCls}-rail`;
	const [hashId, cssVarCls] = style_default$38(prefixCls);
	const sizeFullName = useSize_default(customSize);
	const sizeCls = sizeClassNameMap[sizeFullName];
	const hasChildren = !!children;
	const validTitlePlacement = titlePlacementList.includes(orientation || "");
	const mergedTitlePlacement = import_react.useMemo(() => {
		const placement = titlePlacement ?? (validTitlePlacement ? orientation : "center");
		if (placement === "left") return direction === "rtl" ? "end" : "start";
		if (placement === "right") return direction === "rtl" ? "start" : "end";
		return placement;
	}, [
		direction,
		orientation,
		titlePlacement,
		validTitlePlacement
	]);
	const hasMarginStart = mergedTitlePlacement === "start" && orientationMargin != null;
	const hasMarginEnd = mergedTitlePlacement === "end" && orientationMargin != null;
	const [mergedOrientation, mergedVertical] = useOrientation(orientation, vertical, type$2);
	const mergedProps = {
		...props,
		orientation: mergedOrientation,
		titlePlacement: mergedTitlePlacement,
		size: sizeFullName
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const classString = clsx(prefixCls, contextClassName, hashId, cssVarCls, `${prefixCls}-${mergedOrientation}`, {
		[`${prefixCls}-with-text`]: hasChildren,
		[`${prefixCls}-with-text-${mergedTitlePlacement}`]: hasChildren,
		[`${prefixCls}-dashed`]: !!dashed,
		[`${prefixCls}-${variant}`]: variant !== "solid",
		[`${prefixCls}-plain`]: !!plain,
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-no-default-orientation-margin-start`]: hasMarginStart,
		[`${prefixCls}-no-default-orientation-margin-end`]: hasMarginEnd,
		[`${prefixCls}-${sizeCls}`]: !!sizeCls,
		[railCls]: !children,
		[mergedClassNames.rail]: mergedClassNames.rail && !children
	}, className, rootClassName, mergedClassNames.root);
	const memoizedPlacementMargin = import_react.useMemo(() => {
		if (typeof orientationMargin === "number") return orientationMargin;
		if (/^\d+$/.test(orientationMargin)) return Number(orientationMargin);
		return orientationMargin;
	}, [orientationMargin]);
	const innerStyle = {
		marginInlineStart: hasMarginStart ? memoizedPlacementMargin : void 0,
		marginInlineEnd: hasMarginEnd ? memoizedPlacementMargin : void 0
	};
	{
		const warning$3 = devUseWarning("Divider");
		warning$3(!children || !mergedVertical, "usage", "`children` not working in `vertical` mode.");
		warning$3(!validTitlePlacement, "usage", "`orientation` is used for direction, please use `titlePlacement` replace this");
		[["type", "orientation"], ["orientationMargin", "styles.content.margin"]].forEach(([deprecatedName, newName]) => {
			warning$3.deprecated(!(deprecatedName in props), deprecatedName, newName);
		});
	}
	return /* @__PURE__ */ import_react.createElement("div", {
		className: classString,
		style: {
			...contextStyle,
			...mergedStyles.root,
			...children ? {} : mergedStyles.rail,
			...style$1
		},
		...restProps,
		role: "separator"
	}, children && !mergedVertical && /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(railCls, `${railCls}-start`, mergedClassNames.rail),
		style: mergedStyles.rail
	}), /* @__PURE__ */ import_react.createElement("span", {
		className: clsx(`${prefixCls}-inner-text`, mergedClassNames.content),
		style: {
			...innerStyle,
			...mergedStyles.content
		}
	}, children), /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(railCls, `${railCls}-end`, mergedClassNames.rail),
		style: mergedStyles.rail
	})));
};
Divider.displayName = "Divider";
var divider_default = Divider;

//#endregion
//#region node_modules/@rc-component/segmented/es/MotionThumb.js
var calcThumbStyle = (targetElement, vertical) => {
	if (!targetElement) return null;
	const style$1 = {
		left: targetElement.offsetLeft,
		right: targetElement.parentElement.clientWidth - targetElement.clientWidth - targetElement.offsetLeft,
		width: targetElement.clientWidth,
		top: targetElement.offsetTop,
		bottom: targetElement.parentElement.clientHeight - targetElement.clientHeight - targetElement.offsetTop,
		height: targetElement.clientHeight
	};
	if (vertical) return {
		left: 0,
		right: 0,
		width: 0,
		top: style$1.top,
		bottom: style$1.bottom,
		height: style$1.height
	};
	return {
		left: style$1.left,
		right: style$1.right,
		width: style$1.width,
		top: 0,
		bottom: 0,
		height: 0
	};
};
var toPX = (value) => value !== void 0 ? `${value}px` : void 0;
function MotionThumb(props) {
	const { prefixCls, containerRef, value, getValueIndex, motionName, onMotionStart, onMotionEnd, direction, vertical = false } = props;
	const thumbRef = import_react.useRef(null);
	const [prevValue, setPrevValue] = import_react.useState(value);
	const findValueElement = (val) => {
		const index$1 = getValueIndex(val);
		const ele = containerRef.current?.querySelectorAll(`.${prefixCls}-item`)[index$1];
		return ele?.offsetParent && ele;
	};
	const [prevStyle, setPrevStyle] = import_react.useState(null);
	const [nextStyle, setNextStyle] = import_react.useState(null);
	useLayoutEffect_default(() => {
		if (prevValue !== value) {
			const prev$1 = findValueElement(prevValue);
			const next$1 = findValueElement(value);
			const calcPrevStyle = calcThumbStyle(prev$1, vertical);
			const calcNextStyle = calcThumbStyle(next$1, vertical);
			setPrevValue(value);
			setPrevStyle(calcPrevStyle);
			setNextStyle(calcNextStyle);
			if (prev$1 && next$1) onMotionStart();
			else onMotionEnd();
		}
	}, [value]);
	const thumbStart = import_react.useMemo(() => {
		if (vertical) return toPX(prevStyle?.top ?? 0);
		if (direction === "rtl") return toPX(-prevStyle?.right);
		return toPX(prevStyle?.left);
	}, [
		vertical,
		direction,
		prevStyle
	]);
	const thumbActive = import_react.useMemo(() => {
		if (vertical) return toPX(nextStyle?.top ?? 0);
		if (direction === "rtl") return toPX(-nextStyle?.right);
		return toPX(nextStyle?.left);
	}, [
		vertical,
		direction,
		nextStyle
	]);
	const onAppearStart = () => {
		if (vertical) return {
			transform: "translateY(var(--thumb-start-top))",
			height: "var(--thumb-start-height)"
		};
		return {
			transform: "translateX(var(--thumb-start-left))",
			width: "var(--thumb-start-width)"
		};
	};
	const onAppearActive = () => {
		if (vertical) return {
			transform: "translateY(var(--thumb-active-top))",
			height: "var(--thumb-active-height)"
		};
		return {
			transform: "translateX(var(--thumb-active-left))",
			width: "var(--thumb-active-width)"
		};
	};
	const onVisibleChanged = () => {
		setPrevStyle(null);
		setNextStyle(null);
		onMotionEnd();
	};
	if (!prevStyle || !nextStyle) return null;
	return /* @__PURE__ */ import_react.createElement(es_default$1, {
		visible: true,
		motionName,
		motionAppear: true,
		onAppearStart,
		onAppearActive,
		onVisibleChanged
	}, ({ className: motionClassName, style: motionStyle }, ref) => {
		const mergedStyle = {
			...motionStyle,
			"--thumb-start-left": thumbStart,
			"--thumb-start-width": toPX(prevStyle?.width),
			"--thumb-active-left": thumbActive,
			"--thumb-active-width": toPX(nextStyle?.width),
			"--thumb-start-top": thumbStart,
			"--thumb-start-height": toPX(prevStyle?.height),
			"--thumb-active-top": thumbActive,
			"--thumb-active-height": toPX(nextStyle?.height)
		};
		const motionProps = {
			ref: composeRef(thumbRef, ref),
			style: mergedStyle,
			className: clsx(`${prefixCls}-thumb`, motionClassName)
		};
		return /* @__PURE__ */ import_react.createElement("div", motionProps);
	});
}

//#endregion
//#region node_modules/@rc-component/segmented/es/index.js
function getValidTitle(option) {
	if (typeof option.title !== "undefined") return option.title;
	if (typeof option.label !== "object") return option.label?.toString();
}
function normalizeOptions(options) {
	return options.map((option) => {
		if (typeof option === "object" && option !== null) {
			const validTitle = getValidTitle(option);
			return {
				...option,
				title: validTitle
			};
		}
		return {
			label: option?.toString(),
			title: option?.toString(),
			value: option
		};
	});
}
var InternalSegmentedOption = ({ prefixCls, className, style: style$1, styles, classNames: segmentedClassNames, data, disabled, checked, label, title, value, name, onChange, onFocus, onBlur, onKeyDown: onKeyDown$1, onKeyUp, onMouseDown, itemRender = (node$1) => node$1 }) => {
	const handleChange = (event) => {
		if (disabled) return;
		onChange(event, value);
	};
	return itemRender(/* @__PURE__ */ import_react.createElement("label", {
		className: clsx(className, { [`${prefixCls}-item-disabled`]: disabled }),
		style: style$1,
		onMouseDown
	}, /* @__PURE__ */ import_react.createElement("input", {
		name,
		className: `${prefixCls}-item-input`,
		type: "radio",
		disabled,
		checked,
		onChange: handleChange,
		onFocus,
		onBlur,
		onKeyDown: onKeyDown$1,
		onKeyUp
	}), /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-item-label`, segmentedClassNames?.label),
		title,
		style: styles?.label
	}, label)), { item: data });
};
var Segmented$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls = "rc-segmented", direction, vertical, options = [], disabled, defaultValue, value, name, onChange, className = "", style: style$1, styles, classNames: segmentedClassNames, motionName = "thumb-motion", itemRender, ...restProps } = props;
	const containerRef = import_react.useRef(null);
	const mergedRef = import_react.useMemo(() => composeRef(containerRef, ref), [containerRef, ref]);
	const segmentedOptions = import_react.useMemo(() => {
		return normalizeOptions(options);
	}, [options]);
	const [rawValue, setRawValue] = useControlledState(defaultValue ?? segmentedOptions[0]?.value, value);
	const [thumbShow, setThumbShow] = import_react.useState(false);
	const handleChange = (event, val) => {
		setRawValue(val);
		onChange?.(val);
	};
	const divProps = omit(restProps, ["children"]);
	const [isKeyboard, setIsKeyboard] = import_react.useState(false);
	const [isFocused, setIsFocused] = import_react.useState(false);
	const handleFocus = () => {
		setIsFocused(true);
	};
	const handleBlur = () => {
		setIsFocused(false);
	};
	const handleMouseDown = () => {
		setIsKeyboard(false);
	};
	const handleKeyUp = (event) => {
		if (event.key === "Tab") setIsKeyboard(true);
	};
	const onOffset = (offset$2) => {
		const currentIndex = segmentedOptions.findIndex((option) => option.value === rawValue);
		const total = segmentedOptions.length;
		const nextOption = segmentedOptions[(currentIndex + offset$2 + total) % total];
		if (nextOption) {
			setRawValue(nextOption.value);
			onChange?.(nextOption.value);
		}
	};
	const handleKeyDown = (event) => {
		switch (event.key) {
			case "ArrowLeft":
			case "ArrowUp":
				onOffset(-1);
				break;
			case "ArrowRight":
			case "ArrowDown":
				onOffset(1);
				break;
		}
	};
	const renderOption = (segmentedOption) => {
		const { value: optionValue, disabled: optionDisabled } = segmentedOption;
		return /* @__PURE__ */ import_react.createElement(InternalSegmentedOption, _extends$26({}, segmentedOption, {
			name,
			data: segmentedOption,
			itemRender,
			key: optionValue,
			prefixCls,
			className: clsx(segmentedOption.className, `${prefixCls}-item`, segmentedClassNames?.item, {
				[`${prefixCls}-item-selected`]: optionValue === rawValue && !thumbShow,
				[`${prefixCls}-item-focused`]: isFocused && isKeyboard && optionValue === rawValue
			}),
			style: styles?.item,
			classNames: segmentedClassNames,
			styles,
			checked: optionValue === rawValue,
			onChange: handleChange,
			onFocus: handleFocus,
			onBlur: handleBlur,
			onKeyDown: handleKeyDown,
			onKeyUp: handleKeyUp,
			onMouseDown: handleMouseDown,
			disabled: !!disabled || !!optionDisabled
		}));
	};
	return /* @__PURE__ */ import_react.createElement("div", _extends$26({
		role: "radiogroup",
		"aria-label": "segmented control",
		tabIndex: disabled ? void 0 : 0,
		"aria-orientation": vertical ? "vertical" : "horizontal",
		style: style$1
	}, divProps, {
		className: clsx(prefixCls, {
			[`${prefixCls}-rtl`]: direction === "rtl",
			[`${prefixCls}-disabled`]: disabled,
			[`${prefixCls}-vertical`]: vertical
		}, className),
		ref: mergedRef
	}), /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-group` }, /* @__PURE__ */ import_react.createElement(MotionThumb, {
		vertical,
		prefixCls,
		value: rawValue,
		containerRef,
		motionName: `${prefixCls}-${motionName}`,
		direction,
		getValueIndex: (val) => segmentedOptions.findIndex((n$1) => n$1.value === val),
		onMotionStart: () => {
			setThumbShow(true);
		},
		onMotionEnd: () => {
			setThumbShow(false);
		}
	}), segmentedOptions.map(renderOption)));
});
Segmented$1.displayName = "Segmented";
var TypedSegmented = Segmented$1;
var es_default$24 = TypedSegmented;

//#endregion
//#region node_modules/antd/es/segmented/style/index.js
function getItemDisabledStyle(cls, token$1) {
	return { [`${cls}, ${cls}:hover, ${cls}:focus`]: {
		color: token$1.colorTextDisabled,
		cursor: "not-allowed"
	} };
}
function getItemSelectedStyle(token$1) {
	return {
		background: token$1.itemSelectedBg,
		boxShadow: token$1.boxShadowTertiary
	};
}
var segmentedTextEllipsisCss = {
	overflow: "hidden",
	...textEllipsis
};
var genSegmentedStyle = (token$1) => {
	const { componentCls } = token$1;
	const labelHeight = token$1.calc(token$1.controlHeight).sub(token$1.calc(token$1.trackPadding).mul(2)).equal();
	const labelHeightLG = token$1.calc(token$1.controlHeightLG).sub(token$1.calc(token$1.trackPadding).mul(2)).equal();
	const labelHeightSM = token$1.calc(token$1.controlHeightSM).sub(token$1.calc(token$1.trackPadding).mul(2)).equal();
	return { [componentCls]: {
		...resetComponent(token$1),
		display: "inline-block",
		padding: token$1.trackPadding,
		color: token$1.itemColor,
		background: token$1.trackBg,
		borderRadius: token$1.borderRadius,
		transition: `all ${token$1.motionDurationMid}`,
		...genFocusStyle(token$1),
		[`${componentCls}-group`]: {
			position: "relative",
			display: "flex",
			alignItems: "stretch",
			justifyItems: "flex-start",
			flexDirection: "row",
			width: "100%"
		},
		[`&${componentCls}-rtl`]: { direction: "rtl" },
		[`&${componentCls}-vertical`]: {
			[`${componentCls}-group`]: { flexDirection: "column" },
			[`${componentCls}-thumb`]: {
				width: "100%",
				height: 0,
				padding: `0 ${unit(token$1.paddingXXS)}`
			}
		},
		[`&${componentCls}-block`]: { display: "flex" },
		[`&${componentCls}-block ${componentCls}-item`]: {
			flex: 1,
			minWidth: 0
		},
		[`${componentCls}-item`]: {
			position: "relative",
			textAlign: "center",
			cursor: "pointer",
			transition: `color ${token$1.motionDurationMid}`,
			borderRadius: token$1.borderRadiusSM,
			transform: "translateZ(0)",
			"&-selected": {
				...getItemSelectedStyle(token$1),
				color: token$1.itemSelectedColor
			},
			"&-focused": genFocusOutline(token$1),
			"&::after": {
				content: "\"\"",
				position: "absolute",
				zIndex: -1,
				width: "100%",
				height: "100%",
				top: 0,
				insetInlineStart: 0,
				borderRadius: "inherit",
				opacity: 0,
				transition: `opacity ${token$1.motionDurationMid}, background-color ${token$1.motionDurationMid}`,
				pointerEvents: "none"
			},
			[`&:not(${componentCls}-item-selected):not(${componentCls}-item-disabled)`]: {
				"&:hover, &:active": { color: token$1.itemHoverColor },
				"&:hover::after": {
					opacity: 1,
					backgroundColor: token$1.itemHoverBg
				},
				"&:active::after": {
					opacity: 1,
					backgroundColor: token$1.itemActiveBg
				}
			},
			"&-label": {
				minHeight: labelHeight,
				lineHeight: unit(labelHeight),
				padding: `0 ${unit(token$1.segmentedPaddingHorizontal)}`,
				...segmentedTextEllipsisCss
			},
			"&-icon + *": { marginInlineStart: token$1.calc(token$1.marginSM).div(2).equal() },
			"&-input": {
				position: "absolute",
				insetBlockStart: 0,
				insetInlineStart: 0,
				width: 0,
				height: 0,
				opacity: 0,
				pointerEvents: "none"
			}
		},
		[`${componentCls}-thumb`]: {
			...getItemSelectedStyle(token$1),
			position: "absolute",
			insetBlockStart: 0,
			insetInlineStart: 0,
			width: 0,
			height: "100%",
			padding: `${unit(token$1.paddingXXS)} 0`,
			borderRadius: token$1.borderRadiusSM,
			[`& ~ ${componentCls}-item:not(${componentCls}-item-selected):not(${componentCls}-item-disabled)::after`]: { backgroundColor: "transparent" }
		},
		[`&${componentCls}-lg`]: {
			borderRadius: token$1.borderRadiusLG,
			[`${componentCls}-item-label`]: {
				minHeight: labelHeightLG,
				lineHeight: unit(labelHeightLG),
				padding: `0 ${unit(token$1.segmentedPaddingHorizontal)}`,
				fontSize: token$1.fontSizeLG
			},
			[`${componentCls}-item, ${componentCls}-thumb`]: { borderRadius: token$1.borderRadius }
		},
		[`&${componentCls}-sm`]: {
			borderRadius: token$1.borderRadiusSM,
			[`${componentCls}-item-label`]: {
				minHeight: labelHeightSM,
				lineHeight: unit(labelHeightSM),
				padding: `0 ${unit(token$1.segmentedPaddingHorizontalSM)}`
			},
			[`${componentCls}-item, ${componentCls}-thumb`]: { borderRadius: token$1.borderRadiusXS }
		},
		...getItemDisabledStyle(`&-disabled ${componentCls}-item`, token$1),
		...getItemDisabledStyle(`${componentCls}-item-disabled`, token$1),
		[`${componentCls}-thumb-motion-appear-active`]: {
			transition: `transform ${token$1.motionDurationSlow} ${token$1.motionEaseInOut}, width ${token$1.motionDurationSlow} ${token$1.motionEaseInOut}`,
			willChange: "transform, width"
		},
		[`&${componentCls}-shape-round`]: {
			borderRadius: 9999,
			[`${componentCls}-item, ${componentCls}-thumb`]: { borderRadius: 9999 }
		}
	} };
};
const prepareComponentToken$29 = (token$1) => {
	const { colorTextLabel, colorText, colorFillSecondary, colorBgElevated, colorFill, lineWidthBold, colorBgLayout } = token$1;
	return {
		trackPadding: lineWidthBold,
		trackBg: colorBgLayout,
		itemColor: colorTextLabel,
		itemHoverColor: colorText,
		itemHoverBg: colorFillSecondary,
		itemSelectedBg: colorBgElevated,
		itemActiveBg: colorFill,
		itemSelectedColor: colorText
	};
};
var style_default$37 = genStyleHooks("Segmented", (token$1) => {
	const { lineWidth, calc } = token$1;
	return genSegmentedStyle(merge(token$1, {
		segmentedPaddingHorizontal: calc(token$1.controlPaddingHorizontal).sub(lineWidth).equal(),
		segmentedPaddingHorizontalSM: calc(token$1.controlPaddingHorizontalSM).sub(lineWidth).equal()
	}));
}, prepareComponentToken$29);

//#endregion
//#region node_modules/antd/es/segmented/index.js
function isSegmentedLabeledOptionWithIcon(option) {
	return typeof option === "object" && !!option?.icon;
}
var Segmented = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const defaultName = useId_default();
	const { prefixCls: customizePrefixCls, className, rootClassName, block, options = [], size: customSize = "middle", style: style$1, vertical, orientation, shape = "default", name = defaultName, styles, classNames, ...restProps } = props;
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("segmented");
	const mergedProps = {
		...props,
		options,
		size: customSize,
		shape
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const prefixCls = getPrefixCls("segmented", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$37(prefixCls);
	const mergedSize = useSize_default(customSize);
	const extendedOptions = import_react.useMemo(() => options.map((option) => {
		if (isSegmentedLabeledOptionWithIcon(option)) {
			const { icon, label, ...restOption } = option;
			return {
				...restOption,
				label: /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("span", {
					className: clsx(`${prefixCls}-item-icon`, mergedClassNames.icon),
					style: mergedStyles.icon
				}, icon), label && /* @__PURE__ */ import_react.createElement("span", null, label))
			};
		}
		return option;
	}), [
		options,
		prefixCls,
		mergedClassNames.icon,
		mergedStyles.icon
	]);
	const [, mergedVertical] = useOrientation(orientation, vertical);
	const cls = clsx(className, rootClassName, contextClassName, mergedClassNames.root, {
		[`${prefixCls}-block`]: block,
		[`${prefixCls}-sm`]: mergedSize === "small",
		[`${prefixCls}-lg`]: mergedSize === "large",
		[`${prefixCls}-vertical`]: mergedVertical,
		[`${prefixCls}-shape-${shape}`]: shape === "round"
	}, hashId, cssVarCls);
	const mergedStyle = {
		...mergedStyles.root,
		...contextStyle,
		...style$1
	};
	const itemRender = (node$1, { item }) => {
		if (!item.tooltip) return node$1;
		const tooltipProps = typeof item.tooltip === "object" ? item.tooltip : { title: item.tooltip };
		return /* @__PURE__ */ import_react.createElement(tooltip_default, { ...tooltipProps }, node$1);
	};
	return /* @__PURE__ */ import_react.createElement(es_default$24, {
		...restProps,
		name,
		className: cls,
		style: mergedStyle,
		classNames: mergedClassNames,
		styles: mergedStyles,
		itemRender,
		options: extendedOptions,
		ref,
		prefixCls,
		direction,
		vertical: mergedVertical
	});
});
Segmented.displayName = "Segmented";
var segmented_default = Segmented;

//#endregion
//#region node_modules/antd/es/color-picker/context.js
const PanelPickerContext = /* @__PURE__ */ import_react.createContext({});
const PanelPresetsContext = /* @__PURE__ */ import_react.createContext({});

//#endregion
//#region node_modules/antd/es/color-picker/components/ColorClear.js
var ColorClear = ({ prefixCls, value, onChange }) => {
	const handleClick = () => {
		if (onChange && value && !value.cleared) {
			const hsba = value.toHsb();
			hsba.a = 0;
			const genColor = generateColor(hsba);
			genColor.cleared = true;
			onChange(genColor);
		}
	};
	return /* @__PURE__ */ import_react.createElement("div", {
		className: `${prefixCls}-clear`,
		onClick: handleClick
	});
};
var ColorClear_default = ColorClear;

//#endregion
//#region node_modules/antd/es/color-picker/interface.js
const FORMAT_HEX = "hex";
const FORMAT_RGB = "rgb";
const FORMAT_HSB = "hsb";

//#endregion
//#region node_modules/@rc-component/mini-decimal/es/supportUtil.js
function supportBigInt() {
	return typeof BigInt === "function";
}

//#endregion
//#region node_modules/@rc-component/mini-decimal/es/numberUtil.js
function isEmpty(value) {
	return !value && value !== 0 && !Number.isNaN(value) || !String(value).trim();
}
/**
* Format string number to readable number
*/
function trimNumber(numStr) {
	var str = numStr.trim();
	var negative = str.startsWith("-");
	if (negative) str = str.slice(1);
	str = str.replace(/(\.\d*[^0])0*$/, "$1").replace(/\.0*$/, "").replace(/^0+/, "");
	if (str.startsWith(".")) str = "0".concat(str);
	var trimStr = str || "0";
	var splitNumber = trimStr.split(".");
	var integerStr = splitNumber[0] || "0";
	var decimalStr = splitNumber[1] || "0";
	if (integerStr === "0" && decimalStr === "0") negative = false;
	var negativeStr = negative ? "-" : "";
	return {
		negative,
		negativeStr,
		trimStr,
		integerStr,
		decimalStr,
		fullStr: "".concat(negativeStr).concat(trimStr)
	};
}
function isE(number$1) {
	var str = String(number$1);
	return !Number.isNaN(Number(str)) && str.includes("e");
}
/**
* [Legacy] Convert 1e-9 to 0.000000001.
* This may lose some precision if user really want 1e-9.
*/
function getNumberPrecision(number$1) {
	var numStr = String(number$1);
	if (isE(number$1)) {
		var precision = Number(numStr.slice(numStr.indexOf("e-") + 2));
		var decimalMatch = numStr.match(/\.(\d+)/);
		if (decimalMatch !== null && decimalMatch !== void 0 && decimalMatch[1]) precision += decimalMatch[1].length;
		return precision;
	}
	return numStr.includes(".") && validateNumber(numStr) ? numStr.length - numStr.indexOf(".") - 1 : 0;
}
/**
* Convert number (includes scientific notation) to -xxx.yyy format
*/
function num2str(number$1) {
	var numStr = String(number$1);
	if (isE(number$1)) {
		if (number$1 > Number.MAX_SAFE_INTEGER) return String(supportBigInt() ? BigInt(number$1).toString() : Number.MAX_SAFE_INTEGER);
		if (number$1 < Number.MIN_SAFE_INTEGER) return String(supportBigInt() ? BigInt(number$1).toString() : Number.MIN_SAFE_INTEGER);
		numStr = number$1.toFixed(getNumberPrecision(numStr));
	}
	return trimNumber(numStr).fullStr;
}
function validateNumber(num) {
	if (typeof num === "number") return !Number.isNaN(num);
	if (!num) return false;
	return /^\s*-?\d+(\.\d+)?\s*$/.test(num) || /^\s*-?\d+\.\s*$/.test(num) || /^\s*-?\.\d+\s*$/.test(num);
}

//#endregion
//#region node_modules/@rc-component/mini-decimal/es/BigIntDecimal.js
var BigIntDecimal = /* @__PURE__ */ function() {
	/** BigInt will convert `0009` to `9`. We need record the len of decimal */
	function BigIntDecimal$1(value) {
		_classCallCheck(this, BigIntDecimal$1);
		_defineProperty(this, "origin", "");
		_defineProperty(this, "negative", void 0);
		_defineProperty(this, "integer", void 0);
		_defineProperty(this, "decimal", void 0);
		_defineProperty(this, "decimalLen", void 0);
		_defineProperty(this, "empty", void 0);
		_defineProperty(this, "nan", void 0);
		if (isEmpty(value)) {
			this.empty = true;
			return;
		}
		this.origin = String(value);
		if (value === "-" || Number.isNaN(value)) {
			this.nan = true;
			return;
		}
		var mergedValue = value;
		if (isE(mergedValue)) mergedValue = Number(mergedValue);
		mergedValue = typeof mergedValue === "string" ? mergedValue : num2str(mergedValue);
		if (validateNumber(mergedValue)) {
			var trimRet = trimNumber(mergedValue);
			this.negative = trimRet.negative;
			var numbers = trimRet.trimStr.split(".");
			this.integer = BigInt(numbers[0]);
			var decimalStr = numbers[1] || "0";
			this.decimal = BigInt(decimalStr);
			this.decimalLen = decimalStr.length;
		} else this.nan = true;
	}
	_createClass(BigIntDecimal$1, [
		{
			key: "getMark",
			value: function getMark() {
				return this.negative ? "-" : "";
			}
		},
		{
			key: "getIntegerStr",
			value: function getIntegerStr() {
				return this.integer.toString();
			}
		},
		{
			key: "getDecimalStr",
			value: function getDecimalStr() {
				return this.decimal.toString().padStart(this.decimalLen, "0");
			}
		},
		{
			key: "alignDecimal",
			value: function alignDecimal(decimalLength) {
				var str = "".concat(this.getMark()).concat(this.getIntegerStr()).concat(this.getDecimalStr().padEnd(decimalLength, "0"));
				return BigInt(str);
			}
		},
		{
			key: "negate",
			value: function negate() {
				var clone = new BigIntDecimal$1(this.toString());
				clone.negative = !clone.negative;
				return clone;
			}
		},
		{
			key: "cal",
			value: function cal(offset$2, calculator, calDecimalLen) {
				var maxDecimalLength = Math.max(this.getDecimalStr().length, offset$2.getDecimalStr().length);
				var valueStr = calculator(this.alignDecimal(maxDecimalLength), offset$2.alignDecimal(maxDecimalLength)).toString();
				var nextDecimalLength = calDecimalLen(maxDecimalLength);
				var _trimNumber = trimNumber(valueStr), negativeStr = _trimNumber.negativeStr, trimStr = _trimNumber.trimStr;
				var hydrateValueStr = "".concat(negativeStr).concat(trimStr.padStart(nextDecimalLength + 1, "0"));
				return new BigIntDecimal$1("".concat(hydrateValueStr.slice(0, -nextDecimalLength), ".").concat(hydrateValueStr.slice(-nextDecimalLength)));
			}
		},
		{
			key: "add",
			value: function add(value) {
				if (this.isInvalidate()) return new BigIntDecimal$1(value);
				var offset$2 = new BigIntDecimal$1(value);
				if (offset$2.isInvalidate()) return this;
				return this.cal(offset$2, function(num1, num2) {
					return num1 + num2;
				}, function(len) {
					return len;
				});
			}
		},
		{
			key: "multi",
			value: function multi(value) {
				var target = new BigIntDecimal$1(value);
				if (this.isInvalidate() || target.isInvalidate()) return new BigIntDecimal$1(NaN);
				return this.cal(target, function(num1, num2) {
					return num1 * num2;
				}, function(len) {
					return len * 2;
				});
			}
		},
		{
			key: "isEmpty",
			value: function isEmpty$1() {
				return this.empty;
			}
		},
		{
			key: "isNaN",
			value: function isNaN$1() {
				return this.nan;
			}
		},
		{
			key: "isInvalidate",
			value: function isInvalidate() {
				return this.isEmpty() || this.isNaN();
			}
		},
		{
			key: "equals",
			value: function equals(target) {
				return this.toString() === (target === null || target === void 0 ? void 0 : target.toString());
			}
		},
		{
			key: "lessEquals",
			value: function lessEquals(target) {
				return this.add(target.negate().toString()).toNumber() <= 0;
			}
		},
		{
			key: "toNumber",
			value: function toNumber() {
				if (this.isNaN()) return NaN;
				return Number(this.toString());
			}
		},
		{
			key: "toString",
			value: function toString() {
				if (!(arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true)) return this.origin;
				if (this.isInvalidate()) return "";
				return trimNumber("".concat(this.getMark()).concat(this.getIntegerStr(), ".").concat(this.getDecimalStr())).fullStr;
			}
		}
	]);
	return BigIntDecimal$1;
}();

//#endregion
//#region node_modules/@rc-component/mini-decimal/es/NumberDecimal.js
/**
* We can remove this when IE not support anymore
*/
var NumberDecimal = /* @__PURE__ */ function() {
	function NumberDecimal$1(value) {
		_classCallCheck(this, NumberDecimal$1);
		_defineProperty(this, "origin", "");
		_defineProperty(this, "number", void 0);
		_defineProperty(this, "empty", void 0);
		if (isEmpty(value)) {
			this.empty = true;
			return;
		}
		this.origin = String(value);
		this.number = Number(value);
	}
	_createClass(NumberDecimal$1, [
		{
			key: "negate",
			value: function negate() {
				return new NumberDecimal$1(-this.toNumber());
			}
		},
		{
			key: "add",
			value: function add(value) {
				if (this.isInvalidate()) return new NumberDecimal$1(value);
				var target = Number(value);
				if (Number.isNaN(target)) return this;
				var number$1 = this.number + target;
				if (number$1 > Number.MAX_SAFE_INTEGER) return new NumberDecimal$1(Number.MAX_SAFE_INTEGER);
				if (number$1 < Number.MIN_SAFE_INTEGER) return new NumberDecimal$1(Number.MIN_SAFE_INTEGER);
				var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
				return new NumberDecimal$1(number$1.toFixed(maxPrecision));
			}
		},
		{
			key: "multi",
			value: function multi(value) {
				var target = Number(value);
				if (this.isInvalidate() || Number.isNaN(target)) return new NumberDecimal$1(NaN);
				var number$1 = this.number * target;
				if (number$1 > Number.MAX_SAFE_INTEGER) return new NumberDecimal$1(Number.MAX_SAFE_INTEGER);
				if (number$1 < Number.MIN_SAFE_INTEGER) return new NumberDecimal$1(Number.MIN_SAFE_INTEGER);
				var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
				return new NumberDecimal$1(number$1.toFixed(maxPrecision));
			}
		},
		{
			key: "isEmpty",
			value: function isEmpty$1() {
				return this.empty;
			}
		},
		{
			key: "isNaN",
			value: function isNaN$1() {
				return Number.isNaN(this.number);
			}
		},
		{
			key: "isInvalidate",
			value: function isInvalidate() {
				return this.isEmpty() || this.isNaN();
			}
		},
		{
			key: "equals",
			value: function equals(target) {
				return this.toNumber() === (target === null || target === void 0 ? void 0 : target.toNumber());
			}
		},
		{
			key: "lessEquals",
			value: function lessEquals(target) {
				return this.add(target.negate().toString()).toNumber() <= 0;
			}
		},
		{
			key: "toNumber",
			value: function toNumber() {
				return this.number;
			}
		},
		{
			key: "toString",
			value: function toString() {
				if (!(arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true)) return this.origin;
				if (this.isInvalidate()) return "";
				return num2str(this.number);
			}
		}
	]);
	return NumberDecimal$1;
}();

//#endregion
//#region node_modules/@rc-component/mini-decimal/es/MiniDecimal.js
function getMiniDecimal(value) {
	if (supportBigInt()) return new BigIntDecimal(value);
	return new NumberDecimal(value);
}
/**
* Align the logic of toFixed to around like 1.5 => 2.
* If set `cutOnly`, will just remove the over decimal part.
*/
function toFixed(numStr, separatorStr, precision) {
	var cutOnly = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
	if (numStr === "") return "";
	var _trimNumber = trimNumber(numStr), negativeStr = _trimNumber.negativeStr, integerStr = _trimNumber.integerStr, decimalStr = _trimNumber.decimalStr;
	var precisionDecimalStr = "".concat(separatorStr).concat(decimalStr);
	var numberWithoutDecimal = "".concat(negativeStr).concat(integerStr);
	if (precision >= 0) {
		var advancedNum = Number(decimalStr[precision]);
		if (advancedNum >= 5 && !cutOnly) return toFixed(getMiniDecimal(numStr).add("".concat(negativeStr, "0.").concat("0".repeat(precision)).concat(10 - advancedNum)).toString(), separatorStr, precision, cutOnly);
		if (precision === 0) return numberWithoutDecimal;
		return "".concat(numberWithoutDecimal).concat(separatorStr).concat(decimalStr.padEnd(precision, "0").slice(0, precision));
	}
	if (precisionDecimalStr === ".0") return numberWithoutDecimal;
	return "".concat(numberWithoutDecimal).concat(precisionDecimalStr);
}

//#endregion
//#region node_modules/@rc-component/mini-decimal/es/index.js
var es_default$23 = getMiniDecimal;

//#endregion
//#region node_modules/@rc-component/util/es/proxyObject.js
/**
* Proxy object if environment supported
*/
function proxyObject(obj, extendProps) {
	if (typeof Proxy !== "undefined" && obj) return new Proxy(obj, { get(target, prop) {
		if (extendProps[prop]) return extendProps[prop];
		const originProp = target[prop];
		return typeof originProp === "function" ? originProp.bind(target) : originProp;
	} });
	return obj;
}

//#endregion
//#region node_modules/@rc-component/input-number/es/hooks/useCursor.js
/**
* Keep input cursor in the correct position if possible.
* Is this necessary since we have `formatter` which may mass the content?
*/
function useCursor(input, focused) {
	const selectionRef = (0, import_react.useRef)(null);
	function recordCursor() {
		try {
			const { selectionStart: start, selectionEnd: end, value } = input;
			selectionRef.current = {
				start,
				end,
				value,
				beforeTxt: value.substring(0, start),
				afterTxt: value.substring(end)
			};
		} catch (e$2) {}
	}
	/**
	* Restore logic:
	*  1. back string same
	*  2. start string same
	*/
	function restoreCursor() {
		if (input && selectionRef.current && focused) try {
			const { value } = input;
			const { beforeTxt, afterTxt, start } = selectionRef.current;
			let startPos = value.length;
			if (value.startsWith(beforeTxt)) startPos = beforeTxt.length;
			else if (value.endsWith(afterTxt)) startPos = value.length - selectionRef.current.afterTxt.length;
			else {
				const beforeLastChar = beforeTxt[start - 1];
				const newIndex = value.indexOf(beforeLastChar, start - 1);
				if (newIndex !== -1) startPos = newIndex + 1;
			}
			input.setSelectionRange(startPos, startPos);
		} catch (e$2) {
			warning_default$1(false, `Something warning of cursor restore. Please fire issue about this: ${e$2.message}`);
		}
	}
	return [recordCursor, restoreCursor];
}

//#endregion
//#region node_modules/@rc-component/input-number/es/StepHandler.js
/**
* When click and hold on a button - the speed of auto changing the value.
*/
var STEP_INTERVAL = 200;
/**
* When click and hold on a button - the delay before auto changing the value.
*/
var STEP_DELAY = 600;
function StepHandler({ prefixCls, action, children, disabled, className, style: style$1, onStep }) {
	const isUpAction = action === "up";
	const stepTimeoutRef = import_react.useRef();
	const frameIds = import_react.useRef([]);
	const onStopStep = () => {
		clearTimeout(stepTimeoutRef.current);
	};
	const onStepMouseDown = (e$2) => {
		e$2.preventDefault();
		onStopStep();
		onStep(isUpAction, "handler");
		function loopStep() {
			onStep(isUpAction, "handler");
			stepTimeoutRef.current = setTimeout(loopStep, STEP_INTERVAL);
		}
		stepTimeoutRef.current = setTimeout(loopStep, STEP_DELAY);
	};
	import_react.useEffect(() => () => {
		onStopStep();
		frameIds.current.forEach((id) => {
			raf_default.cancel(id);
		});
	}, []);
	const actionClassName = `${prefixCls}-action`;
	const mergedClassName = clsx(actionClassName, `${actionClassName}-${action}`, { [`${actionClassName}-${action}-disabled`]: disabled }, className);
	const safeOnStopStep = () => frameIds.current.push(raf_default(onStopStep));
	return /* @__PURE__ */ import_react.createElement("span", {
		unselectable: "on",
		role: "button",
		onMouseUp: safeOnStopStep,
		onMouseLeave: safeOnStopStep,
		onMouseDown: (e$2) => {
			onStepMouseDown(e$2);
		},
		"aria-label": isUpAction ? "Increase Value" : "Decrease Value",
		"aria-disabled": disabled,
		className: mergedClassName,
		style: style$1
	}, children || /* @__PURE__ */ import_react.createElement("span", {
		unselectable: "on",
		className: `${prefixCls}-action-${action}-inner`
	}));
}

//#endregion
//#region node_modules/@rc-component/input-number/es/utils/numberUtil.js
function getDecupleSteps(step) {
	const stepStr = typeof step === "number" ? num2str(step) : trimNumber(step).fullStr;
	if (!stepStr.includes(".")) return step + "0";
	return trimNumber(stepStr.replace(/(\d)\.(\d)/g, "$1$2.")).fullStr;
}

//#endregion
//#region node_modules/@rc-component/input-number/es/hooks/useFrame.js
/**
* Always trigger latest once when call multiple time
*/
var useFrame_default = (() => {
	const idRef = (0, import_react.useRef)(0);
	const cleanUp = () => {
		raf_default.cancel(idRef.current);
	};
	(0, import_react.useEffect)(() => cleanUp, []);
	return (callback) => {
		cleanUp();
		idRef.current = raf_default(() => {
			callback();
		});
	};
});

//#endregion
//#region node_modules/@rc-component/input-number/es/InputNumber.js
function _extends$42() {
	_extends$42 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$42.apply(this, arguments);
}
/**
* We support `stringMode` which need handle correct type when user call in onChange
* format max or min value
* 1. if isInvalid return null
* 2. if precision is undefined, return decimal
* 3. format with precision
*    I. if max > 0, round down with precision. Example: max= 3.5, precision=0  afterFormat: 3
*    II. if max < 0, round up with precision. Example: max= -3.5, precision=0  afterFormat: -4
*    III. if min > 0, round up with precision. Example: min= 3.5, precision=0  afterFormat: 4
*    IV. if min < 0, round down with precision. Example: max= -3.5, precision=0  afterFormat: -3
*/
var getDecimalValue = (stringMode, decimalValue) => {
	if (stringMode || decimalValue.isEmpty()) return decimalValue.toString();
	return decimalValue.toNumber();
};
var getDecimalIfValidate = (value) => {
	const decimal = es_default$23(value);
	return decimal.isInvalidate() ? null : decimal;
};
var InputNumber$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { mode = "input", prefixCls = "rc-input-number", className, style: style$1, classNames, styles, min, max, step = 1, defaultValue, value, disabled, readOnly, upHandler, downHandler, keyboard, changeOnWheel = false, controls = true, prefix: prefix$1, suffix, stringMode, parser, formatter, precision, decimalSeparator, onChange, onInput, onPressEnter, onStep, onMouseDown, onClick, onMouseUp, onMouseLeave, onMouseMove, onMouseEnter, onMouseOut, changeOnBlur = true, ...restProps } = props;
	const [focus, setFocus] = import_react.useState(false);
	const userTypingRef = import_react.useRef(false);
	const compositionRef = import_react.useRef(false);
	const shiftKeyRef = import_react.useRef(false);
	const rootRef = import_react.useRef(null);
	const inputRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => proxyObject(inputRef.current, {
		focus: (option) => {
			triggerFocus(inputRef.current, option);
		},
		blur: () => {
			inputRef.current?.blur();
		},
		nativeElement: rootRef.current
	}));
	const [decimalValue, setDecimalValue] = import_react.useState(() => es_default$23(value ?? defaultValue));
	function setUncontrolledDecimalValue(newDecimal) {
		if (value === void 0) setDecimalValue(newDecimal);
	}
	/**
	* `precision` is used for formatter & onChange.
	* It will auto generate by `value` & `step`.
	* But it will not block user typing.
	*
	* Note: Auto generate `precision` is used for legacy logic.
	* We should remove this since we already support high precision with BigInt.
	*
	* @param number  Provide which number should calculate precision
	* @param userTyping  Change by user typing
	*/
	const getPrecision = import_react.useCallback((numStr, userTyping) => {
		if (userTyping) return;
		if (precision >= 0) return precision;
		return Math.max(getNumberPrecision(numStr), getNumberPrecision(step));
	}, [precision, step]);
	const mergedParser = import_react.useCallback((num) => {
		const numStr = String(num);
		if (parser) return parser(numStr);
		let parsedStr = numStr;
		if (decimalSeparator) parsedStr = parsedStr.replace(decimalSeparator, ".");
		return parsedStr.replace(/[^\w.-]+/g, "");
	}, [parser, decimalSeparator]);
	const inputValueRef = import_react.useRef("");
	const mergedFormatter = import_react.useCallback((number$1, userTyping) => {
		if (formatter) return formatter(number$1, {
			userTyping,
			input: String(inputValueRef.current)
		});
		let str = typeof number$1 === "number" ? num2str(number$1) : number$1;
		if (!userTyping) {
			const mergedPrecision = getPrecision(str, userTyping);
			if (validateNumber(str) && (decimalSeparator || mergedPrecision >= 0)) str = toFixed(str, decimalSeparator || ".", mergedPrecision);
		}
		return str;
	}, [
		formatter,
		getPrecision,
		decimalSeparator
	]);
	/**
	* Input text value control
	*
	* User can not update input content directly. It updates with follow rules by priority:
	*  1. controlled `value` changed
	*    * [SPECIAL] Typing like `1.` should not immediately convert to `1`
	*  2. User typing with format (not precision)
	*  3. Blur or Enter trigger revalidate
	*/
	const [inputValue, setInternalInputValue] = import_react.useState(() => {
		const initValue = defaultValue ?? value;
		if (decimalValue.isInvalidate() && ["string", "number"].includes(typeof initValue)) return Number.isNaN(initValue) ? "" : initValue;
		return mergedFormatter(decimalValue.toString(), false);
	});
	inputValueRef.current = inputValue;
	function setInputValue(newValue, userTyping) {
		setInternalInputValue(mergedFormatter(newValue.isInvalidate() ? newValue.toString(false) : newValue.toString(!userTyping), userTyping));
	}
	const maxDecimal = import_react.useMemo(() => getDecimalIfValidate(max), [max, precision]);
	const minDecimal = import_react.useMemo(() => getDecimalIfValidate(min), [min, precision]);
	const upDisabled = import_react.useMemo(() => {
		if (!maxDecimal || !decimalValue || decimalValue.isInvalidate()) return false;
		return maxDecimal.lessEquals(decimalValue);
	}, [maxDecimal, decimalValue]);
	const downDisabled = import_react.useMemo(() => {
		if (!minDecimal || !decimalValue || decimalValue.isInvalidate()) return false;
		return decimalValue.lessEquals(minDecimal);
	}, [minDecimal, decimalValue]);
	const [recordCursor, restoreCursor] = useCursor(inputRef.current, focus);
	/**
	* Find target value closet within range.
	* e.g. [11, 28]:
	*    3  => 11
	*    23 => 23
	*    99 => 28
	*/
	const getRangeValue = (target) => {
		if (maxDecimal && !target.lessEquals(maxDecimal)) return maxDecimal;
		if (minDecimal && !minDecimal.lessEquals(target)) return minDecimal;
		return null;
	};
	/**
	* Check value is in [min, max] range
	*/
	const isInRange$1 = (target) => !getRangeValue(target);
	/**
	* Trigger `onChange` if value validated and not equals of origin.
	* Return the value that re-align in range.
	*/
	const triggerValueUpdate = (newValue, userTyping) => {
		let updateValue = newValue;
		let isRangeValidate = isInRange$1(updateValue) || updateValue.isEmpty();
		if (!updateValue.isEmpty() && !userTyping) {
			updateValue = getRangeValue(updateValue) || updateValue;
			isRangeValidate = true;
		}
		if (!readOnly && !disabled && isRangeValidate) {
			const numStr = updateValue.toString();
			const mergedPrecision = getPrecision(numStr, userTyping);
			if (mergedPrecision >= 0) {
				updateValue = es_default$23(toFixed(numStr, ".", mergedPrecision));
				if (!isInRange$1(updateValue)) updateValue = es_default$23(toFixed(numStr, ".", mergedPrecision, true));
			}
			if (!updateValue.equals(decimalValue)) {
				setUncontrolledDecimalValue(updateValue);
				onChange?.(updateValue.isEmpty() ? null : getDecimalValue(stringMode, updateValue));
				if (value === void 0) setInputValue(updateValue, userTyping);
			}
			return updateValue;
		}
		return decimalValue;
	};
	const onNextPromise = useFrame_default();
	const collectInputValue = (inputStr) => {
		recordCursor();
		inputValueRef.current = inputStr;
		setInternalInputValue(inputStr);
		if (!compositionRef.current) {
			const finalDecimal = es_default$23(mergedParser(inputStr));
			if (!finalDecimal.isNaN()) triggerValueUpdate(finalDecimal, true);
		}
		onInput?.(inputStr);
		onNextPromise(() => {
			let nextInputStr = inputStr;
			if (!parser) nextInputStr = inputStr.replace(//g, ".");
			if (nextInputStr !== inputStr) collectInputValue(nextInputStr);
		});
	};
	const onCompositionStart = () => {
		compositionRef.current = true;
	};
	const onCompositionEnd = () => {
		compositionRef.current = false;
		collectInputValue(inputRef.current.value);
	};
	const onInternalInput = (e$2) => {
		collectInputValue(e$2.target.value);
	};
	const onInternalStep = useEvent_default((up, emitter) => {
		if (up && upDisabled || !up && downDisabled) return;
		userTypingRef.current = false;
		let stepDecimal = es_default$23(shiftKeyRef.current ? getDecupleSteps(step) : step);
		if (!up) stepDecimal = stepDecimal.negate();
		const updatedValue = triggerValueUpdate((decimalValue || es_default$23(0)).add(stepDecimal.toString()), false);
		onStep?.(getDecimalValue(stringMode, updatedValue), {
			offset: shiftKeyRef.current ? getDecupleSteps(step) : step,
			type: up ? "up" : "down",
			emitter
		});
		inputRef.current?.focus();
	});
	/**
	* Flush current input content to trigger value change & re-formatter input if needed.
	* This will always flush input value for update.
	* If it's invalidate, will fallback to last validate value.
	*/
	const flushInputValue = (userTyping) => {
		const parsedValue = es_default$23(mergedParser(inputValue));
		let formatValue$1;
		if (!parsedValue.isNaN()) formatValue$1 = triggerValueUpdate(parsedValue, userTyping);
		else formatValue$1 = triggerValueUpdate(decimalValue, userTyping);
		if (value !== void 0) setInputValue(decimalValue, false);
		else if (!formatValue$1.isNaN()) setInputValue(formatValue$1, false);
	};
	const onBeforeInput = () => {
		userTypingRef.current = true;
	};
	const onKeyDown$1 = (event) => {
		const { key, shiftKey } = event;
		userTypingRef.current = true;
		shiftKeyRef.current = shiftKey;
		if (key === "Enter") {
			if (!compositionRef.current) userTypingRef.current = false;
			flushInputValue(false);
			onPressEnter?.(event);
		}
		if (keyboard === false) return;
		if (!compositionRef.current && [
			"Up",
			"ArrowUp",
			"Down",
			"ArrowDown"
		].includes(key)) {
			onInternalStep(key === "Up" || key === "ArrowUp", "keyboard");
			event.preventDefault();
		}
	};
	const onKeyUp = () => {
		userTypingRef.current = false;
		shiftKeyRef.current = false;
	};
	import_react.useEffect(() => {
		if (changeOnWheel && focus) {
			const onWheel = (event) => {
				onInternalStep(event.deltaY < 0, "wheel");
				event.preventDefault();
			};
			const input = inputRef.current;
			if (input) {
				input.addEventListener("wheel", onWheel, { passive: false });
				return () => input.removeEventListener("wheel", onWheel);
			}
		}
	});
	const onBlur = () => {
		if (changeOnBlur) flushInputValue(false);
		setFocus(false);
		userTypingRef.current = false;
	};
	const onInternalMouseDown = (event) => {
		if (inputRef.current && event.target !== inputRef.current) {
			inputRef.current.focus();
			event.preventDefault();
		}
		onMouseDown?.(event);
	};
	useLayoutUpdateEffect(() => {
		if (!decimalValue.isInvalidate()) setInputValue(decimalValue, false);
	}, [precision, formatter]);
	useLayoutUpdateEffect(() => {
		const newValue = es_default$23(value);
		setDecimalValue(newValue);
		const currentParsedValue = es_default$23(mergedParser(inputValue));
		if (!newValue.equals(currentParsedValue) || !userTypingRef.current || formatter) setInputValue(newValue, userTypingRef.current);
	}, [value]);
	useLayoutUpdateEffect(() => {
		if (formatter) restoreCursor();
	}, [inputValue]);
	const sharedHandlerProps = {
		prefixCls,
		onStep: onInternalStep,
		className: classNames?.action,
		style: styles?.action
	};
	const upNode = /* @__PURE__ */ import_react.createElement(StepHandler, _extends$42({}, sharedHandlerProps, {
		action: "up",
		disabled: upDisabled
	}), upHandler);
	const downNode = /* @__PURE__ */ import_react.createElement(StepHandler, _extends$42({}, sharedHandlerProps, {
		action: "down",
		disabled: downDisabled
	}), downHandler);
	return /* @__PURE__ */ import_react.createElement("div", {
		ref: rootRef,
		className: clsx(prefixCls, `${prefixCls}-mode-${mode}`, className, classNames?.root, {
			[`${prefixCls}-focused`]: focus,
			[`${prefixCls}-disabled`]: disabled,
			[`${prefixCls}-readonly`]: readOnly,
			[`${prefixCls}-not-a-number`]: decimalValue.isNaN(),
			[`${prefixCls}-out-of-range`]: !decimalValue.isInvalidate() && !isInRange$1(decimalValue)
		}),
		style: {
			...styles?.root,
			...style$1
		},
		onMouseDown: onInternalMouseDown,
		onMouseUp,
		onMouseLeave,
		onMouseMove,
		onMouseEnter,
		onMouseOut,
		onClick,
		onFocus: () => {
			setFocus(true);
		},
		onBlur,
		onKeyDown: onKeyDown$1,
		onKeyUp,
		onCompositionStart,
		onCompositionEnd,
		onBeforeInput
	}, mode === "spinner" && controls && downNode, prefix$1 !== void 0 && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-prefix`, classNames?.prefix),
		style: styles?.prefix
	}, prefix$1), /* @__PURE__ */ import_react.createElement("input", _extends$42({
		autoComplete: "off",
		role: "spinbutton",
		"aria-valuemin": min,
		"aria-valuemax": max,
		"aria-valuenow": decimalValue.isInvalidate() ? null : decimalValue.toString(),
		step,
		ref: inputRef,
		className: clsx(`${prefixCls}-input`, classNames?.input),
		style: styles?.input,
		value: inputValue,
		onChange: onInternalInput,
		disabled,
		readOnly
	}, restProps)), suffix !== void 0 && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-suffix`, classNames?.suffix),
		style: styles?.suffix
	}, suffix), mode === "spinner" && controls && upNode, mode === "input" && controls && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-actions`, classNames?.actions),
		style: styles?.actions
	}, upNode, downNode));
});
InputNumber$1.displayName = "InputNumber";
var InputNumber_default = InputNumber$1;

//#endregion
//#region node_modules/@rc-component/input-number/es/index.js
var es_default$22 = InputNumber_default;

//#endregion
//#region node_modules/antd/es/space/style/addon.js
var genSpaceAddonStyle = (token$1) => {
	const { componentCls, borderRadius, paddingSM, colorBorder, paddingXS, fontSizeLG, fontSizeSM, borderRadiusLG, borderRadiusSM, colorBgContainerDisabled, lineWidth } = token$1;
	return { [componentCls]: [
		{
			display: "inline-flex",
			alignItems: "center",
			gap: 0,
			paddingInline: paddingSM,
			margin: 0,
			borderWidth: lineWidth,
			borderStyle: "solid",
			borderRadius,
			"&:hover": { zIndex: 0 },
			[`&${componentCls}-disabled`]: { color: token$1.colorTextDisabled },
			"&-large": {
				fontSize: fontSizeLG,
				borderRadius: borderRadiusLG
			},
			"&-small": {
				paddingInline: paddingXS,
				borderRadius: borderRadiusSM,
				fontSize: fontSizeSM
			},
			"&-compact-last-item": {
				borderEndStartRadius: 0,
				borderStartStartRadius: 0
			},
			"&-compact-first-item": {
				borderEndEndRadius: 0,
				borderStartEndRadius: 0
			},
			"&-compact-item:not(:first-child):not(:last-child)": { borderRadius: 0 },
			"&-compact-item:not(:last-child)": { borderInlineEndWidth: 0 },
			"&-compact-item:not(:first-child)": { borderInlineStartWidth: 0 }
		},
		{
			"--space-addon-border-color": colorBorder,
			"--space-addon-background": colorBgContainerDisabled,
			"--space-addon-border-color-outlined": colorBorder,
			"--space-addon-background-filled": colorBgContainerDisabled,
			borderColor: "var(--space-addon-border-color)",
			background: "var(--space-addon-background)",
			"&-variant-outlined": { "--space-addon-border-color": "var(--space-addon-border-color-outlined)" },
			"&-variant-filled": {
				"--space-addon-border-color": "transparent",
				"--space-addon-background": "var(--space-addon-background-filled)",
				[`&${componentCls}-disabled`]: {
					"--space-addon-border-color": colorBorder,
					"--space-addon-background": colorBgContainerDisabled
				}
			},
			"&-variant-borderless": {
				border: "none",
				background: "transparent"
			},
			"&-variant-underlined": {
				border: "none",
				background: "transparent"
			}
		},
		{
			"&-status-error": {
				"--space-addon-border-color-outlined": token$1.colorError,
				"--space-addon-background-filled": token$1.colorErrorBg,
				color: token$1.colorError
			},
			"&-status-warning": {
				"--space-addon-border-color-outlined": token$1.colorWarning,
				"--space-addon-background-filled": token$1.colorWarningBg,
				color: token$1.colorWarning
			}
		}
	] };
};
var addon_default = genStyleHooks(["Space", "Addon"], (token$1) => [genSpaceAddonStyle(token$1), genCompactItemStyle(token$1, { focus: false })]);

//#endregion
//#region node_modules/antd/es/space/Addon.js
var SpaceAddon = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { className, children, style: style$1, prefixCls: customizePrefixCls, variant = "outlined", disabled, status, ...restProps } = props;
	const { getPrefixCls, direction: directionConfig } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("space-addon", customizePrefixCls);
	const [hashId, cssVarCls] = addon_default(prefixCls);
	const { compactItemClassnames, compactSize } = useCompactItemContext(prefixCls, directionConfig);
	const statusCls = getStatusClassNames(prefixCls, status);
	const classes = clsx(prefixCls, hashId, compactItemClassnames, cssVarCls, `${prefixCls}-variant-${variant}`, statusCls, {
		[`${prefixCls}-${compactSize}`]: compactSize,
		[`${prefixCls}-disabled`]: disabled
	}, className);
	return /* @__PURE__ */ import_react.createElement("div", {
		ref,
		className: classes,
		style: style$1,
		...restProps
	}, children);
});
var Addon_default = SpaceAddon;

//#endregion
//#region node_modules/antd/es/input-number/style/token.js
const prepareComponentToken$28 = (token$1) => {
	const handleVisible = token$1.handleVisible ?? "auto";
	const handleWidth = token$1.controlHeightSM - token$1.lineWidth * 2;
	return {
		...initComponentToken$1(token$1),
		controlWidth: 90,
		handleWidth,
		handleFontSize: token$1.fontSize / 2,
		handleVisible,
		handleActiveBg: token$1.colorFillAlter,
		handleBg: token$1.colorBgContainer,
		filledHandleBg: new FastColor(token$1.colorFillSecondary).onBackground(token$1.colorBgContainer).toHexString(),
		handleHoverColor: token$1.colorPrimary,
		handleBorderColor: token$1.colorBorder,
		handleOpacity: handleVisible === true ? 1 : 0,
		handleVisibleWidth: handleVisible === true ? handleWidth : 0
	};
};

//#endregion
//#region node_modules/antd/es/input-number/style/index.js
var genInputNumberStyles = (token$1) => {
	const { componentCls, lineWidth, lineType, borderRadius, inputFontSizeSM, inputFontSizeLG, colorError, paddingInlineSM, paddingBlockSM, paddingBlockLG, paddingInlineLG, colorIcon, motionDurationMid, handleHoverColor, handleOpacity, paddingInline, paddingBlock, handleBg, handleActiveBg, inputAffixPadding, borderRadiusSM, controlWidth, handleBorderColor, filledHandleBg, lineHeightLG } = token$1;
	const borderStyle = `${unit(lineWidth)} ${lineType} ${handleBorderColor}`;
	return [
		{ [componentCls]: {
			...resetComponent(token$1),
			...genBasicInputStyle(token$1),
			"--input-number-input-padding-block": unit(paddingBlock),
			"--input-number-input-padding-inline": unit(paddingInline),
			display: "inline-flex",
			width: controlWidth,
			margin: 0,
			paddingBlock: 0,
			borderRadius,
			...genOutlinedStyle(token$1, { [`${componentCls}-actions`]: {
				background: handleBg,
				[`${componentCls}-action-down`]: { borderBlockStart: borderStyle }
			} }),
			...genFilledStyle(token$1, {
				[`${componentCls}-actions`]: {
					background: filledHandleBg,
					[`${componentCls}-action-down`]: { borderBlockStart: borderStyle }
				},
				"&:focus-within": { [`${componentCls}-actions`]: { background: handleBg } }
			}),
			...genUnderlinedStyle(token$1, { [`${componentCls}-actions`]: {
				background: handleBg,
				[`${componentCls}-action-down`]: { borderBlockStart: borderStyle }
			} }),
			...genBorderlessStyle(token$1),
			"&-rtl": {
				direction: "rtl",
				[`${componentCls}-input`]: { direction: "rtl" }
			},
			[`&${componentCls}-out-of-range`]: { [`${componentCls}-input`]: { color: colorError } },
			[`${componentCls}-input`]: {
				...resetComponent(token$1),
				width: "100%",
				paddingBlock: `var(--input-number-input-padding-block)`,
				textAlign: "start",
				backgroundColor: "transparent",
				border: 0,
				borderRadius,
				outline: 0,
				transition: `all ${motionDurationMid} linear`,
				appearance: "textfield",
				fontSize: "inherit",
				lineHeight: "inherit",
				...genPlaceholderStyle(token$1.colorTextPlaceholder),
				"&[type=\"number\"]::-webkit-inner-spin-button, &[type=\"number\"]::-webkit-outer-spin-button": {
					margin: 0,
					appearance: "none"
				}
			},
			[`&:hover ${componentCls}-handler-wrap, &-focused ${componentCls}-handler-wrap`]: {
				width: token$1.handleWidth,
				opacity: 1
			},
			[`&-disabled ${componentCls}-input`]: {
				cursor: "not-allowed",
				color: token$1.colorTextDisabled
			}
		} },
		{ [componentCls]: {
			[`
          ${componentCls}-action-up-disabled,
          ${componentCls}-action-down-disabled
        `]: { cursor: "not-allowed" },
			[`${componentCls}-action`]: {
				...resetIcon(),
				userSelect: "none",
				overflow: "hidden",
				fontWeight: "bold",
				lineHeight: 0,
				textAlign: "center",
				cursor: "pointer",
				transition: `all ${motionDurationMid} linear`,
				"&:active": { background: handleActiveBg },
				"&:hover": { color: handleHoverColor }
			},
			"&-mode-input": {
				overflow: "hidden",
				[`${componentCls}-actions`]: {
					position: "absolute",
					insetBlockStart: 0,
					insetInlineEnd: 0,
					width: token$1.handleVisibleWidth,
					opacity: handleOpacity,
					height: "100%",
					borderRadius: 0,
					display: "flex",
					flexDirection: "column",
					alignItems: "stretch",
					transition: `all ${motionDurationMid}`,
					overflow: "hidden",
					[`${componentCls}-action`]: {
						display: "flex",
						alignItems: "center",
						justifyContent: "center",
						flex: "auto",
						height: "40%",
						marginInlineEnd: 0,
						fontSize: token$1.handleFontSize
					}
				},
				[`&:hover ${componentCls}-actions, &-focused ${componentCls}-actions`]: {
					width: token$1.handleWidth,
					opacity: 1
				},
				[`${componentCls}-action`]: {
					color: colorIcon,
					height: "50%",
					borderInlineStart: borderStyle,
					"&:hover": { height: `60%` }
				},
				[`&${componentCls}-disabled, &${componentCls}-readonly`]: { [`${componentCls}-actions`]: { display: "none" } }
			},
			[`&${componentCls}-mode-spinner`]: {
				padding: 0,
				width: "auto",
				[`${componentCls}-action`]: {
					flex: "none",
					paddingInline: "var(--input-number-input-padding-inline)",
					"&-up": { borderInlineStart: borderStyle },
					"&-down": { borderInlineEnd: borderStyle }
				},
				[`${componentCls}-input`]: {
					textAlign: "center",
					paddingInline: "var(--input-number-input-padding-inline)"
				}
			}
		} },
		{ [componentCls]: {
			"&-lg": {
				"--input-number-input-padding-block": unit(paddingBlockLG),
				"--input-number-input-padding-inline": unit(paddingInlineLG),
				paddingBlock: 0,
				fontSize: inputFontSizeLG,
				lineHeight: lineHeightLG
			},
			"&-sm": {
				"--input-number-input-padding-block": unit(paddingBlockSM),
				"--input-number-input-padding-inline": unit(paddingInlineSM),
				paddingBlock: 0,
				fontSize: inputFontSizeSM,
				borderRadius: borderRadiusSM
			}
		} },
		{ [componentCls]: {
			[`${componentCls}-prefix, ${componentCls}-suffix`]: {
				display: "flex",
				flex: "none",
				alignItems: "center",
				alignSelf: "center",
				pointerEvents: "none"
			},
			[`${componentCls}-prefix`]: { marginInlineEnd: inputAffixPadding },
			[`${componentCls}-suffix`]: {
				height: "100%",
				marginInlineStart: inputAffixPadding,
				transition: `margin ${motionDurationMid}`
			},
			[`&:hover:not(${componentCls}-without-controls)`]: { [`${componentCls}-suffix`]: { marginInlineEnd: token$1.handleWidth } }
		} }
	];
};
var genCompatibleStyles = (token$1) => {
	const { componentCls, antCls } = token$1;
	return { [`${componentCls}-addon`]: { [`&:has(${antCls}-select)`]: {
		border: 0,
		padding: 0
	} } };
};
var style_default$36 = genStyleHooks("InputNumber", (token$1) => {
	const inputNumberToken = merge(token$1, initInputToken(token$1));
	return [
		genInputNumberStyles(inputNumberToken),
		genCompatibleStyles(inputNumberToken),
		genCompactItemStyle(inputNumberToken)
	];
}, prepareComponentToken$28, {
	unitless: { handleOpacity: true },
	resetFont: false
});

//#endregion
//#region node_modules/antd/es/input-number/index.js
var InternalInputNumber = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const inputRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => inputRef.current);
	const { rootClassName, size: customizeSize, disabled: customDisabled, prefixCls, addonBefore: _addonBefore, addonAfter: _addonAfter, prefix: prefix$1, suffix, bordered, readOnly, status, controls = true, variant: customVariant, className, style: style$1, classNames, styles, mode, ...others } = props;
	const { direction, className: contextClassName, style: contextStyle, styles: contextStyles, classNames: contextClassNames } = useComponentConfig("inputNumber");
	const mergedControls = import_react.useMemo(() => {
		if (!controls || props.disabled || props.readOnly) return false;
		return controls;
	}, [
		controls,
		props.disabled,
		props.readOnly
	]);
	const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
	let upIcon = mode === "spinner" ? /* @__PURE__ */ import_react.createElement(PlusOutlined_default, null) : /* @__PURE__ */ import_react.createElement(UpOutlined_default, null);
	let downIcon = mode === "spinner" ? /* @__PURE__ */ import_react.createElement(MinusOutlined_default, null) : /* @__PURE__ */ import_react.createElement(DownOutlined_default, null);
	const controlsTemp = typeof mergedControls === "boolean" ? mergedControls : void 0;
	if (typeof mergedControls === "object") {
		upIcon = mergedControls.upIcon || upIcon;
		downIcon = mergedControls.downIcon || downIcon;
	}
	const { hasFeedback, isFormItemInput, feedbackIcon } = import_react.useContext(FormItemInputContext);
	const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
	const disabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = customDisabled ?? disabled;
	const [variant, enableVariantCls] = useVariants_default("inputNumber", customVariant, bordered);
	const suffixNode = hasFeedback && /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, feedbackIcon);
	const mergedProps = {
		...props,
		size: mergedSize,
		disabled: mergedDisabled,
		controls: mergedControls
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	return /* @__PURE__ */ import_react.createElement(es_default$22, {
		ref: inputRef,
		mode,
		disabled: mergedDisabled,
		className: clsx(className, rootClassName, mergedClassNames.root, contextClassName, compactItemClassnames, getStatusClassNames(prefixCls, status, hasFeedback), {
			[`${prefixCls}-${variant}`]: enableVariantCls,
			[`${prefixCls}-lg`]: mergedSize === "large",
			[`${prefixCls}-sm`]: mergedSize === "small",
			[`${prefixCls}-rtl`]: direction === "rtl",
			[`${prefixCls}-in-form-item`]: isFormItemInput,
			[`${prefixCls}-without-controls`]: !mergedControls
		}),
		style: {
			...mergedStyles.root,
			...contextStyle,
			...style$1
		},
		upHandler: upIcon,
		downHandler: downIcon,
		prefixCls,
		readOnly,
		controls: controlsTemp,
		prefix: prefix$1,
		suffix: suffixNode || suffix,
		classNames: mergedClassNames,
		styles: mergedStyles,
		...others
	});
});
var InputNumber = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { addonBefore, addonAfter, prefixCls: customizePrefixCls, className, status: customStatus, rootClassName, ...rest } = props;
	const { getPrefixCls } = useComponentConfig("inputNumber");
	const prefixCls = getPrefixCls("input-number", customizePrefixCls);
	const { status: contextStatus } = import_react.useContext(FormItemInputContext);
	const mergedStatus = getMergedStatus(contextStatus, customStatus);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$36(prefixCls, rootCls);
	const hasLegacyAddon = addonBefore || addonAfter;
	{
		const typeWarning = devUseWarning("InputNumber");
		[
			["bordered", "variant"],
			["addonAfter", "Space.Compact"],
			["addonBefore", "Space.Compact"]
		].forEach(([prop, newProp]) => {
			typeWarning.deprecated(!(prop in props), prop, newProp);
		});
		typeWarning(!(props.type === "number" && props.changeOnWheel), "usage", "When `type=number` is used together with `changeOnWheel`, changeOnWheel may not work properly. Please delete `type=number` if it is not necessary.");
	}
	const inputNumberNode = /* @__PURE__ */ import_react.createElement(InternalInputNumber, {
		ref,
		...rest,
		prefixCls,
		status: mergedStatus,
		className: clsx(cssVarCls, rootCls, hashId, className),
		rootClassName: !hasLegacyAddon ? rootClassName : void 0
	});
	if (hasLegacyAddon) {
		const renderAddon = (node$1) => {
			if (!node$1) return null;
			return /* @__PURE__ */ import_react.createElement(Addon_default, {
				className: clsx(`${prefixCls}-addon`, cssVarCls, hashId),
				variant: props.variant,
				disabled: props.disabled,
				status: mergedStatus
			}, /* @__PURE__ */ import_react.createElement(ContextIsolator_default, { form: true }, node$1));
		};
		const addonBeforeNode = renderAddon(addonBefore);
		const addonAfterNode = renderAddon(addonAfter);
		return /* @__PURE__ */ import_react.createElement(Compact_default, { rootClassName }, addonBeforeNode, inputNumberNode, addonAfterNode);
	}
	return inputNumberNode;
});
var TypedInputNumber = InputNumber;
/** @private Internal Component. Do not use in your production. */
var PureInputNumber = (props) => /* @__PURE__ */ import_react.createElement(config_provider_default, { theme: { components: { InputNumber: { handleVisible: true } } } }, /* @__PURE__ */ import_react.createElement(InputNumber, { ...props }));
InternalInputNumber.displayName = "InternalInputNumber";
TypedInputNumber.displayName = "InputNumber";
TypedInputNumber._InternalPanelDoNotUseOrYouWillBeFired = PureInputNumber;
var input_number_default = TypedInputNumber;

//#endregion
//#region node_modules/antd/es/color-picker/components/ColorSteppers.js
var ColorSteppers = ({ prefixCls, min = 0, max = 100, value, onChange, className, formatter }) => {
	const colorSteppersPrefixCls = `${prefixCls}-steppers`;
	const [internalValue, setInternalValue] = (0, import_react.useState)(0);
	const stepValue = !Number.isNaN(value) ? value : internalValue;
	return /* @__PURE__ */ import_react.createElement(input_number_default, {
		className: clsx(colorSteppersPrefixCls, className),
		min,
		max,
		value: stepValue,
		formatter,
		size: "small",
		onChange: (step) => {
			setInternalValue(step || 0);
			onChange?.(step);
		}
	});
};
var ColorSteppers_default = ColorSteppers;

//#endregion
//#region node_modules/antd/es/color-picker/components/ColorAlphaInput.js
var ColorAlphaInput = ({ prefixCls, value, onChange }) => {
	const colorAlphaInputPrefixCls = `${prefixCls}-alpha-input`;
	const [internalValue, setInternalValue] = (0, import_react.useState)(() => generateColor(value || "#000"));
	const alphaValue = value || internalValue;
	const handleAlphaChange = (step) => {
		const hsba = alphaValue.toHsb();
		hsba.a = (step || 0) / 100;
		const genColor = generateColor(hsba);
		setInternalValue(genColor);
		onChange?.(genColor);
	};
	return /* @__PURE__ */ import_react.createElement(ColorSteppers_default, {
		value: getColorAlpha(alphaValue),
		prefixCls,
		formatter: (step) => `${step}%`,
		className: colorAlphaInputPrefixCls,
		onChange: handleAlphaChange
	});
};
var ColorAlphaInput_default = ColorAlphaInput;

//#endregion
//#region node_modules/@rc-component/input/es/utils/commonUtils.js
function hasAddon(props) {
	return !!(props.addonBefore || props.addonAfter);
}
function hasPrefixSuffix$1(props) {
	return !!(props.prefix || props.suffix || props.allowClear);
}
function cloneEvent(event, target, value) {
	const currentTarget = target.cloneNode(true);
	const newEvent = Object.create(event, {
		target: { value: currentTarget },
		currentTarget: { value: currentTarget }
	});
	currentTarget.value = value;
	if (typeof target.selectionStart === "number" && typeof target.selectionEnd === "number") {
		currentTarget.selectionStart = target.selectionStart;
		currentTarget.selectionEnd = target.selectionEnd;
	}
	currentTarget.setSelectionRange = (...args) => {
		target.setSelectionRange(...args);
	};
	return newEvent;
}
function resolveOnChange(target, e$2, onChange, targetValue) {
	if (!onChange) return;
	let event = e$2;
	if (e$2.type === "click") {
		event = cloneEvent(e$2, target, "");
		onChange(event);
		return;
	}
	if (target.type !== "file" && targetValue !== void 0) {
		event = cloneEvent(e$2, target, targetValue);
		onChange(event);
		return;
	}
	onChange(event);
}

//#endregion
//#region node_modules/@rc-component/input/es/BaseInput.js
function _extends$41() {
	_extends$41 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$41.apply(this, arguments);
}
var BaseInput = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { inputElement: inputEl, children, prefixCls, prefix: prefix$1, suffix, addonBefore, addonAfter, className, style: style$1, disabled, readOnly, focused, triggerFocus: triggerFocus$1, allowClear, value, handleReset, hidden, classes, classNames, dataAttrs, styles, components: components$1, onClear } = props;
	const inputElement = children ?? inputEl;
	const AffixWrapperComponent = components$1?.affixWrapper || "span";
	const GroupWrapperComponent = components$1?.groupWrapper || "span";
	const WrapperComponent = components$1?.wrapper || "span";
	const GroupAddonComponent = components$1?.groupAddon || "span";
	const containerRef = (0, import_react.useRef)(null);
	const onInputClick = (e$2) => {
		if (containerRef.current?.contains(e$2.target)) triggerFocus$1?.();
	};
	const hasAffix = hasPrefixSuffix$1(props);
	let element = /* @__PURE__ */ (0, import_react.cloneElement)(inputElement, {
		value,
		className: clsx(inputElement.props?.className, !hasAffix && classNames?.variant) || null
	});
	const groupRef = (0, import_react.useRef)(null);
	import_react.useImperativeHandle(ref, () => ({ nativeElement: groupRef.current || containerRef.current }));
	if (hasAffix) {
		let clearIcon = null;
		if (allowClear) {
			const needClear = !disabled && !readOnly && value;
			const clearIconCls = `${prefixCls}-clear-icon`;
			const iconNode = typeof allowClear === "object" && allowClear?.clearIcon ? allowClear.clearIcon : "";
			clearIcon = /* @__PURE__ */ import_react.createElement("button", {
				type: "button",
				tabIndex: -1,
				onClick: (event) => {
					handleReset?.(event);
					onClear?.();
				},
				onMouseDown: (e$2) => e$2.preventDefault(),
				className: clsx(clearIconCls, {
					[`${clearIconCls}-hidden`]: !needClear,
					[`${clearIconCls}-has-suffix`]: !!suffix
				})
			}, iconNode);
		}
		const affixWrapperPrefixCls = `${prefixCls}-affix-wrapper`;
		const affixWrapperCls = clsx(affixWrapperPrefixCls, {
			[`${prefixCls}-disabled`]: disabled,
			[`${affixWrapperPrefixCls}-disabled`]: disabled,
			[`${affixWrapperPrefixCls}-focused`]: focused,
			[`${affixWrapperPrefixCls}-readonly`]: readOnly,
			[`${affixWrapperPrefixCls}-input-with-clear-btn`]: suffix && allowClear && value
		}, classes?.affixWrapper, classNames?.affixWrapper, classNames?.variant);
		const suffixNode = (suffix || allowClear) && /* @__PURE__ */ import_react.createElement("span", {
			className: clsx(`${prefixCls}-suffix`, classNames?.suffix),
			style: styles?.suffix
		}, clearIcon, suffix);
		element = /* @__PURE__ */ import_react.createElement(AffixWrapperComponent, _extends$41({
			className: affixWrapperCls,
			style: styles?.affixWrapper,
			onClick: onInputClick
		}, dataAttrs?.affixWrapper, { ref: containerRef }), prefix$1 && /* @__PURE__ */ import_react.createElement("span", {
			className: clsx(`${prefixCls}-prefix`, classNames?.prefix),
			style: styles?.prefix
		}, prefix$1), element, suffixNode);
	}
	if (hasAddon(props)) {
		const wrapperCls = `${prefixCls}-group`;
		const addonCls = `${wrapperCls}-addon`;
		const groupWrapperCls = `${wrapperCls}-wrapper`;
		const mergedWrapperClassName = clsx(`${prefixCls}-wrapper`, wrapperCls, classes?.wrapper, classNames?.wrapper);
		const mergedGroupClassName = clsx(groupWrapperCls, { [`${groupWrapperCls}-disabled`]: disabled }, classes?.group, classNames?.groupWrapper);
		element = /* @__PURE__ */ import_react.createElement(GroupWrapperComponent, {
			className: mergedGroupClassName,
			ref: groupRef
		}, /* @__PURE__ */ import_react.createElement(WrapperComponent, { className: mergedWrapperClassName }, addonBefore && /* @__PURE__ */ import_react.createElement(GroupAddonComponent, { className: addonCls }, addonBefore), element, addonAfter && /* @__PURE__ */ import_react.createElement(GroupAddonComponent, { className: addonCls }, addonAfter)));
	}
	return /* @__PURE__ */ import_react.cloneElement(element, {
		className: clsx(element.props?.className, className) || null,
		style: {
			...element.props?.style,
			...style$1
		},
		hidden
	});
});
var BaseInput_default = BaseInput;

//#endregion
//#region node_modules/@rc-component/input/es/hooks/useCount.js
function useCount(count, showCount) {
	return import_react.useMemo(() => {
		let mergedConfig = {};
		if (showCount) mergedConfig.show = typeof showCount === "object" && showCount.formatter ? showCount.formatter : !!showCount;
		mergedConfig = {
			...mergedConfig,
			...count
		};
		const { show, ...rest } = mergedConfig;
		return {
			...rest,
			show: !!show,
			showFormatter: typeof show === "function" ? show : void 0,
			strategy: rest.strategy || ((value) => value.length)
		};
	}, [count, showCount]);
}

//#endregion
//#region node_modules/@rc-component/input/es/Input.js
function _extends$40() {
	_extends$40 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$40.apply(this, arguments);
}
var Input$2 = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	const { autoComplete, onChange, onFocus, onBlur, onPressEnter, onKeyDown: onKeyDown$1, onKeyUp, prefixCls = "rc-input", disabled, htmlSize, className, maxLength, suffix, showCount, count, type: type$2 = "text", classes, classNames, styles, onCompositionStart, onCompositionEnd, ...rest } = props;
	const [focused, setFocused] = (0, import_react.useState)(false);
	const compositionRef = (0, import_react.useRef)(false);
	const keyLockRef = (0, import_react.useRef)(false);
	const inputRef = (0, import_react.useRef)(null);
	const holderRef = (0, import_react.useRef)(null);
	const focus = (option) => {
		if (inputRef.current) triggerFocus(inputRef.current, option);
	};
	const [value, setValue] = useControlledState(props.defaultValue, props.value);
	const formatValue$1 = value === void 0 || value === null ? "" : String(value);
	const [selection, setSelection] = (0, import_react.useState)(null);
	const countConfig = useCount(count, showCount);
	const mergedMax = countConfig.max || maxLength;
	const valueLength = countConfig.strategy(formatValue$1);
	const isOutOfRange = !!mergedMax && valueLength > mergedMax;
	(0, import_react.useImperativeHandle)(ref, () => ({
		focus,
		blur: () => {
			inputRef.current?.blur();
		},
		setSelectionRange: (start, end, direction) => {
			inputRef.current?.setSelectionRange(start, end, direction);
		},
		select: () => {
			inputRef.current?.select();
		},
		input: inputRef.current,
		nativeElement: holderRef.current?.nativeElement || inputRef.current
	}));
	(0, import_react.useEffect)(() => {
		if (keyLockRef.current) keyLockRef.current = false;
		setFocused((prev$1) => prev$1 && disabled ? false : prev$1);
	}, [disabled]);
	const triggerChange = (e$2, currentValue, info) => {
		let cutValue = currentValue;
		if (!compositionRef.current && countConfig.exceedFormatter && countConfig.max && countConfig.strategy(currentValue) > countConfig.max) {
			cutValue = countConfig.exceedFormatter(currentValue, { max: countConfig.max });
			if (currentValue !== cutValue) setSelection([inputRef.current?.selectionStart || 0, inputRef.current?.selectionEnd || 0]);
		} else if (info.source === "compositionEnd") return;
		setValue(cutValue);
		if (inputRef.current) resolveOnChange(inputRef.current, e$2, onChange, cutValue);
	};
	(0, import_react.useEffect)(() => {
		if (selection) inputRef.current?.setSelectionRange(...selection);
	}, [selection]);
	const onInternalChange = (e$2) => {
		triggerChange(e$2, e$2.target.value, { source: "change" });
	};
	const onInternalCompositionEnd = (e$2) => {
		compositionRef.current = false;
		triggerChange(e$2, e$2.currentTarget.value, { source: "compositionEnd" });
		onCompositionEnd?.(e$2);
	};
	const handleKeyDown = (e$2) => {
		if (onPressEnter && e$2.key === "Enter" && !keyLockRef.current && !e$2.nativeEvent.isComposing) {
			keyLockRef.current = true;
			onPressEnter(e$2);
		}
		onKeyDown$1?.(e$2);
	};
	const handleKeyUp = (e$2) => {
		if (e$2.key === "Enter") keyLockRef.current = false;
		onKeyUp?.(e$2);
	};
	const handleFocus = (e$2) => {
		setFocused(true);
		onFocus?.(e$2);
	};
	const handleBlur = (e$2) => {
		if (keyLockRef.current) keyLockRef.current = false;
		setFocused(false);
		onBlur?.(e$2);
	};
	const handleReset = (e$2) => {
		setValue("");
		focus();
		if (inputRef.current) resolveOnChange(inputRef.current, e$2, onChange);
	};
	const outOfRangeCls = isOutOfRange && `${prefixCls}-out-of-range`;
	const getInputElement = () => {
		const otherProps = omit(props, [
			"prefixCls",
			"onPressEnter",
			"addonBefore",
			"addonAfter",
			"prefix",
			"suffix",
			"allowClear",
			"defaultValue",
			"showCount",
			"count",
			"classes",
			"htmlSize",
			"styles",
			"classNames",
			"onClear"
		]);
		return /* @__PURE__ */ import_react.createElement("input", _extends$40({ autoComplete }, otherProps, {
			onChange: onInternalChange,
			onFocus: handleFocus,
			onBlur: handleBlur,
			onKeyDown: handleKeyDown,
			onKeyUp: handleKeyUp,
			className: clsx(prefixCls, { [`${prefixCls}-disabled`]: disabled }, classNames?.input),
			style: styles?.input,
			ref: inputRef,
			size: htmlSize,
			type: type$2,
			onCompositionStart: (e$2) => {
				compositionRef.current = true;
				onCompositionStart?.(e$2);
			},
			onCompositionEnd: onInternalCompositionEnd
		}));
	};
	const getSuffix = () => {
		const hasMaxLength = Number(mergedMax) > 0;
		if (suffix || countConfig.show) {
			const dataCount = countConfig.showFormatter ? countConfig.showFormatter({
				value: formatValue$1,
				count: valueLength,
				maxLength: mergedMax
			}) : `${valueLength}${hasMaxLength ? ` / ${mergedMax}` : ""}`;
			return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, countConfig.show && /* @__PURE__ */ import_react.createElement("span", {
				className: clsx(`${prefixCls}-show-count-suffix`, { [`${prefixCls}-show-count-has-suffix`]: !!suffix }, classNames?.count),
				style: { ...styles?.count }
			}, dataCount), suffix);
		}
		return null;
	};
	return /* @__PURE__ */ import_react.createElement(BaseInput_default, _extends$40({}, rest, {
		prefixCls,
		className: clsx(className, outOfRangeCls),
		handleReset,
		value: formatValue$1,
		focused,
		triggerFocus: focus,
		suffix: getSuffix(),
		disabled,
		classes,
		classNames,
		styles,
		ref: holderRef
	}), getInputElement());
});
var Input_default$1 = Input$2;

//#endregion
//#region node_modules/@rc-component/input/es/index.js
var es_default$21 = Input_default$1;

//#endregion
//#region node_modules/antd/es/_util/getAllowClear.js
var getAllowClear = (allowClear) => {
	let mergedAllowClear;
	if (typeof allowClear === "object" && allowClear?.clearIcon) mergedAllowClear = allowClear;
	else if (allowClear) mergedAllowClear = { clearIcon: /* @__PURE__ */ import_react.createElement(CloseCircleFilled_default, null) };
	return mergedAllowClear;
};
var getAllowClear_default = getAllowClear;

//#endregion
//#region node_modules/antd/es/input/hooks/useRemovePasswordTimeout.js
function useRemovePasswordTimeout(inputRef, triggerOnMount) {
	const removePasswordTimeoutRef = (0, import_react.useRef)([]);
	const removePasswordTimeout = () => {
		removePasswordTimeoutRef.current.push(setTimeout(() => {
			if (inputRef.current?.input && inputRef.current?.input.getAttribute("type") === "password" && inputRef.current?.input.hasAttribute("value")) inputRef.current?.input.removeAttribute("value");
		}));
	};
	(0, import_react.useEffect)(() => {
		if (triggerOnMount) removePasswordTimeout();
		return () => removePasswordTimeoutRef.current.forEach((timer) => {
			if (timer) clearTimeout(timer);
		});
	}, []);
	return removePasswordTimeout;
}

//#endregion
//#region node_modules/antd/es/input/utils.js
function hasPrefixSuffix(props) {
	return !!(props.prefix || props.suffix || props.allowClear || props.showCount);
}

//#endregion
//#region node_modules/antd/es/input/Input.js
var Input$1 = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	const { prefixCls: customizePrefixCls, bordered = true, status: customStatus, size: customSize, disabled: customDisabled, onBlur, onFocus, suffix, allowClear, addonAfter, addonBefore, className, style: style$1, styles, rootClassName, onChange, classNames, variant: customVariant, ...rest } = props;
	{
		const { deprecated } = devUseWarning("Input");
		[
			["bordered", "variant"],
			["addonAfter", "Space.Compact"],
			["addonBefore", "Space.Compact"]
		].forEach(([prop, newProp]) => {
			deprecated(!(prop in props), prop, newProp);
		});
	}
	const { getPrefixCls, direction, allowClear: contextAllowClear, autoComplete: contextAutoComplete, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("input");
	const prefixCls = getPrefixCls("input", customizePrefixCls);
	const inputRef = (0, import_react.useRef)(null);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = useSharedStyle(prefixCls, rootClassName);
	style_default$25(prefixCls, rootCls);
	const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
	const mergedSize = useSize_default((ctx) => customSize ?? compactSize ?? ctx);
	const disabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = customDisabled ?? disabled;
	const mergedProps = {
		...props,
		size: mergedSize,
		disabled: mergedDisabled
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const { status: contextStatus, hasFeedback, feedbackIcon } = (0, import_react.useContext)(FormItemInputContext);
	const mergedStatus = getMergedStatus(contextStatus, customStatus);
	const inputHasPrefixSuffix = hasPrefixSuffix(props) || !!hasFeedback;
	const prevHasPrefixSuffix = (0, import_react.useRef)(inputHasPrefixSuffix);
	{
		const warning$3 = devUseWarning("Input");
		(0, import_react.useEffect)(() => {
			if (inputHasPrefixSuffix && !prevHasPrefixSuffix.current) warning$3(document.activeElement === inputRef.current?.input, "usage", `When Input is focused, dynamic add or remove prefix / suffix will make it lose focus caused by dom structure change. Read more: https://ant.design/components/input/#FAQ`);
			prevHasPrefixSuffix.current = inputHasPrefixSuffix;
		}, [inputHasPrefixSuffix]);
	}
	const removePasswordTimeout = useRemovePasswordTimeout(inputRef, true);
	const handleBlur = (e$2) => {
		removePasswordTimeout();
		onBlur?.(e$2);
	};
	const handleFocus = (e$2) => {
		removePasswordTimeout();
		onFocus?.(e$2);
	};
	const handleChange = (e$2) => {
		removePasswordTimeout();
		onChange?.(e$2);
	};
	const suffixNode = (hasFeedback || suffix) && /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, suffix, hasFeedback && feedbackIcon);
	const mergedAllowClear = getAllowClear_default(allowClear ?? contextAllowClear);
	const [variant, enableVariantCls] = useVariants_default("input", customVariant, bordered);
	return /* @__PURE__ */ import_react.createElement(es_default$21, {
		ref: composeRef(ref, inputRef),
		prefixCls,
		autoComplete: contextAutoComplete,
		...rest,
		disabled: mergedDisabled,
		onBlur: handleBlur,
		onFocus: handleFocus,
		style: {
			...mergedStyles.root,
			...contextStyle,
			...style$1
		},
		styles: mergedStyles,
		suffix: suffixNode,
		allowClear: mergedAllowClear,
		className: clsx(className, rootClassName, cssVarCls, rootCls, compactItemClassnames, contextClassName, mergedClassNames.root),
		onChange: handleChange,
		addonBefore: addonBefore && /* @__PURE__ */ import_react.createElement(ContextIsolator_default, {
			form: true,
			space: true
		}, addonBefore),
		addonAfter: addonAfter && /* @__PURE__ */ import_react.createElement(ContextIsolator_default, {
			form: true,
			space: true
		}, addonAfter),
		classNames: {
			...mergedClassNames,
			input: clsx({
				[`${prefixCls}-sm`]: mergedSize === "small",
				[`${prefixCls}-lg`]: mergedSize === "large",
				[`${prefixCls}-rtl`]: direction === "rtl"
			}, mergedClassNames.input, hashId),
			variant: clsx({ [`${prefixCls}-${variant}`]: enableVariantCls }, getStatusClassNames(prefixCls, mergedStatus)),
			affixWrapper: clsx({
				[`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
				[`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
				[`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl"
			}, hashId),
			wrapper: clsx({ [`${prefixCls}-group-rtl`]: direction === "rtl" }, hashId),
			groupWrapper: clsx({
				[`${prefixCls}-group-wrapper-sm`]: mergedSize === "small",
				[`${prefixCls}-group-wrapper-lg`]: mergedSize === "large",
				[`${prefixCls}-group-wrapper-rtl`]: direction === "rtl",
				[`${prefixCls}-group-wrapper-${variant}`]: enableVariantCls
			}, getStatusClassNames(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback), hashId)
		}
	});
});
Input$1.displayName = "Input";
var Input_default = Input$1;

//#endregion
//#region node_modules/antd/es/color-picker/components/ColorHexInput.js
var hexReg = /(^#[\da-f]{6}$)|(^#[\da-f]{8}$)/i;
var isHexString = (hex) => hexReg.test(`#${hex}`);
var ColorHexInput = ({ prefixCls, value, onChange }) => {
	const colorHexInputPrefixCls = `${prefixCls}-hex-input`;
	const [hexValue, setHexValue] = (0, import_react.useState)(() => value ? toHexFormat(value.toHexString()) : void 0);
	(0, import_react.useEffect)(() => {
		if (value) setHexValue(toHexFormat(value.toHexString()));
	}, [value]);
	const handleHexChange = (e$2) => {
		const originValue = e$2.target.value;
		setHexValue(toHexFormat(originValue));
		if (isHexString(toHexFormat(originValue, true))) onChange?.(generateColor(originValue));
	};
	return /* @__PURE__ */ import_react.createElement(Input_default, {
		className: colorHexInputPrefixCls,
		value: hexValue,
		prefix: "#",
		onChange: handleHexChange,
		size: "small"
	});
};
var ColorHexInput_default = ColorHexInput;

//#endregion
//#region node_modules/antd/es/color-picker/components/ColorHsbInput.js
var ColorHsbInput = ({ prefixCls, value, onChange }) => {
	const colorHsbInputPrefixCls = `${prefixCls}-hsb-input`;
	const [internalValue, setInternalValue] = (0, import_react.useState)(() => generateColor(value || "#000"));
	const hsbValue = value || internalValue;
	const handleHsbChange = (step, type$2) => {
		const hsb = hsbValue.toHsb();
		hsb[type$2] = type$2 === "h" ? step : (step || 0) / 100;
		const genColor = generateColor(hsb);
		setInternalValue(genColor);
		onChange?.(genColor);
	};
	return /* @__PURE__ */ import_react.createElement("div", { className: colorHsbInputPrefixCls }, /* @__PURE__ */ import_react.createElement(ColorSteppers_default, {
		max: 360,
		min: 0,
		value: Number(hsbValue.toHsb().h),
		prefixCls,
		className: colorHsbInputPrefixCls,
		formatter: (step) => getRoundNumber(step || 0).toString(),
		onChange: (step) => handleHsbChange(Number(step), "h")
	}), /* @__PURE__ */ import_react.createElement(ColorSteppers_default, {
		max: 100,
		min: 0,
		value: Number(hsbValue.toHsb().s) * 100,
		prefixCls,
		className: colorHsbInputPrefixCls,
		formatter: (step) => `${getRoundNumber(step || 0)}%`,
		onChange: (step) => handleHsbChange(Number(step), "s")
	}), /* @__PURE__ */ import_react.createElement(ColorSteppers_default, {
		max: 100,
		min: 0,
		value: Number(hsbValue.toHsb().b) * 100,
		prefixCls,
		className: colorHsbInputPrefixCls,
		formatter: (step) => `${getRoundNumber(step || 0)}%`,
		onChange: (step) => handleHsbChange(Number(step), "b")
	}));
};
var ColorHsbInput_default = ColorHsbInput;

//#endregion
//#region node_modules/antd/es/color-picker/components/ColorRgbInput.js
var ColorRgbInput = ({ prefixCls, value, onChange }) => {
	const colorRgbInputPrefixCls = `${prefixCls}-rgb-input`;
	const [internalValue, setInternalValue] = (0, import_react.useState)(() => generateColor(value || "#000"));
	const rgbValue = value || internalValue;
	const handleRgbChange = (step, type$2) => {
		const rgb = rgbValue.toRgb();
		rgb[type$2] = step || 0;
		const genColor = generateColor(rgb);
		setInternalValue(genColor);
		onChange?.(genColor);
	};
	return /* @__PURE__ */ import_react.createElement("div", { className: colorRgbInputPrefixCls }, /* @__PURE__ */ import_react.createElement(ColorSteppers_default, {
		max: 255,
		min: 0,
		value: Number(rgbValue.toRgb().r),
		prefixCls,
		className: colorRgbInputPrefixCls,
		onChange: (step) => handleRgbChange(Number(step), "r")
	}), /* @__PURE__ */ import_react.createElement(ColorSteppers_default, {
		max: 255,
		min: 0,
		value: Number(rgbValue.toRgb().g),
		prefixCls,
		className: colorRgbInputPrefixCls,
		onChange: (step) => handleRgbChange(Number(step), "g")
	}), /* @__PURE__ */ import_react.createElement(ColorSteppers_default, {
		max: 255,
		min: 0,
		value: Number(rgbValue.toRgb().b),
		prefixCls,
		className: colorRgbInputPrefixCls,
		onChange: (step) => handleRgbChange(Number(step), "b")
	}));
};
var ColorRgbInput_default = ColorRgbInput;

//#endregion
//#region node_modules/antd/es/color-picker/components/ColorInput.js
var selectOptions = [
	FORMAT_HEX,
	FORMAT_HSB,
	FORMAT_RGB
].map((format$1) => ({
	value: format$1,
	label: format$1.toUpperCase()
}));
var ColorInput = (props) => {
	const { prefixCls, format: format$1, value, disabledAlpha, onFormatChange, onChange, disabledFormat } = props;
	const [colorFormat, setColorFormat] = useControlledState(FORMAT_HEX, format$1);
	const colorInputPrefixCls = `${prefixCls}-input`;
	const triggerFormatChange = (newFormat) => {
		setColorFormat(newFormat);
		onFormatChange?.(newFormat);
	};
	const steppersNode = (0, import_react.useMemo)(() => {
		const inputProps = {
			value,
			prefixCls,
			onChange
		};
		switch (colorFormat) {
			case FORMAT_HSB: return /* @__PURE__ */ import_react.createElement(ColorHsbInput_default, { ...inputProps });
			case FORMAT_RGB: return /* @__PURE__ */ import_react.createElement(ColorRgbInput_default, { ...inputProps });
			default: return /* @__PURE__ */ import_react.createElement(ColorHexInput_default, { ...inputProps });
		}
	}, [
		colorFormat,
		prefixCls,
		value,
		onChange
	]);
	return /* @__PURE__ */ import_react.createElement("div", { className: `${colorInputPrefixCls}-container` }, !disabledFormat && /* @__PURE__ */ import_react.createElement(select_default, {
		value: colorFormat,
		variant: "borderless",
		getPopupContainer: (current) => current,
		popupMatchSelectWidth: 68,
		placement: "bottomRight",
		onChange: triggerFormatChange,
		className: `${prefixCls}-format-select`,
		size: "small",
		options: selectOptions
	}), /* @__PURE__ */ import_react.createElement("div", { className: colorInputPrefixCls }, steppersNode), !disabledAlpha && /* @__PURE__ */ import_react.createElement(ColorAlphaInput_default, {
		prefixCls,
		value,
		onChange
	}));
};
var ColorInput_default = ColorInput;

//#endregion
//#region node_modules/@rc-component/slider/es/util.js
function getOffset$1(value, min, max) {
	return (value - min) / (max - min);
}
function getDirectionStyle(direction, value, min, max) {
	const offset$2 = getOffset$1(value, min, max);
	const positionStyle = {};
	switch (direction) {
		case "rtl":
			positionStyle.right = `${offset$2 * 100}%`;
			positionStyle.transform = "translateX(50%)";
			break;
		case "btt":
			positionStyle.bottom = `${offset$2 * 100}%`;
			positionStyle.transform = "translateY(50%)";
			break;
		case "ttb":
			positionStyle.top = `${offset$2 * 100}%`;
			positionStyle.transform = "translateY(-50%)";
			break;
		default:
			positionStyle.left = `${offset$2 * 100}%`;
			positionStyle.transform = "translateX(-50%)";
			break;
	}
	return positionStyle;
}
/** Return index value if is list or return value directly */
function getIndex(value, index$1) {
	return Array.isArray(value) ? value[index$1] : value;
}

//#endregion
//#region node_modules/@rc-component/slider/es/context.js
var SliderContext = /* @__PURE__ */ import_react.createContext({
	min: 0,
	max: 0,
	direction: "ltr",
	step: 1,
	includedStart: 0,
	includedEnd: 0,
	tabIndex: 0,
	keyboard: true,
	styles: {},
	classNames: {}
});
var context_default$2 = SliderContext;
/** @private NOT PROMISE AVAILABLE. DO NOT USE IN PRODUCTION. */
const UnstableContext$3 = /* @__PURE__ */ import_react.createContext({});

//#endregion
//#region node_modules/@rc-component/slider/es/Handles/Handle.js
function _extends$39() {
	_extends$39 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$39.apply(this, arguments);
}
var Handle = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls, value, valueIndex, onStartMove, onDelete, style: style$1, render: render$1, dragging, draggingDelete, onOffsetChange, onChangeComplete, onFocus, onMouseEnter, ...restProps } = props;
	const { min, max, direction, disabled, keyboard, range: range$1, tabIndex, ariaLabelForHandle, ariaLabelledByForHandle, ariaRequired, ariaValueTextFormatterForHandle, styles, classNames } = import_react.useContext(context_default$2);
	const handlePrefixCls = `${prefixCls}-handle`;
	const onInternalStartMove = (e$2) => {
		if (!disabled) onStartMove(e$2, valueIndex);
	};
	const onInternalFocus = (e$2) => {
		onFocus?.(e$2, valueIndex);
	};
	const onInternalMouseEnter = (e$2) => {
		onMouseEnter(e$2, valueIndex);
	};
	const onKeyDown$1 = (e$2) => {
		if (!disabled && keyboard) {
			let offset$2 = null;
			switch (e$2.which || e$2.keyCode) {
				case KeyCode_default.LEFT:
					offset$2 = direction === "ltr" || direction === "btt" ? -1 : 1;
					break;
				case KeyCode_default.RIGHT:
					offset$2 = direction === "ltr" || direction === "btt" ? 1 : -1;
					break;
				case KeyCode_default.UP:
					offset$2 = direction !== "ttb" ? 1 : -1;
					break;
				case KeyCode_default.DOWN:
					offset$2 = direction !== "ttb" ? -1 : 1;
					break;
				case KeyCode_default.HOME:
					offset$2 = "min";
					break;
				case KeyCode_default.END:
					offset$2 = "max";
					break;
				case KeyCode_default.PAGE_UP:
					offset$2 = 2;
					break;
				case KeyCode_default.PAGE_DOWN:
					offset$2 = -2;
					break;
				case KeyCode_default.BACKSPACE:
				case KeyCode_default.DELETE:
					onDelete?.(valueIndex);
					break;
			}
			if (offset$2 !== null) {
				e$2.preventDefault();
				onOffsetChange(offset$2, valueIndex);
			}
		}
	};
	const handleKeyUp = (e$2) => {
		switch (e$2.which || e$2.keyCode) {
			case KeyCode_default.LEFT:
			case KeyCode_default.RIGHT:
			case KeyCode_default.UP:
			case KeyCode_default.DOWN:
			case KeyCode_default.HOME:
			case KeyCode_default.END:
			case KeyCode_default.PAGE_UP:
			case KeyCode_default.PAGE_DOWN:
				onChangeComplete?.();
				break;
		}
	};
	const positionStyle = getDirectionStyle(direction, value, min, max);
	let divProps = {};
	if (valueIndex !== null) divProps = {
		tabIndex: disabled ? null : getIndex(tabIndex, valueIndex),
		role: "slider",
		"aria-valuemin": min,
		"aria-valuemax": max,
		"aria-valuenow": value,
		"aria-disabled": disabled,
		"aria-label": getIndex(ariaLabelForHandle, valueIndex),
		"aria-labelledby": getIndex(ariaLabelledByForHandle, valueIndex),
		"aria-required": getIndex(ariaRequired, valueIndex),
		"aria-valuetext": getIndex(ariaValueTextFormatterForHandle, valueIndex)?.(value),
		"aria-orientation": direction === "ltr" || direction === "rtl" ? "horizontal" : "vertical",
		onMouseDown: onInternalStartMove,
		onTouchStart: onInternalStartMove,
		onFocus: onInternalFocus,
		onMouseEnter: onInternalMouseEnter,
		onKeyDown: onKeyDown$1,
		onKeyUp: handleKeyUp
	};
	let handleNode = /* @__PURE__ */ import_react.createElement("div", _extends$39({
		ref,
		className: clsx(handlePrefixCls, {
			[`${handlePrefixCls}-${valueIndex + 1}`]: valueIndex !== null && range$1,
			[`${handlePrefixCls}-dragging`]: dragging,
			[`${handlePrefixCls}-dragging-delete`]: draggingDelete
		}, classNames.handle),
		style: {
			...positionStyle,
			...style$1,
			...styles.handle
		}
	}, divProps, restProps));
	if (render$1) handleNode = render$1(handleNode, {
		index: valueIndex,
		prefixCls,
		value,
		dragging,
		draggingDelete
	});
	return handleNode;
});
Handle.displayName = "Handle";
var Handle_default = Handle;

//#endregion
//#region node_modules/@rc-component/slider/es/Handles/index.js
var import_react_dom$2 = require_react_dom();
function _extends$38() {
	_extends$38 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$38.apply(this, arguments);
}
var Handles = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls, style: style$1, onStartMove, onOffsetChange, values, handleRender, activeHandleRender, draggingIndex, draggingDelete, onFocus, ...restProps } = props;
	const handlesRef = import_react.useRef({});
	const [activeVisible, setActiveVisible] = import_react.useState(false);
	const [activeIndex, setActiveIndex] = import_react.useState(-1);
	const onActive = (index$1) => {
		setActiveIndex(index$1);
		setActiveVisible(true);
	};
	const onHandleFocus = (e$2, index$1) => {
		onActive(index$1);
		onFocus?.(e$2);
	};
	const onHandleMouseEnter = (e$2, index$1) => {
		onActive(index$1);
	};
	import_react.useImperativeHandle(ref, () => ({
		focus: (index$1) => {
			handlesRef.current[index$1]?.focus();
		},
		hideHelp: () => {
			(0, import_react_dom$2.flushSync)(() => {
				setActiveVisible(false);
			});
		}
	}));
	const handleProps = {
		prefixCls,
		onStartMove,
		onOffsetChange,
		render: handleRender,
		onFocus: onHandleFocus,
		onMouseEnter: onHandleMouseEnter,
		...restProps
	};
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, values.map((value, index$1) => {
		const dragging = draggingIndex === index$1;
		return /* @__PURE__ */ import_react.createElement(Handle_default, _extends$38({
			ref: (node$1) => {
				if (!node$1) delete handlesRef.current[index$1];
				else handlesRef.current[index$1] = node$1;
			},
			dragging,
			draggingDelete: dragging && draggingDelete,
			style: getIndex(style$1, index$1),
			key: index$1,
			value,
			valueIndex: index$1
		}, handleProps));
	}), activeHandleRender && activeVisible && /* @__PURE__ */ import_react.createElement(Handle_default, _extends$38({ key: "a11y" }, handleProps, {
		value: values[activeIndex],
		valueIndex: null,
		dragging: draggingIndex !== -1,
		draggingDelete,
		render: activeHandleRender,
		style: { pointerEvents: "none" },
		tabIndex: null,
		"aria-hidden": true
	})));
});
Handles.displayName = "Handles";
var Handles_default = Handles;

//#endregion
//#region node_modules/@rc-component/slider/es/Marks/Mark.js
var Mark = (props) => {
	const { prefixCls, style: style$1, children, value, onClick } = props;
	const { min, max, direction, includedStart, includedEnd, included } = import_react.useContext(context_default$2);
	const textCls = `${prefixCls}-text`;
	const positionStyle = getDirectionStyle(direction, value, min, max);
	return /* @__PURE__ */ import_react.createElement("span", {
		className: clsx(textCls, { [`${textCls}-active`]: included && includedStart <= value && value <= includedEnd }),
		style: {
			...positionStyle,
			...style$1
		},
		onMouseDown: (e$2) => {
			e$2.stopPropagation();
		},
		onClick: () => {
			onClick(value);
		}
	}, children);
};
var Mark_default = Mark;

//#endregion
//#region node_modules/@rc-component/slider/es/Marks/index.js
var Marks = (props) => {
	const { prefixCls, marks, onClick } = props;
	const markPrefixCls = `${prefixCls}-mark`;
	if (!marks.length) return null;
	return /* @__PURE__ */ import_react.createElement("div", { className: markPrefixCls }, marks.map(({ value, style: style$1, label }) => /* @__PURE__ */ import_react.createElement(Mark_default, {
		key: value,
		prefixCls: markPrefixCls,
		style: style$1,
		value,
		onClick
	}, label)));
};
var Marks_default = Marks;

//#endregion
//#region node_modules/@rc-component/slider/es/Steps/Dot.js
var Dot = (props) => {
	const { prefixCls, value, style: style$1, activeStyle } = props;
	const { min, max, direction, included, includedStart, includedEnd } = import_react.useContext(context_default$2);
	const dotClassName = `${prefixCls}-dot`;
	const active = included && includedStart <= value && value <= includedEnd;
	let mergedStyle = {
		...getDirectionStyle(direction, value, min, max),
		...typeof style$1 === "function" ? style$1(value) : style$1
	};
	if (active) mergedStyle = {
		...mergedStyle,
		...typeof activeStyle === "function" ? activeStyle(value) : activeStyle
	};
	return /* @__PURE__ */ import_react.createElement("span", {
		className: clsx(dotClassName, { [`${dotClassName}-active`]: active }),
		style: mergedStyle
	});
};
var Dot_default = Dot;

//#endregion
//#region node_modules/@rc-component/slider/es/Steps/index.js
var Steps$3 = (props) => {
	const { prefixCls, marks, dots, style: style$1, activeStyle } = props;
	const { min, max, step } = import_react.useContext(context_default$2);
	const stepDots = import_react.useMemo(() => {
		const dotSet = /* @__PURE__ */ new Set();
		marks.forEach((mark) => {
			dotSet.add(mark.value);
		});
		if (dots && step !== null) {
			let current = min;
			while (current <= max) {
				dotSet.add(current);
				current += step;
			}
		}
		return Array.from(dotSet);
	}, [
		min,
		max,
		step,
		dots,
		marks
	]);
	return /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-step` }, stepDots.map((dotValue) => /* @__PURE__ */ import_react.createElement(Dot_default, {
		prefixCls,
		key: dotValue,
		value: dotValue,
		style: style$1,
		activeStyle
	})));
};
var Steps_default$1 = Steps$3;

//#endregion
//#region node_modules/@rc-component/slider/es/Tracks/Track.js
var Track = (props) => {
	const { prefixCls, style: style$1, start, end, index: index$1, onStartMove, replaceCls } = props;
	const { direction, min, max, disabled, range: range$1, classNames } = import_react.useContext(context_default$2);
	const trackPrefixCls = `${prefixCls}-track`;
	const offsetStart = getOffset$1(start, min, max);
	const offsetEnd = getOffset$1(end, min, max);
	const onInternalStartMove = (e$2) => {
		if (!disabled && onStartMove) onStartMove(e$2, -1);
	};
	const positionStyle = {};
	switch (direction) {
		case "rtl":
			positionStyle.right = `${offsetStart * 100}%`;
			positionStyle.width = `${offsetEnd * 100 - offsetStart * 100}%`;
			break;
		case "btt":
			positionStyle.bottom = `${offsetStart * 100}%`;
			positionStyle.height = `${offsetEnd * 100 - offsetStart * 100}%`;
			break;
		case "ttb":
			positionStyle.top = `${offsetStart * 100}%`;
			positionStyle.height = `${offsetEnd * 100 - offsetStart * 100}%`;
			break;
		default:
			positionStyle.left = `${offsetStart * 100}%`;
			positionStyle.width = `${offsetEnd * 100 - offsetStart * 100}%`;
	}
	const className = replaceCls || clsx(trackPrefixCls, {
		[`${trackPrefixCls}-${index$1 + 1}`]: index$1 !== null && range$1,
		[`${prefixCls}-track-draggable`]: onStartMove
	}, classNames.track);
	return /* @__PURE__ */ import_react.createElement("div", {
		className,
		style: {
			...positionStyle,
			...style$1
		},
		onMouseDown: onInternalStartMove,
		onTouchStart: onInternalStartMove
	});
};
var Track_default = Track;

//#endregion
//#region node_modules/@rc-component/slider/es/Tracks/index.js
var Tracks = (props) => {
	const { prefixCls, style: style$1, values, startPoint, onStartMove } = props;
	const { included, range: range$1, min, styles, classNames } = import_react.useContext(context_default$2);
	const trackList = import_react.useMemo(() => {
		if (!range$1) {
			if (values.length === 0) return [];
			const startValue = startPoint ?? min;
			const endValue = values[0];
			return [{
				start: Math.min(startValue, endValue),
				end: Math.max(startValue, endValue)
			}];
		}
		const list = [];
		for (let i = 0; i < values.length - 1; i += 1) list.push({
			start: values[i],
			end: values[i + 1]
		});
		return list;
	}, [
		values,
		range$1,
		startPoint,
		min
	]);
	if (!included) return null;
	const tracksNode = trackList?.length && (classNames.tracks || styles.tracks) ? /* @__PURE__ */ import_react.createElement(Track_default, {
		index: null,
		prefixCls,
		start: trackList[0].start,
		end: trackList[trackList.length - 1].end,
		replaceCls: clsx(classNames.tracks, `${prefixCls}-tracks`),
		style: styles.tracks
	}) : null;
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, tracksNode, trackList.map(({ start, end }, index$1) => /* @__PURE__ */ import_react.createElement(Track_default, {
		index: index$1,
		prefixCls,
		style: {
			...getIndex(style$1, index$1),
			...styles.track
		},
		start,
		end,
		key: index$1,
		onStartMove
	})));
};
var Tracks_default = Tracks;

//#endregion
//#region node_modules/@rc-component/slider/es/hooks/useDrag.js
/** Drag to delete offset. It's a user experience number for dragging out */
var REMOVE_DIST = 130;
function getPosition(e$2) {
	const obj = "targetTouches" in e$2 ? e$2.targetTouches[0] : e$2;
	return {
		pageX: obj.pageX,
		pageY: obj.pageY
	};
}
function useDrag$1(containerRef, direction, rawValues, min, max, formatValue$1, triggerChange, finishChange, offsetValues, editable, minCount) {
	const [draggingValue, setDraggingValue] = import_react.useState(null);
	const [draggingIndex, setDraggingIndex] = import_react.useState(-1);
	const [draggingDelete, setDraggingDelete] = import_react.useState(false);
	const [cacheValues, setCacheValues] = import_react.useState(rawValues);
	const [originValues, setOriginValues] = import_react.useState(rawValues);
	const mouseMoveEventRef = import_react.useRef(null);
	const mouseUpEventRef = import_react.useRef(null);
	const touchEventTargetRef = import_react.useRef(null);
	const { onDragStart, onDragChange } = import_react.useContext(UnstableContext$3);
	useLayoutEffect_default(() => {
		if (draggingIndex === -1) setCacheValues(rawValues);
	}, [rawValues, draggingIndex]);
	import_react.useEffect(() => () => {
		document.removeEventListener("mousemove", mouseMoveEventRef.current);
		document.removeEventListener("mouseup", mouseUpEventRef.current);
		if (touchEventTargetRef.current) {
			touchEventTargetRef.current.removeEventListener("touchmove", mouseMoveEventRef.current);
			touchEventTargetRef.current.removeEventListener("touchend", mouseUpEventRef.current);
		}
	}, []);
	const flushValues = (nextValues, nextValue, deleteMark) => {
		if (nextValue !== void 0) setDraggingValue(nextValue);
		setCacheValues(nextValues);
		let changeValues = nextValues;
		if (deleteMark) changeValues = nextValues.filter((_, i) => i !== draggingIndex);
		triggerChange(changeValues);
		if (onDragChange) onDragChange({
			rawValues: nextValues,
			deleteIndex: deleteMark ? draggingIndex : -1,
			draggingIndex,
			draggingValue: nextValue
		});
	};
	const updateCacheValue = useEvent_default((valueIndex, offsetPercent, deleteMark) => {
		if (valueIndex === -1) {
			const startValue = originValues[0];
			const endValue = originValues[originValues.length - 1];
			const maxStartOffset = min - startValue;
			const maxEndOffset = max - endValue;
			let offset$2 = offsetPercent * (max - min);
			offset$2 = Math.max(offset$2, maxStartOffset);
			offset$2 = Math.min(offset$2, maxEndOffset);
			offset$2 = formatValue$1(startValue + offset$2) - startValue;
			flushValues(originValues.map((val) => val + offset$2));
		} else {
			const offsetDist = (max - min) * offsetPercent;
			const cloneValues = [...cacheValues];
			cloneValues[valueIndex] = originValues[valueIndex];
			const next$1 = offsetValues(cloneValues, offsetDist, valueIndex, "dist");
			flushValues(next$1.values, next$1.value, deleteMark);
		}
	});
	const onStartMove = (e$2, valueIndex, startValues) => {
		e$2.stopPropagation();
		const initialValues = startValues || rawValues;
		const originValue = initialValues[valueIndex];
		setDraggingIndex(valueIndex);
		setDraggingValue(originValue);
		setOriginValues(initialValues);
		setCacheValues(initialValues);
		setDraggingDelete(false);
		const { pageX: startX, pageY: startY } = getPosition(e$2);
		let deleteMark = false;
		if (onDragStart) onDragStart({
			rawValues: initialValues,
			draggingIndex: valueIndex,
			draggingValue: originValue
		});
		const onMouseMove = (event) => {
			event.preventDefault();
			const { pageX: moveX, pageY: moveY } = getPosition(event);
			const offsetX = moveX - startX;
			const offsetY = moveY - startY;
			const { width, height } = containerRef.current.getBoundingClientRect();
			let offSetPercent;
			let removeDist;
			switch (direction) {
				case "btt":
					offSetPercent = -offsetY / height;
					removeDist = offsetX;
					break;
				case "ttb":
					offSetPercent = offsetY / height;
					removeDist = offsetX;
					break;
				case "rtl":
					offSetPercent = -offsetX / width;
					removeDist = offsetY;
					break;
				default:
					offSetPercent = offsetX / width;
					removeDist = offsetY;
			}
			deleteMark = editable ? Math.abs(removeDist) > REMOVE_DIST && minCount < cacheValues.length : false;
			setDraggingDelete(deleteMark);
			updateCacheValue(valueIndex, offSetPercent, deleteMark);
		};
		const onMouseUp = (event) => {
			event.preventDefault();
			document.removeEventListener("mouseup", onMouseUp);
			document.removeEventListener("mousemove", onMouseMove);
			if (touchEventTargetRef.current) {
				touchEventTargetRef.current.removeEventListener("touchmove", mouseMoveEventRef.current);
				touchEventTargetRef.current.removeEventListener("touchend", mouseUpEventRef.current);
			}
			mouseMoveEventRef.current = null;
			mouseUpEventRef.current = null;
			touchEventTargetRef.current = null;
			finishChange(deleteMark);
			setDraggingIndex(-1);
			setDraggingDelete(false);
		};
		document.addEventListener("mouseup", onMouseUp);
		document.addEventListener("mousemove", onMouseMove);
		e$2.currentTarget.addEventListener("touchend", onMouseUp);
		e$2.currentTarget.addEventListener("touchmove", onMouseMove);
		mouseMoveEventRef.current = onMouseMove;
		mouseUpEventRef.current = onMouseUp;
		touchEventTargetRef.current = e$2.currentTarget;
	};
	return [
		draggingIndex,
		draggingValue,
		draggingDelete,
		import_react.useMemo(() => {
			const sourceValues = [...rawValues].sort((a, b) => a - b);
			const targetValues = [...cacheValues].sort((a, b) => a - b);
			const counts = {};
			targetValues.forEach((val) => {
				counts[val] = (counts[val] || 0) + 1;
			});
			sourceValues.forEach((val) => {
				counts[val] = (counts[val] || 0) - 1;
			});
			const maxDiffCount = editable ? 1 : 0;
			return Object.values(counts).reduce((prev$1, next$1) => prev$1 + Math.abs(next$1), 0) <= maxDiffCount ? cacheValues : rawValues;
		}, [
			rawValues,
			cacheValues,
			editable
		]),
		onStartMove
	];
}
var useDrag_default = useDrag$1;

//#endregion
//#region node_modules/@rc-component/slider/es/hooks/useOffset.js
/** Format the value in the range of [min, max] */
/** Format value align with step */
/** Format value align with step & marks */
function useOffset(min, max, step, markList, allowCross, pushable) {
	const formatRangeValue = import_react.useCallback((val) => Math.max(min, Math.min(max, val)), [min, max]);
	const formatStepValue = import_react.useCallback((val) => {
		if (step !== null) {
			const stepValue = min + Math.round((formatRangeValue(val) - min) / step) * step;
			const getDecimal = (num) => (String(num).split(".")[1] || "").length;
			const maxDecimal = Math.max(getDecimal(step), getDecimal(max), getDecimal(min));
			const fixedValue = Number(stepValue.toFixed(maxDecimal));
			return min <= fixedValue && fixedValue <= max ? fixedValue : null;
		}
		return null;
	}, [
		step,
		min,
		max,
		formatRangeValue
	]);
	const formatValue$1 = import_react.useCallback((val) => {
		const formatNextValue = formatRangeValue(val);
		const alignValues = markList.map((mark) => mark.value);
		if (step !== null) alignValues.push(formatStepValue(val));
		alignValues.push(min, max);
		let closeValue = alignValues[0];
		let closeDist = max - min;
		alignValues.forEach((alignValue) => {
			const dist = Math.abs(formatNextValue - alignValue);
			if (dist <= closeDist) {
				closeValue = alignValue;
				closeDist = dist;
			}
		});
		return closeValue;
	}, [
		min,
		max,
		markList,
		step,
		formatRangeValue,
		formatStepValue
	]);
	const offsetValue = (values, offset$2, valueIndex, mode = "unit") => {
		if (typeof offset$2 === "number") {
			let nextValue;
			const originValue = values[valueIndex];
			const targetDistValue = originValue + offset$2;
			let potentialValues = [];
			markList.forEach((mark) => {
				potentialValues.push(mark.value);
			});
			potentialValues.push(min, max);
			potentialValues.push(formatStepValue(originValue));
			const sign = offset$2 > 0 ? 1 : -1;
			if (mode === "unit") potentialValues.push(formatStepValue(originValue + sign * step));
			else potentialValues.push(formatStepValue(targetDistValue));
			potentialValues = potentialValues.filter((val) => val !== null).filter((val) => offset$2 < 0 ? val <= originValue : val >= originValue);
			if (mode === "unit") potentialValues = potentialValues.filter((val) => val !== originValue);
			const compareValue = mode === "unit" ? originValue : targetDistValue;
			nextValue = potentialValues[0];
			let valueDist = Math.abs(nextValue - compareValue);
			potentialValues.forEach((potentialValue) => {
				const dist = Math.abs(potentialValue - compareValue);
				if (dist < valueDist) {
					nextValue = potentialValue;
					valueDist = dist;
				}
			});
			if (nextValue === void 0) return offset$2 < 0 ? min : max;
			if (mode === "dist") return nextValue;
			if (Math.abs(offset$2) > 1) {
				const cloneValues = [...values];
				cloneValues[valueIndex] = nextValue;
				return offsetValue(cloneValues, offset$2 - sign, valueIndex, mode);
			}
			return nextValue;
		} else if (offset$2 === "min") return min;
		else if (offset$2 === "max") return max;
	};
	/** Same as `offsetValue` but return `changed` mark to tell value changed */
	const offsetChangedValue = (values, offset$2, valueIndex, mode = "unit") => {
		const originValue = values[valueIndex];
		const nextValue = offsetValue(values, offset$2, valueIndex, mode);
		return {
			value: nextValue,
			changed: nextValue !== originValue
		};
	};
	const needPush = (dist) => {
		return pushable === null && dist === 0 || typeof pushable === "number" && dist < pushable;
	};
	const offsetValues = (values, offset$2, valueIndex, mode = "unit") => {
		const nextValues = values.map(formatValue$1);
		const originValue = nextValues[valueIndex];
		nextValues[valueIndex] = offsetValue(nextValues, offset$2, valueIndex, mode);
		if (allowCross === false) {
			const pushNum = pushable || 0;
			if (valueIndex > 0 && nextValues[valueIndex - 1] !== originValue) nextValues[valueIndex] = Math.max(nextValues[valueIndex], nextValues[valueIndex - 1] + pushNum);
			if (valueIndex < nextValues.length - 1 && nextValues[valueIndex + 1] !== originValue) nextValues[valueIndex] = Math.min(nextValues[valueIndex], nextValues[valueIndex + 1] - pushNum);
		} else if (typeof pushable === "number" || pushable === null) {
			for (let i = valueIndex + 1; i < nextValues.length; i += 1) {
				let changed = true;
				while (needPush(nextValues[i] - nextValues[i - 1]) && changed) ({value: nextValues[i], changed} = offsetChangedValue(nextValues, 1, i));
			}
			for (let i = valueIndex; i > 0; i -= 1) {
				let changed = true;
				while (needPush(nextValues[i] - nextValues[i - 1]) && changed) ({value: nextValues[i - 1], changed} = offsetChangedValue(nextValues, -1, i - 1));
			}
			for (let i = nextValues.length - 1; i > 0; i -= 1) {
				let changed = true;
				while (needPush(nextValues[i] - nextValues[i - 1]) && changed) ({value: nextValues[i - 1], changed} = offsetChangedValue(nextValues, -1, i - 1));
			}
			for (let i = 0; i < nextValues.length - 1; i += 1) {
				let changed = true;
				while (needPush(nextValues[i + 1] - nextValues[i]) && changed) ({value: nextValues[i + 1], changed} = offsetChangedValue(nextValues, 1, i + 1));
			}
		}
		return {
			value: nextValues[valueIndex],
			values: nextValues
		};
	};
	return [formatValue$1, offsetValues];
}

//#endregion
//#region node_modules/@rc-component/slider/es/hooks/useRange.js
function useRange(range$1) {
	return (0, import_react.useMemo)(() => {
		if (range$1 === true || !range$1) return [
			!!range$1,
			false,
			false,
			0
		];
		const { editable, draggableTrack, minCount, maxCount } = range$1;
		warning(!editable || !draggableTrack, "`editable` can not work with `draggableTrack`.");
		return [
			true,
			editable,
			!editable && draggableTrack,
			minCount || 0,
			maxCount
		];
	}, [range$1]);
}

//#endregion
//#region node_modules/@rc-component/slider/es/Slider.js
/**
* New:
* - click mark to update range value
* - handleRender
* - Fix handle with count not correct
* - Fix pushable not work in some case
* - No more FindDOMNode
* - Move all position related style into inline style
* - Key: up is plus, down is minus
* - fix Key with step = null not align with marks
* - Change range should not trigger onChange
* - keyboard support pushable
*/
var Slider$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls = "rc-slider", className, style: style$1, classNames, styles, id, disabled = false, keyboard = true, autoFocus, onFocus, onBlur, min = 0, max = 100, step = 1, value, defaultValue, range: range$1, count, onChange, onBeforeChange, onAfterChange, onChangeComplete, allowCross = true, pushable = false, reverse, vertical, included = true, startPoint, trackStyle, handleStyle, railStyle, dotStyle, activeDotStyle, marks, dots, handleRender, activeHandleRender, track, tabIndex = 0, ariaLabelForHandle, ariaLabelledByForHandle, ariaRequired, ariaValueTextFormatterForHandle } = props;
	const handlesRef = import_react.useRef(null);
	const containerRef = import_react.useRef(null);
	const direction = import_react.useMemo(() => {
		if (vertical) return reverse ? "ttb" : "btt";
		return reverse ? "rtl" : "ltr";
	}, [reverse, vertical]);
	const [rangeEnabled, rangeEditable, rangeDraggableTrack, minCount, maxCount] = useRange(range$1);
	const mergedMin = import_react.useMemo(() => isFinite(min) ? min : 0, [min]);
	const mergedMax = import_react.useMemo(() => isFinite(max) ? max : 100, [max]);
	const mergedStep = import_react.useMemo(() => step !== null && step <= 0 ? 1 : step, [step]);
	const mergedPush = import_react.useMemo(() => {
		if (typeof pushable === "boolean") return pushable ? mergedStep : false;
		return pushable >= 0 ? pushable : false;
	}, [pushable, mergedStep]);
	const markList = import_react.useMemo(() => {
		return Object.keys(marks || {}).map((key) => {
			const mark = marks[key];
			const markObj = { value: Number(key) };
			if (mark && typeof mark === "object" && !/* @__PURE__ */ import_react.isValidElement(mark) && ("label" in mark || "style" in mark)) {
				markObj.style = mark.style;
				markObj.label = mark.label;
			} else markObj.label = mark;
			return markObj;
		}).filter(({ label }) => label || typeof label === "number").sort((a, b) => a.value - b.value);
	}, [marks]);
	const [formatValue$1, offsetValues] = useOffset(mergedMin, mergedMax, mergedStep, markList, allowCross, mergedPush);
	const [mergedValue, setValue] = useControlledState(defaultValue, value);
	const rawValues = import_react.useMemo(() => {
		const valueList = mergedValue === null || mergedValue === void 0 ? [] : Array.isArray(mergedValue) ? mergedValue : [mergedValue];
		const [val0 = mergedMin] = valueList;
		let returnValues = mergedValue === null ? [] : [val0];
		if (rangeEnabled) {
			returnValues = [...valueList];
			if (count || mergedValue === void 0) {
				const pointCount = count >= 0 ? count + 1 : 2;
				returnValues = returnValues.slice(0, pointCount);
				while (returnValues.length < pointCount) returnValues.push(returnValues[returnValues.length - 1] ?? mergedMin);
			}
			returnValues.sort((a, b) => a - b);
		}
		returnValues.forEach((val, index$1) => {
			returnValues[index$1] = formatValue$1(val);
		});
		return returnValues;
	}, [
		mergedValue,
		rangeEnabled,
		mergedMin,
		count,
		formatValue$1
	]);
	const getTriggerValue = (triggerValues) => rangeEnabled ? triggerValues : triggerValues[0];
	const triggerChange = useEvent_default((nextValues) => {
		const cloneNextValues = [...nextValues].sort((a, b) => a - b);
		if (onChange && !isEqual_default(cloneNextValues, rawValues, true)) onChange(getTriggerValue(cloneNextValues));
		setValue(cloneNextValues);
	});
	const finishChange = useEvent_default((draggingDelete$1) => {
		if (draggingDelete$1) handlesRef.current.hideHelp();
		const finishValue = getTriggerValue(rawValues);
		onAfterChange?.(finishValue);
		warning_default$1(!onAfterChange, "[rc-slider] `onAfterChange` is deprecated. Please use `onChangeComplete` instead.");
		onChangeComplete?.(finishValue);
	});
	const onDelete = (index$1) => {
		if (disabled || !rangeEditable || rawValues.length <= minCount) return;
		const cloneNextValues = [...rawValues];
		cloneNextValues.splice(index$1, 1);
		onBeforeChange?.(getTriggerValue(cloneNextValues));
		triggerChange(cloneNextValues);
		const nextFocusIndex = Math.max(0, index$1 - 1);
		handlesRef.current.hideHelp();
		handlesRef.current.focus(nextFocusIndex);
	};
	const [draggingIndex, draggingValue, draggingDelete, cacheValues, onStartDrag] = useDrag_default(containerRef, direction, rawValues, mergedMin, mergedMax, formatValue$1, triggerChange, finishChange, offsetValues, rangeEditable, minCount);
	/**
	* When `rangeEditable` will insert a new value in the values array.
	* Else it will replace the value in the values array.
	*/
	const changeToCloseValue = (newValue, e$2) => {
		if (!disabled) {
			const cloneNextValues = [...rawValues];
			let valueIndex = 0;
			let valueBeforeIndex = 0;
			let valueDist = mergedMax - mergedMin;
			rawValues.forEach((val, index$1) => {
				const dist = Math.abs(newValue - val);
				if (dist <= valueDist) {
					valueDist = dist;
					valueIndex = index$1;
				}
				if (val < newValue) valueBeforeIndex = index$1;
			});
			let focusIndex = valueIndex;
			if (rangeEditable && valueDist !== 0 && (!maxCount || rawValues.length < maxCount)) {
				cloneNextValues.splice(valueBeforeIndex + 1, 0, newValue);
				focusIndex = valueBeforeIndex + 1;
			} else cloneNextValues[valueIndex] = newValue;
			if (rangeEnabled && !rawValues.length && count === void 0) cloneNextValues.push(newValue);
			const nextValue = getTriggerValue(cloneNextValues);
			onBeforeChange?.(nextValue);
			triggerChange(cloneNextValues);
			if (e$2) {
				document.activeElement?.blur?.();
				handlesRef.current.focus(focusIndex);
				onStartDrag(e$2, focusIndex, cloneNextValues);
			} else {
				onAfterChange?.(nextValue);
				warning_default$1(!onAfterChange, "[rc-slider] `onAfterChange` is deprecated. Please use `onChangeComplete` instead.");
				onChangeComplete?.(nextValue);
			}
		}
	};
	const onSliderMouseDown = (e$2) => {
		e$2.preventDefault();
		const { width, height, left, top, bottom, right } = containerRef.current.getBoundingClientRect();
		const { clientX, clientY } = e$2;
		let percent;
		switch (direction) {
			case "btt":
				percent = (bottom - clientY) / height;
				break;
			case "ttb":
				percent = (clientY - top) / height;
				break;
			case "rtl":
				percent = (right - clientX) / width;
				break;
			default: percent = (clientX - left) / width;
		}
		changeToCloseValue(formatValue$1(mergedMin + percent * (mergedMax - mergedMin)), e$2);
	};
	const [keyboardValue, setKeyboardValue] = import_react.useState(null);
	const onHandleOffsetChange = (offset$2, valueIndex) => {
		if (!disabled) {
			const next$1 = offsetValues(rawValues, offset$2, valueIndex);
			onBeforeChange?.(getTriggerValue(rawValues));
			triggerChange(next$1.values);
			setKeyboardValue(next$1.value);
		}
	};
	import_react.useEffect(() => {
		if (keyboardValue !== null) {
			const valueIndex = rawValues.indexOf(keyboardValue);
			if (valueIndex >= 0) handlesRef.current.focus(valueIndex);
		}
		setKeyboardValue(null);
	}, [keyboardValue]);
	const mergedDraggableTrack = import_react.useMemo(() => {
		if (rangeDraggableTrack && mergedStep === null) {
			warning_default$1(false, "`draggableTrack` is not supported when `step` is `null`.");
			return false;
		}
		return rangeDraggableTrack;
	}, [rangeDraggableTrack, mergedStep]);
	const onStartMove = useEvent_default((e$2, valueIndex) => {
		onStartDrag(e$2, valueIndex);
		onBeforeChange?.(getTriggerValue(rawValues));
	});
	const dragging = draggingIndex !== -1;
	import_react.useEffect(() => {
		if (!dragging) {
			const valueIndex = rawValues.lastIndexOf(draggingValue);
			handlesRef.current.focus(valueIndex);
		}
	}, [dragging]);
	const sortedCacheValues = import_react.useMemo(() => [...cacheValues].sort((a, b) => a - b), [cacheValues]);
	const [includedStart, includedEnd] = import_react.useMemo(() => {
		if (!rangeEnabled) return [mergedMin, sortedCacheValues[0]];
		return [sortedCacheValues[0], sortedCacheValues[sortedCacheValues.length - 1]];
	}, [
		sortedCacheValues,
		rangeEnabled,
		mergedMin
	]);
	import_react.useImperativeHandle(ref, () => ({
		focus: () => {
			handlesRef.current.focus(0);
		},
		blur: () => {
			const { activeElement } = document;
			if (containerRef.current?.contains(activeElement)) activeElement?.blur();
		}
	}));
	import_react.useEffect(() => {
		if (autoFocus) handlesRef.current.focus(0);
	}, []);
	const context = import_react.useMemo(() => ({
		min: mergedMin,
		max: mergedMax,
		direction,
		disabled,
		keyboard,
		step: mergedStep,
		included,
		includedStart,
		includedEnd,
		range: rangeEnabled,
		tabIndex,
		ariaLabelForHandle,
		ariaLabelledByForHandle,
		ariaRequired,
		ariaValueTextFormatterForHandle,
		styles: styles || {},
		classNames: classNames || {}
	}), [
		mergedMin,
		mergedMax,
		direction,
		disabled,
		keyboard,
		mergedStep,
		included,
		includedStart,
		includedEnd,
		rangeEnabled,
		tabIndex,
		ariaLabelForHandle,
		ariaLabelledByForHandle,
		ariaRequired,
		ariaValueTextFormatterForHandle,
		styles,
		classNames
	]);
	return /* @__PURE__ */ import_react.createElement(context_default$2.Provider, { value: context }, /* @__PURE__ */ import_react.createElement("div", {
		ref: containerRef,
		className: clsx(prefixCls, className, {
			[`${prefixCls}-disabled`]: disabled,
			[`${prefixCls}-vertical`]: vertical,
			[`${prefixCls}-horizontal`]: !vertical,
			[`${prefixCls}-with-marks`]: markList.length
		}),
		style: style$1,
		onMouseDown: onSliderMouseDown,
		id
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-rail`, classNames?.rail),
		style: {
			...railStyle,
			...styles?.rail
		}
	}), track !== false && /* @__PURE__ */ import_react.createElement(Tracks_default, {
		prefixCls,
		style: trackStyle,
		values: rawValues,
		startPoint,
		onStartMove: mergedDraggableTrack ? onStartMove : void 0
	}), /* @__PURE__ */ import_react.createElement(Steps_default$1, {
		prefixCls,
		marks: markList,
		dots,
		style: dotStyle,
		activeStyle: activeDotStyle
	}), /* @__PURE__ */ import_react.createElement(Handles_default, {
		ref: handlesRef,
		prefixCls,
		style: handleStyle,
		values: cacheValues,
		draggingIndex,
		draggingDelete,
		onStartMove,
		onOffsetChange: onHandleOffsetChange,
		onFocus,
		onBlur,
		handleRender,
		activeHandleRender,
		onChangeComplete: finishChange,
		onDelete: rangeEditable ? onDelete : void 0
	}), /* @__PURE__ */ import_react.createElement(Marks_default, {
		prefixCls,
		marks: markList,
		onClick: changeToCloseValue
	})));
});
Slider$1.displayName = "Slider";
var Slider_default = Slider$1;

//#endregion
//#region node_modules/@rc-component/slider/es/index.js
var es_default$20 = Slider_default;

//#endregion
//#region node_modules/antd/es/slider/Context.js
/** @private Internal context. Do not use in your production. */
var SliderInternalContext = /* @__PURE__ */ (0, import_react.createContext)({});
var Context_default = SliderInternalContext;

//#endregion
//#region node_modules/antd/es/slider/SliderTooltip.js
var SliderTooltip = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { open: open$2, draggingDelete, value } = props;
	const innerRef = (0, import_react.useRef)(null);
	const mergedOpen = open$2 && !draggingDelete;
	const rafRef = (0, import_react.useRef)(null);
	function cancelKeepAlign() {
		raf_default.cancel(rafRef.current);
		rafRef.current = null;
	}
	function keepAlign() {
		rafRef.current = raf_default(() => {
			innerRef.current?.forceAlign();
			rafRef.current = null;
		});
	}
	import_react.useEffect(() => {
		if (mergedOpen) keepAlign();
		else cancelKeepAlign();
		return cancelKeepAlign;
	}, [
		mergedOpen,
		props.title,
		value
	]);
	return /* @__PURE__ */ import_react.createElement(tooltip_default, {
		ref: composeRef(innerRef, ref),
		...props,
		open: mergedOpen
	});
});
SliderTooltip.displayName = "SliderTooltip";
var SliderTooltip_default = SliderTooltip;

//#endregion
//#region node_modules/antd/es/slider/style/index.js
var genBaseStyle$9 = (token$1) => {
	const { componentCls, antCls, controlSize, dotSize, marginFull, marginPart, colorFillContentHover, handleColorDisabled, calc, handleSize, handleSizeHover, handleActiveColor, handleActiveOutlineColor, handleLineWidth, handleLineWidthHover, motionDurationMid } = token$1;
	return { [componentCls]: {
		...resetComponent(token$1),
		position: "relative",
		height: controlSize,
		margin: `${unit(marginPart)} ${unit(marginFull)}`,
		padding: 0,
		cursor: "pointer",
		touchAction: "none",
		"&-vertical": { margin: `${unit(marginFull)} ${unit(marginPart)}` },
		[`${componentCls}-rail`]: {
			position: "absolute",
			backgroundColor: token$1.railBg,
			borderRadius: token$1.borderRadiusXS,
			transition: `background-color ${motionDurationMid}`
		},
		[`${componentCls}-track,${componentCls}-tracks`]: {
			position: "absolute",
			transition: `background-color ${motionDurationMid}`
		},
		[`${componentCls}-track`]: {
			backgroundColor: token$1.trackBg,
			borderRadius: token$1.borderRadiusXS
		},
		[`${componentCls}-track-draggable`]: {
			boxSizing: "content-box",
			backgroundClip: "content-box",
			border: "solid rgba(0,0,0,0)"
		},
		"&:hover": {
			[`${componentCls}-rail`]: { backgroundColor: token$1.railHoverBg },
			[`${componentCls}-track`]: { backgroundColor: token$1.trackHoverBg },
			[`${componentCls}-dot`]: { borderColor: colorFillContentHover },
			[`${componentCls}-handle::after`]: { boxShadow: `0 0 0 ${unit(handleLineWidth)} ${token$1.colorPrimaryBorderHover}` },
			[`${componentCls}-dot-active`]: { borderColor: token$1.dotActiveBorderColor }
		},
		[`${componentCls}-handle`]: {
			position: "absolute",
			width: handleSize,
			height: handleSize,
			outline: "none",
			userSelect: "none",
			"&-dragging-delete": { opacity: 0 },
			"&::before": {
				content: "\"\"",
				position: "absolute",
				insetInlineStart: calc(handleLineWidth).mul(-1).equal(),
				insetBlockStart: calc(handleLineWidth).mul(-1).equal(),
				width: calc(handleSize).add(calc(handleLineWidth).mul(2)).equal(),
				height: calc(handleSize).add(calc(handleLineWidth).mul(2)).equal(),
				backgroundColor: "transparent"
			},
			"&::after": {
				content: "\"\"",
				position: "absolute",
				insetBlockStart: 0,
				insetInlineStart: 0,
				width: handleSize,
				height: handleSize,
				backgroundColor: token$1.colorBgElevated,
				boxShadow: `0 0 0 ${unit(handleLineWidth)} ${token$1.handleColor}`,
				outline: `0px solid transparent`,
				borderRadius: "50%",
				cursor: "pointer",
				transition: `
            inset-inline-start ${motionDurationMid},
            inset-block-start ${motionDurationMid},
            width ${motionDurationMid},
            height ${motionDurationMid},
            box-shadow ${motionDurationMid},
            outline ${motionDurationMid}
          `
			},
			"&:hover, &:active, &:focus": {
				"&::before": {
					insetInlineStart: calc(handleSizeHover).sub(handleSize).div(2).add(handleLineWidthHover).mul(-1).equal(),
					insetBlockStart: calc(handleSizeHover).sub(handleSize).div(2).add(handleLineWidthHover).mul(-1).equal(),
					width: calc(handleSizeHover).add(calc(handleLineWidthHover).mul(2)).equal(),
					height: calc(handleSizeHover).add(calc(handleLineWidthHover).mul(2)).equal()
				},
				"&::after": {
					boxShadow: `0 0 0 ${unit(handleLineWidthHover)} ${handleActiveColor}`,
					outline: `6px solid ${handleActiveOutlineColor}`,
					width: handleSizeHover,
					height: handleSizeHover,
					insetInlineStart: token$1.calc(handleSize).sub(handleSizeHover).div(2).equal(),
					insetBlockStart: token$1.calc(handleSize).sub(handleSizeHover).div(2).equal()
				}
			}
		},
		[`&-lock ${componentCls}-handle`]: { "&::before, &::after": { transition: "none" } },
		[`${componentCls}-mark`]: {
			position: "absolute",
			fontSize: token$1.fontSize
		},
		[`${componentCls}-mark-text`]: {
			position: "absolute",
			display: "inline-block",
			color: token$1.colorTextDescription,
			textAlign: "center",
			wordBreak: "keep-all",
			cursor: "pointer",
			userSelect: "none",
			"&-active": { color: token$1.colorText }
		},
		[`${componentCls}-step`]: {
			position: "absolute",
			background: "transparent",
			pointerEvents: "none"
		},
		[`${componentCls}-dot`]: {
			position: "absolute",
			width: dotSize,
			height: dotSize,
			backgroundColor: token$1.colorBgElevated,
			border: `${unit(handleLineWidth)} solid ${token$1.dotBorderColor}`,
			borderRadius: "50%",
			cursor: "pointer",
			transition: `border-color ${token$1.motionDurationSlow}`,
			pointerEvents: "auto",
			"&-active": { borderColor: token$1.dotActiveBorderColor }
		},
		[`&${componentCls}-disabled`]: {
			cursor: "not-allowed",
			[`${componentCls}-rail`]: { backgroundColor: `${token$1.railBg} !important` },
			[`${componentCls}-track`]: { backgroundColor: `${token$1.trackBgDisabled} !important` },
			[`
          ${componentCls}-dot
        `]: {
				backgroundColor: token$1.colorBgElevated,
				borderColor: token$1.trackBgDisabled,
				boxShadow: "none",
				cursor: "not-allowed"
			},
			[`${componentCls}-handle::after`]: {
				backgroundColor: token$1.colorBgElevated,
				cursor: "not-allowed",
				width: handleSize,
				height: handleSize,
				boxShadow: `0 0 0 ${unit(handleLineWidth)} ${handleColorDisabled}`,
				insetInlineStart: 0,
				insetBlockStart: 0
			},
			[`
          ${componentCls}-mark-text,
          ${componentCls}-dot
        `]: { cursor: `not-allowed !important` }
		},
		[`&-tooltip ${antCls}-tooltip-container`]: { minWidth: "unset" }
	} };
};
var genDirectionStyle = (token$1, horizontal) => {
	const { componentCls, railSize, handleSize, dotSize, marginFull, calc } = token$1;
	const railPadding = horizontal ? "paddingBlock" : "paddingInline";
	const full = horizontal ? "width" : "height";
	const part = horizontal ? "height" : "width";
	const handlePos = horizontal ? "insetBlockStart" : "insetInlineStart";
	const markInset = horizontal ? "top" : "insetInlineStart";
	const handlePosSize = calc(railSize).mul(3).sub(handleSize).div(2).equal();
	const draggableBorderSize = calc(handleSize).sub(railSize).div(2).equal();
	const draggableBorder = horizontal ? {
		borderWidth: `${unit(draggableBorderSize)} 0`,
		transform: `translateY(${unit(calc(draggableBorderSize).mul(-1).equal())})`
	} : {
		borderWidth: `0 ${unit(draggableBorderSize)}`,
		transform: `translateX(${unit(token$1.calc(draggableBorderSize).mul(-1).equal())})`
	};
	return {
		[railPadding]: railSize,
		[part]: calc(railSize).mul(3).equal(),
		[`${componentCls}-rail`]: {
			[full]: "100%",
			[part]: railSize
		},
		[`${componentCls}-track,${componentCls}-tracks`]: { [part]: railSize },
		[`${componentCls}-track-draggable`]: { ...draggableBorder },
		[`${componentCls}-handle`]: { [handlePos]: handlePosSize },
		[`${componentCls}-mark`]: {
			insetInlineStart: 0,
			top: 0,
			[markInset]: calc(railSize).mul(3).add(horizontal ? 0 : marginFull).equal(),
			[full]: "100%"
		},
		[`${componentCls}-step`]: {
			insetInlineStart: 0,
			top: 0,
			[markInset]: railSize,
			[full]: "100%",
			[part]: railSize
		},
		[`${componentCls}-dot`]: {
			position: "absolute",
			[handlePos]: calc(railSize).sub(dotSize).div(2).equal()
		}
	};
};
var genHorizontalStyle$3 = (token$1) => {
	const { componentCls, marginPartWithMark } = token$1;
	return { [`${componentCls}-horizontal`]: {
		...genDirectionStyle(token$1, true),
		[`&${componentCls}-with-marks`]: { marginBottom: marginPartWithMark }
	} };
};
var genVerticalStyle$3 = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-vertical`]: {
		...genDirectionStyle(token$1, false),
		height: "100%"
	} };
};
const prepareComponentToken$27 = (token$1) => {
	const increaseHandleWidth = 1;
	const controlSize = token$1.controlHeightLG / 4;
	const controlSizeHover = token$1.controlHeightSM / 2;
	const handleLineWidth = token$1.lineWidth + increaseHandleWidth;
	const handleLineWidthHover = token$1.lineWidth + increaseHandleWidth * 1.5;
	const handleActiveColor = token$1.colorPrimary;
	const handleActiveOutlineColor = new FastColor(handleActiveColor).setA(.2).toRgbString();
	return {
		controlSize,
		railSize: 4,
		handleSize: controlSize,
		handleSizeHover: controlSizeHover,
		dotSize: 8,
		handleLineWidth,
		handleLineWidthHover,
		railBg: token$1.colorFillTertiary,
		railHoverBg: token$1.colorFillSecondary,
		trackBg: token$1.colorPrimaryBorder,
		trackHoverBg: token$1.colorPrimaryBorderHover,
		handleColor: token$1.colorPrimaryBorder,
		handleActiveColor,
		handleActiveOutlineColor,
		handleColorDisabled: new FastColor(token$1.colorTextDisabled).onBackground(token$1.colorBgContainer).toHexString(),
		dotBorderColor: token$1.colorBorderSecondary,
		dotActiveBorderColor: token$1.colorPrimaryBorder,
		trackBgDisabled: token$1.colorBgContainerDisabled
	};
};
var style_default$35 = genStyleHooks("Slider", (token$1) => {
	const sliderToken = merge(token$1, {
		marginPart: token$1.calc(token$1.controlHeight).sub(token$1.controlSize).div(2).equal(),
		marginFull: token$1.calc(token$1.controlSize).div(2).equal(),
		marginPartWithMark: token$1.calc(token$1.controlHeightLG).sub(token$1.controlSize).equal()
	});
	return [
		genBaseStyle$9(sliderToken),
		genHorizontalStyle$3(sliderToken),
		genVerticalStyle$3(sliderToken)
	];
}, prepareComponentToken$27);

//#endregion
//#region node_modules/antd/es/slider/useRafLock.js
function useRafLock() {
	const [state, setState] = import_react.useState(false);
	const rafRef = import_react.useRef(null);
	const cleanup$1 = () => {
		raf_default.cancel(rafRef.current);
	};
	const setDelayState = (nextState) => {
		cleanup$1();
		if (nextState) setState(nextState);
		else rafRef.current = raf_default(() => {
			setState(nextState);
		});
	};
	import_react.useEffect(() => cleanup$1, []);
	return [state, setDelayState];
}

//#endregion
//#region node_modules/antd/es/slider/index.js
function getTipFormatter(tipFormatter) {
	if (tipFormatter || tipFormatter === null) return tipFormatter;
	return (val) => typeof val === "number" ? val.toString() : "";
}
var Slider = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, range: range$1, className, rootClassName, style: style$1, disabled, tooltip = {}, onChangeComplete, classNames, styles, vertical, orientation, ...restProps } = props;
	const [, mergedVertical] = useOrientation(orientation, vertical);
	const { getPrefixCls, direction: contextDirection, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles, getPopupContainer } = useComponentConfig("slider");
	const contextDisabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = disabled ?? contextDisabled;
	const mergedProps = {
		...props,
		disabled: mergedDisabled,
		vertical: mergedVertical
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const { handleRender: contextHandleRender, direction: internalContextDirection } = import_react.useContext(Context_default);
	const isRTL = (internalContextDirection || contextDirection) === "rtl";
	const [hoverOpen, setHoverOpen] = useRafLock();
	const [focusOpen, setFocusOpen] = useRafLock();
	const tooltipProps = { ...tooltip };
	const { open: tooltipOpen, placement: tooltipPlacement, getPopupContainer: getTooltipPopupContainer, prefixCls: customizeTooltipPrefixCls, formatter: tipFormatter } = tooltipProps;
	const lockOpen = tooltipOpen;
	const activeOpen = (hoverOpen || focusOpen) && lockOpen !== false;
	const mergedTipFormatter = getTipFormatter(tipFormatter);
	const [dragging, setDragging] = useRafLock();
	const onInternalChangeComplete = (nextValues) => {
		onChangeComplete?.(nextValues);
		setDragging(false);
	};
	const getTooltipPlacement = (placement, vert) => {
		if (placement) return placement;
		if (!vert) return "top";
		return isRTL ? "left" : "right";
	};
	const prefixCls = getPrefixCls("slider", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$35(prefixCls);
	const rootClassNames = clsx(className, contextClassName, mergedClassNames.root, rootClassName, {
		[`${prefixCls}-rtl`]: isRTL,
		[`${prefixCls}-lock`]: dragging
	}, hashId, cssVarCls);
	if (isRTL && !mergedVertical) restProps.reverse = !restProps.reverse;
	{
		const warning$3 = devUseWarning("Slider");
		[
			["tooltipPrefixCls", "prefixCls"],
			["getTooltipPopupContainer", "getPopupContainer"],
			["tipFormatter", "formatter"],
			["tooltipPlacement", "placement"],
			["tooltipVisible", "open"]
		].forEach(([deprecatedName, newName]) => {
			warning$3.deprecated(!(deprecatedName in props), deprecatedName, `tooltip.${newName}`);
		});
	}
	import_react.useEffect(() => {
		const onMouseUp = () => {
			raf_default(() => {
				setFocusOpen(false);
			}, 1);
		};
		document.addEventListener("mouseup", onMouseUp);
		return () => {
			document.removeEventListener("mouseup", onMouseUp);
		};
	}, []);
	const useActiveTooltipHandle = range$1 && !lockOpen;
	const handleRender = contextHandleRender || ((node$1, info) => {
		const { index: index$1 } = info;
		const nodeProps = node$1.props;
		function proxyEvent(eventName, event, triggerRestPropsEvent) {
			if (triggerRestPropsEvent) restProps[eventName]?.(event);
			nodeProps[eventName]?.(event);
		}
		const passedProps = {
			...nodeProps,
			onMouseEnter: (e$2) => {
				setHoverOpen(true);
				proxyEvent("onMouseEnter", e$2);
			},
			onMouseLeave: (e$2) => {
				setHoverOpen(false);
				proxyEvent("onMouseLeave", e$2);
			},
			onMouseDown: (e$2) => {
				setFocusOpen(true);
				setDragging(true);
				proxyEvent("onMouseDown", e$2);
			},
			onFocus: (e$2) => {
				setFocusOpen(true);
				restProps.onFocus?.(e$2);
				proxyEvent("onFocus", e$2, true);
			},
			onBlur: (e$2) => {
				setFocusOpen(false);
				restProps.onBlur?.(e$2);
				proxyEvent("onBlur", e$2, true);
			}
		};
		const cloneNode = /* @__PURE__ */ import_react.cloneElement(node$1, passedProps);
		const open$2 = (!!lockOpen || activeOpen) && mergedTipFormatter !== null;
		if (!useActiveTooltipHandle) return /* @__PURE__ */ import_react.createElement(SliderTooltip_default, {
			...tooltipProps,
			prefixCls: getPrefixCls("tooltip", customizeTooltipPrefixCls),
			title: mergedTipFormatter ? mergedTipFormatter(info.value) : "",
			value: info.value,
			open: open$2,
			placement: getTooltipPlacement(tooltipPlacement, mergedVertical),
			key: index$1,
			classNames: { root: `${prefixCls}-tooltip` },
			getPopupContainer: getTooltipPopupContainer || getPopupContainer
		}, cloneNode);
		return cloneNode;
	});
	const activeHandleRender = useActiveTooltipHandle ? (handle, info) => {
		const cloneNode = /* @__PURE__ */ import_react.cloneElement(handle, { style: {
			...handle.props.style,
			visibility: "hidden"
		} });
		return /* @__PURE__ */ import_react.createElement(SliderTooltip_default, {
			...tooltipProps,
			prefixCls: getPrefixCls("tooltip", customizeTooltipPrefixCls),
			title: mergedTipFormatter ? mergedTipFormatter(info.value) : "",
			open: mergedTipFormatter !== null && activeOpen,
			placement: getTooltipPlacement(tooltipPlacement, mergedVertical),
			key: "tooltip",
			classNames: { root: `${prefixCls}-tooltip` },
			getPopupContainer: getTooltipPopupContainer || getPopupContainer,
			draggingDelete: info.draggingDelete
		}, cloneNode);
	} : void 0;
	const rootStyle = {
		...mergedStyles.root,
		...contextStyle,
		...style$1
	};
	return /* @__PURE__ */ import_react.createElement(es_default$20, {
		...restProps,
		classNames: mergedClassNames,
		styles: mergedStyles,
		step: restProps.step,
		range: range$1,
		className: rootClassNames,
		style: rootStyle,
		disabled: mergedDisabled,
		vertical: mergedVertical,
		ref,
		prefixCls,
		handleRender,
		activeHandleRender,
		onChangeComplete: onInternalChangeComplete
	});
});
Slider.displayName = "Slider";
var slider_default = Slider;

//#endregion
//#region node_modules/antd/es/color-picker/components/ColorSlider.js
const GradientColorSlider = (props) => {
	const { prefixCls, colors, type: type$2, color, range: range$1 = false, className, activeIndex, onActive, onDragStart, onDragChange, onKeyDelete, ...restProps } = props;
	const sliderProps = {
		...restProps,
		track: false
	};
	const linearCss = import_react.useMemo(() => {
		return `linear-gradient(90deg, ${colors.map((c) => `${c.color} ${c.percent}%`).join(", ")})`;
	}, [colors]);
	const pointColor = import_react.useMemo(() => {
		if (!color || !type$2) return null;
		if (type$2 === "alpha") return color.toRgbString();
		return `hsl(${color.toHsb().h}, 100%, 50%)`;
	}, [color, type$2]);
	const onInternalDragStart = useEvent_default(onDragStart);
	const onInternalDragChange = useEvent_default(onDragChange);
	const unstableContext = import_react.useMemo(() => ({
		onDragStart: onInternalDragStart,
		onDragChange: onInternalDragChange
	}), []);
	const handleRender = useEvent_default((ori, info) => {
		const { onFocus, style: style$1, className: handleCls, onKeyDown: onKeyDown$1 } = ori.props;
		const mergedStyle = { ...style$1 };
		if (type$2 === "gradient") mergedStyle.background = getGradientPercentColor(colors, info.value);
		return /* @__PURE__ */ import_react.cloneElement(ori, {
			onFocus: (e$2) => {
				onActive?.(info.index);
				onFocus?.(e$2);
			},
			style: mergedStyle,
			className: clsx(handleCls, { [`${prefixCls}-slider-handle-active`]: activeIndex === info.index }),
			onKeyDown: (e$2) => {
				if ((e$2.key === "Delete" || e$2.key === "Backspace") && onKeyDelete) onKeyDelete(info.index);
				onKeyDown$1?.(e$2);
			}
		});
	});
	const sliderContext = import_react.useMemo(() => ({
		direction: "ltr",
		handleRender
	}), []);
	return /* @__PURE__ */ import_react.createElement(Context_default.Provider, { value: sliderContext }, /* @__PURE__ */ import_react.createElement(UnstableContext$3.Provider, { value: unstableContext }, /* @__PURE__ */ import_react.createElement(slider_default, {
		...sliderProps,
		className: clsx(className, `${prefixCls}-slider`),
		tooltip: { open: false },
		range: {
			editable: range$1,
			minCount: 2
		},
		styles: {
			rail: { background: linearCss },
			handle: pointColor ? { background: pointColor } : {}
		},
		classNames: {
			rail: `${prefixCls}-slider-rail`,
			handle: `${prefixCls}-slider-handle`
		}
	})));
};
var SingleColorSlider = (props) => {
	const { value, onChange, onChangeComplete } = props;
	const singleOnChange = (v) => onChange(v[0]);
	const singleOnChangeComplete = (v) => onChangeComplete(v[0]);
	return /* @__PURE__ */ import_react.createElement(GradientColorSlider, {
		...props,
		value: [value],
		onChange: singleOnChange,
		onChangeComplete: singleOnChangeComplete
	});
};
var ColorSlider_default = SingleColorSlider;

//#endregion
//#region node_modules/antd/es/color-picker/components/PanelPicker/GradientColorBar.js
function sortColors(colors) {
	return _toConsumableArray(colors).sort((a, b) => a.percent - b.percent);
}
/**
* GradientColorBar will auto show when the mode is `gradient`.
*/
var GradientColorBar = (props) => {
	const { prefixCls, mode, onChange, onChangeComplete, onActive, activeIndex, onGradientDragging, colors } = props;
	const isGradient = mode === "gradient";
	const colorList = import_react.useMemo(() => colors.map((info) => ({
		percent: info.percent,
		color: info.color.toRgbString()
	})), [colors]);
	const values = import_react.useMemo(() => colorList.map((info) => info.percent), [colorList]);
	const colorsRef = import_react.useRef(colorList);
	const onDragStart = ({ rawValues, draggingIndex, draggingValue }) => {
		if (rawValues.length > colorList.length) {
			const newPointColor = getGradientPercentColor(colorList, draggingValue);
			const nextColors = _toConsumableArray(colorList);
			nextColors.splice(draggingIndex, 0, {
				percent: draggingValue,
				color: newPointColor
			});
			colorsRef.current = nextColors;
		} else colorsRef.current = colorList;
		onGradientDragging(true);
		onChange(new AggregationColor(sortColors(colorsRef.current)), true);
	};
	const onDragChange = ({ deleteIndex, draggingIndex, draggingValue }) => {
		let nextColors = _toConsumableArray(colorsRef.current);
		if (deleteIndex !== -1) nextColors.splice(deleteIndex, 1);
		else {
			nextColors[draggingIndex] = {
				...nextColors[draggingIndex],
				percent: draggingValue
			};
			nextColors = sortColors(nextColors);
		}
		onChange(new AggregationColor(nextColors), true);
	};
	const onKeyDelete = (index$1) => {
		const nextColors = _toConsumableArray(colorList);
		nextColors.splice(index$1, 1);
		const nextColor = new AggregationColor(nextColors);
		onChange(nextColor);
		onChangeComplete(nextColor);
	};
	const onInternalChangeComplete = (nextValues) => {
		onChangeComplete(new AggregationColor(colorList));
		if (activeIndex >= nextValues.length) onActive(nextValues.length - 1);
		onGradientDragging(false);
	};
	if (!isGradient) return null;
	return /* @__PURE__ */ import_react.createElement(GradientColorSlider, {
		min: 0,
		max: 100,
		prefixCls,
		className: `${prefixCls}-gradient-slider`,
		colors: colorList,
		color: null,
		value: values,
		range: true,
		onChangeComplete: onInternalChangeComplete,
		disabled: false,
		type: "gradient",
		activeIndex,
		onActive,
		onDragStart,
		onDragChange,
		onKeyDelete
	});
};
var GradientColorBar_default = /* @__PURE__ */ import_react.memo(GradientColorBar);

//#endregion
//#region node_modules/antd/es/color-picker/components/PanelPicker/index.js
var components = { slider: ColorSlider_default };
var PanelPicker = () => {
	const panelPickerContext = (0, import_react.useContext)(PanelPickerContext);
	const { mode, onModeChange, modeOptions, prefixCls, allowClear, value, disabledAlpha, onChange, onClear, onChangeComplete, activeIndex, gradientDragging, ...injectProps } = panelPickerContext;
	const colors = import_react.useMemo(() => {
		if (!value.cleared) return value.getColors();
		return [{
			percent: 0,
			color: new AggregationColor("")
		}, {
			percent: 100,
			color: new AggregationColor("")
		}];
	}, [value]);
	const isSingle = !value.isGradient();
	const [lockedColor, setLockedColor] = import_react.useState(value);
	useLayoutEffect_default(() => {
		if (!isSingle) setLockedColor(colors[activeIndex]?.color);
	}, [
		isSingle,
		colors,
		gradientDragging,
		activeIndex
	]);
	const activeColor = import_react.useMemo(() => {
		if (isSingle) return value;
		if (gradientDragging) return lockedColor;
		return colors[activeIndex]?.color;
	}, [
		colors,
		value,
		activeIndex,
		isSingle,
		lockedColor,
		gradientDragging
	]);
	const [pickerColor, setPickerColor] = import_react.useState(activeColor);
	const [forceSync, setForceSync] = useForceUpdate();
	const mergedPickerColor = pickerColor?.equals(activeColor) ? activeColor : pickerColor;
	useLayoutEffect_default(() => {
		setPickerColor(activeColor);
	}, [forceSync, activeColor?.toHexString()]);
	const fillColor = (nextColor, info) => {
		let submitColor = generateColor(nextColor);
		if (value.cleared) {
			const rgb = submitColor.toRgb();
			if (!rgb.r && !rgb.g && !rgb.b && info) {
				const { type: infoType, value: infoValue = 0 } = info;
				submitColor = new AggregationColor({
					h: infoType === "hue" ? infoValue : 0,
					s: 1,
					b: 1,
					a: infoType === "alpha" ? infoValue / 100 : 1
				});
			} else submitColor = genAlphaColor(submitColor);
		}
		if (mode === "single") return submitColor;
		const nextColors = _toConsumableArray(colors);
		nextColors[activeIndex] = {
			...nextColors[activeIndex],
			color: submitColor
		};
		return new AggregationColor(nextColors);
	};
	const onPickerChange = (colorValue, fromPicker, info) => {
		const nextColor = fillColor(colorValue, info);
		setPickerColor(nextColor.isGradient() ? nextColor.getColors()[activeIndex].color : nextColor);
		onChange(nextColor, fromPicker);
	};
	const onInternalChangeComplete = (nextColor, info) => {
		onChangeComplete(fillColor(nextColor, info));
		setForceSync();
	};
	const onInputChange = (colorValue) => {
		onChange(fillColor(colorValue));
	};
	let operationNode = null;
	const showMode = modeOptions.length > 1;
	if (allowClear || showMode) operationNode = /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-operation` }, showMode && /* @__PURE__ */ import_react.createElement(segmented_default, {
		size: "small",
		options: modeOptions,
		value: mode,
		onChange: onModeChange
	}), /* @__PURE__ */ import_react.createElement(ColorClear_default, {
		prefixCls,
		value,
		onChange: (clearColor) => {
			onChange(clearColor);
			onClear?.();
		},
		...injectProps
	}));
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, operationNode, /* @__PURE__ */ import_react.createElement(GradientColorBar_default, {
		...panelPickerContext,
		colors
	}), /* @__PURE__ */ import_react.createElement(es_default$19, {
		prefixCls,
		value: mergedPickerColor?.toHsb(),
		disabledAlpha,
		onChange: (colorValue, info) => {
			onPickerChange(colorValue, true, info);
		},
		onChangeComplete: (colorValue, info) => {
			onInternalChangeComplete(colorValue, info);
		},
		components
	}), /* @__PURE__ */ import_react.createElement(ColorInput_default, {
		value: activeColor,
		onChange: onInputChange,
		prefixCls,
		disabledAlpha,
		...injectProps
	}));
};
var PanelPicker_default = PanelPicker;

//#endregion
//#region node_modules/antd/es/color-picker/components/PanelPresets.js
var PanelPresets = () => {
	const { prefixCls, value, presets, onChange } = (0, import_react.useContext)(PanelPresetsContext);
	return Array.isArray(presets) ? /* @__PURE__ */ import_react.createElement(ColorPresets_default, {
		value,
		presets,
		prefixCls,
		onChange
	}) : null;
};
var PanelPresets_default = PanelPresets;

//#endregion
//#region node_modules/antd/es/color-picker/ColorPickerPanel.js
var ColorPickerPanel = (props) => {
	const { prefixCls, presets, panelRender, value, onChange, onClear, allowClear, disabledAlpha, mode, onModeChange, modeOptions, onChangeComplete, activeIndex, onActive, format: format$1, onFormatChange, gradientDragging, onGradientDragging, disabledFormat } = props;
	const colorPickerPanelPrefixCls = `${prefixCls}-inner`;
	const panelContext = import_react.useMemo(() => ({
		prefixCls,
		value,
		onChange,
		onClear,
		allowClear,
		disabledAlpha,
		mode,
		onModeChange,
		modeOptions,
		onChangeComplete,
		activeIndex,
		onActive,
		format: format$1,
		onFormatChange,
		gradientDragging,
		onGradientDragging,
		disabledFormat
	}), [
		prefixCls,
		value,
		onChange,
		onClear,
		allowClear,
		disabledAlpha,
		mode,
		onModeChange,
		modeOptions,
		onChangeComplete,
		activeIndex,
		onActive,
		format$1,
		onFormatChange,
		gradientDragging,
		onGradientDragging,
		disabledFormat
	]);
	const presetContext = import_react.useMemo(() => ({
		prefixCls,
		value,
		presets,
		onChange
	}), [
		prefixCls,
		value,
		presets,
		onChange
	]);
	const innerPanel = /* @__PURE__ */ import_react.createElement("div", { className: `${colorPickerPanelPrefixCls}-content` }, /* @__PURE__ */ import_react.createElement(PanelPicker_default, null), Array.isArray(presets) && /* @__PURE__ */ import_react.createElement(divider_default, null), /* @__PURE__ */ import_react.createElement(PanelPresets_default, null));
	return /* @__PURE__ */ import_react.createElement(PanelPickerContext.Provider, { value: panelContext }, /* @__PURE__ */ import_react.createElement(PanelPresetsContext.Provider, { value: presetContext }, /* @__PURE__ */ import_react.createElement("div", { className: colorPickerPanelPrefixCls }, typeof panelRender === "function" ? panelRender(innerPanel, { components: {
		Picker: PanelPicker_default,
		Presets: PanelPresets_default
	} }) : innerPanel)));
};
ColorPickerPanel.displayName = "ColorPickerPanel";
var ColorPickerPanel_default = ColorPickerPanel;

//#endregion
//#region node_modules/antd/es/color-picker/components/ColorTrigger.js
var ColorTrigger = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	const { color, prefixCls, open: open$2, disabled, format: format$1, className, showText, activeIndex, ...rest } = props;
	const colorTriggerPrefixCls = `${prefixCls}-trigger`;
	const colorTextPrefixCls = `${colorTriggerPrefixCls}-text`;
	const colorTextCellPrefixCls = `${colorTextPrefixCls}-cell`;
	const [locale$5] = useLocale_default("ColorPicker");
	const desc = import_react.useMemo(() => {
		if (!showText) return "";
		if (typeof showText === "function") return showText(color);
		if (color.cleared) return locale$5.transparent;
		if (color.isGradient()) return color.getColors().map((c, index$1) => {
			const inactive = activeIndex !== -1 && activeIndex !== index$1;
			return /* @__PURE__ */ import_react.createElement("span", {
				key: index$1,
				className: clsx(colorTextCellPrefixCls, inactive && `${colorTextCellPrefixCls}-inactive`)
			}, c.color.toRgbString(), " ", c.percent, "%");
		});
		const hexString = color.toHexString().toUpperCase();
		const alpha = getColorAlpha(color);
		switch (format$1) {
			case "rgb": return color.toRgbString();
			case "hsb": return color.toHsbString();
			default: return alpha < 100 ? `${hexString.slice(0, 7)},${alpha}%` : hexString;
		}
	}, [
		color,
		format$1,
		showText,
		activeIndex,
		locale$5.transparent,
		colorTextCellPrefixCls
	]);
	const containerNode = (0, import_react.useMemo)(() => color.cleared ? /* @__PURE__ */ import_react.createElement(ColorClear_default, { prefixCls }) : /* @__PURE__ */ import_react.createElement(ColorBlock_default, {
		prefixCls,
		color: color.toCssString()
	}), [color, prefixCls]);
	return /* @__PURE__ */ import_react.createElement("div", {
		ref,
		className: clsx(colorTriggerPrefixCls, className, {
			[`${colorTriggerPrefixCls}-active`]: open$2,
			[`${colorTriggerPrefixCls}-disabled`]: disabled
		}),
		...pickAttrs(rest)
	}, containerNode, showText && /* @__PURE__ */ import_react.createElement("div", { className: colorTextPrefixCls }, desc));
});
var ColorTrigger_default = ColorTrigger;

//#endregion
//#region node_modules/antd/es/color-picker/hooks/useModeColor.js
/**
* Combine the `color` and `mode` to make sure sync of state.
*/
function useModeColor(defaultValue, value, mode) {
	const [locale$5] = useLocale_default("ColorPicker");
	const [mergedColor, setMergedColor] = useControlledState(defaultValue, value);
	const [modeState, setModeState] = import_react.useState("single");
	const [modeOptionList, modeSet] = import_react.useMemo(() => {
		const list = (Array.isArray(mode) ? mode : [mode]).filter((m) => m);
		if (!list.length) list.push("single");
		const modes = new Set(list);
		const optionList = [];
		const pushOption = (modeType, localeTxt) => {
			if (modes.has(modeType)) optionList.push({
				label: localeTxt,
				value: modeType
			});
		};
		pushOption("single", locale$5.singleColor);
		pushOption("gradient", locale$5.gradientColor);
		return [optionList, modes];
	}, [
		mode,
		locale$5.singleColor,
		locale$5.gradientColor
	]);
	const [cacheColor, setCacheColor] = import_react.useState(null);
	const setColor = useEvent_default((nextColor) => {
		setCacheColor(nextColor);
		setMergedColor(nextColor);
	});
	const postColor = import_react.useMemo(() => {
		const colorObj = generateColor(mergedColor || "");
		return colorObj.equals(cacheColor) ? cacheColor : colorObj;
	}, [mergedColor, cacheColor]);
	const postMode = import_react.useMemo(() => {
		if (modeSet.has(modeState)) return modeState;
		return modeOptionList[0]?.value;
	}, [
		modeSet,
		modeState,
		modeOptionList
	]);
	import_react.useEffect(() => {
		setModeState(postColor.isGradient() ? "gradient" : "single");
	}, [postColor]);
	return [
		postColor,
		setColor,
		postMode,
		setModeState,
		modeOptionList
	];
}

//#endregion
//#region node_modules/antd/es/color-picker/style/color-block.js
/**
* @private Internal usage only
* see: https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/conic-gradient#checkerboard
*/
const getTransBg = (size, colorFill) => ({
	backgroundImage: `conic-gradient(${colorFill} 25%, transparent 25% 50%, ${colorFill} 50% 75%, transparent 75% 100%)`,
	backgroundSize: `${size} ${size}`
});
var genColorBlockStyle = (token$1, size) => {
	const { componentCls, borderRadiusSM, colorPickerInsetShadow, lineWidth, colorFillSecondary } = token$1;
	return { [`${componentCls}-color-block`]: {
		position: "relative",
		borderRadius: borderRadiusSM,
		width: size,
		height: size,
		boxShadow: colorPickerInsetShadow,
		flex: "none",
		...getTransBg("50%", token$1.colorFillSecondary),
		[`${componentCls}-color-block-inner`]: {
			width: "100%",
			height: "100%",
			boxShadow: `inset 0 0 0 ${unit(lineWidth)} ${colorFillSecondary}`,
			borderRadius: "inherit"
		}
	} };
};
var color_block_default = genColorBlockStyle;

//#endregion
//#region node_modules/antd/es/color-picker/style/input.js
var genInputStyle = (token$1) => {
	const { componentCls, antCls, fontSizeSM, lineHeightSM, colorPickerAlphaInputWidth, marginXXS, paddingXXS, controlHeightSM, marginXS, fontSizeIcon, paddingXS, colorTextPlaceholder, colorPickerInputNumberHandleWidth, lineWidth } = token$1;
	return { [`${componentCls}-input-container`]: {
		display: "flex",
		[`${componentCls}-steppers${antCls}-input-number`]: {
			fontSize: fontSizeSM,
			lineHeight: lineHeightSM,
			padding: 0,
			[`${antCls}-input-number-input`]: {
				paddingInlineStart: paddingXXS,
				paddingInlineEnd: 0
			},
			[`${antCls}-input-number-handler-wrap`]: { width: colorPickerInputNumberHandleWidth }
		},
		[`${componentCls}-steppers${componentCls}-alpha-input`]: {
			flex: `0 0 ${unit(colorPickerAlphaInputWidth)}`,
			marginInlineStart: marginXXS
		},
		[`${componentCls}-format-select${antCls}-select`]: {
			marginInlineEnd: marginXS,
			width: "auto",
			"&-single": {
				[`${antCls}-select-selector`]: {
					padding: 0,
					border: 0
				},
				[`${antCls}-select-arrow`]: { insetInlineEnd: 0 },
				[`${antCls}-select-selection-item`]: {
					paddingInlineEnd: token$1.calc(fontSizeIcon).add(marginXXS).equal(),
					fontSize: fontSizeSM,
					lineHeight: unit(controlHeightSM)
				},
				[`${antCls}-select-item-option-content`]: {
					fontSize: fontSizeSM,
					lineHeight: lineHeightSM
				},
				[`${antCls}-select-dropdown`]: { [`${antCls}-select-item`]: { minHeight: "auto" } }
			}
		},
		[`${componentCls}-input`]: {
			gap: marginXXS,
			alignItems: "center",
			flex: 1,
			width: 0,
			[`${componentCls}-hsb-input,${componentCls}-rgb-input`]: {
				height: controlHeightSM,
				display: "flex",
				gap: marginXXS,
				alignItems: "center"
			},
			[`${componentCls}-steppers`]: { flex: 1 },
			[`${componentCls}-hex-input${antCls}-input-affix-wrapper`]: {
				flex: 1,
				padding: `0 ${unit(paddingXS)}`,
				[`${antCls}-input`]: {
					fontSize: fontSizeSM,
					textTransform: "uppercase",
					lineHeight: unit(token$1.calc(controlHeightSM).sub(token$1.calc(lineWidth).mul(2)).equal())
				},
				[`${antCls}-input-prefix`]: { color: colorTextPlaceholder }
			}
		}
	} };
};
var input_default$1 = genInputStyle;

//#endregion
//#region node_modules/antd/es/color-picker/style/picker.js
var genPickerStyle = (token$1) => {
	const { componentCls, controlHeightLG, borderRadiusSM, colorPickerInsetShadow, marginSM, colorBgElevated, colorFillSecondary, lineWidthBold, colorPickerHandlerSize } = token$1;
	return {
		userSelect: "none",
		[`${componentCls}-select`]: {
			[`${componentCls}-palette`]: {
				minHeight: token$1.calc(controlHeightLG).mul(4).equal(),
				overflow: "hidden",
				borderRadius: borderRadiusSM
			},
			[`${componentCls}-saturation`]: {
				position: "absolute",
				borderRadius: "inherit",
				boxShadow: colorPickerInsetShadow,
				inset: 0
			},
			marginBottom: marginSM
		},
		[`${componentCls}-handler`]: {
			width: colorPickerHandlerSize,
			height: colorPickerHandlerSize,
			border: `${unit(lineWidthBold)} solid ${colorBgElevated}`,
			position: "relative",
			borderRadius: "50%",
			cursor: "pointer",
			boxShadow: `${colorPickerInsetShadow}, 0 0 0 1px ${colorFillSecondary}`
		}
	};
};
var picker_default = genPickerStyle;

//#endregion
//#region node_modules/antd/es/color-picker/style/presets.js
var genPresetsStyle = (token$1) => {
	const { componentCls, antCls, colorTextQuaternary, paddingXXS, colorPickerPresetColorSize, fontSizeSM, colorText, lineHeightSM, lineWidth, borderRadius, colorFill, colorWhite, marginXXS, paddingXS, fontHeightSM } = token$1;
	return { [`${componentCls}-presets`]: {
		[`${antCls}-collapse-item > ${antCls}-collapse-header`]: {
			padding: 0,
			[`${antCls}-collapse-expand-icon`]: {
				height: fontHeightSM,
				color: colorTextQuaternary,
				paddingInlineEnd: paddingXXS
			}
		},
		[`${antCls}-collapse`]: {
			display: "flex",
			flexDirection: "column",
			gap: marginXXS
		},
		[`${antCls}-collapse-item > ${antCls}-collapse-panel > ${antCls}-collapse-body`]: { padding: `${unit(paddingXS)} 0` },
		"&-label": {
			fontSize: fontSizeSM,
			color: colorText,
			lineHeight: lineHeightSM
		},
		"&-items": {
			display: "flex",
			flexWrap: "wrap",
			gap: token$1.calc(marginXXS).mul(1.5).equal(),
			[`${componentCls}-presets-color`]: {
				position: "relative",
				cursor: "pointer",
				width: colorPickerPresetColorSize,
				height: colorPickerPresetColorSize,
				"&::before": {
					content: "\"\"",
					pointerEvents: "none",
					width: token$1.calc(colorPickerPresetColorSize).add(token$1.calc(lineWidth).mul(4)).equal(),
					height: token$1.calc(colorPickerPresetColorSize).add(token$1.calc(lineWidth).mul(4)).equal(),
					position: "absolute",
					top: token$1.calc(lineWidth).mul(-2).equal(),
					insetInlineStart: token$1.calc(lineWidth).mul(-2).equal(),
					borderRadius,
					border: `${unit(lineWidth)} solid transparent`,
					transition: `border-color ${token$1.motionDurationMid} ${token$1.motionEaseInBack}`
				},
				"&:hover::before": { borderColor: colorFill },
				"&::after": {
					boxSizing: "border-box",
					position: "absolute",
					top: "50%",
					insetInlineStart: "21.5%",
					display: "table",
					width: token$1.calc(colorPickerPresetColorSize).div(13).mul(5).equal(),
					height: token$1.calc(colorPickerPresetColorSize).div(13).mul(8).equal(),
					border: `${unit(token$1.lineWidthBold)} solid ${token$1.colorWhite}`,
					borderTop: 0,
					borderInlineStart: 0,
					transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
					opacity: 0,
					content: "\"\"",
					transition: `all ${token$1.motionDurationFast} ${token$1.motionEaseInBack}, opacity ${token$1.motionDurationFast}`
				},
				[`&${componentCls}-presets-color-checked`]: {
					"&::after": {
						opacity: 1,
						borderColor: colorWhite,
						transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
						transition: `transform ${token$1.motionDurationMid} ${token$1.motionEaseOutBack} ${token$1.motionDurationFast}`
					},
					[`&${componentCls}-presets-color-bright`]: { "&::after": { borderColor: "rgba(0, 0, 0, 0.45)" } }
				}
			}
		},
		"&-empty": {
			fontSize: fontSizeSM,
			color: colorTextQuaternary
		}
	} };
};
var presets_default = genPresetsStyle;

//#endregion
//#region node_modules/antd/es/color-picker/style/slider.js
var genSliderStyle = (token$1) => {
	const { componentCls, colorPickerInsetShadow, colorBgElevated, colorFillSecondary, lineWidthBold, colorPickerHandlerSizeSM, colorPickerSliderHeight, marginSM, marginXS } = token$1;
	const handleInnerSize = token$1.calc(colorPickerHandlerSizeSM).sub(token$1.calc(lineWidthBold).mul(2).equal()).equal();
	const handleHoverSize = token$1.calc(colorPickerHandlerSizeSM).add(token$1.calc(lineWidthBold).mul(2).equal()).equal();
	const activeHandleStyle = { "&:after": {
		transform: "scale(1)",
		boxShadow: `${colorPickerInsetShadow}, 0 0 0 1px ${token$1.colorPrimaryActive}`
	} };
	return {
		[`${componentCls}-slider`]: [getTransBg(unit(colorPickerSliderHeight), token$1.colorFillSecondary), {
			margin: 0,
			padding: 0,
			height: colorPickerSliderHeight,
			borderRadius: token$1.calc(colorPickerSliderHeight).div(2).equal(),
			"&-rail": {
				height: colorPickerSliderHeight,
				borderRadius: token$1.calc(colorPickerSliderHeight).div(2).equal(),
				boxShadow: colorPickerInsetShadow
			},
			[`& ${componentCls}-slider-handle`]: {
				width: handleInnerSize,
				height: handleInnerSize,
				top: 0,
				borderRadius: "100%",
				"&:before": {
					display: "block",
					position: "absolute",
					background: "transparent",
					left: {
						_skip_check_: true,
						value: "50%"
					},
					top: "50%",
					transform: "translate(-50%, -50%)",
					width: handleHoverSize,
					height: handleHoverSize,
					borderRadius: "100%"
				},
				"&:after": {
					width: colorPickerHandlerSizeSM,
					height: colorPickerHandlerSizeSM,
					border: `${unit(lineWidthBold)} solid ${colorBgElevated}`,
					boxShadow: `${colorPickerInsetShadow}, 0 0 0 1px ${colorFillSecondary}`,
					outline: "none",
					insetInlineStart: token$1.calc(lineWidthBold).mul(-1).equal(),
					top: token$1.calc(lineWidthBold).mul(-1).equal(),
					background: "transparent",
					transition: "none"
				},
				"&:focus": activeHandleStyle
			}
		}],
		[`${componentCls}-slider-container`]: {
			display: "flex",
			gap: marginSM,
			marginBottom: marginSM,
			[`${componentCls}-slider-group`]: {
				flex: 1,
				flexDirection: "column",
				justifyContent: "space-between",
				display: "flex",
				"&-disabled-alpha": { justifyContent: "center" }
			}
		},
		[`${componentCls}-gradient-slider`]: {
			marginBottom: marginXS,
			[`& ${componentCls}-slider-handle`]: {
				"&:after": { transform: "scale(0.8)" },
				"&-active, &:focus": activeHandleStyle
			}
		}
	};
};
var slider_default$1 = genSliderStyle;

//#endregion
//#region node_modules/antd/es/color-picker/style/index.js
const genActiveStyle = (token$1, borderColor, outlineColor) => ({
	borderInlineEndWidth: token$1.lineWidth,
	borderColor,
	boxShadow: `0 0 0 ${unit(token$1.controlOutlineWidth)} ${outlineColor}`,
	outline: 0
});
var genRtlStyle$1 = (token$1) => {
	const { componentCls } = token$1;
	return { "&-rtl": {
		[`${componentCls}-presets-color`]: { "&::after": { direction: "ltr" } },
		[`${componentCls}-clear`]: { "&::after": { direction: "ltr" } }
	} };
};
var genClearStyle = (token$1, size, extraStyle) => {
	const { componentCls, borderRadiusSM, lineWidth, colorSplit, colorBorder, red6 } = token$1;
	return { [`${componentCls}-clear`]: {
		width: size,
		height: size,
		borderRadius: borderRadiusSM,
		border: `${unit(lineWidth)} solid ${colorSplit}`,
		position: "relative",
		overflow: "hidden",
		cursor: "inherit",
		transition: `all ${token$1.motionDurationFast}`,
		...extraStyle,
		"&::after": {
			content: "\"\"",
			position: "absolute",
			insetInlineEnd: token$1.calc(lineWidth).mul(-1).equal(),
			top: token$1.calc(lineWidth).mul(-1).equal(),
			display: "block",
			width: 40,
			height: 2,
			transformOrigin: `calc(100% - 1px) 1px`,
			transform: "rotate(-45deg)",
			backgroundColor: red6
		},
		"&:hover": { borderColor: colorBorder }
	} };
};
var genStatusStyle$1 = (token$1) => {
	const { componentCls, colorError, colorWarning, colorErrorHover, colorWarningHover, colorErrorOutline, colorWarningOutline } = token$1;
	return {
		[`&${componentCls}-status-error`]: {
			borderColor: colorError,
			"&:hover": { borderColor: colorErrorHover },
			[`&${componentCls}-trigger-active`]: { ...genActiveStyle(token$1, colorError, colorErrorOutline) }
		},
		[`&${componentCls}-status-warning`]: {
			borderColor: colorWarning,
			"&:hover": { borderColor: colorWarningHover },
			[`&${componentCls}-trigger-active`]: { ...genActiveStyle(token$1, colorWarning, colorWarningOutline) }
		}
	};
};
var genSizeStyle$1 = (token$1) => {
	const { componentCls, controlHeightLG, controlHeightSM, controlHeight, controlHeightXS, borderRadius, borderRadiusSM, borderRadiusXS, borderRadiusLG, fontSizeLG } = token$1;
	return {
		[`&${componentCls}-lg`]: {
			minWidth: controlHeightLG,
			minHeight: controlHeightLG,
			borderRadius: borderRadiusLG,
			[`${componentCls}-color-block, ${componentCls}-clear`]: {
				width: controlHeight,
				height: controlHeight,
				borderRadius
			},
			[`${componentCls}-trigger-text`]: { fontSize: fontSizeLG }
		},
		[`&${componentCls}-sm`]: {
			minWidth: controlHeightSM,
			minHeight: controlHeightSM,
			borderRadius: borderRadiusSM,
			[`${componentCls}-color-block, ${componentCls}-clear`]: {
				width: controlHeightXS,
				height: controlHeightXS,
				borderRadius: borderRadiusXS
			},
			[`${componentCls}-trigger-text`]: { lineHeight: unit(controlHeightXS) }
		}
	};
};
var genColorPickerStyle = (token$1) => {
	const { antCls, componentCls, colorPickerWidth, colorPrimary, motionDurationMid, colorBgElevated, colorTextDisabled, colorText, colorBgContainerDisabled, borderRadius, marginXS, marginSM, controlHeight, controlHeightSM, colorBgTextActive, colorPickerPresetColorSize, colorPickerPreviewSize, lineWidth, colorBorder, paddingXXS, fontSize, colorPrimaryHover, controlOutline } = token$1;
	return [{ [componentCls]: {
		[`${componentCls}-inner`]: {
			"&-content": {
				display: "flex",
				flexDirection: "column",
				width: colorPickerWidth,
				[`& > ${antCls}-divider`]: { margin: `${unit(marginSM)} 0 ${unit(marginXS)}` }
			},
			[`${componentCls}-panel`]: { ...picker_default(token$1) },
			...slider_default$1(token$1),
			...color_block_default(token$1, colorPickerPreviewSize),
			...input_default$1(token$1),
			...presets_default(token$1),
			...genClearStyle(token$1, colorPickerPresetColorSize, { marginInlineStart: "auto" }),
			[`${componentCls}-operation`]: {
				display: "flex",
				justifyContent: "space-between",
				marginBottom: marginXS
			}
		},
		"&-trigger": {
			minWidth: controlHeight,
			minHeight: controlHeight,
			borderRadius,
			border: `${unit(lineWidth)} solid ${colorBorder}`,
			cursor: "pointer",
			display: "inline-flex",
			alignItems: "flex-start",
			justifyContent: "center",
			transition: `all ${motionDurationMid}`,
			background: colorBgElevated,
			padding: token$1.calc(paddingXXS).sub(lineWidth).equal(),
			[`${componentCls}-trigger-text`]: {
				marginInlineStart: marginXS,
				marginInlineEnd: token$1.calc(marginXS).sub(token$1.calc(paddingXXS).sub(lineWidth)).equal(),
				fontSize,
				color: colorText,
				alignSelf: "center",
				"&-cell": {
					"&:not(:last-child):after": { content: "\", \"" },
					"&-inactive": { color: colorTextDisabled }
				}
			},
			"&:hover": { borderColor: colorPrimaryHover },
			[`&${componentCls}-trigger-active`]: { ...genActiveStyle(token$1, colorPrimary, controlOutline) },
			"&-disabled": {
				color: colorTextDisabled,
				background: colorBgContainerDisabled,
				cursor: "not-allowed",
				"&:hover": { borderColor: colorBgTextActive },
				[`${componentCls}-trigger-text`]: { color: colorTextDisabled }
			},
			...genClearStyle(token$1, controlHeightSM),
			...color_block_default(token$1, controlHeightSM),
			...genStatusStyle$1(token$1),
			...genSizeStyle$1(token$1)
		},
		...genRtlStyle$1(token$1)
	} }, genCompactItemStyle(token$1, { focusElCls: `${componentCls}-trigger-active` })];
};
var style_default$34 = genStyleHooks("ColorPicker", (token$1) => {
	const { colorTextQuaternary, marginSM } = token$1;
	const colorPickerSliderHeight = 8;
	return genColorPickerStyle(merge(token$1, {
		colorPickerWidth: 234,
		colorPickerHandlerSize: 16,
		colorPickerHandlerSizeSM: 12,
		colorPickerAlphaInputWidth: 44,
		colorPickerInputNumberHandleWidth: 16,
		colorPickerPresetColorSize: 24,
		colorPickerInsetShadow: `inset 0 0 1px 0 ${colorTextQuaternary}`,
		colorPickerSliderHeight,
		colorPickerPreviewSize: token$1.calc(colorPickerSliderHeight).mul(2).add(marginSM).equal()
	}));
});

//#endregion
//#region node_modules/antd/es/color-picker/ColorPicker.js
var ColorPicker = (props) => {
	const { mode, value, defaultValue, format: format$1, defaultFormat, allowClear = false, presets, children, trigger = "click", open: open$2, disabled, placement = "bottomLeft", arrow = true, panelRender, showText, style: style$1, className, size: customizeSize, rootClassName, prefixCls: customizePrefixCls, styles, classNames, disabledAlpha = false, onFormatChange, onChange, onClear, onOpenChange, onChangeComplete, getPopupContainer, autoAdjustOverflow: autoAdjustOverflow$2 = true, destroyTooltipOnHide, destroyOnHidden, disabledFormat, ...rest } = props;
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("colorPicker");
	const contextDisabled = (0, import_react.useContext)(DisabledContext_default);
	const mergedDisabled = disabled ?? contextDisabled;
	const prefixCls = getPrefixCls("color-picker", customizePrefixCls);
	const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
	const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
	const mergedProps = {
		...props,
		trigger,
		allowClear,
		autoAdjustOverflow: autoAdjustOverflow$2,
		disabledAlpha,
		arrow,
		placement,
		disabled: mergedDisabled,
		size: mergedSize
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps }, { popup: { _default: "root" } });
	const [internalPopupOpen, setPopupOpen] = useControlledState(false, open$2);
	const popupOpen = !mergedDisabled && internalPopupOpen;
	const [formatValue$1, setFormatValue] = useControlledState(defaultFormat, format$1);
	const triggerFormatChange = (newFormat) => {
		setFormatValue(newFormat);
		if (formatValue$1 !== newFormat) onFormatChange?.(newFormat);
	};
	const triggerOpenChange = (visible) => {
		if (!visible || !mergedDisabled) {
			setPopupOpen(visible);
			onOpenChange?.(visible);
		}
	};
	const [mergedColor, setColor, modeState, setModeState, modeOptions] = useModeColor(defaultValue, value, mode);
	const isAlphaColor = (0, import_react.useMemo)(() => getColorAlpha(mergedColor) < 100, [mergedColor]);
	const [cachedGradientColor, setCachedGradientColor] = import_react.useState(null);
	const onInternalChangeComplete = (color) => {
		if (onChangeComplete) {
			let changeColor = generateColor(color);
			if (disabledAlpha && isAlphaColor) changeColor = genAlphaColor(color);
			onChangeComplete(changeColor);
		}
	};
	const onInternalChange = (data, changeFromPickerDrag) => {
		let color = generateColor(data);
		if (disabledAlpha && isAlphaColor) color = genAlphaColor(color);
		setColor(color);
		setCachedGradientColor(null);
		if (onChange) onChange(color, color.toCssString());
		if (!changeFromPickerDrag) onInternalChangeComplete(color);
	};
	const [activeIndex, setActiveIndex] = import_react.useState(0);
	const [gradientDragging, setGradientDragging] = import_react.useState(false);
	const onInternalModeChange = (newMode) => {
		setModeState(newMode);
		if (newMode === "single" && mergedColor.isGradient()) {
			setActiveIndex(0);
			onInternalChange(new AggregationColor(mergedColor.getColors()[0].color));
			setCachedGradientColor(mergedColor);
		} else if (newMode === "gradient" && !mergedColor.isGradient()) {
			const baseColor = isAlphaColor ? genAlphaColor(mergedColor) : mergedColor;
			onInternalChange(new AggregationColor(cachedGradientColor || [{
				percent: 0,
				color: baseColor
			}, {
				percent: 100,
				color: baseColor
			}]));
		}
	};
	const { status: contextStatus } = import_react.useContext(FormItemInputContext);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$34(prefixCls, rootCls);
	const rtlCls = { [`${prefixCls}-rtl`]: direction };
	const mergedRootCls = clsx(mergedClassNames.root, rootClassName, cssVarCls, rootCls, rtlCls);
	const mergedCls = clsx(getStatusClassNames(prefixCls, contextStatus), {
		[`${prefixCls}-sm`]: mergedSize === "small",
		[`${prefixCls}-lg`]: mergedSize === "large"
	}, compactItemClassnames, contextClassName, mergedRootCls, className, hashId);
	const mergedPopupCls = clsx(prefixCls, mergedRootCls, mergedClassNames.popup?.root);
	devUseWarning("ColorPicker")(!(disabledAlpha && isAlphaColor), "usage", "`disabledAlpha` will make the alpha to be 100% when use alpha color.");
	const popoverProps = {
		open: popupOpen,
		trigger,
		placement,
		arrow,
		rootClassName,
		getPopupContainer,
		autoAdjustOverflow: autoAdjustOverflow$2,
		destroyOnHidden: destroyOnHidden ?? !!destroyTooltipOnHide
	};
	const mergedStyle = {
		...mergedStyles.root,
		...contextStyle,
		...style$1
	};
	return /* @__PURE__ */ import_react.createElement(popover_default, {
		classNames: { root: mergedPopupCls },
		styles: {
			root: mergedStyles.popup?.root,
			container: styles?.popupOverlayInner
		},
		onOpenChange: triggerOpenChange,
		content: /* @__PURE__ */ import_react.createElement(ContextIsolator_default, { form: true }, /* @__PURE__ */ import_react.createElement(ColorPickerPanel_default, {
			mode: modeState,
			onModeChange: onInternalModeChange,
			modeOptions,
			prefixCls,
			value: mergedColor,
			allowClear,
			disabled: mergedDisabled,
			disabledAlpha,
			presets,
			panelRender,
			format: formatValue$1,
			onFormatChange: triggerFormatChange,
			onChange: onInternalChange,
			onChangeComplete: onInternalChangeComplete,
			onClear,
			activeIndex,
			onActive: setActiveIndex,
			gradientDragging,
			onGradientDragging: setGradientDragging,
			disabledFormat
		})),
		...popoverProps
	}, children || /* @__PURE__ */ import_react.createElement(ColorTrigger_default, {
		activeIndex: popupOpen ? activeIndex : -1,
		open: popupOpen,
		className: mergedCls,
		style: mergedStyle,
		prefixCls,
		disabled: mergedDisabled,
		showText,
		format: formatValue$1,
		...rest,
		color: mergedColor
	}));
};
ColorPicker.displayName = "ColorPicker";
ColorPicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default(ColorPicker, void 0, (props) => ({
	...props,
	placement: "bottom",
	autoAdjustOverflow: false
}), "color-picker", (prefixCls) => prefixCls);
var ColorPicker_default = ColorPicker;

//#endregion
//#region node_modules/antd/es/color-picker/index.js
var color_picker_default = ColorPicker_default;

//#endregion
//#region node_modules/antd/es/date-picker/hooks/useMergedPickerSemantic.js
var useMergedPickerSemantic = (pickerType, classNames, styles, popupClassName, popupStyle, mergedProps) => {
	const { classNames: contextClassNames, styles: contextStyles } = useComponentConfig(pickerType);
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps }, { popup: { _default: "root" } });
	return import_react.useMemo(() => {
		return [{
			...mergedClassNames,
			popup: {
				...mergedClassNames.popup,
				root: clsx(mergedClassNames.popup?.root, popupClassName)
			}
		}, {
			...mergedStyles,
			popup: {
				...mergedStyles.popup,
				root: {
					...mergedStyles.popup?.root,
					...popupStyle
				}
			}
		}];
	}, [
		mergedClassNames,
		mergedStyles,
		popupClassName,
		popupStyle
	]);
};
var useMergedPickerSemantic_default = useMergedPickerSemantic;

//#endregion
//#region node_modules/antd/es/date-picker/util.js
function getPlaceholder(locale$5, picker, customizePlaceholder) {
	if (customizePlaceholder !== void 0) return customizePlaceholder;
	if (picker === "year" && locale$5.lang.yearPlaceholder) return locale$5.lang.yearPlaceholder;
	if (picker === "quarter" && locale$5.lang.quarterPlaceholder) return locale$5.lang.quarterPlaceholder;
	if (picker === "month" && locale$5.lang.monthPlaceholder) return locale$5.lang.monthPlaceholder;
	if (picker === "week" && locale$5.lang.weekPlaceholder) return locale$5.lang.weekPlaceholder;
	if (picker === "time" && locale$5.timePickerLocale.placeholder) return locale$5.timePickerLocale.placeholder;
	return locale$5.lang.placeholder;
}
function getRangePlaceholder(locale$5, picker, customizePlaceholder) {
	if (customizePlaceholder !== void 0) return customizePlaceholder;
	if (picker === "year" && locale$5.lang.yearPlaceholder) return locale$5.lang.rangeYearPlaceholder;
	if (picker === "quarter" && locale$5.lang.quarterPlaceholder) return locale$5.lang.rangeQuarterPlaceholder;
	if (picker === "month" && locale$5.lang.monthPlaceholder) return locale$5.lang.rangeMonthPlaceholder;
	if (picker === "week" && locale$5.lang.weekPlaceholder) return locale$5.lang.rangeWeekPlaceholder;
	if (picker === "time" && locale$5.timePickerLocale.placeholder) return locale$5.timePickerLocale.rangePlaceholder;
	return locale$5.lang.rangePlaceholder;
}
function useIcons$1(props, prefixCls) {
	const { allowClear = true } = props;
	const { clearIcon, removeIcon } = useIcons({
		...props,
		prefixCls,
		componentName: "DatePicker"
	});
	return [import_react.useMemo(() => {
		if (allowClear === false) return false;
		return {
			clearIcon,
			...allowClear === true ? {} : allowClear
		};
	}, [allowClear, clearIcon]), removeIcon];
}

//#endregion
//#region node_modules/antd/es/date-picker/generatePicker/constant.js
const [WEEK, WEEKPICKER] = ["week", "WeekPicker"];
const [MONTH, MONTHPICKER] = ["month", "MonthPicker"];
const [YEAR, YEARPICKER] = ["year", "YearPicker"];
const [QUARTER, QUARTERPICKER] = ["quarter", "QuarterPicker"];
const [TIME, TIMEPICKER] = ["time", "TimePicker"];

//#endregion
//#region node_modules/antd/es/date-picker/generatePicker/SuffixIcon.js
var SuffixIcon = ({ picker, hasFeedback, feedbackIcon, suffixIcon }) => {
	if (suffixIcon === null || suffixIcon === false) return null;
	if (suffixIcon === true || suffixIcon === void 0) return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, picker === TIME ? /* @__PURE__ */ import_react.createElement(ClockCircleOutlined_default, null) : /* @__PURE__ */ import_react.createElement(CalendarOutlined_default, null), hasFeedback && feedbackIcon);
	return suffixIcon;
};
var SuffixIcon_default = SuffixIcon;

//#endregion
//#region node_modules/antd/es/date-picker/PickerButton.js
var PickerButton = (props) => /* @__PURE__ */ import_react.createElement(Button_default, {
	size: "small",
	type: "primary",
	...props
});
var PickerButton_default = PickerButton;

//#endregion
//#region node_modules/antd/es/date-picker/generatePicker/useComponents.js
function useComponents(components$1) {
	return (0, import_react.useMemo)(() => ({
		button: PickerButton_default,
		...components$1
	}), [components$1]);
}

//#endregion
//#region node_modules/antd/es/date-picker/generatePicker/generateRangePicker.js
var generateRangePicker = (generateConfig$1) => {
	const RangePicker$2 = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
		const { prefixCls: customizePrefixCls, getPopupContainer: customGetPopupContainer, components: components$1, className, style: style$1, classNames, styles, placement, size: customizeSize, disabled: customDisabled, bordered = true, placeholder, status: customStatus, variant: customVariant, picker, dropdownClassName, popupClassName, popupStyle, rootClassName, suffixIcon, ...restProps } = props;
		const pickerType = picker === TIME ? "timePicker" : "datePicker";
		{
			const warning$3 = devUseWarning("DatePicker.RangePicker");
			Object.entries({
				dropdownClassName: "classNames.popup.root",
				popupClassName: "classNames.popup.root",
				popupStyle: "styles.popup.root",
				bordered: "variant",
				onSelect: "onCalendarChange"
			}).forEach(([oldProp, newProp]) => {
				warning$3.deprecated(!(oldProp in props), oldProp, newProp);
			});
		}
		const [mergedClassNames, mergedStyles] = useMergedPickerSemantic_default(pickerType, classNames, styles, popupClassName || dropdownClassName, popupStyle);
		const innerRef = import_react.useRef(null);
		const { getPrefixCls, direction, getPopupContainer, rangePicker } = (0, import_react.useContext)(ConfigContext);
		const prefixCls = getPrefixCls("picker", customizePrefixCls);
		const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
		const rootPrefixCls = getPrefixCls();
		const [variant, enableVariantCls] = useVariants_default("rangePicker", customVariant, bordered);
		const rootCls = useCSSVarCls_default(prefixCls);
		const [hashId, cssVarCls] = style_default$33(prefixCls, rootCls);
		const mergedRootClassName = clsx(hashId, cssVarCls, rootCls, rootClassName);
		const [mergedAllowClear] = useIcons$1(props, prefixCls);
		const mergedComponents = useComponents(components$1);
		const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
		const disabled = import_react.useContext(DisabledContext_default);
		const mergedDisabled = customDisabled ?? disabled;
		const { hasFeedback, status: contextStatus, feedbackIcon } = (0, import_react.useContext)(FormItemInputContext);
		const mergedSuffixIcon = /* @__PURE__ */ import_react.createElement(SuffixIcon_default, {
			picker,
			hasFeedback,
			feedbackIcon,
			suffixIcon
		});
		(0, import_react.useImperativeHandle)(ref, () => innerRef.current);
		const [contextLocale] = useLocale_default("Calendar", en_US_default$2);
		const locale$5 = {
			...contextLocale,
			...props.locale
		};
		const [zIndex] = useZIndex("DatePicker", mergedStyles?.popup?.root?.zIndex);
		return /* @__PURE__ */ import_react.createElement(ContextIsolator_default, { space: true }, /* @__PURE__ */ import_react.createElement(RangePicker_default, {
			separator: /* @__PURE__ */ import_react.createElement("span", {
				"aria-label": "to",
				className: `${prefixCls}-separator`
			}, /* @__PURE__ */ import_react.createElement(SwapRightOutlined_default, null)),
			disabled: mergedDisabled,
			ref: innerRef,
			placement,
			placeholder: getRangePlaceholder(locale$5, picker, placeholder),
			suffixIcon: mergedSuffixIcon,
			prevIcon: /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-prev-icon` }),
			nextIcon: /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-next-icon` }),
			superPrevIcon: /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-super-prev-icon` }),
			superNextIcon: /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-super-next-icon` }),
			transitionName: `${rootPrefixCls}-slide-up`,
			picker,
			...restProps,
			locale: locale$5.lang,
			getPopupContainer: customGetPopupContainer || getPopupContainer,
			generateConfig: generateConfig$1,
			components: mergedComponents,
			direction,
			prefixCls,
			rootClassName: mergedRootClassName,
			className: clsx({
				[`${prefixCls}-${mergedSize}`]: mergedSize,
				[`${prefixCls}-${variant}`]: enableVariantCls
			}, getStatusClassNames(prefixCls, getMergedStatus(contextStatus, customStatus), hasFeedback), compactItemClassnames, className, rangePicker?.className),
			style: {
				...rangePicker?.style,
				...style$1
			},
			classNames: mergedClassNames,
			styles: {
				...mergedStyles,
				popup: {
					...mergedStyles.popup,
					root: {
						...mergedStyles.popup.root,
						zIndex
					}
				}
			},
			allowClear: mergedAllowClear
		}));
	});
	RangePicker$2.displayName = "RangePicker";
	return RangePicker$2;
};
var generateRangePicker_default = generateRangePicker;

//#endregion
//#region node_modules/antd/es/date-picker/generatePicker/generateSinglePicker.js
var generatePicker$1 = (generateConfig$1) => {
	const getPicker = (picker, displayName) => {
		const pickerType = displayName === TIMEPICKER ? "timePicker" : "datePicker";
		const Picker$2 = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
			const { prefixCls: customizePrefixCls, getPopupContainer: customizeGetPopupContainer, components: components$1, style: style$1, className, size: customizeSize, bordered, placement, placeholder, disabled: customDisabled, status: customStatus, variant: customVariant, onCalendarChange, classNames, styles, dropdownClassName, popupClassName, popupStyle, rootClassName, suffixIcon, ...restProps } = props;
			{
				const warning$3 = devUseWarning(displayName || "DatePicker");
				warning$3(picker !== "quarter", "deprecated", `DatePicker.${displayName} is legacy usage. Please use DatePicker[picker='${picker}'] directly.`);
				Object.entries({
					dropdownClassName: "classNames.popup.root",
					popupClassName: "classNames.popup.root",
					popupStyle: "styles.popup.root",
					bordered: "variant",
					onSelect: "onCalendarChange"
				}).forEach(([oldProp, newProp]) => {
					warning$3.deprecated(!(oldProp in props), oldProp, newProp);
				});
			}
			const { getPrefixCls, direction, getPopupContainer, [pickerType]: contextPickerConfig } = (0, import_react.useContext)(ConfigContext);
			const prefixCls = getPrefixCls("picker", customizePrefixCls);
			const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
			const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
			const disabled = import_react.useContext(DisabledContext_default);
			const mergedDisabled = customDisabled ?? disabled;
			const mergedProps = {
				...props,
				size: mergedSize,
				disabled: mergedDisabled,
				status: customStatus,
				variant: customVariant
			};
			const [mergedClassNames, mergedStyles] = useMergedPickerSemantic_default(pickerType, classNames, styles, popupClassName || dropdownClassName, popupStyle, mergedProps);
			const innerRef = import_react.useRef(null);
			const [variant, enableVariantCls] = useVariants_default("datePicker", customVariant, bordered);
			const rootCls = useCSSVarCls_default(prefixCls);
			const [hashId, cssVarCls] = style_default$33(prefixCls, rootCls);
			const mergedRootClassName = clsx(hashId, cssVarCls, rootCls, rootClassName);
			(0, import_react.useImperativeHandle)(ref, () => innerRef.current);
			const additionalProps = { showToday: true };
			const mergedPicker = picker || props.picker;
			const rootPrefixCls = getPrefixCls();
			const { onSelect, multiple } = restProps;
			const hasLegacyOnSelect = onSelect && picker === "time" && !multiple;
			const onInternalCalendarChange = (date$1, dateStr, info) => {
				onCalendarChange?.(date$1, dateStr, info);
				if (hasLegacyOnSelect) onSelect(date$1);
			};
			const [mergedAllowClear, removeIcon] = useIcons$1(props, prefixCls);
			const mergedComponents = useComponents(components$1);
			const { hasFeedback, status: contextStatus, feedbackIcon } = (0, import_react.useContext)(FormItemInputContext);
			const mergedSuffixIcon = /* @__PURE__ */ import_react.createElement(SuffixIcon_default, {
				picker: mergedPicker,
				hasFeedback,
				feedbackIcon,
				suffixIcon
			});
			const [contextLocale] = useLocale_default("DatePicker", en_US_default$2);
			const locale$5 = {
				...contextLocale,
				...props.locale
			};
			const [zIndex] = useZIndex("DatePicker", mergedStyles?.popup?.root?.zIndex);
			return /* @__PURE__ */ import_react.createElement(ContextIsolator_default, { space: true }, /* @__PURE__ */ import_react.createElement(es_default$18, {
				ref: innerRef,
				placeholder: getPlaceholder(locale$5, mergedPicker, placeholder),
				suffixIcon: mergedSuffixIcon,
				placement,
				prevIcon: /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-prev-icon` }),
				nextIcon: /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-next-icon` }),
				superPrevIcon: /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-super-prev-icon` }),
				superNextIcon: /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-super-next-icon` }),
				transitionName: `${rootPrefixCls}-slide-up`,
				picker,
				onCalendarChange: onInternalCalendarChange,
				...additionalProps,
				...restProps,
				locale: locale$5.lang,
				getPopupContainer: customizeGetPopupContainer || getPopupContainer,
				generateConfig: generateConfig$1,
				components: mergedComponents,
				direction,
				disabled: mergedDisabled,
				prefixCls,
				rootClassName: mergedRootClassName,
				className: clsx({
					[`${prefixCls}-${mergedSize}`]: mergedSize,
					[`${prefixCls}-${variant}`]: enableVariantCls
				}, getStatusClassNames(prefixCls, getMergedStatus(contextStatus, customStatus), hasFeedback), compactItemClassnames, contextPickerConfig?.className, className),
				style: {
					...contextPickerConfig?.style,
					...style$1
				},
				classNames: mergedClassNames,
				styles: {
					...mergedStyles,
					popup: {
						...mergedStyles.popup,
						root: {
							...mergedStyles.popup.root,
							zIndex
						}
					}
				},
				allowClear: mergedAllowClear,
				removeIcon
			}));
		});
		if (displayName) Picker$2.displayName = displayName;
		return Picker$2;
	};
	const DatePicker$1 = getPicker();
	const WeekPicker = getPicker(WEEK, WEEKPICKER);
	const MonthPicker = getPicker(MONTH, MONTHPICKER);
	const YearPicker = getPicker(YEAR, YEARPICKER);
	const QuarterPicker = getPicker(QUARTER, QUARTERPICKER);
	return {
		DatePicker: DatePicker$1,
		WeekPicker,
		MonthPicker,
		YearPicker,
		TimePicker: getPicker(TIME, TIMEPICKER),
		QuarterPicker
	};
};
var generateSinglePicker_default = generatePicker$1;

//#endregion
//#region node_modules/antd/es/date-picker/generatePicker/index.js
var generatePicker = (generateConfig$1) => {
	const { DatePicker: DatePicker$1, WeekPicker, MonthPicker, YearPicker, TimePicker: TimePicker$1, QuarterPicker } = generateSinglePicker_default(generateConfig$1);
	const RangePicker$2 = generateRangePicker_default(generateConfig$1);
	const MergedDatePicker = DatePicker$1;
	MergedDatePicker.WeekPicker = WeekPicker;
	MergedDatePicker.MonthPicker = MonthPicker;
	MergedDatePicker.YearPicker = YearPicker;
	MergedDatePicker.RangePicker = RangePicker$2;
	MergedDatePicker.TimePicker = TimePicker$1;
	MergedDatePicker.QuarterPicker = QuarterPicker;
	MergedDatePicker.displayName = "DatePicker";
	return MergedDatePicker;
};
var generatePicker_default = generatePicker;

//#endregion
//#region node_modules/antd/es/date-picker/index.js
var DatePicker = generatePicker_default(dayjs_default);
DatePicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default(DatePicker, "popupAlign", void 0, "picker");
DatePicker._InternalRangePanelDoNotUseOrYouWillBeFired = PurePanel_default(DatePicker.RangePicker, "popupAlign", void 0, "picker");
DatePicker.generatePicker = generatePicker_default;
var date_picker_default = DatePicker;

//#endregion
//#region node_modules/antd/es/descriptions/constant.js
var DEFAULT_COLUMN_MAP = {
	xxl: 3,
	xl: 3,
	lg: 3,
	md: 3,
	sm: 2,
	xs: 1
};
var constant_default = DEFAULT_COLUMN_MAP;

//#endregion
//#region node_modules/antd/es/descriptions/DescriptionsContext.js
var DescriptionsContext = /* @__PURE__ */ import_react.createContext(null);
var DescriptionsContext_default = DescriptionsContext;

//#endregion
//#region node_modules/antd/es/descriptions/hooks/useItems.js
var transChildren2Items = (childNodes) => toArray(childNodes).map((node$1) => ({
	...node$1?.props,
	key: node$1.key
}));
function useItems$2(screens, items, children) {
	const mergedItems = import_react.useMemo(() => items || transChildren2Items(children), [items, children]);
	return import_react.useMemo(() => mergedItems.map(({ span, ...restItem }) => {
		if (span === "filled") return {
			...restItem,
			filled: true
		};
		return {
			...restItem,
			span: typeof span === "number" ? span : matchScreen(screens, span)
		};
	}), [mergedItems, screens]);
}

//#endregion
//#region node_modules/antd/es/descriptions/hooks/useRow.js
function getCalcRows(rowItems, mergedColumn) {
	let rows = [];
	let tmpRow = [];
	let exceed = false;
	let count = 0;
	rowItems.filter((n$1) => n$1).forEach((rowItem) => {
		const { filled, ...restItem } = rowItem;
		if (filled) {
			tmpRow.push(restItem);
			rows.push(tmpRow);
			tmpRow = [];
			count = 0;
			return;
		}
		const restSpan = mergedColumn - count;
		count += rowItem.span || 1;
		if (count >= mergedColumn) {
			if (count > mergedColumn) {
				exceed = true;
				tmpRow.push({
					...restItem,
					span: restSpan
				});
			} else tmpRow.push(restItem);
			rows.push(tmpRow);
			tmpRow = [];
			count = 0;
		} else tmpRow.push(restItem);
	});
	if (tmpRow.length > 0) rows.push(tmpRow);
	rows = rows.map((rows$1) => {
		const count$1 = rows$1.reduce((acc, item) => acc + (item.span || 1), 0);
		if (count$1 < mergedColumn) {
			const last = rows$1[rows$1.length - 1];
			last.span = mergedColumn - (count$1 - (last.span || 1));
			return rows$1;
		}
		return rows$1;
	});
	return [rows, exceed];
}
var useRow = (mergedColumn, items) => {
	const [rows, exceed] = (0, import_react.useMemo)(() => getCalcRows(items, mergedColumn), [items, mergedColumn]);
	devUseWarning("Descriptions")(!exceed, "usage", "Sum of column `span` in a line not match `column` of Descriptions.");
	return rows;
};
var useRow_default = useRow;

//#endregion
//#region node_modules/antd/es/descriptions/Item.js
/* istanbul ignore next */
var DescriptionsItem = (props) => {
	return props.children;
};
var Item_default$2 = DescriptionsItem;

//#endregion
//#region node_modules/antd/es/descriptions/Cell.js
var Cell$1 = (props) => {
	const { itemPrefixCls, component, span, className, style: style$1, labelStyle, contentStyle, bordered, label, content, colon, type: type$2, styles, classNames } = props;
	const Component$2 = component;
	const { classNames: contextClassNames, styles: contextStyles } = import_react.useContext(DescriptionsContext_default);
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props });
	const mergedLabelStyle = {
		...labelStyle,
		...mergedStyles.label
	};
	const mergedContentStyle = {
		...contentStyle,
		...mergedStyles.content
	};
	if (bordered) return /* @__PURE__ */ import_react.createElement(Component$2, {
		colSpan: span,
		style: style$1,
		className: clsx(className, {
			[`${itemPrefixCls}-item-${type$2}`]: type$2 === "label" || type$2 === "content",
			[mergedClassNames.label]: mergedClassNames.label && type$2 === "label",
			[mergedClassNames.content]: mergedClassNames.content && type$2 === "content"
		})
	}, isNonNullable_default(label) && /* @__PURE__ */ import_react.createElement("span", { style: mergedLabelStyle }, label), isNonNullable_default(content) && /* @__PURE__ */ import_react.createElement("span", { style: mergedContentStyle }, content));
	return /* @__PURE__ */ import_react.createElement(Component$2, {
		className: clsx(`${itemPrefixCls}-item`, className),
		style: style$1,
		colSpan: span
	}, /* @__PURE__ */ import_react.createElement("div", { className: `${itemPrefixCls}-item-container` }, isNonNullable_default(label) && /* @__PURE__ */ import_react.createElement("span", {
		style: mergedLabelStyle,
		className: clsx(`${itemPrefixCls}-item-label`, mergedClassNames.label, { [`${itemPrefixCls}-item-no-colon`]: !colon })
	}, label), isNonNullable_default(content) && /* @__PURE__ */ import_react.createElement("span", {
		style: mergedContentStyle,
		className: clsx(`${itemPrefixCls}-item-content`, mergedClassNames.content)
	}, content)));
};
var Cell_default$2 = Cell$1;

//#endregion
//#region node_modules/antd/es/descriptions/Row.js
function renderCells(items, { colon, prefixCls, bordered }, { component, type: type$2, showLabel, showContent, labelStyle: rootLabelStyle, contentStyle: rootContentStyle, styles: rootStyles }) {
	return items.map(({ label, children, prefixCls: itemPrefixCls = prefixCls, className, style: style$1, labelStyle, contentStyle, span = 1, key, styles, classNames }, index$1) => {
		if (typeof component === "string") return /* @__PURE__ */ import_react.createElement(Cell_default$2, {
			key: `${type$2}-${key || index$1}`,
			className,
			style: style$1,
			classNames,
			styles: {
				label: {
					...rootLabelStyle,
					...rootStyles?.label,
					...labelStyle,
					...styles?.label
				},
				content: {
					...rootContentStyle,
					...rootStyles?.content,
					...contentStyle,
					...styles?.content
				}
			},
			span,
			colon,
			component,
			itemPrefixCls,
			bordered,
			label: showLabel ? label : null,
			content: showContent ? children : null,
			type: type$2
		});
		return [/* @__PURE__ */ import_react.createElement(Cell_default$2, {
			key: `label-${key || index$1}`,
			className,
			style: {
				...rootLabelStyle,
				...rootStyles?.label,
				...style$1,
				...labelStyle,
				...styles?.label
			},
			span: 1,
			colon,
			component: component[0],
			itemPrefixCls,
			bordered,
			label,
			type: "label"
		}), /* @__PURE__ */ import_react.createElement(Cell_default$2, {
			key: `content-${key || index$1}`,
			className,
			style: {
				...rootContentStyle,
				...rootStyles?.content,
				...style$1,
				...contentStyle,
				...styles?.content
			},
			span: span * 2 - 1,
			component: component[1],
			itemPrefixCls,
			bordered,
			content: children,
			type: "content"
		})];
	});
}
var Row = (props) => {
	const descContext = import_react.useContext(DescriptionsContext_default);
	const { prefixCls, vertical, row, index: index$1, bordered } = props;
	if (vertical) return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("tr", {
		key: `label-${index$1}`,
		className: `${prefixCls}-row`
	}, renderCells(row, props, {
		component: "th",
		type: "label",
		showLabel: true,
		...descContext
	})), /* @__PURE__ */ import_react.createElement("tr", {
		key: `content-${index$1}`,
		className: `${prefixCls}-row`
	}, renderCells(row, props, {
		component: "td",
		type: "content",
		showContent: true,
		...descContext
	})));
	return /* @__PURE__ */ import_react.createElement("tr", {
		key: index$1,
		className: `${prefixCls}-row`
	}, renderCells(row, props, {
		component: bordered ? ["th", "td"] : "td",
		type: "item",
		showLabel: true,
		showContent: true,
		...descContext
	}));
};
var Row_default$1 = Row;

//#endregion
//#region node_modules/antd/es/descriptions/style/index.js
var genBorderedStyle$3 = (token$1) => {
	const { componentCls, labelBg } = token$1;
	return { [`&${componentCls}-bordered`]: {
		[`> ${componentCls}-view`]: {
			border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}`,
			"> table": { tableLayout: "auto" },
			[`${componentCls}-row`]: {
				borderBottom: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}`,
				"&:first-child": { "> th:first-child, > td:first-child": { borderStartStartRadius: token$1.borderRadiusLG } },
				"&:last-child": {
					borderBottom: "none",
					"> th:first-child, > td:first-child": { borderEndStartRadius: token$1.borderRadiusLG }
				},
				[`> ${componentCls}-item-label, > ${componentCls}-item-content`]: {
					padding: `${unit(token$1.padding)} ${unit(token$1.paddingLG)}`,
					borderInlineEnd: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}`,
					"&:last-child": { borderInlineEnd: "none" }
				},
				[`> ${componentCls}-item-label`]: {
					color: token$1.colorTextSecondary,
					backgroundColor: labelBg,
					"&::after": { display: "none" }
				}
			}
		},
		[`&${componentCls}-middle`]: { [`${componentCls}-row`]: { [`> ${componentCls}-item-label, > ${componentCls}-item-content`]: { padding: `${unit(token$1.paddingSM)} ${unit(token$1.paddingLG)}` } } },
		[`&${componentCls}-small`]: { [`${componentCls}-row`]: { [`> ${componentCls}-item-label, > ${componentCls}-item-content`]: { padding: `${unit(token$1.paddingXS)} ${unit(token$1.padding)}` } } }
	} };
};
var genDescriptionStyles = (token$1) => {
	const { componentCls, extraColor, itemPaddingBottom, itemPaddingEnd, colonMarginRight, colonMarginLeft, titleMarginBottom } = token$1;
	return { [componentCls]: {
		...resetComponent(token$1),
		...genBorderedStyle$3(token$1),
		"&-rtl": { direction: "rtl" },
		[`${componentCls}-header`]: {
			display: "flex",
			alignItems: "center",
			marginBottom: titleMarginBottom
		},
		[`${componentCls}-title`]: {
			...textEllipsis,
			flex: "auto",
			color: token$1.titleColor,
			fontWeight: token$1.fontWeightStrong,
			fontSize: token$1.fontSizeLG,
			lineHeight: token$1.lineHeightLG
		},
		[`${componentCls}-extra`]: {
			marginInlineStart: "auto",
			color: extraColor,
			fontSize: token$1.fontSize
		},
		[`${componentCls}-view`]: {
			width: "100%",
			borderRadius: token$1.borderRadiusLG,
			table: {
				width: "100%",
				tableLayout: "fixed",
				borderCollapse: "collapse"
			}
		},
		[`${componentCls}-row`]: {
			"> th, > td": {
				paddingBottom: itemPaddingBottom,
				paddingInlineEnd: itemPaddingEnd
			},
			"> th:last-child, > td:last-child": { paddingInlineEnd: 0 },
			"&:last-child": {
				borderBottom: "none",
				"> th, > td": { paddingBottom: 0 }
			}
		},
		[`${componentCls}-item-label`]: {
			color: token$1.labelColor,
			fontWeight: "normal",
			fontSize: token$1.fontSize,
			lineHeight: token$1.lineHeight,
			textAlign: "start",
			"&::after": {
				content: "\":\"",
				position: "relative",
				top: -.5,
				marginInline: `${unit(colonMarginLeft)} ${unit(colonMarginRight)}`
			},
			[`&${componentCls}-item-no-colon::after`]: { content: "\"\"" }
		},
		[`${componentCls}-item-no-label`]: { "&::after": {
			margin: 0,
			content: "\"\""
		} },
		[`${componentCls}-item-content`]: {
			display: "table-cell",
			flex: 1,
			color: token$1.contentColor,
			fontSize: token$1.fontSize,
			lineHeight: token$1.lineHeight,
			wordBreak: "break-word",
			overflowWrap: "break-word"
		},
		[`${componentCls}-item`]: {
			paddingBottom: 0,
			verticalAlign: "top",
			"&-container": {
				display: "flex",
				[`${componentCls}-item-label`]: {
					display: "inline-flex",
					alignItems: "baseline"
				},
				[`${componentCls}-item-content`]: {
					display: "inline-flex",
					alignItems: "baseline",
					minWidth: "1em"
				}
			}
		},
		"&-middle": { [`${componentCls}-row`]: { "> th, > td": { paddingBottom: token$1.paddingSM } } },
		"&-small": { [`${componentCls}-row`]: { "> th, > td": { paddingBottom: token$1.paddingXS } } }
	} };
};
const prepareComponentToken$26 = (token$1) => ({
	labelBg: token$1.colorFillAlter,
	labelColor: token$1.colorTextTertiary,
	titleColor: token$1.colorText,
	titleMarginBottom: token$1.fontSizeSM * token$1.lineHeightSM,
	itemPaddingBottom: token$1.padding,
	itemPaddingEnd: token$1.padding,
	colonMarginRight: token$1.marginXS,
	colonMarginLeft: token$1.marginXXS / 2,
	contentColor: token$1.colorText,
	extraColor: token$1.colorText
});
var style_default$32 = genStyleHooks("Descriptions", (token$1) => {
	return genDescriptionStyles(merge(token$1, {}));
}, prepareComponentToken$26);

//#endregion
//#region node_modules/antd/es/descriptions/index.js
var Descriptions = (props) => {
	const { prefixCls: customizePrefixCls, title, extra, column: column$1, colon = true, bordered, layout, children, className, rootClassName, style: style$1, size: customizeSize, labelStyle, contentStyle, styles, items, classNames, ...restProps } = props;
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("descriptions");
	const prefixCls = getPrefixCls("descriptions", customizePrefixCls);
	const screens = useBreakpoint_default();
	{
		const warning$3 = devUseWarning("Descriptions");
		[["labelStyle", "styles.label"], ["contentStyle", "styles.content"]].forEach(([deprecatedName, newName]) => {
			warning$3.deprecated(!(deprecatedName in props), deprecatedName, newName);
		});
	}
	const mergedColumn = import_react.useMemo(() => {
		if (typeof column$1 === "number") return column$1;
		return matchScreen(screens, {
			...constant_default,
			...column$1
		}) ?? 3;
	}, [screens, column$1]);
	const mergedItems = useItems$2(screens, items, children);
	const mergedSize = useSize_default(customizeSize);
	const rows = useRow_default(mergedColumn, mergedItems);
	const [hashId, cssVarCls] = style_default$32(prefixCls);
	const mergedProps = {
		...props,
		column: mergedColumn,
		items: mergedItems,
		size: mergedSize
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const memoizedValue = import_react.useMemo(() => ({
		labelStyle,
		contentStyle,
		styles: {
			label: mergedStyles.label,
			content: mergedStyles.content
		},
		classNames: {
			label: clsx(mergedClassNames.label),
			content: clsx(mergedClassNames.content)
		}
	}), [
		labelStyle,
		contentStyle,
		mergedStyles.label,
		mergedStyles.content,
		mergedClassNames.label,
		mergedClassNames.content
	]);
	return /* @__PURE__ */ import_react.createElement(DescriptionsContext_default.Provider, { value: memoizedValue }, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(prefixCls, contextClassName, mergedClassNames.root, {
			[`${prefixCls}-${mergedSize}`]: mergedSize && mergedSize !== "default",
			[`${prefixCls}-bordered`]: !!bordered,
			[`${prefixCls}-rtl`]: direction === "rtl"
		}, className, rootClassName, hashId, cssVarCls),
		style: {
			...contextStyle,
			...mergedStyles.root,
			...style$1
		},
		...restProps
	}, (title || extra) && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-header`, mergedClassNames.header),
		style: mergedStyles.header
	}, title && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-title`, mergedClassNames.title),
		style: mergedStyles.title
	}, title), extra && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-extra`, mergedClassNames.extra),
		style: mergedStyles.extra
	}, extra)), /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-view` }, /* @__PURE__ */ import_react.createElement("table", null, /* @__PURE__ */ import_react.createElement("tbody", null, rows.map((row, index$1) => /* @__PURE__ */ import_react.createElement(Row_default$1, {
		key: index$1,
		index: index$1,
		colon,
		prefixCls,
		vertical: layout === "vertical",
		bordered,
		row
	})))))));
};
Descriptions.displayName = "Descriptions";
Descriptions.Item = Item_default$2;
var descriptions_default = Descriptions;

//#endregion
//#region node_modules/@rc-component/drawer/es/context.js
var DrawerContext = /* @__PURE__ */ import_react.createContext(null);
const RefContext = /* @__PURE__ */ import_react.createContext({});
var context_default$1 = DrawerContext;

//#endregion
//#region node_modules/@rc-component/drawer/es/DrawerPanel.js
function _extends$37() {
	_extends$37 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$37.apply(this, arguments);
}
var DrawerPanel$1 = (props) => {
	const { prefixCls, className, containerRef, ...restProps } = props;
	const { panel: panelRef } = import_react.useContext(RefContext);
	const mergedRef = useComposeRef(panelRef, containerRef);
	return /* @__PURE__ */ import_react.createElement("div", _extends$37({
		className: clsx(`${prefixCls}-section`, className),
		role: "dialog",
		ref: mergedRef
	}, pickAttrs(props, { aria: true }), { "aria-modal": "true" }, restProps));
};
DrawerPanel$1.displayName = "DrawerPanel";
var DrawerPanel_default$1 = DrawerPanel$1;

//#endregion
//#region node_modules/@rc-component/drawer/es/hooks/useDrag.js
function useDrag(options) {
	const { prefixCls, direction, className, style: style$1, maxSize, containerRef, currentSize, onResize: onResize$1, onResizeEnd, onResizeStart } = options;
	const [isDragging, setIsDragging] = import_react.useState(false);
	const [startPos, setStartPos] = import_react.useState(0);
	const [startSize, setStartSize] = import_react.useState(0);
	const isHorizontal = direction === "left" || direction === "right";
	const handleMouseDown = useEvent_default((e$2) => {
		e$2.preventDefault();
		e$2.stopPropagation();
		setIsDragging(true);
		if (isHorizontal) setStartPos(e$2.clientX);
		else setStartPos(e$2.clientY);
		let startSize$1;
		if (typeof currentSize === "number") startSize$1 = currentSize;
		else if (containerRef?.current) {
			const rect = containerRef.current.getBoundingClientRect();
			startSize$1 = isHorizontal ? rect.width : rect.height;
		}
		setStartSize(startSize$1);
		onResizeStart?.(startSize$1);
	});
	const handleMouseMove = useEvent_default((e$2) => {
		if (!isDragging) return;
		let delta = (isHorizontal ? e$2.clientX : e$2.clientY) - startPos;
		if (direction === "right" || direction === "bottom") delta = -delta;
		let newSize = startSize + delta;
		if (newSize < 0) newSize = 0;
		if (maxSize && newSize > maxSize) newSize = maxSize;
		onResize$1?.(newSize);
	});
	const handleMouseUp = import_react.useCallback(() => {
		if (isDragging) {
			setIsDragging(false);
			if (containerRef?.current) {
				const rect = containerRef.current.getBoundingClientRect();
				const finalSize = isHorizontal ? rect.width : rect.height;
				onResizeEnd?.(finalSize);
			}
		}
	}, [
		isDragging,
		containerRef,
		onResizeEnd,
		isHorizontal
	]);
	import_react.useEffect(() => {
		if (isDragging) {
			document.addEventListener("mousemove", handleMouseMove);
			document.addEventListener("mouseup", handleMouseUp);
			return () => {
				document.removeEventListener("mousemove", handleMouseMove);
				document.removeEventListener("mouseup", handleMouseUp);
			};
		}
	}, [
		isDragging,
		handleMouseMove,
		handleMouseUp
	]);
	return {
		dragElementProps: {
			className: clsx(`${prefixCls}-dragger`, `${prefixCls}-dragger-${direction}`, {
				[`${prefixCls}-dragger-dragging`]: isDragging,
				[`${prefixCls}-dragger-horizontal`]: isHorizontal,
				[`${prefixCls}-dragger-vertical`]: !isHorizontal
			}, className),
			style: style$1,
			onMouseDown: handleMouseDown
		},
		isDragging
	};
}

//#endregion
//#region node_modules/@rc-component/drawer/es/util.js
function parseWidthHeight(value) {
	if (typeof value === "string") {
		const num = Number(value.replace(/px$/i, ""));
		if (parseFloat(value) === num) warning_default$1(false, "Invalid value type of `width` or `height` which should be number type instead.");
		if (!Number.isNaN(num)) return num;
	}
	return value;
}
function warnCheck(props) {
	warning_default$1(!("wrapperClassName" in props), `'wrapperClassName' is removed. Please use 'rootClassName' instead.`);
	warning_default$1(canUseDom() || !props.open, `Drawer with 'open' in SSR is not work since no place to createPortal. Please move to 'useEffect' instead.`);
}

//#endregion
//#region node_modules/@rc-component/drawer/es/DrawerPopup.js
function _extends$36() {
	_extends$36 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$36.apply(this, arguments);
}
var sentinelStyle = {
	width: 0,
	height: 0,
	overflow: "hidden",
	outline: "none",
	position: "absolute"
};
var DrawerPopup = (props, ref) => {
	const { prefixCls, open: open$2, placement, inline: inline$1, push, forceRender, autoFocus, keyboard, classNames: drawerClassNames, rootClassName, rootStyle, zIndex, className, id, style: style$1, motion: motion$1, width, height, size, maxSize, children, mask, maskClosable, maskMotion, maskClassName, maskStyle, afterOpenChange, onClose, onMouseEnter, onMouseOver, onMouseLeave, onClick, onKeyDown: onKeyDown$1, onKeyUp, styles, drawerRender, resizable, defaultSize } = props;
	const panelRef = import_react.useRef(null);
	const sentinelStartRef = import_react.useRef(null);
	const sentinelEndRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => panelRef.current);
	const onPanelKeyDown = (event) => {
		const { keyCode, shiftKey } = event;
		switch (keyCode) {
			case KeyCode_default.TAB:
				if (keyCode === KeyCode_default.TAB) {
					if (!shiftKey && document.activeElement === sentinelEndRef.current) sentinelStartRef.current?.focus({ preventScroll: true });
					else if (shiftKey && document.activeElement === sentinelStartRef.current) sentinelEndRef.current?.focus({ preventScroll: true });
				}
				break;
			case KeyCode_default.ESC:
				if (onClose && keyboard) {
					event.stopPropagation();
					onClose(event);
				}
				break;
		}
	};
	import_react.useEffect(() => {
		if (open$2 && autoFocus) panelRef.current?.focus({ preventScroll: true });
	}, [open$2]);
	const [pushed, setPushed] = import_react.useState(false);
	const parentContext = import_react.useContext(context_default$1);
	let pushConfig;
	if (typeof push === "boolean") pushConfig = push ? {} : { distance: 0 };
	else pushConfig = push || {};
	const pushDistance = pushConfig?.distance ?? parentContext?.pushDistance ?? 180;
	const mergedContext = import_react.useMemo(() => ({
		pushDistance,
		push: () => {
			setPushed(true);
		},
		pull: () => {
			setPushed(false);
		}
	}), [pushDistance]);
	import_react.useEffect(() => {
		if (open$2) parentContext?.push?.();
		else parentContext?.pull?.();
	}, [open$2]);
	import_react.useEffect(() => () => {
		parentContext?.pull?.();
	}, []);
	const maskNode = /* @__PURE__ */ import_react.createElement(es_default$1, _extends$36({ key: "mask" }, maskMotion, { visible: mask && open$2 }), ({ className: motionMaskClassName, style: motionMaskStyle }, maskRef) => /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-mask`, motionMaskClassName, drawerClassNames?.mask, maskClassName),
		style: {
			...motionMaskStyle,
			...maskStyle,
			...styles?.mask
		},
		onClick: maskClosable && open$2 ? onClose : void 0,
		ref: maskRef
	}));
	const motionProps = typeof motion$1 === "function" ? motion$1(placement) : motion$1;
	const [currentSize, setCurrentSize] = import_react.useState();
	const isHorizontal = placement === "left" || placement === "right";
	const mergedSize = import_react.useMemo(() => {
		return parseWidthHeight(size ?? (isHorizontal ? width : height) ?? currentSize ?? defaultSize ?? (isHorizontal ? 378 : void 0));
	}, [
		size,
		width,
		height,
		defaultSize,
		isHorizontal,
		currentSize
	]);
	const wrapperStyle = import_react.useMemo(() => {
		const nextWrapperStyle = {};
		if (pushed && pushDistance) switch (placement) {
			case "top":
				nextWrapperStyle.transform = `translateY(${pushDistance}px)`;
				break;
			case "bottom":
				nextWrapperStyle.transform = `translateY(${-pushDistance}px)`;
				break;
			case "left":
				nextWrapperStyle.transform = `translateX(${pushDistance}px)`;
				break;
			default:
				nextWrapperStyle.transform = `translateX(${-pushDistance}px)`;
				break;
		}
		if (isHorizontal) nextWrapperStyle.width = parseWidthHeight(mergedSize);
		else nextWrapperStyle.height = parseWidthHeight(mergedSize);
		return nextWrapperStyle;
	}, [
		pushed,
		pushDistance,
		placement,
		isHorizontal,
		mergedSize
	]);
	const wrapperRef = import_react.useRef(null);
	const isResizable = !!resizable;
	const resizeConfig = typeof resizable === "object" && resizable || {};
	const onInternalResize = useEvent_default((size$1) => {
		setCurrentSize(size$1);
		resizeConfig.onResize?.(size$1);
	});
	const { dragElementProps, isDragging } = useDrag({
		prefixCls: `${prefixCls}-resizable`,
		direction: placement,
		className: drawerClassNames?.dragger,
		style: styles?.dragger,
		maxSize,
		containerRef: wrapperRef,
		currentSize: mergedSize,
		onResize: onInternalResize,
		onResizeStart: resizeConfig.onResizeStart,
		onResizeEnd: resizeConfig.onResizeEnd
	});
	const eventHandlers = {
		onMouseEnter,
		onMouseOver,
		onMouseLeave,
		onClick,
		onKeyDown: onKeyDown$1,
		onKeyUp
	};
	const panelNode = /* @__PURE__ */ import_react.createElement(es_default$1, _extends$36({ key: "panel" }, motionProps, {
		visible: open$2,
		forceRender,
		onVisibleChanged: (nextVisible) => {
			afterOpenChange?.(nextVisible);
		},
		removeOnLeave: false,
		leavedClassName: `${prefixCls}-content-wrapper-hidden`
	}), ({ className: motionClassName, style: motionStyle }, motionRef) => {
		const content = /* @__PURE__ */ import_react.createElement(DrawerPanel_default$1, _extends$36({
			id,
			containerRef: motionRef,
			prefixCls,
			className: clsx(className, drawerClassNames?.section),
			style: {
				...style$1,
				...styles?.section
			}
		}, pickAttrs(props, { aria: true }), eventHandlers), children);
		return /* @__PURE__ */ import_react.createElement("div", _extends$36({
			ref: wrapperRef,
			className: clsx(`${prefixCls}-content-wrapper`, isDragging && `${prefixCls}-content-wrapper-dragging`, drawerClassNames?.wrapper, !isDragging && motionClassName),
			style: {
				...motionStyle,
				...wrapperStyle,
				...styles?.wrapper
			}
		}, pickAttrs(props, { data: true })), isResizable && /* @__PURE__ */ import_react.createElement("div", dragElementProps), drawerRender ? drawerRender(content) : content);
	});
	const containerStyle = { ...rootStyle };
	if (zIndex) containerStyle.zIndex = zIndex;
	return /* @__PURE__ */ import_react.createElement(context_default$1.Provider, { value: mergedContext }, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(prefixCls, `${prefixCls}-${placement}`, rootClassName, {
			[`${prefixCls}-open`]: open$2,
			[`${prefixCls}-inline`]: inline$1
		}),
		style: containerStyle,
		tabIndex: -1,
		ref: panelRef,
		onKeyDown: onPanelKeyDown
	}, maskNode, /* @__PURE__ */ import_react.createElement("div", {
		tabIndex: 0,
		ref: sentinelStartRef,
		style: sentinelStyle,
		"aria-hidden": "true",
		"data-sentinel": "start"
	}), panelNode, /* @__PURE__ */ import_react.createElement("div", {
		tabIndex: 0,
		ref: sentinelEndRef,
		style: sentinelStyle,
		"aria-hidden": "true",
		"data-sentinel": "end"
	})));
};
var RefDrawerPopup = /* @__PURE__ */ import_react.forwardRef(DrawerPopup);
RefDrawerPopup.displayName = "DrawerPopup";
var DrawerPopup_default = RefDrawerPopup;

//#endregion
//#region node_modules/@rc-component/drawer/es/Drawer.js
var Drawer$1 = (props) => {
	const { open: open$2 = false, prefixCls = "rc-drawer", placement = "right", autoFocus = true, keyboard = true, width, height, size, maxSize, mask = true, maskClosable = true, getContainer, forceRender, afterOpenChange, destroyOnHidden, onMouseEnter, onMouseOver, onMouseLeave, onClick, onKeyDown: onKeyDown$1, onKeyUp, resizable, defaultSize, panelRef } = props;
	const [animatedVisible, setAnimatedVisible] = import_react.useState(false);
	warnCheck(props);
	const [mounted, setMounted] = import_react.useState(false);
	useLayoutEffect_default(() => {
		setMounted(true);
	}, []);
	const mergedOpen = mounted ? open$2 : false;
	const popupRef = import_react.useRef(null);
	const lastActiveRef = import_react.useRef(null);
	useLayoutEffect_default(() => {
		if (mergedOpen) lastActiveRef.current = document.activeElement;
	}, [mergedOpen]);
	const internalAfterOpenChange = (nextVisible) => {
		setAnimatedVisible(nextVisible);
		afterOpenChange?.(nextVisible);
		if (!nextVisible && lastActiveRef.current && !popupRef.current?.contains(lastActiveRef.current)) lastActiveRef.current?.focus({ preventScroll: true });
	};
	const refContext = import_react.useMemo(() => ({ panel: panelRef }), [panelRef]);
	if (!forceRender && !animatedVisible && !mergedOpen && destroyOnHidden) return null;
	const eventHandlers = {
		onMouseEnter,
		onMouseOver,
		onMouseLeave,
		onClick,
		onKeyDown: onKeyDown$1,
		onKeyUp
	};
	const drawerPopupProps = {
		...props,
		open: mergedOpen,
		prefixCls,
		placement,
		autoFocus,
		keyboard,
		width,
		height,
		size,
		maxSize,
		defaultSize,
		mask,
		maskClosable,
		inline: getContainer === false,
		afterOpenChange: internalAfterOpenChange,
		ref: popupRef,
		resizable,
		...eventHandlers
	};
	return /* @__PURE__ */ import_react.createElement(RefContext.Provider, { value: refContext }, /* @__PURE__ */ import_react.createElement(es_default$7, {
		open: mergedOpen || forceRender || animatedVisible,
		autoDestroy: false,
		getContainer,
		autoLock: mask && (mergedOpen || animatedVisible)
	}, /* @__PURE__ */ import_react.createElement(DrawerPopup_default, drawerPopupProps)));
};
Drawer$1.displayName = "Drawer";
var Drawer_default = Drawer$1;

//#endregion
//#region node_modules/@rc-component/drawer/es/index.js
var es_default$17 = Drawer_default;

//#endregion
//#region node_modules/antd/es/drawer/DrawerPanel.js
var DrawerPanel = (props) => {
	const { prefixCls, ariaId, title, footer, extra, closable, loading, onClose, headerStyle, bodyStyle, footerStyle, children, classNames: drawerClassNames, styles: drawerStyles } = props;
	const drawerContext = useComponentConfig("drawer");
	const { classNames: contextClassNames, styles: contextStyles, closable: contextClosable } = drawerContext;
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, drawerClassNames], [contextStyles, drawerStyles], { props: {
		...props,
		closable: closable ?? contextClosable
	} });
	const closablePlacement = import_react.useMemo(() => {
		const mergedClosableVal = closable ?? contextClosable;
		if (mergedClosableVal === false) return;
		if (typeof mergedClosableVal === "object" && mergedClosableVal && mergedClosableVal.placement === "end") return "end";
		return "start";
	}, [closable, contextClosable]);
	const customCloseIconRender = import_react.useCallback((icon) => /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		onClick: onClose,
		className: clsx(`${prefixCls}-close`, { [`${prefixCls}-close-${closablePlacement}`]: closablePlacement === "end" }, mergedClassNames.close),
		style: mergedStyles.close
	}, icon), [
		onClose,
		prefixCls,
		closablePlacement,
		mergedClassNames.close,
		mergedStyles.close
	]);
	const [mergedClosable, mergedCloseIcon] = useClosable(pickClosable(props), pickClosable(drawerContext), {
		closable: true,
		closeIconRender: customCloseIconRender
	});
	const renderHeader = () => {
		if (!title && !mergedClosable) return null;
		return /* @__PURE__ */ import_react.createElement("div", {
			style: {
				...mergedStyles.header,
				...headerStyle
			},
			className: clsx(`${prefixCls}-header`, mergedClassNames.header, { [`${prefixCls}-header-close-only`]: mergedClosable && !title && !extra })
		}, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-header-title` }, closablePlacement === "start" && mergedCloseIcon, title && /* @__PURE__ */ import_react.createElement("div", {
			className: clsx(`${prefixCls}-title`, mergedClassNames.title),
			style: mergedStyles.title,
			id: ariaId
		}, title)), extra && /* @__PURE__ */ import_react.createElement("div", {
			className: clsx(`${prefixCls}-extra`, mergedClassNames.extra),
			style: mergedStyles.extra
		}, extra), closablePlacement === "end" && mergedCloseIcon);
	};
	const renderFooter = () => {
		if (!footer) return null;
		return /* @__PURE__ */ import_react.createElement("div", {
			className: clsx(`${prefixCls}-footer`, mergedClassNames.footer),
			style: {
				...mergedStyles.footer,
				...footerStyle
			}
		}, footer);
	};
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, renderHeader(), /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-body`, mergedClassNames.body),
		style: {
			...mergedStyles.body,
			...bodyStyle
		}
	}, loading ? /* @__PURE__ */ import_react.createElement(skeleton_default, {
		active: true,
		title: false,
		paragraph: { rows: 5 },
		className: `${prefixCls}-body-skeleton`
	}) : children), renderFooter());
};
var DrawerPanel_default = DrawerPanel;

//#endregion
//#region node_modules/antd/es/drawer/style/motion.js
var getMoveTranslate = (direction) => {
	const value = "100%";
	return {
		left: `translateX(-${value})`,
		right: `translateX(${value})`,
		top: `translateY(-${value})`,
		bottom: `translateY(${value})`
	}[direction];
};
var getEnterLeaveStyle = (startStyle, endStyle) => ({
	"&-enter, &-appear": {
		...startStyle,
		"&-active": endStyle
	},
	"&-leave": {
		...endStyle,
		"&-active": startStyle
	}
});
var getFadeStyle = (from$1, duration) => ({
	"&-enter, &-appear, &-leave": {
		"&-start": { transition: "none" },
		"&-active": { transition: `all ${duration}` }
	},
	...getEnterLeaveStyle({ opacity: from$1 }, { opacity: 1 })
});
var getPanelMotionStyles = (direction, duration) => [getFadeStyle(.7, duration), getEnterLeaveStyle({ transform: getMoveTranslate(direction) }, { transform: "none" })];
var genMotionStyle$1 = (token$1) => {
	const { componentCls, motionDurationSlow } = token$1;
	return { [componentCls]: {
		[`${componentCls}-mask-motion`]: getFadeStyle(0, motionDurationSlow),
		[`${componentCls}-panel-motion`]: [
			"left",
			"right",
			"top",
			"bottom"
		].reduce((obj, direction) => ({
			...obj,
			[`&-${direction}`]: getPanelMotionStyles(direction, motionDurationSlow)
		}), {})
	} };
};
var motion_default$2 = genMotionStyle$1;

//#endregion
//#region node_modules/antd/es/drawer/style/index.js
var genDrawerStyle = (token$1) => {
	const { borderRadiusSM, componentCls, zIndexPopup, colorBgMask, colorBgElevated, motionDurationSlow, motionDurationMid, paddingXS, padding, paddingLG, fontSizeLG, lineHeightLG, lineWidth, lineType, colorSplit, marginXS, colorIcon, colorIconHover, colorBgTextHover, colorBgTextActive, colorText, fontWeightStrong, footerPaddingBlock, footerPaddingInline, draggerSize, calc } = token$1;
	const wrapperCls = `${componentCls}-content-wrapper`;
	const draggerCls = `${componentCls}-resizable-dragger`;
	return { [componentCls]: {
		position: "fixed",
		inset: 0,
		zIndex: zIndexPopup,
		pointerEvents: "none",
		color: colorText,
		"&-pure": {
			position: "relative",
			background: colorBgElevated,
			display: "flex",
			flexDirection: "column",
			pointerEvents: "auto",
			[`&${componentCls}-left`]: { boxShadow: token$1.boxShadowDrawerLeft },
			[`&${componentCls}-right`]: { boxShadow: token$1.boxShadowDrawerRight },
			[`&${componentCls}-top`]: { boxShadow: token$1.boxShadowDrawerUp },
			[`&${componentCls}-bottom`]: { boxShadow: token$1.boxShadowDrawerDown }
		},
		"&-inline": { position: "absolute" },
		[`${componentCls}-mask`]: {
			position: "absolute",
			inset: 0,
			zIndex: zIndexPopup,
			background: colorBgMask,
			pointerEvents: "auto",
			[`&${componentCls}-mask-blur`]: { backdropFilter: "blur(4px)" }
		},
		[wrapperCls]: {
			position: "absolute",
			zIndex: zIndexPopup,
			maxWidth: "100vw",
			transition: `all ${motionDurationSlow}`,
			"&-hidden": { display: "none" }
		},
		[`&-left > ${wrapperCls}`]: {
			top: 0,
			bottom: 0,
			left: {
				_skip_check_: true,
				value: 0
			},
			boxShadow: token$1.boxShadowDrawerLeft
		},
		[`&-right > ${wrapperCls}`]: {
			top: 0,
			right: {
				_skip_check_: true,
				value: 0
			},
			bottom: 0,
			boxShadow: token$1.boxShadowDrawerRight
		},
		[`&-top > ${wrapperCls}`]: {
			top: 0,
			insetInline: 0,
			boxShadow: token$1.boxShadowDrawerUp
		},
		[`&-bottom > ${wrapperCls}`]: {
			bottom: 0,
			insetInline: 0,
			boxShadow: token$1.boxShadowDrawerDown
		},
		[`${componentCls}-section`]: {
			display: "flex",
			flexDirection: "column",
			width: "100%",
			height: "100%",
			overflow: "auto",
			background: colorBgElevated,
			pointerEvents: "auto"
		},
		[`${componentCls}-header`]: {
			display: "flex",
			flex: 0,
			alignItems: "center",
			padding: `${unit(padding)} ${unit(paddingLG)}`,
			fontSize: fontSizeLG,
			lineHeight: lineHeightLG,
			borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
			"&-title": {
				display: "flex",
				flex: 1,
				alignItems: "center",
				minWidth: 0,
				minHeight: 0
			}
		},
		[`${componentCls}-extra`]: { flex: "none" },
		[`${componentCls}-close`]: {
			display: "inline-flex",
			width: calc(fontSizeLG).add(paddingXS).equal(),
			height: calc(fontSizeLG).add(paddingXS).equal(),
			borderRadius: borderRadiusSM,
			justifyContent: "center",
			alignItems: "center",
			color: colorIcon,
			fontWeight: fontWeightStrong,
			fontSize: fontSizeLG,
			fontStyle: "normal",
			lineHeight: 1,
			textAlign: "center",
			textTransform: "none",
			textDecoration: "none",
			background: "transparent",
			border: 0,
			cursor: "pointer",
			transition: `all ${motionDurationMid}`,
			textRendering: "auto",
			[`&${componentCls}-close-end`]: { marginInlineStart: marginXS },
			[`&:not(${componentCls}-close-end)`]: { marginInlineEnd: marginXS },
			"&:hover": {
				color: colorIconHover,
				backgroundColor: colorBgTextHover,
				textDecoration: "none"
			},
			"&:active": { backgroundColor: colorBgTextActive },
			...genFocusStyle(token$1)
		},
		[`${componentCls}-title`]: {
			flex: 1,
			margin: 0,
			fontWeight: token$1.fontWeightStrong,
			fontSize: fontSizeLG,
			lineHeight: lineHeightLG
		},
		[`${componentCls}-body`]: {
			flex: 1,
			minWidth: 0,
			minHeight: 0,
			padding: paddingLG,
			overflow: "auto",
			[`${componentCls}-body-skeleton`]: {
				width: "100%",
				height: "100%",
				display: "flex",
				justifyContent: "center"
			}
		},
		[`${componentCls}-footer`]: {
			flexShrink: 0,
			padding: `${unit(footerPaddingBlock)} ${unit(footerPaddingInline)}`,
			borderTop: `${unit(lineWidth)} ${lineType} ${colorSplit}`
		},
		[draggerCls]: {
			position: "absolute",
			zIndex: 1,
			backgroundColor: "transparent",
			userSelect: "none",
			pointerEvents: "auto",
			"&:hover": {
				backgroundColor: token$1.colorPrimary,
				opacity: .2
			},
			"&-dragging": {
				backgroundColor: token$1.colorPrimary,
				opacity: .3
			}
		},
		[`${draggerCls}-left`]: {
			top: 0,
			bottom: 0,
			insetInlineEnd: 0,
			width: draggerSize,
			cursor: "col-resize"
		},
		[`${draggerCls}-right`]: {
			top: 0,
			bottom: 0,
			insetInlineStart: 0,
			width: draggerSize,
			cursor: "col-resize"
		},
		[`${draggerCls}-top`]: {
			insetInline: 0,
			bottom: 0,
			height: draggerSize,
			cursor: "row-resize"
		},
		[`${draggerCls}-bottom`]: {
			insetInline: 0,
			top: 0,
			height: draggerSize,
			cursor: "row-resize"
		},
		[`${wrapperCls}-dragging`]: {
			userSelect: "none",
			transition: "none",
			willChange: "width, height",
			[`${componentCls}-content`]: { pointerEvents: "none" },
			[`${componentCls}-section`]: { pointerEvents: "none" }
		},
		"&-rtl": { direction: "rtl" }
	} };
};
const prepareComponentToken$25 = (token$1) => ({
	zIndexPopup: token$1.zIndexPopupBase,
	footerPaddingBlock: token$1.paddingXS,
	footerPaddingInline: token$1.padding,
	draggerSize: 4
});
var style_default$31 = genStyleHooks("Drawer", (token$1) => {
	const drawerToken = merge(token$1, {});
	return [genDrawerStyle(drawerToken), motion_default$2(drawerToken)];
}, prepareComponentToken$25);

//#endregion
//#region node_modules/antd/es/drawer/index.js
var defaultPushState = { distance: 180 };
var DEFAULT_SIZE$1 = 378;
var Drawer = (props) => {
	const { rootClassName, size, defaultSize = DEFAULT_SIZE$1, height, width, mask: drawerMask, push = defaultPushState, open: open$2, afterOpenChange, onClose, prefixCls: customizePrefixCls, getContainer: customizeGetContainer, panelRef = null, style: style$1, className, resizable, "aria-labelledby": ariaLabelledby, maskStyle, drawerStyle, contentWrapperStyle, destroyOnClose, destroyOnHidden, ...rest } = props;
	const { placement } = rest;
	const id = useId_default();
	const ariaId = rest.title ? id : void 0;
	const { getPopupContainer, getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles, mask: contextMask } = useComponentConfig("drawer");
	const prefixCls = getPrefixCls("drawer", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$31(prefixCls);
	const getContainer = customizeGetContainer === void 0 && getPopupContainer ? () => getPopupContainer(document.body) : customizeGetContainer;
	{
		const warning$3 = devUseWarning("Drawer");
		[
			["headerStyle", "styles.header"],
			["bodyStyle", "styles.body"],
			["footerStyle", "styles.footer"],
			["contentWrapperStyle", "styles.wrapper"],
			["maskStyle", "styles.mask"],
			["drawerStyle", "styles.section"],
			["destroyInactivePanel", "destroyOnHidden"],
			["width", "size"],
			["height", "size"]
		].forEach(([deprecatedName, newName]) => {
			warning$3.deprecated(!(deprecatedName in props), deprecatedName, newName);
		});
		if (getContainer !== void 0 && props.style?.position === "absolute") warning$3(false, "breaking", "`style` is replaced by `rootStyle` in v5. Please check that `position: absolute` is necessary.");
	}
	const drawerSize = import_react.useMemo(() => {
		if (typeof size === "number") return size;
		if (size === "large") return 736;
		if (size === "default") return DEFAULT_SIZE$1;
		if (!placement || placement === "left" || placement === "right") return width;
		return height;
	}, [
		size,
		placement,
		width,
		height
	]);
	const maskMotion = {
		motionName: getTransitionName(prefixCls, "mask-motion"),
		motionAppear: true,
		motionEnter: true,
		motionLeave: true,
		motionDeadline: 500
	};
	const panelMotion = (motionPlacement) => ({
		motionName: getTransitionName(prefixCls, `panel-motion-${motionPlacement}`),
		motionAppear: true,
		motionEnter: true,
		motionLeave: true,
		motionDeadline: 500
	});
	const mergedPanelRef = composeRef(panelRef, usePanelRef());
	const [zIndex, contextZIndex] = useZIndex("Drawer", rest.zIndex);
	const { classNames, styles, rootStyle } = rest;
	const [mergedMask, maskBlurClassName] = useMergedMask(drawerMask, contextMask, prefixCls);
	const mergedProps = {
		...props,
		zIndex,
		panelRef,
		mask: mergedMask,
		defaultSize,
		push
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const drawerClassName = clsx({
		"no-mask": !mergedMask,
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, rootClassName, hashId, cssVarCls, mergedClassNames.root);
	return /* @__PURE__ */ import_react.createElement(ContextIsolator_default, {
		form: true,
		space: true
	}, /* @__PURE__ */ import_react.createElement(zindexContext_default.Provider, { value: contextZIndex }, /* @__PURE__ */ import_react.createElement(es_default$17, {
		prefixCls,
		onClose,
		maskMotion,
		motion: panelMotion,
		...rest,
		classNames: {
			mask: clsx(mergedClassNames.mask, maskBlurClassName.mask),
			section: mergedClassNames.section,
			wrapper: mergedClassNames.wrapper,
			dragger: mergedClassNames.dragger
		},
		styles: {
			mask: {
				...mergedStyles.mask,
				...maskStyle
			},
			section: {
				...mergedStyles.section,
				...drawerStyle
			},
			wrapper: {
				...mergedStyles.wrapper,
				...contentWrapperStyle
			},
			dragger: mergedStyles.dragger
		},
		open: open$2,
		mask: mergedMask,
		push,
		size: drawerSize,
		defaultSize,
		style: {
			...contextStyle,
			...style$1
		},
		rootStyle: {
			...rootStyle,
			...mergedStyles.root
		},
		className: clsx(contextClassName, className),
		rootClassName: drawerClassName,
		getContainer,
		afterOpenChange,
		panelRef: mergedPanelRef,
		zIndex,
		...resizable ? { resizable } : {},
		"aria-labelledby": ariaLabelledby ?? ariaId,
		destroyOnHidden: destroyOnHidden ?? destroyOnClose
	}, /* @__PURE__ */ import_react.createElement(DrawerPanel_default, {
		prefixCls,
		size,
		...rest,
		ariaId,
		onClose
	}))));
};
/** @private Internal Component. Do not use in your production. */
var PurePanel$6 = (props) => {
	const { prefixCls: customizePrefixCls, style: style$1, className, placement = "right", ...restProps } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("drawer", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$31(prefixCls);
	const cls = clsx(prefixCls, `${prefixCls}-pure`, `${prefixCls}-${placement}`, hashId, cssVarCls, className);
	return /* @__PURE__ */ import_react.createElement("div", {
		className: cls,
		style: style$1
	}, /* @__PURE__ */ import_react.createElement(DrawerPanel_default, {
		prefixCls,
		...restProps
	}));
};
Drawer._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$6;
Drawer.displayName = "Drawer";
var drawer_default = Drawer;

//#endregion
//#region node_modules/antd/es/_util/gapSize.js
function isPresetSize(size) {
	return [
		"small",
		"middle",
		"large"
	].includes(size);
}
function isValidGapNumber(size) {
	if (!size) return false;
	return typeof size === "number" && !Number.isNaN(size);
}

//#endregion
//#region node_modules/antd/es/space/context.js
const SpaceContext = /* @__PURE__ */ import_react.createContext({ latestIndex: 0 });
const SpaceContextProvider = SpaceContext.Provider;

//#endregion
//#region node_modules/antd/es/space/Item.js
var Item$1 = (props) => {
	const { className, prefix: prefix$1, index: index$1, children, separator, style: style$1, classNames, styles } = props;
	const { latestIndex } = import_react.useContext(SpaceContext);
	if (!isNonNullable_default(children)) return null;
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("div", {
		className,
		style: style$1
	}, children), index$1 < latestIndex && separator && /* @__PURE__ */ import_react.createElement("span", {
		className: clsx(`${prefix$1}-item-separator`, classNames.separator),
		style: styles.separator
	}, separator));
};
var Item_default$1 = Item$1;

//#endregion
//#region node_modules/antd/es/space/style/index.js
var genSpaceStyle = (token$1) => {
	const { componentCls, antCls } = token$1;
	return { [componentCls]: {
		display: "inline-flex",
		"&-rtl": { direction: "rtl" },
		"&-vertical": { flexDirection: "column" },
		"&-align": {
			flexDirection: "column",
			"&-center": { alignItems: "center" },
			"&-start": { alignItems: "flex-start" },
			"&-end": { alignItems: "flex-end" },
			"&-baseline": { alignItems: "baseline" }
		},
		[`${componentCls}-item:empty`]: { display: "none" },
		[`${componentCls}-item > ${antCls}-badge-not-a-wrapper:only-child`]: { display: "block" }
	} };
};
var genSpaceGapStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: {
		"&-gap-row-small": { rowGap: token$1.spaceGapSmallSize },
		"&-gap-row-middle": { rowGap: token$1.spaceGapMiddleSize },
		"&-gap-row-large": { rowGap: token$1.spaceGapLargeSize },
		"&-gap-col-small": { columnGap: token$1.spaceGapSmallSize },
		"&-gap-col-middle": { columnGap: token$1.spaceGapMiddleSize },
		"&-gap-col-large": { columnGap: token$1.spaceGapLargeSize }
	} };
};
var style_default$30 = genStyleHooks("Space", (token$1) => {
	const spaceToken = merge(token$1, {
		spaceGapSmallSize: token$1.paddingXS,
		spaceGapMiddleSize: token$1.padding,
		spaceGapLargeSize: token$1.paddingLG
	});
	return [genSpaceStyle(spaceToken), genSpaceGapStyle(spaceToken)];
}, () => ({}), { resetStyle: false });

//#endregion
//#region node_modules/antd/es/space/index.js
var Space = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { getPrefixCls, direction: directionConfig, size: contextSize, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("space");
	const { size = contextSize ?? "small", align, className, rootClassName, children, direction, orientation, prefixCls: customizePrefixCls, split, separator, style: style$1, vertical, wrap = false, classNames, styles, ...restProps } = props;
	const [horizontalSize, verticalSize] = Array.isArray(size) ? size : [size, size];
	const isPresetVerticalSize = isPresetSize(verticalSize);
	const isPresetHorizontalSize = isPresetSize(horizontalSize);
	const isValidVerticalSize = isValidGapNumber(verticalSize);
	const isValidHorizontalSize = isValidGapNumber(horizontalSize);
	const childNodes = toArray(children, { keepEmpty: true });
	const [mergedOrientation, mergedVertical] = useOrientation(orientation, vertical, direction);
	const mergedAlign = align === void 0 && !mergedVertical ? "center" : align;
	const mergedSeparator = separator ?? split;
	const prefixCls = getPrefixCls("space", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$30(prefixCls);
	const mergedProps = {
		...props,
		size,
		orientation: mergedOrientation,
		align: mergedAlign
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const rootClassNames = clsx(prefixCls, contextClassName, hashId, `${prefixCls}-${mergedOrientation}`, {
		[`${prefixCls}-rtl`]: directionConfig === "rtl",
		[`${prefixCls}-align-${mergedAlign}`]: mergedAlign,
		[`${prefixCls}-gap-row-${verticalSize}`]: isPresetVerticalSize,
		[`${prefixCls}-gap-col-${horizontalSize}`]: isPresetHorizontalSize
	}, className, rootClassName, cssVarCls, mergedClassNames.root);
	const itemClassName = clsx(`${prefixCls}-item`, mergedClassNames.item);
	const renderedItems = childNodes.map((child, i) => {
		const key = child?.key || `${itemClassName}-${i}`;
		return /* @__PURE__ */ import_react.createElement(Item_default$1, {
			prefix: prefixCls,
			classNames: mergedClassNames,
			styles: mergedStyles,
			className: itemClassName,
			key,
			index: i,
			separator: mergedSeparator,
			style: mergedStyles.item
		}, child);
	});
	{
		const warning$3 = devUseWarning("Space");
		[["direction", "orientation"], ["split", "separator"]].forEach(([deprecatedName, newName]) => {
			warning$3.deprecated(!(deprecatedName in props), deprecatedName, newName);
		});
	}
	const memoizedSpaceContext = import_react.useMemo(() => {
		return { latestIndex: childNodes.reduce((latest, child, i) => isNonNullable_default(child) ? i : latest, 0) };
	}, [childNodes]);
	if (childNodes.length === 0) return null;
	const gapStyle = {};
	if (wrap) gapStyle.flexWrap = "wrap";
	if (!isPresetHorizontalSize && isValidHorizontalSize) gapStyle.columnGap = horizontalSize;
	if (!isPresetVerticalSize && isValidVerticalSize) gapStyle.rowGap = verticalSize;
	return /* @__PURE__ */ import_react.createElement("div", {
		ref,
		className: rootClassNames,
		style: {
			...gapStyle,
			...mergedStyles.root,
			...contextStyle,
			...style$1
		},
		...restProps
	}, /* @__PURE__ */ import_react.createElement(SpaceContextProvider, { value: memoizedSpaceContext }, renderedItems));
});
Space.Compact = Compact_default;
Space.Addon = Addon_default;
Space.displayName = "Space";
var space_default = Space;

//#endregion
//#region node_modules/antd/es/dropdown/dropdown-button.js
/** @deprecated Please use Space.Compact + Dropdown + Button instead */
var DropdownButton = (props) => {
	const { getPopupContainer: getContextPopupContainer, getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const { prefixCls: customizePrefixCls, type: type$2 = "default", danger, disabled, loading, onClick, htmlType, children, className, menu, arrow, autoFocus, trigger, align, open: open$2, onOpenChange, placement, getPopupContainer, href, icon = /* @__PURE__ */ import_react.createElement(EllipsisOutlined_default, null), title, buttonsRender = (buttons) => buttons, mouseEnterDelay, mouseLeaveDelay, overlayClassName, overlayStyle, destroyOnHidden, destroyPopupOnHide, dropdownRender, popupRender, ...restProps } = props;
	const prefixCls = getPrefixCls("dropdown", customizePrefixCls);
	const buttonPrefixCls = `${prefixCls}-button`;
	const dropdownProps = {
		menu,
		arrow,
		autoFocus,
		align,
		disabled,
		trigger: disabled ? [] : trigger,
		onOpenChange,
		getPopupContainer: getPopupContainer || getContextPopupContainer,
		mouseEnterDelay,
		mouseLeaveDelay,
		classNames: { root: overlayClassName },
		styles: { root: overlayStyle },
		destroyOnHidden,
		popupRender: popupRender || dropdownRender
	};
	const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
	const classes = clsx(buttonPrefixCls, compactItemClassnames, className);
	if ("destroyPopupOnHide" in props) dropdownProps.destroyPopupOnHide = destroyPopupOnHide;
	if ("open" in props) dropdownProps.open = open$2;
	if ("placement" in props) dropdownProps.placement = placement;
	else dropdownProps.placement = direction === "rtl" ? "bottomLeft" : "bottomRight";
	devUseWarning("Dropdown.Button").deprecated(false, "Dropdown.Button", "Space.Compact + Dropdown + Button");
	const [leftButtonToRender, rightButtonToRender] = buttonsRender([/* @__PURE__ */ import_react.createElement(button_default, {
		type: type$2,
		danger,
		disabled,
		loading,
		onClick,
		htmlType,
		href,
		title
	}, children), /* @__PURE__ */ import_react.createElement(button_default, {
		type: type$2,
		danger,
		icon
	})]);
	return /* @__PURE__ */ import_react.createElement(space_default.Compact, {
		className: classes,
		size: compactSize,
		block: true,
		...restProps
	}, leftButtonToRender, /* @__PURE__ */ import_react.createElement(dropdown_default$1, { ...dropdownProps }, rightButtonToRender));
};
DropdownButton.__ANT_BUTTON = true;
var dropdown_button_default = DropdownButton;

//#endregion
//#region node_modules/antd/es/dropdown/index.js
var Dropdown = dropdown_default$1;
/** @deprecated Please use Space.Compact + Dropdown + Button instead */
Dropdown.Button = dropdown_button_default;
var dropdown_default = Dropdown;

//#endregion
//#region node_modules/antd/es/flex/utils.js
const flexWrapValues = [
	"wrap",
	"nowrap",
	"wrap-reverse"
];
const justifyContentValues = [
	"flex-start",
	"flex-end",
	"start",
	"end",
	"center",
	"space-between",
	"space-around",
	"space-evenly",
	"stretch",
	"normal",
	"left",
	"right"
];
const alignItemsValues = [
	"center",
	"start",
	"end",
	"flex-start",
	"flex-end",
	"self-start",
	"self-end",
	"baseline",
	"normal",
	"stretch"
];
var genClsWrap = (prefixCls, props) => {
	const wrap = props.wrap === true ? "wrap" : props.wrap;
	return { [`${prefixCls}-wrap-${wrap}`]: wrap && flexWrapValues.includes(wrap) };
};
var genClsAlign = (prefixCls, props) => {
	const alignCls = {};
	alignItemsValues.forEach((cssKey) => {
		alignCls[`${prefixCls}-align-${cssKey}`] = props.align === cssKey;
	});
	alignCls[`${prefixCls}-align-stretch`] = !props.align && !!props.vertical;
	return alignCls;
};
var genClsJustify = (prefixCls, props) => {
	const justifyCls = {};
	justifyContentValues.forEach((cssKey) => {
		justifyCls[`${prefixCls}-justify-${cssKey}`] = props.justify === cssKey;
	});
	return justifyCls;
};
var createFlexClassNames = (prefixCls, props) => {
	return clsx({
		...genClsWrap(prefixCls, props),
		...genClsAlign(prefixCls, props),
		...genClsJustify(prefixCls, props)
	});
};
var utils_default = createFlexClassNames;

//#endregion
//#region node_modules/antd/es/flex/style/index.js
var genFlexStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: {
		display: "flex",
		margin: 0,
		padding: 0,
		"&-vertical": { flexDirection: "column" },
		"&-rtl": { direction: "rtl" },
		"&:empty": { display: "none" }
	} };
};
var genFlexGapStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: {
		"&-gap-small": { gap: token$1.flexGapSM },
		"&-gap-middle": { gap: token$1.flexGap },
		"&-gap-large": { gap: token$1.flexGapLG }
	} };
};
var genFlexWrapStyle = (token$1) => {
	const { componentCls } = token$1;
	const wrapStyle = {};
	flexWrapValues.forEach((value) => {
		wrapStyle[`${componentCls}-wrap-${value}`] = { flexWrap: value };
	});
	return wrapStyle;
};
var genAlignItemsStyle = (token$1) => {
	const { componentCls } = token$1;
	const alignStyle = {};
	alignItemsValues.forEach((value) => {
		alignStyle[`${componentCls}-align-${value}`] = { alignItems: value };
	});
	return alignStyle;
};
var genJustifyContentStyle = (token$1) => {
	const { componentCls } = token$1;
	const justifyStyle = {};
	justifyContentValues.forEach((value) => {
		justifyStyle[`${componentCls}-justify-${value}`] = { justifyContent: value };
	});
	return justifyStyle;
};
const prepareComponentToken$24 = () => ({});
var style_default$29 = genStyleHooks("Flex", (token$1) => {
	const { paddingXS, padding, paddingLG } = token$1;
	const flexToken = merge(token$1, {
		flexGapSM: paddingXS,
		flexGap: padding,
		flexGapLG: paddingLG
	});
	return [
		genFlexStyle(flexToken),
		genFlexGapStyle(flexToken),
		genFlexWrapStyle(flexToken),
		genAlignItemsStyle(flexToken),
		genJustifyContentStyle(flexToken)
	];
}, prepareComponentToken$24, { resetStyle: false });

//#endregion
//#region node_modules/antd/es/flex/index.js
var Flex = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, rootClassName, className, style: style$1, flex, gap, vertical, orientation, component: Component$2 = "div", children, ...othersProps } = props;
	const { flex: ctxFlex, direction: ctxDirection, getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("flex", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$29(prefixCls);
	const [, mergedVertical] = useOrientation(orientation, vertical ?? ctxFlex?.vertical);
	const mergedCls = clsx(className, rootClassName, ctxFlex?.className, prefixCls, hashId, cssVarCls, utils_default(prefixCls, props), {
		[`${prefixCls}-rtl`]: ctxDirection === "rtl",
		[`${prefixCls}-gap-${gap}`]: isPresetSize(gap),
		[`${prefixCls}-vertical`]: mergedVertical
	});
	const mergedStyle = {
		...ctxFlex?.style,
		...style$1
	};
	if (isNonNullable_default(flex)) mergedStyle.flex = flex;
	if (isNonNullable_default(gap) && !isPresetSize(gap)) mergedStyle.gap = gap;
	return /* @__PURE__ */ import_react.createElement(Component$2, {
		ref,
		className: mergedCls,
		style: mergedStyle,
		...omit(othersProps, [
			"justify",
			"wrap",
			"align"
		])
	}, children);
});
Flex.displayName = "Flex";
var flex_default = Flex;

//#endregion
//#region node_modules/antd/es/float-button/context.js
const GroupContext = /* @__PURE__ */ import_react.createContext(null);

//#endregion
//#region node_modules/antd/es/_util/convertToTooltipProps.js
var convertToTooltipProps = (tooltip) => {
	if (!isNonNullable_default(tooltip)) return null;
	if (typeof tooltip === "object" && !/* @__PURE__ */ (0, import_react.isValidElement)(tooltip)) return tooltip;
	return { title: tooltip };
};
var convertToTooltipProps_default = convertToTooltipProps;

//#endregion
//#region node_modules/antd/es/float-button/style/button.js
var genFloatButtonStyle = (token$1) => {
	const { componentCls, floatButtonSize, iconCls, antCls, floatButtonIconSize } = token$1;
	const getCssVar = genCssVar(antCls, "float-btn");
	const badgeCls = `${componentCls}-badge`;
	const R = Math.SQRT2;
	const offsetR = (R - 1) / R;
	const offsetSquare = token$1.calc(token$1.borderRadius).mul(offsetR).equal();
	const offsetCircle = token$1.calc(token$1.controlHeight).div(2).mul(offsetR).equal();
	return { [componentCls]: [{ [getCssVar("size")]: unit(floatButtonSize) }, {
		flexDirection: "column",
		margin: 0,
		padding: `${unit(token$1.paddingXXS)} 0`,
		width: `var(${getCssVar("size")})`,
		minHeight: `var(${getCssVar("size")})`,
		height: "auto",
		wordBreak: "break-word",
		whiteSpace: "normal",
		gap: token$1.calc(token$1.paddingXXS).div(2).equal(),
		"&-rtl": { direction: "rtl" },
		[`&${componentCls}-individual`]: {
			position: "fixed",
			zIndex: token$1.zIndexPopupBase,
			insetInlineEnd: token$1.floatButtonInsetInlineEnd,
			bottom: token$1.floatButtonInsetBlockEnd,
			boxShadow: token$1.boxShadowSecondary
		},
		[`&${componentCls}-pure`]: {
			position: "relative",
			inset: "auto"
		},
		"&:empty": { display: "none" },
		[`${componentCls}-icon`]: { lineHeight: 1 },
		[`&${componentCls}-icon-only`]: { [iconCls]: { fontSize: floatButtonIconSize } },
		[`${componentCls}-content`]: { fontSize: token$1.fontSizeSM },
		[badgeCls]: {
			position: "absolute",
			top: 0,
			insetInlineEnd: 0,
			[`&:not(${badgeCls}-dot)`]: { transform: "translate(50%, -50%)" }
		},
		[`&-rtl ${badgeCls}:not(${badgeCls}-dot)`]: { transform: "translate(-50%, -50%)" },
		"&-square": { [`${badgeCls}-dot`]: {
			marginTop: offsetSquare,
			marginInlineEnd: offsetSquare
		} },
		"&-circle": { [badgeCls]: {
			marginTop: offsetCircle,
			marginInlineEnd: offsetCircle
		} }
	}] };
};
var button_default$1 = genFloatButtonStyle;

//#endregion
//#region node_modules/antd/es/float-button/style/group.js
var genGroupStyle = (token$1) => {
	const { componentCls, antCls, floatButtonSize, padding } = token$1;
	const groupCls = `${componentCls}-group`;
	const listCls = `${groupCls}-list`;
	const getCssVar = genCssVar(antCls, "float-btn");
	return { [groupCls]: [
		{
			[getCssVar("list-transform-start")]: `translate(0,${unit(floatButtonSize)})`,
			[getCssVar("list-trigger-offset")]: `calc(${unit(floatButtonSize)} + ${unit(padding)})`
		},
		{
			...resetComponent(token$1),
			position: "fixed",
			zIndex: token$1.zIndexPopupBase,
			insetInlineEnd: token$1.floatButtonInsetInlineEnd,
			bottom: token$1.floatButtonInsetBlockEnd,
			gap: padding,
			"&-rtl": { direction: "rtl" },
			[`&${componentCls}-pure`]: {
				position: "relative",
				inset: "auto"
			},
			[componentCls]: {
				position: "relative",
				inset: "auto"
			}
		},
		{
			[`&:not(${groupCls}-individual) ${listCls}`]: { boxShadow: token$1.boxShadowSecondary },
			[`&${groupCls}-individual ${listCls}`]: { gap: padding },
			[`&-menu-mode ${listCls}`]: { position: "absolute" },
			[listCls]: {
				borderRadius: token$1.borderRadiusLG,
				"&-motion": {
					transition: `all ${token$1.motionDurationSlow}`,
					"&-enter, &-appear": {
						opacity: 0,
						transform: getCssVar("list-transform-start", true),
						"&-active": {
							opacity: 1,
							transform: `translate(0, 0)`
						}
					},
					"&-leave": { "&-active": {
						opacity: 0,
						transform: getCssVar("list-transform-start", true)
					} }
				}
			},
			"&-top": { [listCls]: { bottom: getCssVar("list-trigger-offset", true) } },
			"&-bottom": { [listCls]: {
				[getCssVar("list-transform-start")]: `translate(0, calc(${unit(floatButtonSize)} * -1))`,
				top: getCssVar("list-trigger-offset", true)
			} },
			"&-left": { [listCls]: {
				[getCssVar("list-transform-start")]: `translate(${unit(floatButtonSize)}, 0)`,
				right: getCssVar("list-trigger-offset", true)
			} },
			"&-right": { [listCls]: {
				[getCssVar("list-transform-start")]: `translate(calc(${unit(floatButtonSize)} * -1), 0)`,
				left: getCssVar("list-trigger-offset", true)
			} }
		}
	] };
};
var group_default = genGroupStyle;

//#endregion
//#region node_modules/antd/es/float-button/style/index.js
const prepareComponentToken$23 = () => ({});
var style_default$28 = genStyleHooks("FloatButton", (token$1) => {
	const { controlHeightLG, marginXXL, marginLG, fontSizeIcon, calc } = token$1;
	const floatButtonToken = merge(token$1, {
		floatButtonIconSize: calc(fontSizeIcon).mul(1.5).equal(),
		floatButtonSize: controlHeightLG,
		floatButtonInsetBlockEnd: marginXXL,
		floatButtonInsetInlineEnd: marginLG
	});
	return [
		button_default$1(floatButtonToken),
		group_default(floatButtonToken),
		initFadeMotion(token$1)
	];
}, prepareComponentToken$23, { order: -998 });

//#endregion
//#region node_modules/antd/es/float-button/FloatButton.js
const floatButtonPrefixCls = "float-btn";
var FloatButton = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, style: style$1, type: type$2 = "default", shape = "circle", icon, description, content, tooltip, badge = {}, classNames, styles, ...restProps } = props;
	const { getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const groupContext = import_react.useContext(GroupContext);
	const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const { shape: contextShape, individual: contextIndividual, classNames: contextClassNames, styles: contextStyles } = groupContext || {};
	const mergedShape = contextShape || shape;
	const mergedIndividual = contextIndividual ?? true;
	const mergedContent = content ?? description;
	const mergedProps = {
		...props,
		type: type$2,
		shape: mergedShape
	};
	const [hashId, cssVarCls] = style_default$28(prefixCls, rootCls);
	const [mergedClassNames, mergedStyles] = useMergeSemantic([
		import_react.useMemo(() => ({
			icon: `${prefixCls}-icon`,
			content: `${prefixCls}-content`
		}), [prefixCls]),
		contextClassNames,
		classNames
	], [contextStyles, styles], { props: mergedProps });
	const mergedIcon = !mergedContent && !icon ? /* @__PURE__ */ import_react.createElement(FileTextOutlined_default, null) : icon;
	const [zIndex] = useZIndex("FloatButton", style$1?.zIndex);
	const mergedStyle = {
		...style$1,
		zIndex
	};
	const badgeProps = omit(badge, [
		"title",
		"children",
		"status",
		"text"
	]);
	const badgeNode = "badge" in props && /* @__PURE__ */ import_react.createElement(badge_default, {
		...badgeProps,
		className: clsx(badgeProps.className, `${prefixCls}-badge`, { [`${prefixCls}-badge-dot`]: badgeProps.dot })
	});
	const tooltipProps = convertToTooltipProps_default(tooltip);
	{
		const warning$3 = devUseWarning("FloatButton");
		warning$3(!(mergedShape === "circle" && mergedContent), "usage", "supported only when `shape` is `square`. Due to narrow space for text, short sentence is recommended.");
		warning$3.deprecated(!description, "description", "content");
	}
	let node$1 = /* @__PURE__ */ import_react.createElement(Button_default, {
		...restProps,
		ref,
		className: clsx(hashId, cssVarCls, rootCls, prefixCls, className, rootClassName, `${prefixCls}-${type$2}`, `${prefixCls}-${mergedShape}`, {
			[`${prefixCls}-rtl`]: direction === "rtl",
			[`${prefixCls}-individual`]: mergedIndividual,
			[`${prefixCls}-icon-only`]: !mergedContent
		}),
		classNames: mergedClassNames,
		styles: mergedStyles,
		style: mergedStyle,
		shape: mergedShape,
		type: type$2,
		size: "large",
		icon: mergedIcon,
		_skipSemantic: true
	}, mergedContent, badgeNode);
	if (tooltipProps) node$1 = /* @__PURE__ */ import_react.createElement(tooltip_default, { ...tooltipProps }, node$1);
	return node$1;
});
FloatButton.displayName = "FloatButton";
var FloatButton_default = FloatButton;

//#endregion
//#region node_modules/antd/es/float-button/BackTop.js
var defaultIcon = /* @__PURE__ */ import_react.createElement(VerticalAlignTopOutlined_default, null);
var BackTop = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { backTopIcon: contextIcon } = useComponentConfig("floatButton");
	const { prefixCls: customizePrefixCls, className, type: type$2 = "default", shape = "circle", visibilityHeight = 400, icon, target, onClick, duration = 450, ...restProps } = props;
	const mergedIcon = icon ?? contextIcon ?? defaultIcon;
	const [visible, setVisible] = (0, import_react.useState)(visibilityHeight === 0);
	const internalRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => ({ nativeElement: internalRef.current }));
	const getDefaultTarget$1 = () => internalRef.current?.ownerDocument || window;
	const handleScroll = throttleByAnimationFrame_default((e$2) => {
		setVisible(getScroll_default(e$2.target) >= visibilityHeight);
	});
	(0, import_react.useEffect)(() => {
		const container = (target || getDefaultTarget$1)();
		handleScroll({ target: container });
		container?.addEventListener("scroll", handleScroll);
		return () => {
			handleScroll.cancel();
			container?.removeEventListener("scroll", handleScroll);
		};
	}, [target]);
	const scrollToTop = (e$2) => {
		scrollTo(0, {
			getContainer: target || getDefaultTarget$1,
			duration
		});
		onClick?.(e$2);
	};
	const { getPrefixCls } = (0, import_react.useContext)(ConfigContext);
	const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
	const rootPrefixCls = getPrefixCls();
	const contentProps = {
		prefixCls,
		icon: mergedIcon,
		type: type$2,
		shape: (0, import_react.useContext)(GroupContext)?.shape || shape,
		...restProps
	};
	return /* @__PURE__ */ import_react.createElement(es_default$1, {
		visible,
		motionName: `${rootPrefixCls}-fade`
	}, ({ className: motionClassName }, setRef) => /* @__PURE__ */ import_react.createElement(FloatButton_default, {
		ref: composeRef(internalRef, setRef),
		...contentProps,
		onClick: scrollToTop,
		className: clsx(className, motionClassName)
	}));
});
BackTop.displayName = "FloatButton.BackTop";
var BackTop_default = BackTop;

//#endregion
//#region node_modules/antd/es/float-button/FloatButtonGroup.js
var FloatButtonGroup = (props) => {
	const { prefixCls: customizePrefixCls, className, style: style$1, classNames, styles, rootClassName, shape = "circle", type: type$2 = "default", placement, icon = /* @__PURE__ */ import_react.createElement(FileTextOutlined_default, null), closeIcon, trigger, children, onOpenChange, open: customOpen, onClick: onTriggerButtonClick, ...floatButtonProps } = props;
	const { direction, getPrefixCls, closeIcon: contextCloseIcon, classNames: contextClassNames, styles: contextStyles, className: contextClassName, style: contextStyle } = useComponentConfig("floatButtonGroup");
	const mergedCloseIcon = closeIcon ?? contextCloseIcon ?? /* @__PURE__ */ import_react.createElement(CloseOutlined_default, null);
	const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$28(prefixCls, rootCls);
	const groupPrefixCls = `${prefixCls}-group`;
	const isMenuMode = trigger && ["click", "hover"].includes(trigger);
	const [zIndex] = useZIndex("FloatButton", style$1?.zIndex);
	const floatButtonGroupRef = import_react.useRef(null);
	const mergedPlacement = [
		"top",
		"left",
		"right",
		"bottom"
	].includes(placement) ? placement : "top";
	const [open$2, setOpen] = useControlledState(false, customOpen);
	const hoverTrigger = trigger === "hover";
	const clickTrigger = trigger === "click";
	const triggerOpen = useEvent_default((nextOpen) => {
		if (open$2 !== nextOpen) {
			setOpen(nextOpen);
			onOpenChange?.(nextOpen);
		}
	});
	const onMouseEnter = () => {
		if (hoverTrigger) triggerOpen(true);
	};
	const onMouseLeave = () => {
		if (hoverTrigger) triggerOpen(false);
	};
	const onInternalTriggerButtonClick = (e$2) => {
		if (clickTrigger) triggerOpen(!open$2);
		onTriggerButtonClick?.(e$2);
	};
	import_react.useEffect(() => {
		if (clickTrigger) {
			const onDocClick = (e$2) => {
				if (floatButtonGroupRef.current?.contains(e$2.target)) return;
				triggerOpen(false);
			};
			document.addEventListener("click", onDocClick, { capture: true });
			return () => document.removeEventListener("click", onDocClick, { capture: true });
		}
	}, [clickTrigger]);
	devUseWarning("FloatButton.Group")(!("open" in props) || !!trigger, "usage", "`open` need to be used together with `trigger`");
	const individual = shape === "circle";
	const mergedProps = {
		...props,
		shape,
		type: type$2,
		placement: mergedPlacement
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const listContext = import_react.useMemo(() => ({
		shape,
		individual,
		classNames: {
			root: mergedClassNames.item,
			icon: mergedClassNames.itemIcon,
			content: mergedClassNames.itemContent
		},
		styles: {
			root: mergedStyles.item,
			icon: mergedStyles.itemIcon,
			content: mergedStyles.itemContent
		}
	}), [
		shape,
		individual,
		mergedClassNames,
		mergedStyles
	]);
	const triggerContext = import_react.useMemo(() => ({
		...listContext,
		individual: true,
		classNames: {
			root: mergedClassNames.trigger,
			icon: mergedClassNames.triggerIcon,
			content: mergedClassNames.triggerContent
		},
		styles: {
			root: mergedStyles.trigger,
			icon: mergedStyles.triggerIcon,
			content: mergedStyles.triggerContent
		}
	}), [
		listContext,
		mergedClassNames,
		mergedStyles
	]);
	let listNode;
	const listCls = `${groupPrefixCls}-list`;
	const renderList = (motionClassName) => {
		const vertical = mergedPlacement === "top" || mergedPlacement === "bottom";
		const sharedProps = {
			className: clsx(listCls, mergedClassNames.list, motionClassName),
			style: mergedStyles.list
		};
		if (individual) listNode = /* @__PURE__ */ import_react.createElement(flex_default, {
			vertical,
			...sharedProps
		}, children);
		else listNode = /* @__PURE__ */ import_react.createElement(space_default.Compact, {
			vertical,
			...sharedProps
		}, children);
		return listNode;
	};
	return /* @__PURE__ */ import_react.createElement(GroupContext.Provider, { value: listContext }, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(groupPrefixCls, hashId, cssVarCls, rootCls, contextClassName, mergedClassNames.root, className, rootClassName, {
			[`${groupPrefixCls}-rtl`]: direction === "rtl",
			[`${groupPrefixCls}-individual`]: individual,
			[`${groupPrefixCls}-${mergedPlacement}`]: isMenuMode,
			[`${groupPrefixCls}-menu-mode`]: isMenuMode
		}),
		style: {
			...contextStyle,
			zIndex,
			...mergedStyles.root,
			...style$1
		},
		ref: floatButtonGroupRef,
		onMouseEnter,
		onMouseLeave
	}, isMenuMode ? /* @__PURE__ */ import_react.createElement(es_default$1, {
		visible: open$2,
		motionName: `${listCls}-motion`
	}, ({ className: motionClassName }) => renderList(motionClassName)) : renderList(), isMenuMode && /* @__PURE__ */ import_react.createElement(GroupContext.Provider, { value: triggerContext }, /* @__PURE__ */ import_react.createElement(FloatButton_default, {
		type: type$2,
		icon: open$2 ? mergedCloseIcon : icon,
		"aria-label": props["aria-label"],
		className: `${groupPrefixCls}-trigger`,
		onClick: onInternalTriggerButtonClick,
		...floatButtonProps
	}))));
};
var FloatButtonGroup_default = FloatButtonGroup;

//#endregion
//#region node_modules/antd/es/float-button/PurePanel.js
var PureFloatButton = ({ backTop, ...props }) => backTop ? /* @__PURE__ */ import_react.createElement(BackTop_default, {
	...props,
	visibilityHeight: 0
}) : /* @__PURE__ */ import_react.createElement(FloatButton_default, { ...props });
/** @private Internal Component. Do not use in your production. */
var PurePanel$5 = ({ className, items, classNames: cls, styles, prefixCls: customizePrefixCls, ...restProps }) => {
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const pureCls = `${getPrefixCls(floatButtonPrefixCls, customizePrefixCls)}-pure`;
	if (items) return /* @__PURE__ */ import_react.createElement(FloatButtonGroup_default, {
		className: clsx(className, pureCls),
		classNames: cls,
		styles,
		...restProps
	}, items.map((item, index$1) => /* @__PURE__ */ import_react.createElement(PureFloatButton, {
		key: index$1,
		...item
	})));
	return /* @__PURE__ */ import_react.createElement(PureFloatButton, {
		className: clsx(className, pureCls),
		classNames: cls,
		styles,
		...restProps
	});
};
var PurePanel_default$7 = PurePanel$5;

//#endregion
//#region node_modules/antd/es/float-button/index.js
FloatButton_default.BackTop = BackTop_default;
FloatButton_default.Group = FloatButtonGroup_default;
FloatButton_default._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default$7;
var float_button_default = FloatButton_default;

//#endregion
//#region node_modules/antd/es/form/hooks/useDebounce.js
function useDebounce(value) {
	const [cacheValue, setCacheValue] = import_react.useState(value);
	import_react.useEffect(() => {
		const timeout = setTimeout(() => {
			setCacheValue(value);
		}, value.length ? 0 : 10);
		return () => {
			clearTimeout(timeout);
		};
	}, [value]);
	return cacheValue;
}

//#endregion
//#region node_modules/antd/es/form/style/explain.js
var genFormValidateMotionStyle = (token$1) => {
	const { componentCls } = token$1;
	const helpCls = `${componentCls}-show-help`;
	const helpItemCls = `${componentCls}-show-help-item`;
	return { [helpCls]: {
		transition: `opacity ${token$1.motionDurationFast} ${token$1.motionEaseInOut}`,
		"&-appear, &-enter": {
			opacity: 0,
			"&-active": { opacity: 1 }
		},
		"&-leave": {
			opacity: 1,
			"&-active": { opacity: 0 }
		},
		[helpItemCls]: {
			overflow: "hidden",
			transition: `height ${token$1.motionDurationFast} ${token$1.motionEaseInOut},
                     opacity ${token$1.motionDurationFast} ${token$1.motionEaseInOut},
                     transform ${token$1.motionDurationFast} ${token$1.motionEaseInOut} !important`,
			[`&${helpItemCls}-appear, &${helpItemCls}-enter`]: {
				transform: `translateY(-5px)`,
				opacity: 0,
				"&-active": {
					transform: "translateY(0)",
					opacity: 1
				}
			},
			[`&${helpItemCls}-leave-active`]: { transform: `translateY(-5px)` }
		}
	} };
};
var explain_default = genFormValidateMotionStyle;

//#endregion
//#region node_modules/antd/es/form/style/index.js
var resetForm = (token$1) => ({
	legend: {
		display: "block",
		width: "100%",
		marginBottom: token$1.marginLG,
		padding: 0,
		color: token$1.colorTextDescription,
		fontSize: token$1.fontSizeLG,
		lineHeight: "inherit",
		border: 0,
		borderBottom: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`
	},
	"input[type=\"search\"]": { boxSizing: "border-box" },
	"input[type=\"radio\"], input[type=\"checkbox\"]": { lineHeight: "normal" },
	"input[type=\"file\"]": { display: "block" },
	"input[type=\"range\"]": {
		display: "block",
		width: "100%"
	},
	"select[multiple], select[size]": { height: "auto" },
	[`input[type='file']:focus,
  input[type='radio']:focus,
  input[type='checkbox']:focus`]: {
		outline: 0,
		boxShadow: `0 0 0 ${unit(token$1.controlOutlineWidth)} ${token$1.controlOutline}`
	},
	output: {
		display: "block",
		paddingTop: 15,
		color: token$1.colorText,
		fontSize: token$1.fontSize,
		lineHeight: token$1.lineHeight
	}
});
var genFormSize = (token$1, height) => {
	const { formItemCls } = token$1;
	return { [formItemCls]: {
		[`${formItemCls}-label > label`]: { height },
		[`${formItemCls}-control-input`]: { minHeight: height }
	} };
};
var genFormStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [token$1.componentCls]: {
		...resetComponent(token$1),
		...resetForm(token$1),
		[`${componentCls}-text`]: {
			display: "inline-block",
			paddingInlineEnd: token$1.paddingSM
		},
		"&-small": { ...genFormSize(token$1, token$1.controlHeightSM) },
		"&-large": { ...genFormSize(token$1, token$1.controlHeightLG) }
	} };
};
var genFormItemStyle = (token$1) => {
	const { formItemCls, iconCls, rootPrefixCls, antCls, labelRequiredMarkColor, labelColor, labelFontSize, labelHeight, labelColonMarginInlineStart, labelColonMarginInlineEnd, itemMarginBottom } = token$1;
	return { [formItemCls]: {
		...resetComponent(token$1),
		marginBottom: itemMarginBottom,
		verticalAlign: "top",
		"&-with-help": { transition: "none" },
		[`&-hidden,
        &-hidden${antCls}-row`]: { display: "none" },
		"&-has-warning": { [`${formItemCls}-split`]: { color: token$1.colorError } },
		"&-has-error": { [`${formItemCls}-split`]: { color: token$1.colorWarning } },
		[`${formItemCls}-label`]: {
			flexGrow: 0,
			overflow: "hidden",
			whiteSpace: "nowrap",
			textAlign: "end",
			verticalAlign: "middle",
			"&-left": { textAlign: "start" },
			"&-wrap": {
				overflow: "unset",
				lineHeight: token$1.lineHeight,
				whiteSpace: "unset",
				"> label": {
					verticalAlign: "middle",
					textWrap: "balance"
				}
			},
			"> label": {
				position: "relative",
				display: "inline-flex",
				alignItems: "center",
				maxWidth: "100%",
				height: labelHeight,
				color: labelColor,
				fontSize: labelFontSize,
				[`> ${iconCls}`]: {
					fontSize: token$1.fontSize,
					verticalAlign: "top"
				},
				[`&${formItemCls}-required`]: {
					"&::before": {
						display: "inline-block",
						marginInlineEnd: token$1.marginXXS,
						color: labelRequiredMarkColor,
						fontSize: token$1.fontSize,
						fontFamily: "SimSun, sans-serif",
						lineHeight: 1,
						content: "\"*\""
					},
					[`&${formItemCls}-required-mark-hidden, &${formItemCls}-required-mark-optional`]: { "&::before": { display: "none" } }
				},
				[`${formItemCls}-optional`]: {
					display: "inline-block",
					marginInlineStart: token$1.marginXXS,
					color: token$1.colorTextDescription,
					[`&${formItemCls}-required-mark-hidden`]: { display: "none" }
				},
				[`${formItemCls}-tooltip`]: {
					color: token$1.colorTextDescription,
					cursor: "help",
					writingMode: "horizontal-tb",
					marginInlineStart: token$1.marginXXS
				},
				"&::after": {
					content: "\":\"",
					position: "relative",
					marginBlock: 0,
					marginInlineStart: labelColonMarginInlineStart,
					marginInlineEnd: labelColonMarginInlineEnd
				},
				[`&${formItemCls}-no-colon::after`]: { content: "\"\\a0\"" }
			}
		},
		[`${formItemCls}-control`]: {
			["--ant-display"]: "flex",
			flexDirection: "column",
			flexGrow: 1,
			[`&:first-child:not([class^="'${rootPrefixCls}-col-'"]):not([class*="' ${rootPrefixCls}-col-'"])`]: { width: "100%" },
			"&-input": {
				position: "relative",
				display: "flex",
				alignItems: "center",
				minHeight: token$1.controlHeight,
				"&-content": {
					flex: "auto",
					maxWidth: "100%",
					[`&:has(> ${antCls}-switch:only-child, > ${antCls}-rate:only-child)`]: {
						display: "flex",
						alignItems: "center"
					}
				}
			}
		},
		[formItemCls]: {
			"&-additional": {
				display: "flex",
				flexDirection: "column"
			},
			"&-explain, &-extra": {
				clear: "both",
				color: token$1.colorTextDescription,
				fontSize: token$1.fontSize,
				lineHeight: token$1.lineHeight
			},
			"&-explain-connected": { width: "100%" },
			"&-extra": {
				minHeight: token$1.controlHeightSM,
				transition: `color ${token$1.motionDurationMid} ${token$1.motionEaseOut}`
			},
			"&-explain": {
				"&-error": { color: token$1.colorError },
				"&-warning": { color: token$1.colorWarning }
			}
		},
		[`&-with-help ${formItemCls}-explain`]: {
			height: "auto",
			opacity: 1
		},
		[`${formItemCls}-feedback-icon`]: {
			fontSize: token$1.fontSize,
			textAlign: "center",
			visibility: "visible",
			animationName: zoomIn,
			animationDuration: token$1.motionDurationMid,
			animationTimingFunction: token$1.motionEaseOutBack,
			pointerEvents: "none",
			"&-success": { color: token$1.colorSuccess },
			"&-error": { color: token$1.colorError },
			"&-warning": { color: token$1.colorWarning },
			"&-validating": { color: token$1.colorPrimary }
		}
	} };
};
var makeVerticalLayoutLabel = (token$1) => ({
	padding: token$1.verticalLabelPadding,
	margin: token$1.verticalLabelMargin,
	whiteSpace: "initial",
	textAlign: "start",
	"> label": {
		margin: 0,
		"&::after": { visibility: "hidden" }
	}
});
var genHorizontalStyle$2 = (token$1) => {
	const { antCls, formItemCls } = token$1;
	return { [`${formItemCls}-horizontal`]: {
		[`${formItemCls}-label`]: { flexGrow: 0 },
		[`${formItemCls}-control`]: {
			flex: "1 1 0",
			minWidth: 0
		},
		[`${formItemCls}-label[class$='-24'], ${formItemCls}-label[class*='-24 ']`]: { [`& + ${formItemCls}-control`]: { minWidth: "unset" } },
		[`${antCls}-col-24${formItemCls}-label,
        ${antCls}-col-xl-24${formItemCls}-label`]: makeVerticalLayoutLabel(token$1)
	} };
};
var genInlineStyle$1 = (token$1) => {
	const { componentCls, formItemCls, inlineItemMarginBottom } = token$1;
	return { [`${componentCls}-inline`]: {
		display: "flex",
		flexWrap: "wrap",
		[`${formItemCls}-inline`]: {
			flex: "none",
			marginInlineEnd: token$1.margin,
			marginBottom: inlineItemMarginBottom,
			"&-row": { flexWrap: "nowrap" },
			[`> ${formItemCls}-label,
        > ${formItemCls}-control`]: {
				display: "inline-block",
				verticalAlign: "top"
			},
			[`> ${formItemCls}-label`]: { flex: "none" },
			[`${componentCls}-text`]: { display: "inline-block" },
			[`${formItemCls}-has-feedback`]: { display: "inline-block" }
		}
	} };
};
var makeVerticalLayout = (token$1) => {
	const { componentCls, formItemCls, rootPrefixCls } = token$1;
	return {
		[`${formItemCls} ${formItemCls}-label`]: makeVerticalLayoutLabel(token$1),
		[`${componentCls}:not(${componentCls}-inline)`]: { [formItemCls]: {
			flexWrap: "wrap",
			[`${formItemCls}-label, ${formItemCls}-control`]: { [`&:not([class*=" ${rootPrefixCls}-col-xs"])`]: {
				flex: "0 0 100%",
				maxWidth: "100%"
			} }
		} }
	};
};
var genVerticalStyle$2 = (token$1) => {
	const { componentCls, formItemCls, antCls } = token$1;
	return {
		[`${formItemCls}-vertical`]: {
			[`${formItemCls}-row`]: { flexDirection: "column" },
			[`${formItemCls}-label > label`]: { height: "auto" },
			[`${formItemCls}-control`]: { width: "100%" },
			[`${formItemCls}-label,
        ${antCls}-col-24${formItemCls}-label,
        ${antCls}-col-xl-24${formItemCls}-label`]: makeVerticalLayoutLabel(token$1)
		},
		[`@media (max-width: ${unit(token$1.screenXSMax)})`]: [makeVerticalLayout(token$1), { [componentCls]: { [`${formItemCls}:not(${formItemCls}-horizontal)`]: { [`${antCls}-col-xs-24${formItemCls}-label`]: makeVerticalLayoutLabel(token$1) } } }],
		[`@media (max-width: ${unit(token$1.screenSMMax)})`]: { [componentCls]: { [`${formItemCls}:not(${formItemCls}-horizontal)`]: { [`${antCls}-col-sm-24${formItemCls}-label`]: makeVerticalLayoutLabel(token$1) } } },
		[`@media (max-width: ${unit(token$1.screenMDMax)})`]: { [componentCls]: { [`${formItemCls}:not(${formItemCls}-horizontal)`]: { [`${antCls}-col-md-24${formItemCls}-label`]: makeVerticalLayoutLabel(token$1) } } },
		[`@media (max-width: ${unit(token$1.screenLGMax)})`]: { [componentCls]: { [`${formItemCls}:not(${formItemCls}-horizontal)`]: { [`${antCls}-col-lg-24${formItemCls}-label`]: makeVerticalLayoutLabel(token$1) } } }
	};
};
const prepareComponentToken$22 = (token$1) => ({
	labelRequiredMarkColor: token$1.colorError,
	labelColor: token$1.colorTextHeading,
	labelFontSize: token$1.fontSize,
	labelHeight: token$1.controlHeight,
	labelColonMarginInlineStart: token$1.marginXXS / 2,
	labelColonMarginInlineEnd: token$1.marginXS,
	itemMarginBottom: token$1.marginLG,
	verticalLabelPadding: `0 0 ${token$1.paddingXS}px`,
	verticalLabelMargin: 0,
	inlineItemMarginBottom: 0
});
const prepareToken$2 = (token$1, rootPrefixCls) => {
	return merge(token$1, {
		formItemCls: `${token$1.componentCls}-item`,
		rootPrefixCls
	});
};
var style_default$27 = genStyleHooks("Form", (token$1, { rootPrefixCls }) => {
	const formToken = prepareToken$2(token$1, rootPrefixCls);
	return [
		genFormStyle(formToken),
		genFormItemStyle(formToken),
		explain_default(formToken),
		genHorizontalStyle$2(formToken),
		genInlineStyle$1(formToken),
		genVerticalStyle$2(formToken),
		collapse_default$1(formToken),
		zoomIn
	];
}, prepareComponentToken$22, { order: -1e3 });

//#endregion
//#region node_modules/antd/es/form/ErrorList.js
var EMPTY_LIST$2 = [];
function toErrorEntity(error, prefix$1, errorStatus, index$1 = 0) {
	return {
		key: typeof error === "string" ? error : `${prefix$1}-${index$1}`,
		error,
		errorStatus
	};
}
var ErrorList = ({ help, helpStatus, errors = EMPTY_LIST$2, warnings = EMPTY_LIST$2, className: rootClassName, fieldId, onVisibleChanged }) => {
	const { prefixCls } = import_react.useContext(FormItemPrefixContext);
	const baseClassName = `${prefixCls}-item-explain`;
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$27(prefixCls, rootCls);
	const collapseMotion = import_react.useMemo(() => motion_default(prefixCls), [prefixCls]);
	const debounceErrors = useDebounce(errors);
	const debounceWarnings = useDebounce(warnings);
	const fullKeyList = import_react.useMemo(() => {
		if (isNonNullable_default(help)) return [toErrorEntity(help, "help", helpStatus)];
		return [].concat(_toConsumableArray(debounceErrors.map((error, index$1) => toErrorEntity(error, "error", "error", index$1))), _toConsumableArray(debounceWarnings.map((warning$3, index$1) => toErrorEntity(warning$3, "warning", "warning", index$1))));
	}, [
		help,
		helpStatus,
		debounceErrors,
		debounceWarnings
	]);
	const filledKeyFullKeyList = import_react.useMemo(() => {
		const keysCount = {};
		fullKeyList.forEach(({ key }) => {
			keysCount[key] = (keysCount[key] || 0) + 1;
		});
		return fullKeyList.map((entity, index$1) => ({
			...entity,
			key: keysCount[entity.key] > 1 ? `${entity.key}-fallback-${index$1}` : entity.key
		}));
	}, [fullKeyList]);
	const helpProps = {};
	if (fieldId) helpProps.id = `${fieldId}_help`;
	return /* @__PURE__ */ import_react.createElement(es_default$1, {
		motionDeadline: collapseMotion.motionDeadline,
		motionName: `${prefixCls}-show-help`,
		visible: !!filledKeyFullKeyList.length,
		onVisibleChanged
	}, (holderProps) => {
		const { className: holderClassName, style: holderStyle } = holderProps;
		return /* @__PURE__ */ import_react.createElement("div", {
			...helpProps,
			className: clsx(baseClassName, holderClassName, cssVarCls, rootCls, rootClassName, hashId),
			style: holderStyle
		}, /* @__PURE__ */ import_react.createElement(CSSMotionList_default, {
			keys: filledKeyFullKeyList,
			...motion_default(prefixCls),
			motionName: `${prefixCls}-show-help-item`,
			component: false
		}, (itemProps) => {
			const { key, error, errorStatus, className: itemClassName, style: itemStyle } = itemProps;
			return /* @__PURE__ */ import_react.createElement("div", {
				key,
				className: clsx(itemClassName, { [`${baseClassName}-${errorStatus}`]: errorStatus }),
				style: itemStyle
			}, error);
		}));
	});
};
var ErrorList_default = ErrorList;

//#endregion
//#region node_modules/antd/es/form/hooks/useFormWarning.js
var names = {};
function useFormWarning({ name }) {
	const warning$3 = devUseWarning("Form");
	import_react.useEffect(() => {
		if (name) {
			names[name] = (names[name] || 0) + 1;
			warning$3(names[name] <= 1, "usage", "There exist multiple Form with same `name`.");
			return () => {
				names[name] -= 1;
			};
		}
	}, [name]);
}

//#endregion
//#region node_modules/antd/es/form/Form.js
var InternalForm = (props, ref) => {
	const contextDisabled = import_react.useContext(DisabledContext_default);
	const { getPrefixCls, direction, requiredMark: contextRequiredMark, colon: contextColon, scrollToFirstError: contextScrollToFirstError, className: contextClassName, style: contextStyle, styles: contextStyles, classNames: contextClassNames } = useComponentConfig("form");
	const { prefixCls: customizePrefixCls, className, rootClassName, size, disabled = contextDisabled, form, colon, labelAlign, labelWrap, labelCol, wrapperCol, layout = "horizontal", scrollToFirstError, requiredMark, onFinishFailed, name, style: style$1, feedbackIcons, variant, classNames, styles, ...restFormProps } = props;
	const mergedSize = useSize_default(size);
	const contextValidateMessages = import_react.useContext(validateMessagesContext_default);
	useFormWarning(props);
	const mergedRequiredMark = import_react.useMemo(() => {
		if (requiredMark !== void 0) return requiredMark;
		if (contextRequiredMark !== void 0) return contextRequiredMark;
		return true;
	}, [requiredMark, contextRequiredMark]);
	const mergedColon = colon ?? contextColon;
	const prefixCls = getPrefixCls("form", customizePrefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$27(prefixCls, rootCls);
	const mergedProps = {
		...props,
		size: mergedSize,
		disabled,
		layout,
		colon: mergedColon,
		requiredMark: mergedRequiredMark
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const formClassName = clsx(prefixCls, `${prefixCls}-${layout}`, {
		[`${prefixCls}-hide-required-mark`]: mergedRequiredMark === false,
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-${mergedSize}`]: mergedSize
	}, cssVarCls, rootCls, hashId, contextClassName, className, rootClassName, mergedClassNames.root);
	const [wrapForm] = useForm(form);
	const { __INTERNAL__ } = wrapForm;
	__INTERNAL__.name = name;
	const formContextValue = import_react.useMemo(() => ({
		name,
		labelAlign,
		labelCol,
		labelWrap,
		wrapperCol,
		layout,
		colon: mergedColon,
		requiredMark: mergedRequiredMark,
		itemRef: __INTERNAL__.itemRef,
		form: wrapForm,
		feedbackIcons,
		classNames: mergedClassNames,
		styles: mergedStyles
	}), [
		name,
		labelAlign,
		labelCol,
		wrapperCol,
		layout,
		mergedColon,
		mergedRequiredMark,
		wrapForm,
		feedbackIcons,
		mergedClassNames,
		mergedStyles
	]);
	const nativeElementRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => ({
		...wrapForm,
		nativeElement: nativeElementRef.current?.nativeElement
	}));
	const scrollToField = (options, fieldName) => {
		if (options) {
			let defaultScrollToFirstError = { block: "nearest" };
			if (typeof options === "object") defaultScrollToFirstError = {
				...defaultScrollToFirstError,
				...options
			};
			wrapForm.scrollToField(fieldName, defaultScrollToFirstError);
		}
	};
	const onInternalFinishFailed = (errorInfo) => {
		onFinishFailed?.(errorInfo);
		if (errorInfo.errorFields.length) {
			const fieldName = errorInfo.errorFields[0].name;
			if (scrollToFirstError !== void 0) {
				scrollToField(scrollToFirstError, fieldName);
				return;
			}
			if (contextScrollToFirstError !== void 0) scrollToField(contextScrollToFirstError, fieldName);
		}
	};
	return /* @__PURE__ */ import_react.createElement(VariantContext.Provider, { value: variant }, /* @__PURE__ */ import_react.createElement(DisabledContextProvider, { disabled }, /* @__PURE__ */ import_react.createElement(SizeContext_default.Provider, { value: mergedSize }, /* @__PURE__ */ import_react.createElement(FormProvider, { validateMessages: contextValidateMessages }, /* @__PURE__ */ import_react.createElement(FormContext.Provider, { value: formContextValue }, /* @__PURE__ */ import_react.createElement(NoFormStyle, { status: true }, /* @__PURE__ */ import_react.createElement(es_default$16, {
		id: name,
		...restFormProps,
		name,
		onFinishFailed: onInternalFinishFailed,
		form: wrapForm,
		ref: nativeElementRef,
		style: {
			...mergedStyles?.root,
			...contextStyle,
			...style$1
		},
		className: formClassName
	})))))));
};
var Form$1 = /* @__PURE__ */ import_react.forwardRef(InternalForm);
Form$1.displayName = "Form";
var Form_default = Form$1;

//#endregion
//#region node_modules/antd/es/form/hooks/useChildren.js
function useChildren(children) {
	if (typeof children === "function") return children;
	const childList = toArray(children);
	return childList.length <= 1 ? childList[0] : childList;
}

//#endregion
//#region node_modules/antd/es/form/hooks/useFormItemStatus.js
var useFormItemStatus = () => {
	const { status, errors = [], warnings = [] } = import_react.useContext(FormItemInputContext);
	devUseWarning("Form.Item")(status !== void 0, "usage", "Form.Item.useStatus should be used under Form.Item component. For more information: https://u.ant.design/form-item-usestatus");
	return {
		status,
		errors,
		warnings
	};
};
useFormItemStatus.Context = FormItemInputContext;
var useFormItemStatus_default = useFormItemStatus;

//#endregion
//#region node_modules/antd/es/form/hooks/useFrameState.js
function useFrameState(defaultValue) {
	const [value, setValue] = import_react.useState(defaultValue);
	const frameRef = import_react.useRef(null);
	const batchRef = import_react.useRef([]);
	const destroyRef = import_react.useRef(false);
	import_react.useEffect(() => {
		destroyRef.current = false;
		return () => {
			destroyRef.current = true;
			raf_default.cancel(frameRef.current);
			frameRef.current = null;
		};
	}, []);
	function setFrameValue(updater) {
		if (destroyRef.current) return;
		if (frameRef.current === null) {
			batchRef.current = [];
			frameRef.current = raf_default(() => {
				frameRef.current = null;
				setValue((prevValue) => {
					let current = prevValue;
					batchRef.current.forEach((func) => {
						current = func(current);
					});
					return current;
				});
			});
		}
		batchRef.current.push(updater);
	}
	return [value, setFrameValue];
}

//#endregion
//#region node_modules/antd/es/form/hooks/useItemRef.js
function useItemRef() {
	const { itemRef } = import_react.useContext(FormContext);
	const cacheRef = import_react.useRef({});
	function getRef(name, children) {
		const childrenRef = children && typeof children === "object" && getNodeRef(children);
		const nameStr = name.join("_");
		if (cacheRef.current.name !== nameStr || cacheRef.current.originRef !== childrenRef) {
			cacheRef.current.name = nameStr;
			cacheRef.current.originRef = childrenRef;
			cacheRef.current.ref = composeRef(itemRef(name), childrenRef);
		}
		return cacheRef.current.ref;
	}
	return getRef;
}

//#endregion
//#region node_modules/antd/es/form/style/fallbackCmp.js
/**
* Fallback of IE.
* Safe to remove.
*/
var genFallbackStyle = (token$1) => {
	const { formItemCls } = token$1;
	return { "@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none)": { [`${formItemCls}-control`]: { display: "flex" } } };
};
var fallbackCmp_default = genSubStyleComponent(["Form", "item-item"], (token$1, { rootPrefixCls }) => {
	return genFallbackStyle(prepareToken$2(token$1, rootPrefixCls));
});

//#endregion
//#region node_modules/antd/es/form/FormItemInput.js
var GRID_MAX = 24;
var FormItemInput = (props) => {
	const { prefixCls, status, labelCol, wrapperCol, children, errors, warnings, _internalItemRender: formItemRender, extra, help, fieldId, marginBottom, onErrorVisibleChanged, label } = props;
	const baseClassName = `${prefixCls}-item`;
	const formContext = import_react.useContext(FormContext);
	const { classNames: contextClassNames, styles: contextStyles } = formContext;
	const mergedWrapperCol = import_react.useMemo(() => {
		let mergedWrapper = { ...wrapperCol || formContext.wrapperCol || {} };
		if (label === null && !labelCol && !wrapperCol && formContext.labelCol) [
			void 0,
			"xs",
			"sm",
			"md",
			"lg",
			"xl",
			"xxl"
		].forEach((size) => {
			const _size = size ? [size] : [];
			const formLabel = get(formContext.labelCol, _size);
			const formLabelObj = typeof formLabel === "object" ? formLabel : {};
			const wrapper = get(mergedWrapper, _size);
			const wrapperObj = typeof wrapper === "object" ? wrapper : {};
			if ("span" in formLabelObj && !("offset" in wrapperObj) && formLabelObj.span < GRID_MAX) mergedWrapper = set(mergedWrapper, [].concat(_size, ["offset"]), formLabelObj.span);
		});
		return mergedWrapper;
	}, [
		wrapperCol,
		formContext.wrapperCol,
		formContext.labelCol,
		label,
		labelCol
	]);
	const className = clsx(`${baseClassName}-control`, mergedWrapperCol.className);
	const subFormContext = import_react.useMemo(() => {
		const { labelCol: _labelCol, wrapperCol: _wrapperCol, ...rest } = formContext;
		return rest;
	}, [formContext]);
	const extraRef = import_react.useRef(null);
	const [extraHeight, setExtraHeight] = import_react.useState(0);
	useLayoutEffect_default(() => {
		if (extra && extraRef.current) setExtraHeight(extraRef.current.clientHeight);
		else setExtraHeight(0);
	}, [extra]);
	const inputDom = /* @__PURE__ */ import_react.createElement("div", { className: `${baseClassName}-control-input` }, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${baseClassName}-control-input-content`, contextClassNames?.content),
		style: contextStyles?.content
	}, children));
	const formItemContext = import_react.useMemo(() => ({
		prefixCls,
		status
	}), [prefixCls, status]);
	const errorListDom = marginBottom !== null || errors.length || warnings.length ? /* @__PURE__ */ import_react.createElement(FormItemPrefixContext.Provider, { value: formItemContext }, /* @__PURE__ */ import_react.createElement(ErrorList_default, {
		fieldId,
		errors,
		warnings,
		help,
		helpStatus: status,
		className: `${baseClassName}-explain-connected`,
		onVisibleChanged: onErrorVisibleChanged
	})) : null;
	const extraProps = {};
	if (fieldId) extraProps.id = `${fieldId}_extra`;
	const extraDom = extra ? /* @__PURE__ */ import_react.createElement("div", {
		...extraProps,
		className: `${baseClassName}-extra`,
		ref: extraRef
	}, extra) : null;
	const additionalDom = errorListDom || extraDom ? /* @__PURE__ */ import_react.createElement("div", {
		className: `${baseClassName}-additional`,
		style: marginBottom ? { minHeight: marginBottom + extraHeight } : {}
	}, errorListDom, extraDom) : null;
	const dom = formItemRender && formItemRender.mark === "pro_table_render" && formItemRender.render ? formItemRender.render(props, {
		input: inputDom,
		errorList: errorListDom,
		extra: extraDom
	}) : /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, inputDom, additionalDom);
	return /* @__PURE__ */ import_react.createElement(FormContext.Provider, { value: subFormContext }, /* @__PURE__ */ import_react.createElement(col_default$1, {
		...mergedWrapperCol,
		className
	}, dom), /* @__PURE__ */ import_react.createElement(fallbackCmp_default, { prefixCls }));
};
var FormItemInput_default = FormItemInput;

//#endregion
//#region node_modules/antd/es/form/FormItemLabel.js
var FormItemLabel = ({ prefixCls, label, htmlFor, labelCol, labelAlign, colon, required: required$2, requiredMark, tooltip, vertical }) => {
	const [formLocale] = useLocale_default("Form");
	const { labelAlign: contextLabelAlign, labelCol: contextLabelCol, labelWrap, colon: contextColon, classNames: contextClassNames, styles: contextStyles } = import_react.useContext(FormContext);
	if (!label) return null;
	const mergedLabelCol = labelCol || contextLabelCol || {};
	const mergedLabelAlign = labelAlign || contextLabelAlign;
	const labelClsBasic = `${prefixCls}-item-label`;
	const labelColClassName = clsx(labelClsBasic, mergedLabelAlign === "left" && `${labelClsBasic}-left`, mergedLabelCol.className, { [`${labelClsBasic}-wrap`]: !!labelWrap });
	let labelChildren = label;
	const computedColon = colon === true || contextColon !== false && colon !== false;
	if (computedColon && !vertical && typeof label === "string" && label.trim()) labelChildren = label.replace(/[:|]\s*$/, "");
	const tooltipProps = convertToTooltipProps_default(tooltip);
	if (tooltipProps) {
		const { icon = /* @__PURE__ */ import_react.createElement(QuestionCircleOutlined_default, null), ...restTooltipProps } = tooltipProps;
		const tooltipNode = /* @__PURE__ */ import_react.createElement(tooltip_default, { ...restTooltipProps }, /* @__PURE__ */ import_react.cloneElement(icon, {
			className: `${prefixCls}-item-tooltip`,
			title: "",
			onClick: (e$2) => {
				e$2.preventDefault();
			},
			tabIndex: null
		}));
		labelChildren = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, labelChildren, tooltipNode);
	}
	const isOptionalMark = requiredMark === "optional";
	const isRenderMark = typeof requiredMark === "function";
	const hideRequiredMark = requiredMark === false;
	if (isRenderMark) labelChildren = requiredMark(labelChildren, { required: !!required$2 });
	else if (isOptionalMark && !required$2) labelChildren = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, labelChildren, /* @__PURE__ */ import_react.createElement("span", {
		className: `${prefixCls}-item-optional`,
		title: ""
	}, formLocale?.optional || en_US_default.Form?.optional));
	let markType;
	if (hideRequiredMark) markType = "hidden";
	else if (isOptionalMark || isRenderMark) markType = "optional";
	const labelClassName = clsx(contextClassNames?.label, {
		[`${prefixCls}-item-required`]: required$2,
		[`${prefixCls}-item-required-mark-${markType}`]: markType,
		[`${prefixCls}-item-no-colon`]: !computedColon
	});
	return /* @__PURE__ */ import_react.createElement(col_default$1, {
		...mergedLabelCol,
		className: labelColClassName
	}, /* @__PURE__ */ import_react.createElement("label", {
		htmlFor,
		className: labelClassName,
		style: contextStyles?.label,
		title: typeof label === "string" ? label : ""
	}, labelChildren));
};
var FormItemLabel_default = FormItemLabel;

//#endregion
//#region node_modules/antd/es/form/FormItem/StatusProvider.js
var iconMap = {
	success: CheckCircleFilled_default,
	warning: ExclamationCircleFilled_default,
	error: CloseCircleFilled_default,
	validating: LoadingOutlined_default
};
function StatusProvider({ children, errors, warnings, hasFeedback, validateStatus, prefixCls, meta, noStyle, name }) {
	const itemPrefixCls = `${prefixCls}-item`;
	const { feedbackIcons } = import_react.useContext(FormContext);
	const mergedValidateStatus = getStatus(errors, warnings, meta, null, !!hasFeedback, validateStatus);
	const { isFormItemInput: parentIsFormItemInput, status: parentStatus, hasFeedback: parentHasFeedback, feedbackIcon: parentFeedbackIcon, name: parentName } = import_react.useContext(FormItemInputContext);
	const formItemStatusContext = import_react.useMemo(() => {
		let feedbackIcon;
		if (hasFeedback) {
			const customIcons = hasFeedback !== true && hasFeedback.icons || feedbackIcons;
			const customIconNode = mergedValidateStatus && customIcons?.({
				status: mergedValidateStatus,
				errors,
				warnings
			})?.[mergedValidateStatus];
			const IconNode$1 = mergedValidateStatus ? iconMap[mergedValidateStatus] : null;
			feedbackIcon = customIconNode !== false && IconNode$1 ? /* @__PURE__ */ import_react.createElement("span", { className: clsx(`${itemPrefixCls}-feedback-icon`, `${itemPrefixCls}-feedback-icon-${mergedValidateStatus}`) }, customIconNode || /* @__PURE__ */ import_react.createElement(IconNode$1, null)) : null;
		}
		const context = {
			status: mergedValidateStatus || "",
			errors,
			warnings,
			hasFeedback: !!hasFeedback,
			feedbackIcon,
			isFormItemInput: true,
			name
		};
		if (noStyle) {
			context.status = (mergedValidateStatus ?? parentStatus) || "";
			context.isFormItemInput = parentIsFormItemInput;
			context.hasFeedback = !!(hasFeedback ?? parentHasFeedback);
			context.feedbackIcon = hasFeedback !== void 0 ? context.feedbackIcon : parentFeedbackIcon;
			context.name = name ?? parentName;
		}
		return context;
	}, [
		mergedValidateStatus,
		hasFeedback,
		noStyle,
		parentIsFormItemInput,
		parentStatus
	]);
	return /* @__PURE__ */ import_react.createElement(FormItemInputContext.Provider, { value: formItemStatusContext }, children);
}
var StatusProvider_default = StatusProvider;

//#endregion
//#region node_modules/antd/es/form/FormItem/ItemHolder.js
function ItemHolder(props) {
	const { prefixCls, className, rootClassName, style: style$1, help, errors, warnings, validateStatus, meta, hasFeedback, hidden, children, fieldId, required: required$2, isRequired, onSubItemMetaChange, layout: propsLayout, name, ...restProps } = props;
	const itemPrefixCls = `${prefixCls}-item`;
	const { requiredMark, layout: formLayout } = import_react.useContext(FormContext);
	const layout = propsLayout || formLayout;
	const vertical = layout === "vertical";
	const itemRef = import_react.useRef(null);
	const debounceErrors = useDebounce(errors);
	const debounceWarnings = useDebounce(warnings);
	const hasHelp = isNonNullable_default(help);
	const hasError = !!(hasHelp || errors.length || warnings.length);
	const isOnScreen = !!itemRef.current && isVisible_default(itemRef.current);
	const [marginBottom, setMarginBottom] = import_react.useState(null);
	useLayoutEffect_default(() => {
		if (hasError && itemRef.current) {
			const itemStyle = getComputedStyle(itemRef.current);
			setMarginBottom(Number.parseInt(itemStyle.marginBottom, 10));
		}
	}, [hasError, isOnScreen]);
	const onErrorVisibleChanged = (nextVisible) => {
		if (!nextVisible) setMarginBottom(null);
	};
	const getValidateState = (isDebounce = false) => {
		return getStatus(isDebounce ? debounceErrors : meta.errors, isDebounce ? debounceWarnings : meta.warnings, meta, "", !!hasFeedback, validateStatus);
	};
	const mergedValidateStatus = getValidateState();
	const itemClassName = clsx(itemPrefixCls, className, rootClassName, {
		[`${itemPrefixCls}-with-help`]: hasHelp || debounceErrors.length || debounceWarnings.length,
		[`${itemPrefixCls}-has-feedback`]: mergedValidateStatus && hasFeedback,
		[`${itemPrefixCls}-has-success`]: mergedValidateStatus === "success",
		[`${itemPrefixCls}-has-warning`]: mergedValidateStatus === "warning",
		[`${itemPrefixCls}-has-error`]: mergedValidateStatus === "error",
		[`${itemPrefixCls}-is-validating`]: mergedValidateStatus === "validating",
		[`${itemPrefixCls}-hidden`]: hidden,
		[`${itemPrefixCls}-${layout}`]: layout
	});
	return /* @__PURE__ */ import_react.createElement("div", {
		className: itemClassName,
		style: style$1,
		ref: itemRef
	}, /* @__PURE__ */ import_react.createElement(row_default$1, {
		className: `${itemPrefixCls}-row`,
		...omit(restProps, [
			"_internalItemRender",
			"colon",
			"dependencies",
			"extra",
			"fieldKey",
			"getValueFromEvent",
			"getValueProps",
			"htmlFor",
			"id",
			"initialValue",
			"isListField",
			"label",
			"labelAlign",
			"labelCol",
			"labelWrap",
			"messageVariables",
			"name",
			"normalize",
			"noStyle",
			"preserve",
			"requiredMark",
			"rules",
			"shouldUpdate",
			"trigger",
			"tooltip",
			"validateFirst",
			"validateTrigger",
			"valuePropName",
			"wrapperCol",
			"validateDebounce"
		])
	}, /* @__PURE__ */ import_react.createElement(FormItemLabel_default, {
		htmlFor: fieldId,
		...props,
		requiredMark,
		required: required$2 ?? isRequired,
		prefixCls,
		vertical
	}), /* @__PURE__ */ import_react.createElement(FormItemInput_default, {
		...props,
		...meta,
		errors: debounceErrors,
		warnings: debounceWarnings,
		prefixCls,
		status: mergedValidateStatus,
		help,
		marginBottom,
		onErrorVisibleChanged
	}, /* @__PURE__ */ import_react.createElement(NoStyleItemContext.Provider, { value: onSubItemMetaChange }, /* @__PURE__ */ import_react.createElement(StatusProvider_default, {
		prefixCls,
		meta,
		errors: meta.errors,
		warnings: meta.warnings,
		hasFeedback,
		validateStatus: mergedValidateStatus,
		name
	}, children)))), !!marginBottom && /* @__PURE__ */ import_react.createElement("div", {
		className: `${itemPrefixCls}-margin-offset`,
		style: { marginBottom: -marginBottom }
	}));
}

//#endregion
//#region node_modules/antd/es/form/FormItem/index.js
var NAME_SPLIT = "__SPLIT__";
function isSimilarControl(a, b) {
	const keysA = Object.keys(a);
	const keysB = Object.keys(b);
	return keysA.length === keysB.length && keysA.every((key) => {
		const propValueA = a[key];
		const propValueB = b[key];
		return propValueA === propValueB || typeof propValueA === "function" || typeof propValueB === "function";
	});
}
var MemoInput = /* @__PURE__ */ import_react.memo((props) => props.children, (prev$1, next$1) => isSimilarControl(prev$1.control, next$1.control) && prev$1.update === next$1.update && prev$1.childProps.length === next$1.childProps.length && prev$1.childProps.every((value, index$1) => value === next$1.childProps[index$1]));
function genEmptyMeta() {
	return {
		errors: [],
		warnings: [],
		touched: false,
		validating: false,
		name: [],
		validated: false
	};
}
function InternalFormItem(props) {
	const { name, noStyle, className, dependencies, prefixCls: customizePrefixCls, shouldUpdate, rules, children, required: required$2, label, messageVariables, trigger = "onChange", validateTrigger, hidden, help, layout } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const { name: formName } = import_react.useContext(FormContext);
	const mergedChildren = useChildren(children);
	const isRenderProps = typeof mergedChildren === "function";
	const notifyParentMetaChange = import_react.useContext(NoStyleItemContext);
	const { validateTrigger: contextValidateTrigger } = import_react.useContext(FieldContext_default);
	const mergedValidateTrigger = isNonNullable_default(validateTrigger) ? validateTrigger : contextValidateTrigger;
	const hasName = isNonNullable_default(name);
	const prefixCls = getPrefixCls("form", customizePrefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$27(prefixCls, rootCls);
	const warning$3 = devUseWarning("Form.Item");
	warning$3(name !== null, "usage", "`null` is passed as `name` property");
	const listContext = import_react.useContext(ListContext_default);
	const fieldKeyPathRef = import_react.useRef(null);
	const [subFieldErrors, setSubFieldErrors] = useFrameState({});
	const [meta, setMeta] = useSafeState(() => genEmptyMeta());
	const onMetaChange = (nextMeta) => {
		const keyInfo = listContext?.getKey(nextMeta.name);
		setMeta(nextMeta.destroy ? genEmptyMeta() : nextMeta, true);
		if (noStyle && help !== false && notifyParentMetaChange) {
			let namePath = nextMeta.name;
			if (!nextMeta.destroy) {
				if (keyInfo !== void 0) {
					const [fieldKey, restPath] = keyInfo;
					namePath = [fieldKey].concat(_toConsumableArray(restPath));
					fieldKeyPathRef.current = namePath;
				}
			} else namePath = fieldKeyPathRef.current || namePath;
			notifyParentMetaChange(nextMeta, namePath);
		}
	};
	const onSubItemMetaChange = (subMeta, uniqueKeys) => {
		setSubFieldErrors((prevSubFieldErrors) => {
			const clone = { ...prevSubFieldErrors };
			const mergedNameKey = [].concat(_toConsumableArray(subMeta.name.slice(0, -1)), _toConsumableArray(uniqueKeys)).join(NAME_SPLIT);
			if (subMeta.destroy) delete clone[mergedNameKey];
			else clone[mergedNameKey] = subMeta;
			return clone;
		});
	};
	const [mergedErrors, mergedWarnings] = import_react.useMemo(() => {
		const errorList = _toConsumableArray(meta.errors);
		const warningList = _toConsumableArray(meta.warnings);
		Object.values(subFieldErrors).forEach((subFieldError) => {
			errorList.push.apply(errorList, _toConsumableArray(subFieldError.errors || []));
			warningList.push.apply(warningList, _toConsumableArray(subFieldError.warnings || []));
		});
		return [errorList, warningList];
	}, [
		subFieldErrors,
		meta.errors,
		meta.warnings
	]);
	const getItemRef = useItemRef();
	function renderLayout(baseChildren, fieldId, isRequired) {
		if (noStyle && !hidden) return /* @__PURE__ */ import_react.createElement(StatusProvider_default, {
			prefixCls,
			hasFeedback: props.hasFeedback,
			validateStatus: props.validateStatus,
			meta,
			errors: mergedErrors,
			warnings: mergedWarnings,
			noStyle: true,
			name
		}, baseChildren);
		return /* @__PURE__ */ import_react.createElement(ItemHolder, {
			key: "row",
			...props,
			className: clsx(className, cssVarCls, rootCls, hashId),
			prefixCls,
			fieldId,
			isRequired,
			errors: mergedErrors,
			warnings: mergedWarnings,
			meta,
			onSubItemMetaChange,
			layout,
			name
		}, baseChildren);
	}
	if (!hasName && !isRenderProps && !dependencies) return renderLayout(mergedChildren);
	let variables = {};
	if (typeof label === "string") variables.label = label;
	else if (name) variables.label = String(name);
	if (messageVariables) variables = {
		...variables,
		...messageVariables
	};
	return /* @__PURE__ */ import_react.createElement(Field_default, {
		...props,
		messageVariables: variables,
		trigger,
		validateTrigger: mergedValidateTrigger,
		onMetaChange
	}, (control, renderMeta, context) => {
		const mergedName = toArray$4(name).length && renderMeta ? renderMeta.name : [];
		const fieldId = getFieldId(mergedName, formName);
		const isRequired = required$2 !== void 0 ? required$2 : !!rules?.some((rule) => {
			if (rule && typeof rule === "object" && rule.required && !rule.warningOnly) return true;
			if (typeof rule === "function") {
				const ruleEntity = rule(context);
				return ruleEntity?.required && !ruleEntity?.warningOnly;
			}
			return false;
		});
		const mergedControl = { ...control };
		let childNode = null;
		warning$3(!(shouldUpdate && dependencies), "usage", "`shouldUpdate` and `dependencies` shouldn't be used together. See https://u.ant.design/form-deps.");
		if (Array.isArray(mergedChildren) && hasName) {
			warning$3(false, "usage", "A `Form.Item` with a `name` prop must have a single child element. For information on how to render more complex form items, see https://u.ant.design/complex-form-item.");
			childNode = mergedChildren;
		} else if (isRenderProps && (!(shouldUpdate || dependencies) || hasName)) {
			warning$3(!!(shouldUpdate || dependencies), "usage", "A `Form.Item` with a render function must have either `shouldUpdate` or `dependencies`.");
			warning$3(!hasName, "usage", "A `Form.Item` with a render function cannot be a field, and thus cannot have a `name` prop.");
		} else if (dependencies && !isRenderProps && !hasName) warning$3(false, "usage", "Must set `name` or use a render function when `dependencies` is set.");
		else if (/* @__PURE__ */ import_react.isValidElement(mergedChildren)) {
			warning$3(mergedChildren.props.defaultValue === void 0, "usage", "`defaultValue` will not work on controlled Field. You should use `initialValues` of Form instead.");
			const childProps = {
				...mergedChildren.props,
				...mergedControl
			};
			if (!childProps.id) childProps.id = fieldId;
			if (help || mergedErrors.length > 0 || mergedWarnings.length > 0 || props.extra) {
				const describedbyArr = [];
				if (help || mergedErrors.length > 0) describedbyArr.push(`${fieldId}_help`);
				if (props.extra) describedbyArr.push(`${fieldId}_extra`);
				childProps["aria-describedby"] = describedbyArr.join(" ");
			}
			if (mergedErrors.length > 0) childProps["aria-invalid"] = "true";
			if (isRequired) childProps["aria-required"] = "true";
			if (supportRef(mergedChildren)) childProps.ref = getItemRef(mergedName, mergedChildren);
			new Set([].concat(_toConsumableArray(toArray$4(trigger)), _toConsumableArray(toArray$4(mergedValidateTrigger)))).forEach((eventName) => {
				childProps[eventName] = (...args) => {
					mergedControl[eventName]?.(...args);
					mergedChildren.props[eventName]?.(...args);
				};
			});
			const watchingChildProps = [
				childProps["aria-required"],
				childProps["aria-invalid"],
				childProps["aria-describedby"]
			];
			childNode = /* @__PURE__ */ import_react.createElement(MemoInput, {
				control: mergedControl,
				update: mergedChildren,
				childProps: watchingChildProps
			}, cloneElement(mergedChildren, childProps));
		} else if (isRenderProps && (shouldUpdate || dependencies) && !hasName) childNode = mergedChildren(context);
		else {
			warning$3(!mergedName.length || !!noStyle, "usage", "`name` is only used for validate React element. If you are using Form.Item as layout display, please remove `name` instead.");
			childNode = mergedChildren;
		}
		return renderLayout(childNode, fieldId, isRequired);
	});
}
var FormItem = InternalFormItem;
FormItem.useStatus = useFormItemStatus_default;
var FormItem_default = FormItem;

//#endregion
//#region node_modules/antd/es/form/FormList.js
var FormList = ({ prefixCls: customizePrefixCls, children, ...props }) => {
	devUseWarning("Form.List")(typeof props.name === "number" || (Array.isArray(props.name) ? !!props.name.length : !!props.name), "usage", "Miss `name` prop.");
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("form", customizePrefixCls);
	const contextValue = import_react.useMemo(() => ({
		prefixCls,
		status: "error"
	}), [prefixCls]);
	return /* @__PURE__ */ import_react.createElement(List_default, { ...props }, (fields, operation, meta) => /* @__PURE__ */ import_react.createElement(FormItemPrefixContext.Provider, { value: contextValue }, children(fields.map((field) => ({
		...field,
		fieldKey: field.key
	})), operation, {
		errors: meta.errors,
		warnings: meta.warnings
	})));
};
var FormList_default = FormList;

//#endregion
//#region node_modules/antd/es/form/hooks/useFormInstance.js
function useFormInstance() {
	const { form } = import_react.useContext(FormContext);
	return form;
}

//#endregion
//#region node_modules/antd/es/form/index.js
var Form = Form_default;
Form.Item = FormItem_default;
Form.List = FormList_default;
Form.ErrorList = ErrorList_default;
Form.useForm = useForm;
Form.useFormInstance = useFormInstance;
Form.useWatch = useWatch_default;
Form.Provider = FormProvider;
var form_default = Form;

//#endregion
//#region node_modules/@rc-component/image/es/context.js
const PreviewGroupContext = /* @__PURE__ */ import_react.createContext(null);

//#endregion
//#region node_modules/@rc-component/image/es/util.js
function isImageValid(src) {
	return new Promise((resolve) => {
		if (!src) {
			resolve(false);
			return;
		}
		const img = document.createElement("img");
		img.onerror = () => resolve(false);
		img.onload = () => resolve(true);
		img.src = src;
	});
}
function getClientSize() {
	return {
		width: document.documentElement.clientWidth,
		height: window.innerHeight || document.documentElement.clientHeight
	};
}

//#endregion
//#region node_modules/@rc-component/image/es/hooks/useImageTransform.js
var initialTransform = {
	x: 0,
	y: 0,
	rotate: 0,
	scale: 1,
	flipX: false,
	flipY: false
};
function useImageTransform(imgRef, minScale, maxScale, onTransform) {
	const frame = (0, import_react.useRef)(null);
	const queue = (0, import_react.useRef)([]);
	const [transform, setTransform] = (0, import_react.useState)(initialTransform);
	const resetTransform = (action) => {
		setTransform(initialTransform);
		if (!isEqual_default(initialTransform, transform)) onTransform?.({
			transform: initialTransform,
			action
		});
	};
	/** Direct update transform */
	const updateTransform = (newTransform, action) => {
		if (frame.current === null) {
			queue.current = [];
			frame.current = raf_default(() => {
				setTransform((preState) => {
					let memoState = preState;
					queue.current.forEach((queueState) => {
						memoState = {
							...memoState,
							...queueState
						};
					});
					frame.current = null;
					onTransform?.({
						transform: memoState,
						action
					});
					return memoState;
				});
			});
		}
		queue.current.push({
			...transform,
			...newTransform
		});
	};
	/** Scale according to the position of centerX and centerY */
	const dispatchZoomChange = (ratio, action, centerX, centerY, isTouch) => {
		const { width, height, offsetWidth, offsetHeight, offsetLeft, offsetTop } = imgRef.current;
		let newRatio = ratio;
		let newScale = transform.scale * ratio;
		if (newScale > maxScale) {
			newScale = maxScale;
			newRatio = maxScale / transform.scale;
		} else if (newScale < minScale) {
			newScale = isTouch ? newScale : minScale;
			newRatio = newScale / transform.scale;
		}
		/** Default center point scaling */
		const mergedCenterX = centerX ?? innerWidth / 2;
		const mergedCenterY = centerY ?? innerHeight / 2;
		const diffRatio = newRatio - 1;
		/** Deviation calculated from image size */
		const diffImgX = diffRatio * width * .5;
		const diffImgY = diffRatio * height * .5;
		/** The difference between the click position and the edge of the document */
		const diffOffsetLeft = diffRatio * (mergedCenterX - transform.x - offsetLeft);
		const diffOffsetTop = diffRatio * (mergedCenterY - transform.y - offsetTop);
		/** Final positioning */
		let newX = transform.x - (diffOffsetLeft - diffImgX);
		let newY = transform.y - (diffOffsetTop - diffImgY);
		/**
		* When zooming the image
		* When the image size is smaller than the width and height of the window, the position is initialized
		*/
		if (ratio < 1 && newScale === 1) {
			const mergedWidth = offsetWidth * newScale;
			const mergedHeight = offsetHeight * newScale;
			const { width: clientWidth, height: clientHeight } = getClientSize();
			if (mergedWidth <= clientWidth && mergedHeight <= clientHeight) {
				newX = 0;
				newY = 0;
			}
		}
		updateTransform({
			x: newX,
			y: newY,
			scale: newScale
		}, action);
	};
	return {
		transform,
		resetTransform,
		updateTransform,
		dispatchZoomChange
	};
}

//#endregion
//#region node_modules/@rc-component/image/es/getFixScaleEleTransPosition.js
function fixPoint(key, start, width, clientWidth) {
	const startAddWidth = start + width;
	const offsetStart = (width - clientWidth) / 2;
	if (width > clientWidth) {
		if (start > 0) return { [key]: offsetStart };
		if (start < 0 && startAddWidth < clientWidth) return { [key]: -offsetStart };
	} else if (start < 0 || startAddWidth > clientWidth) return { [key]: start < 0 ? offsetStart : -offsetStart };
	return {};
}
/**
* Fix positon x,y point when
*
* Ele width && height < client
* - Back origin
*
* - Ele width | height > clientWidth | clientHeight
* - left | top > 0 -> Back 0
* - left | top + width | height < clientWidth | clientHeight -> Back left | top + width | height === clientWidth | clientHeight
*
* Regardless of other
*/
function getFixScaleEleTransPosition(width, height, left, top) {
	const { width: clientWidth, height: clientHeight } = getClientSize();
	let fixPos = null;
	if (width <= clientWidth && height <= clientHeight) fixPos = {
		x: 0,
		y: 0
	};
	else if (width > clientWidth || height > clientHeight) fixPos = {
		...fixPoint("x", left, width, clientWidth),
		...fixPoint("y", top, height, clientHeight)
	};
	return fixPos;
}

//#endregion
//#region node_modules/@rc-component/image/es/previewConfig.js
/** Scale the ratio base */
const BASE_SCALE_RATIO = 1;
/** The maximum zoom ratio when the mouse zooms in, adjustable */
const WHEEL_MAX_SCALE_RATIO = 1;

//#endregion
//#region node_modules/@rc-component/image/es/hooks/useMouseEvent.js
function useMouseEvent(imgRef, movable, open$2, scaleStep, transform, updateTransform, dispatchZoomChange) {
	const { rotate, scale, x, y } = transform;
	const [isMoving, setMoving] = (0, import_react.useState)(false);
	const startPositionInfo = (0, import_react.useRef)({
		diffX: 0,
		diffY: 0,
		transformX: 0,
		transformY: 0
	});
	const onMouseDown = (event) => {
		if (!movable || event.button !== 0) return;
		event.preventDefault();
		event.stopPropagation();
		startPositionInfo.current = {
			diffX: event.pageX - x,
			diffY: event.pageY - y,
			transformX: x,
			transformY: y
		};
		setMoving(true);
	};
	const onMouseMove = (event) => {
		if (open$2 && isMoving) updateTransform({
			x: event.pageX - startPositionInfo.current.diffX,
			y: event.pageY - startPositionInfo.current.diffY
		}, "move");
	};
	const onMouseUp = () => {
		if (open$2 && isMoving) {
			setMoving(false);
			/** No need to restore the position when the picture is not moved, So as not to interfere with the click */
			const { transformX, transformY } = startPositionInfo.current;
			if (!(x !== transformX && y !== transformY)) return;
			const width = imgRef.current.offsetWidth * scale;
			const height = imgRef.current.offsetHeight * scale;
			const { left, top } = imgRef.current.getBoundingClientRect();
			const isRotate = rotate % 180 !== 0;
			const fixState = getFixScaleEleTransPosition(isRotate ? height : width, isRotate ? width : height, left, top);
			if (fixState) updateTransform({ ...fixState }, "dragRebound");
		}
	};
	const onWheel = (event) => {
		if (!open$2 || event.deltaY == 0) return;
		const scaleRatio = Math.abs(event.deltaY / 100);
		let ratio = BASE_SCALE_RATIO + Math.min(scaleRatio, WHEEL_MAX_SCALE_RATIO) * scaleStep;
		if (event.deltaY > 0) ratio = BASE_SCALE_RATIO / ratio;
		dispatchZoomChange(ratio, "wheel", event.clientX, event.clientY);
	};
	(0, import_react.useEffect)(() => {
		if (movable) {
			window.addEventListener("mouseup", onMouseUp, false);
			window.addEventListener("mousemove", onMouseMove, false);
			try {
				/* istanbul ignore next */
				if (window.top !== window.self) {
					window.top.addEventListener("mouseup", onMouseUp, false);
					window.top.addEventListener("mousemove", onMouseMove, false);
				}
			} catch (error) {
				/* istanbul ignore next */
				warning(false, `[rc-image] ${error}`);
			}
		}
		return () => {
			window.removeEventListener("mouseup", onMouseUp);
			window.removeEventListener("mousemove", onMouseMove);
			/* istanbul ignore next */
			try {
				window.top?.removeEventListener("mouseup", onMouseUp);
				window.top?.removeEventListener("mousemove", onMouseMove);
			} catch (error) {}
		};
	}, [
		open$2,
		isMoving,
		x,
		y,
		rotate,
		movable
	]);
	return {
		isMoving,
		onMouseDown,
		onMouseMove,
		onMouseUp,
		onWheel
	};
}

//#endregion
//#region node_modules/@rc-component/image/es/hooks/useStatus.js
function useStatus({ src, isCustomPlaceholder, fallback }) {
	const [status, setStatus] = (0, import_react.useState)(isCustomPlaceholder ? "loading" : "normal");
	const isLoaded = (0, import_react.useRef)(false);
	const isError = status === "error";
	(0, import_react.useEffect)(() => {
		let isCurrentSrc = true;
		isImageValid(src).then((isValid) => {
			if (!isValid && isCurrentSrc) setStatus("error");
		});
		return () => {
			isCurrentSrc = false;
		};
	}, [src]);
	(0, import_react.useEffect)(() => {
		if (isCustomPlaceholder && !isLoaded.current) setStatus("loading");
		else if (isError) setStatus("normal");
	}, [src]);
	const onLoad = () => {
		setStatus("normal");
	};
	const getImgRef = (img) => {
		isLoaded.current = false;
		if (status === "loading" && img?.complete && (img.naturalWidth || img.naturalHeight)) {
			isLoaded.current = true;
			onLoad();
		}
	};
	return [
		getImgRef,
		isError && fallback ? { src: fallback } : {
			onLoad,
			src
		},
		status
	];
}

//#endregion
//#region node_modules/@rc-component/image/es/hooks/useTouchEvent.js
function getDistance(a, b) {
	const x = a.x - b.x;
	const y = a.y - b.y;
	return Math.hypot(x, y);
}
function getCenter(oldPoint1, oldPoint2, newPoint1, newPoint2) {
	const distance1 = getDistance(oldPoint1, newPoint1);
	const distance2 = getDistance(oldPoint2, newPoint2);
	if (distance1 === 0 && distance2 === 0) return [oldPoint1.x, oldPoint1.y];
	const ratio = distance1 / (distance1 + distance2);
	return [oldPoint1.x + ratio * (oldPoint2.x - oldPoint1.x), oldPoint1.y + ratio * (oldPoint2.y - oldPoint1.y)];
}
function useTouchEvent(imgRef, movable, open$2, minScale, transform, updateTransform, dispatchZoomChange) {
	const { rotate, scale, x, y } = transform;
	const [isTouching, setIsTouching] = (0, import_react.useState)(false);
	const touchPointInfo = (0, import_react.useRef)({
		point1: {
			x: 0,
			y: 0
		},
		point2: {
			x: 0,
			y: 0
		},
		eventType: "none"
	});
	const updateTouchPointInfo = (values) => {
		touchPointInfo.current = {
			...touchPointInfo.current,
			...values
		};
	};
	const onTouchStart = (event) => {
		if (!movable) return;
		event.stopPropagation();
		setIsTouching(true);
		const { touches = [] } = event;
		if (touches.length > 1) updateTouchPointInfo({
			point1: {
				x: touches[0].clientX,
				y: touches[0].clientY
			},
			point2: {
				x: touches[1].clientX,
				y: touches[1].clientY
			},
			eventType: "touchZoom"
		});
		else updateTouchPointInfo({
			point1: {
				x: touches[0].clientX - x,
				y: touches[0].clientY - y
			},
			eventType: "move"
		});
	};
	const onTouchMove = (event) => {
		const { touches = [] } = event;
		const { point1, point2, eventType } = touchPointInfo.current;
		if (touches.length > 1 && eventType === "touchZoom") {
			const newPoint1 = {
				x: touches[0].clientX,
				y: touches[0].clientY
			};
			const newPoint2 = {
				x: touches[1].clientX,
				y: touches[1].clientY
			};
			const [centerX, centerY] = getCenter(point1, point2, newPoint1, newPoint2);
			dispatchZoomChange(getDistance(newPoint1, newPoint2) / getDistance(point1, point2), "touchZoom", centerX, centerY, true);
			updateTouchPointInfo({
				point1: newPoint1,
				point2: newPoint2,
				eventType: "touchZoom"
			});
		} else if (eventType === "move") {
			updateTransform({
				x: touches[0].clientX - point1.x,
				y: touches[0].clientY - point1.y
			}, "move");
			updateTouchPointInfo({ eventType: "move" });
		}
	};
	const onTouchEnd = () => {
		if (!open$2) return;
		if (isTouching) setIsTouching(false);
		updateTouchPointInfo({ eventType: "none" });
		if (minScale > scale)
 /** When the scaling ratio is less than the minimum scaling ratio, reset the scaling ratio */
		return updateTransform({
			x: 0,
			y: 0,
			scale: minScale
		}, "touchZoom");
		const width = imgRef.current.offsetWidth * scale;
		const height = imgRef.current.offsetHeight * scale;
		const { left, top } = imgRef.current.getBoundingClientRect();
		const isRotate = rotate % 180 !== 0;
		const fixState = getFixScaleEleTransPosition(isRotate ? height : width, isRotate ? width : height, left, top);
		if (fixState) updateTransform({ ...fixState }, "dragRebound");
	};
	(0, import_react.useEffect)(() => {
		const preventDefault = (e$2) => {
			e$2.preventDefault();
		};
		if (open$2 && movable) window.addEventListener("touchmove", preventDefault, { passive: false });
		return () => {
			window.removeEventListener("touchmove", preventDefault);
		};
	}, [open$2, movable]);
	return {
		isTouching,
		onTouchStart,
		onTouchMove,
		onTouchEnd
	};
}

//#endregion
//#region node_modules/@rc-component/image/es/Preview/CloseBtn.js
function CloseBtn(props) {
	const { prefixCls, icon, onClick } = props;
	return /* @__PURE__ */ import_react.createElement("button", {
		className: `${prefixCls}-close`,
		onClick
	}, icon);
}

//#endregion
//#region node_modules/@rc-component/image/es/Preview/Footer.js
function Footer$3(props) {
	const { prefixCls, showProgress, current, count, showSwitch, classNames, styles, icons: icons$1, image, transform, countRender, actionsRender, scale, minScale, maxScale, onActive, onFlipY, onFlipX, onRotateLeft, onRotateRight, onZoomOut, onZoomIn, onClose, onReset } = props;
	const { left, right, prev: prev$1, next: next$1, flipY, flipX, rotateLeft, rotateRight, zoomOut: zoomOut$1, zoomIn: zoomIn$1 } = icons$1;
	const progressNode = showProgress && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-progress` }, countRender ? countRender(current + 1, count) : /* @__PURE__ */ import_react.createElement("bdi", null, `${current + 1} / ${count}`));
	const actionCls = `${prefixCls}-actions-action`;
	const renderOperation = ({ type: type$2, disabled, onClick, icon }) => {
		return /* @__PURE__ */ import_react.createElement("div", {
			key: type$2,
			className: clsx(actionCls, `${actionCls}-${type$2}`, { [`${actionCls}-disabled`]: !!disabled }),
			onClick
		}, icon);
	};
	const switchPrevNode = showSwitch ? renderOperation({
		icon: prev$1 ?? left,
		onClick: () => onActive(-1),
		type: "prev",
		disabled: current === 0
	}) : void 0;
	const switchNextNode = showSwitch ? renderOperation({
		icon: next$1 ?? right,
		onClick: () => onActive(1),
		type: "next",
		disabled: current === count - 1
	}) : void 0;
	const flipYNode = renderOperation({
		icon: flipY,
		onClick: onFlipY,
		type: "flipY"
	});
	const flipXNode = renderOperation({
		icon: flipX,
		onClick: onFlipX,
		type: "flipX"
	});
	const rotateLeftNode = renderOperation({
		icon: rotateLeft,
		onClick: onRotateLeft,
		type: "rotateLeft"
	});
	const rotateRightNode = renderOperation({
		icon: rotateRight,
		onClick: onRotateRight,
		type: "rotateRight"
	});
	const zoomOutNode = renderOperation({
		icon: zoomOut$1,
		onClick: onZoomOut,
		type: "zoomOut",
		disabled: scale <= minScale
	});
	const zoomInNode = renderOperation({
		icon: zoomIn$1,
		onClick: onZoomIn,
		type: "zoomIn",
		disabled: scale === maxScale
	});
	const actionsNode = /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-actions`, classNames.actions),
		style: styles.actions
	}, flipYNode, flipXNode, rotateLeftNode, rotateRightNode, zoomOutNode, zoomInNode);
	return /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-footer`, classNames.footer),
		style: styles.footer
	}, progressNode, actionsRender ? actionsRender(actionsNode, {
		icons: {
			prevIcon: switchPrevNode,
			nextIcon: switchNextNode,
			flipYIcon: flipYNode,
			flipXIcon: flipXNode,
			rotateLeftIcon: rotateLeftNode,
			rotateRightIcon: rotateRightNode,
			zoomOutIcon: zoomOutNode,
			zoomInIcon: zoomInNode
		},
		actions: {
			onActive,
			onFlipY,
			onFlipX,
			onRotateLeft,
			onRotateRight,
			onZoomOut,
			onZoomIn,
			onReset,
			onClose
		},
		transform,
		current,
		total: count,
		image
	}) : actionsNode);
}

//#endregion
//#region node_modules/@rc-component/image/es/Preview/PrevNext.js
function PrevNext(props) {
	const { prefixCls, onActive, current, count, icons: { left, right, prev: prev$1, next: next$1 } } = props;
	const switchCls = `${prefixCls}-switch`;
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(switchCls, `${switchCls}-prev`, { [`${switchCls}-disabled`]: current === 0 }),
		onClick: () => onActive(-1)
	}, prev$1 ?? left), /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(switchCls, `${switchCls}-next`, { [`${switchCls}-disabled`]: current === count - 1 }),
		onClick: () => onActive(1)
	}, next$1 ?? right));
}

//#endregion
//#region node_modules/@rc-component/image/es/Preview/index.js
function _extends$35() {
	_extends$35 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$35.apply(this, arguments);
}
var PreviewImage = ({ fallback, src, imgRef, ...props }) => {
	const [getImgRef, srcAndOnload] = useStatus({
		src,
		fallback
	});
	return /* @__PURE__ */ import_react.createElement("img", _extends$35({ ref: (ref) => {
		imgRef.current = ref;
		getImgRef(ref);
	} }, props, srcAndOnload));
};
var Preview = (props) => {
	const { prefixCls, rootClassName, src, alt, imageInfo, fallback, movable = true, onClose, open: open$2, afterOpenChange, icons: icons$1 = {}, closeIcon, getContainer, current = 0, count = 1, countRender, scaleStep = .5, minScale = 1, maxScale = 50, motionName = "fade", imageRender, imgCommonProps, actionsRender, onTransform, onChange, classNames = {}, styles = {}, mousePosition: mousePosition$1, zIndex } = props;
	const imgRef = (0, import_react.useRef)();
	const groupContext = (0, import_react.useContext)(PreviewGroupContext);
	const showLeftOrRightSwitches = groupContext && count > 1;
	const showOperationsProgress = groupContext && count >= 1;
	const [enableTransition, setEnableTransition] = (0, import_react.useState)(true);
	const { transform, resetTransform, updateTransform, dispatchZoomChange } = useImageTransform(imgRef, minScale, maxScale, onTransform);
	const { isMoving, onMouseDown, onWheel } = useMouseEvent(imgRef, movable, open$2, scaleStep, transform, updateTransform, dispatchZoomChange);
	const { isTouching, onTouchStart, onTouchMove, onTouchEnd } = useTouchEvent(imgRef, movable, open$2, minScale, transform, updateTransform, dispatchZoomChange);
	const { rotate, scale } = transform;
	(0, import_react.useEffect)(() => {
		if (!enableTransition) setEnableTransition(true);
	}, [enableTransition]);
	(0, import_react.useEffect)(() => {
		if (!open$2) resetTransform("close");
	}, [open$2]);
	const onDoubleClick = (event) => {
		if (open$2) if (scale !== 1) updateTransform({
			x: 0,
			y: 0,
			scale: 1
		}, "doubleClick");
		else dispatchZoomChange(BASE_SCALE_RATIO + scaleStep, "doubleClick", event.clientX, event.clientY);
	};
	const imgNode = /* @__PURE__ */ import_react.createElement(PreviewImage, _extends$35({}, imgCommonProps, {
		width: props.width,
		height: props.height,
		imgRef,
		className: `${prefixCls}-img`,
		alt,
		style: {
			transform: `translate3d(${transform.x}px, ${transform.y}px, 0) scale3d(${transform.flipX ? "-" : ""}${scale}, ${transform.flipY ? "-" : ""}${scale}, 1) rotate(${rotate}deg)`,
			transitionDuration: (!enableTransition || isTouching) && "0s"
		},
		fallback,
		src,
		onWheel,
		onMouseDown,
		onDoubleClick,
		onTouchStart,
		onTouchMove,
		onTouchEnd,
		onTouchCancel: onTouchEnd
	}));
	const image = {
		url: src,
		alt,
		...imageInfo
	};
	const onZoomIn = () => {
		dispatchZoomChange(BASE_SCALE_RATIO + scaleStep, "zoomIn");
	};
	const onZoomOut = () => {
		dispatchZoomChange(BASE_SCALE_RATIO / (BASE_SCALE_RATIO + scaleStep), "zoomOut");
	};
	const onRotateRight = () => {
		updateTransform({ rotate: rotate + 90 }, "rotateRight");
	};
	const onRotateLeft = () => {
		updateTransform({ rotate: rotate - 90 }, "rotateLeft");
	};
	const onFlipX = () => {
		updateTransform({ flipX: !transform.flipX }, "flipX");
	};
	const onFlipY = () => {
		updateTransform({ flipY: !transform.flipY }, "flipY");
	};
	const onReset = () => {
		resetTransform("reset");
	};
	const onActive = (offset$2) => {
		const nextCurrent = current + offset$2;
		if (nextCurrent >= 0 && nextCurrent <= count - 1) {
			setEnableTransition(false);
			resetTransform(offset$2 < 0 ? "prev" : "next");
			onChange?.(nextCurrent, current);
		}
	};
	const onKeyDown$1 = useEvent_default((event) => {
		if (open$2) {
			const { keyCode } = event;
			if (keyCode === KeyCode_default.ESC) onClose?.();
			if (showLeftOrRightSwitches) {
				if (keyCode === KeyCode_default.LEFT) onActive(-1);
				else if (keyCode === KeyCode_default.RIGHT) onActive(1);
			}
		}
	});
	(0, import_react.useEffect)(() => {
		if (open$2) {
			window.addEventListener("keydown", onKeyDown$1);
			return () => {
				window.removeEventListener("keydown", onKeyDown$1);
			};
		}
	}, [open$2]);
	const [lockScroll, setLockScroll] = (0, import_react.useState)(false);
	import_react.useEffect(() => {
		if (open$2) setLockScroll(true);
	}, [open$2]);
	const onVisibleChanged = (nextVisible) => {
		if (!nextVisible) setLockScroll(false);
		afterOpenChange?.(nextVisible);
	};
	const [portalRender, setPortalRender] = (0, import_react.useState)(false);
	useLayoutEffect_default(() => {
		if (open$2) setPortalRender(true);
	}, [open$2]);
	const bodyStyle = { ...styles.body };
	if (mousePosition$1) bodyStyle.transformOrigin = `${mousePosition$1.x}px ${mousePosition$1.y}px`;
	return /* @__PURE__ */ import_react.createElement(es_default$7, {
		open: portalRender,
		getContainer,
		autoLock: lockScroll
	}, /* @__PURE__ */ import_react.createElement(es_default$1, {
		motionName,
		visible: portalRender && open$2,
		motionAppear: true,
		motionEnter: true,
		motionLeave: true,
		onVisibleChanged
	}, ({ className: motionClassName, style: motionStyle }) => {
		const mergedStyle = {
			...styles.root,
			...motionStyle
		};
		if (zIndex) mergedStyle.zIndex = zIndex;
		return /* @__PURE__ */ import_react.createElement("div", {
			className: clsx(prefixCls, rootClassName, classNames.root, motionClassName, { [`${prefixCls}-moving`]: isMoving }),
			style: mergedStyle
		}, /* @__PURE__ */ import_react.createElement("div", {
			className: clsx(`${prefixCls}-mask`, classNames.mask),
			style: styles.mask,
			onClick: onClose
		}), /* @__PURE__ */ import_react.createElement("div", {
			className: clsx(`${prefixCls}-body`, classNames.body),
			style: bodyStyle
		}, imageRender ? imageRender(imgNode, {
			transform,
			image,
			...groupContext ? { current } : {}
		}) : imgNode), closeIcon !== false && closeIcon !== null && /* @__PURE__ */ import_react.createElement(CloseBtn, {
			prefixCls,
			icon: closeIcon === true ? icons$1.close : closeIcon || icons$1.close,
			onClick: onClose
		}), showLeftOrRightSwitches && /* @__PURE__ */ import_react.createElement(PrevNext, {
			prefixCls,
			current,
			count,
			icons: icons$1,
			onActive
		}), /* @__PURE__ */ import_react.createElement(Footer$3, {
			prefixCls,
			showProgress: showOperationsProgress,
			current,
			count,
			showSwitch: showLeftOrRightSwitches,
			classNames,
			styles,
			image,
			transform,
			icons: icons$1,
			countRender,
			actionsRender,
			scale,
			minScale,
			maxScale,
			onActive,
			onFlipY,
			onFlipX,
			onRotateLeft,
			onRotateRight,
			onZoomOut,
			onZoomIn,
			onClose,
			onReset
		}));
	}));
};
var Preview_default = Preview;

//#endregion
//#region node_modules/@rc-component/image/es/common.js
const COMMON_PROPS = [
	"crossOrigin",
	"decoding",
	"draggable",
	"loading",
	"referrerPolicy",
	"sizes",
	"srcSet",
	"useMap",
	"alt"
];

//#endregion
//#region node_modules/@rc-component/image/es/hooks/usePreviewItems.js
/**
* Merge props provided `items` or context collected images
*/
function usePreviewItems(items) {
	const [images, setImages] = import_react.useState({});
	const registerImage = import_react.useCallback((id, data) => {
		setImages((imgs) => ({
			...imgs,
			[id]: data
		}));
		return () => {
			setImages((imgs) => {
				const cloneImgs = { ...imgs };
				delete cloneImgs[id];
				return cloneImgs;
			});
		};
	}, []);
	return [
		import_react.useMemo(() => {
			if (items) return items.map((item) => {
				if (typeof item === "string") return { data: { src: item } };
				const data = {};
				Object.keys(item).forEach((key) => {
					if (["src", ...COMMON_PROPS].includes(key)) data[key] = item[key];
				});
				return { data };
			});
			return Object.keys(images).reduce((total, id) => {
				const { canPreview, data } = images[id];
				if (canPreview) total.push({
					data,
					id
				});
				return total;
			}, []);
		}, [items, images]),
		registerImage,
		!!items
	];
}

//#endregion
//#region node_modules/@rc-component/image/es/PreviewGroup.js
function _extends$34() {
	_extends$34 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$34.apply(this, arguments);
}
var Group$1 = ({ previewPrefixCls = "rc-image-preview", classNames, styles, children, icons: icons$1 = {}, items, preview, fallback }) => {
	const { open: previewOpen, onOpenChange, current: currentIndex, onChange, ...restProps } = preview && typeof preview === "object" ? preview : {};
	const [mergedItems, register, fromItems] = usePreviewItems(items);
	const [current, setCurrent] = useControlledState(0, currentIndex);
	const [keepOpenIndex, setKeepOpenIndex] = (0, import_react.useState)(false);
	const { src, ...imgCommonProps } = mergedItems[current]?.data || {};
	const [isShowPreview, setShowPreview] = useControlledState(!!previewOpen, previewOpen);
	const triggerShowPreview = useEvent_default((next$1) => {
		setShowPreview(next$1);
		if (next$1 !== isShowPreview) onOpenChange?.(next$1, { current });
	});
	const [mousePosition$1, setMousePosition] = (0, import_react.useState)(null);
	const onPreviewFromImage = import_react.useCallback((id, imageSrc, mouseX, mouseY) => {
		const index$1 = fromItems ? mergedItems.findIndex((item) => item.data.src === imageSrc) : mergedItems.findIndex((item) => item.id === id);
		setCurrent(index$1 < 0 ? 0 : index$1);
		triggerShowPreview(true);
		setMousePosition({
			x: mouseX,
			y: mouseY
		});
		setKeepOpenIndex(true);
	}, [mergedItems, fromItems]);
	import_react.useEffect(() => {
		if (isShowPreview) {
			if (!keepOpenIndex) setCurrent(0);
		} else setKeepOpenIndex(false);
	}, [isShowPreview]);
	const onInternalChange = (next$1, prev$1) => {
		setCurrent(next$1);
		onChange?.(next$1, prev$1);
	};
	const onPreviewClose = () => {
		triggerShowPreview(false);
		setMousePosition(null);
	};
	const previewGroupContext = import_react.useMemo(() => ({
		register,
		onPreview: onPreviewFromImage
	}), [register, onPreviewFromImage]);
	return /* @__PURE__ */ import_react.createElement(PreviewGroupContext.Provider, { value: previewGroupContext }, children, /* @__PURE__ */ import_react.createElement(Preview_default, _extends$34({
		"aria-hidden": !isShowPreview,
		open: isShowPreview,
		prefixCls: previewPrefixCls,
		onClose: onPreviewClose,
		mousePosition: mousePosition$1,
		imgCommonProps,
		src,
		fallback,
		icons: icons$1,
		current,
		count: mergedItems.length,
		onChange: onInternalChange
	}, restProps, {
		classNames: classNames?.popup,
		styles: styles?.popup
	})));
};
var PreviewGroup_default$1 = Group$1;

//#endregion
//#region node_modules/@rc-component/image/es/hooks/useRegisterImage.js
var uid$1 = 0;
function useRegisterImage(canPreview, data) {
	const [id] = import_react.useState(() => {
		uid$1 += 1;
		return String(uid$1);
	});
	const groupContext = import_react.useContext(PreviewGroupContext);
	const registerData = {
		data,
		canPreview
	};
	import_react.useEffect(() => {
		if (groupContext) return groupContext.register(id, registerData);
	}, []);
	import_react.useEffect(() => {
		if (groupContext) groupContext.register(id, registerData);
	}, [canPreview, data]);
	return id;
}

//#endregion
//#region node_modules/@rc-component/image/es/Image.js
function _extends$33() {
	_extends$33 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$33.apply(this, arguments);
}
var ImageInternal = (props) => {
	const { prefixCls = "rc-image", previewPrefixCls = `${prefixCls}-preview`, rootClassName, className, style: style$1, classNames = {}, styles = {}, width, height, src: imgSrc, alt, placeholder, fallback, preview = true, onClick, onError, ...otherProps } = props;
	const groupContext = (0, import_react.useContext)(PreviewGroupContext);
	const canPreview = !!preview;
	const { src: previewSrc, open: previewOpen, onOpenChange: onPreviewOpenChange, cover, rootClassName: previewRootClassName, ...restProps } = preview && typeof preview === "object" ? preview : {};
	const coverPlacement = typeof cover === "object" && cover.placement ? cover.placement || "center" : "center";
	const coverNode = typeof cover === "object" && cover.coverNode ? cover.coverNode : cover;
	const [isShowPreview, setShowPreview] = useControlledState(!!previewOpen, previewOpen);
	const [mousePosition$1, setMousePosition] = (0, import_react.useState)(null);
	const triggerPreviewOpen = (nextOpen) => {
		setShowPreview(nextOpen);
		onPreviewOpenChange?.(nextOpen);
	};
	const onPreviewClose = () => {
		triggerPreviewOpen(false);
	};
	const isCustomPlaceholder = placeholder && placeholder !== true;
	const src = previewSrc ?? imgSrc;
	const [getImgRef, srcAndOnload, status] = useStatus({
		src: imgSrc,
		isCustomPlaceholder,
		fallback
	});
	const imgCommonProps = (0, import_react.useMemo)(() => {
		const obj = {};
		COMMON_PROPS.forEach((prop) => {
			if (props[prop] !== void 0) obj[prop] = props[prop];
		});
		return obj;
	}, COMMON_PROPS.map((prop) => props[prop]));
	const imageId = useRegisterImage(canPreview, (0, import_react.useMemo)(() => ({
		...imgCommonProps,
		src
	}), [src, imgCommonProps]));
	const onPreview = (e$2) => {
		const rect = e$2.target.getBoundingClientRect();
		const left = rect.x + rect.width / 2;
		const top = rect.y + rect.height / 2;
		if (groupContext) groupContext.onPreview(imageId, src, left, top);
		else {
			setMousePosition({
				x: left,
				y: top
			});
			triggerPreviewOpen(true);
		}
		onClick?.(e$2);
	};
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("div", _extends$33({}, otherProps, {
		className: clsx(prefixCls, rootClassName, classNames.root, { [`${prefixCls}-error`]: status === "error" }),
		onClick: canPreview ? onPreview : onClick,
		style: {
			width,
			height,
			...styles.root
		}
	}), /* @__PURE__ */ import_react.createElement("img", _extends$33({}, imgCommonProps, {
		className: clsx(`${prefixCls}-img`, { [`${prefixCls}-img-placeholder`]: placeholder === true }, classNames.image, className),
		style: {
			height,
			...styles.image,
			...style$1
		},
		ref: getImgRef
	}, srcAndOnload, {
		width,
		height,
		onError
	})), status === "loading" && /* @__PURE__ */ import_react.createElement("div", {
		"aria-hidden": "true",
		className: `${prefixCls}-placeholder`
	}, placeholder), cover !== false && canPreview && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-cover`, classNames.cover, `${prefixCls}-cover-${coverPlacement}`),
		style: {
			display: style$1?.display === "none" ? "none" : void 0,
			...styles.cover
		}
	}, coverNode)), !groupContext && canPreview && /* @__PURE__ */ import_react.createElement(Preview_default, _extends$33({
		"aria-hidden": !isShowPreview,
		open: isShowPreview,
		prefixCls: previewPrefixCls,
		onClose: onPreviewClose,
		mousePosition: mousePosition$1,
		src,
		alt,
		imageInfo: {
			width,
			height
		},
		fallback,
		imgCommonProps
	}, restProps, {
		classNames: classNames?.popup,
		styles: styles?.popup,
		rootClassName: clsx(previewRootClassName, rootClassName)
	})));
};
ImageInternal.PreviewGroup = PreviewGroup_default$1;
ImageInternal.displayName = "Image";
var Image_default = ImageInternal;

//#endregion
//#region node_modules/@rc-component/image/es/index.js
var es_default$15 = Image_default;

//#endregion
//#region node_modules/antd/es/image/hooks/useMergedPreviewConfig.js
var useMergedPreviewConfig = (previewConfig, contextPreviewConfig, prefixCls, mergedRootClassName, getContextPopupContainer, icons$1, defaultCover) => {
	const [zIndex] = useZIndex("ImagePreview", previewConfig?.zIndex);
	const [mergedPreviewMask, blurClassName] = useMergedMask(previewConfig?.mask, contextPreviewConfig?.mask, `${prefixCls}-preview`);
	return import_react.useMemo(() => {
		if (!previewConfig) return previewConfig;
		const { cover, getContainer, closeIcon, rootClassName: previewRootClassName } = previewConfig;
		const { closeIcon: contextCloseIcon } = contextPreviewConfig ?? {};
		return {
			motionName: getTransitionName(`${prefixCls}-preview`, "fade"),
			...previewConfig,
			...defaultCover ? { cover: cover ?? defaultCover } : {},
			icons: icons$1,
			getContainer: getContainer ?? getContextPopupContainer,
			zIndex,
			closeIcon: closeIcon ?? contextCloseIcon,
			rootClassName: clsx(mergedRootClassName, previewRootClassName),
			mask: mergedPreviewMask,
			blurClassName: blurClassName.mask
		};
	}, [
		previewConfig,
		contextPreviewConfig,
		prefixCls,
		mergedRootClassName,
		getContextPopupContainer,
		defaultCover,
		icons$1,
		zIndex,
		mergedPreviewMask,
		blurClassName
	]);
};
var useMergedPreviewConfig_default = useMergedPreviewConfig;

//#endregion
//#region node_modules/antd/es/image/hooks/usePreviewConfig.js
function normalizeMask(mask) {
	if (/* @__PURE__ */ (0, import_react.isValidElement)(mask)) return [mask, void 0];
	if (typeof mask === "boolean" || mask && typeof mask === "object") return [void 0, mask];
	return [void 0, void 0];
}
function usePreviewConfig(preview) {
	const rawPreviewConfig = (0, import_react.useMemo)(() => {
		if (typeof preview === "boolean") return preview ? {} : null;
		return preview && typeof preview === "object" ? preview : {};
	}, [preview]);
	const splittedPreviewConfig = (0, import_react.useMemo)(() => {
		if (!rawPreviewConfig) return [
			rawPreviewConfig,
			"",
			""
		];
		const { open: open$2, onOpenChange, cover, actionsRender, visible, onVisibleChange, rootClassName, maskClassName, mask, forceRender: _forceRender, destroyOnClose: _destroyOnClose, toolbarRender, ...restPreviewConfig } = rawPreviewConfig;
		let onInternalOpenChange;
		if (onOpenChange) onInternalOpenChange = onOpenChange;
		else if (onVisibleChange) onInternalOpenChange = (nextOpen, info) => {
			const { current } = info || {};
			if (current !== void 0) onVisibleChange(nextOpen, !nextOpen, current);
			else onVisibleChange(nextOpen, !nextOpen);
		};
		const [coverElement, maskConfig] = normalizeMask(mask);
		return [
			{
				...restPreviewConfig,
				open: open$2 ?? visible,
				onOpenChange: onInternalOpenChange,
				cover: cover ?? coverElement,
				mask: maskConfig,
				actionsRender: actionsRender ?? toolbarRender
			},
			rootClassName,
			maskClassName
		];
	}, [rawPreviewConfig]);
	{
		const warning$3 = devUseWarning("Image");
		if (rawPreviewConfig) {
			[
				["visible", "open"],
				["onVisibleChange", "onOpenChange"],
				["maskClassName", "classNames.cover"],
				["rootClassName", "classNames.root"],
				["toolbarRender", "actionsRender"]
			].forEach(([deprecatedName, newName]) => {
				warning$3.deprecated(!(deprecatedName in rawPreviewConfig), deprecatedName, newName);
			});
			warning$3(!/* @__PURE__ */ (0, import_react.isValidElement)(rawPreviewConfig.mask), "deprecated", "`mask` used as ReactNode is deprecated. Please use `cover` instead.");
			warning$3(!("forceRender" in rawPreviewConfig), "breaking", "`forceRender` is no longer supported.");
			warning$3(!("destroyOnClose" in rawPreviewConfig), "breaking", "`destroyOnClose` is no longer supported.");
		}
	}
	return splittedPreviewConfig;
}

//#endregion
//#region node_modules/antd/es/image/style/index.js
const genBoxStyle = (position$2) => ({
	position: position$2 || "absolute",
	inset: 0
});
const genImageCoverStyle = (token$1) => {
	const { componentCls, motionDurationSlow, colorTextLightSolid } = token$1;
	return { [componentCls]: {
		[`${componentCls}-cover`]: {
			position: "absolute",
			inset: 0,
			display: "flex",
			alignItems: "center",
			justifyContent: "center",
			color: colorTextLightSolid,
			background: new FastColor("#000").setA(.3).toRgbString(),
			cursor: "pointer",
			opacity: 0,
			transition: `opacity ${motionDurationSlow}`
		},
		"&:hover": { [`${componentCls}-cover`]: { opacity: 1 } },
		[`${componentCls}-cover-top`]: {
			inset: "0 0 auto 0",
			justifyContent: "center"
		},
		[`${componentCls}-cover-bottom`]: {
			inset: "auto 0 0 0",
			justifyContent: "center"
		}
	} };
};
const genImagePreviewStyle = (token$1) => {
	const { motionEaseOut, previewCls, motionDurationSlow, componentCls, colorBgMask, marginXL, marginSM, margin, colorTextLightSolid, paddingSM, paddingLG, previewOperationHoverColor, previewOperationColorDisabled, previewOperationSize, zIndexPopup } = token$1;
	const operationBg = new FastColor(colorBgMask).setA(.1);
	const operationBgHover = operationBg.clone().setA(.2);
	const singleBtn = {
		position: "absolute",
		color: colorTextLightSolid,
		backgroundColor: operationBg.toRgbString(),
		borderRadius: "50%",
		padding: paddingSM,
		outline: 0,
		border: 0,
		cursor: "pointer",
		transition: `all ${motionDurationSlow}`,
		display: "flex",
		fontSize: previewOperationSize,
		"&:hover": { backgroundColor: operationBgHover.toRgbString() },
		"&:active": { backgroundColor: operationBg.toRgbString() }
	};
	return { [`${componentCls}-preview`]: {
		textAlign: "center",
		inset: 0,
		position: "fixed",
		userSelect: "none",
		zIndex: zIndexPopup,
		[`${previewCls}-mask`]: {
			inset: 0,
			position: "absolute",
			background: colorBgMask,
			[`&${componentCls}-preview-mask-blur`]: { backdropFilter: "blur(4px)" },
			[`&${componentCls}-preview-mask-hidden`]: { display: "none" }
		},
		[`${previewCls}-body`]: {
			...genBoxStyle(),
			"pointer-events": "none",
			display: "flex",
			alignItems: "center",
			justifyContent: "center",
			"> *": { pointerEvents: "auto" }
		},
		[`${previewCls}-img`]: {
			maxWidth: "100%",
			maxHeight: "70%",
			verticalAlign: "middle",
			transform: "scale3d(1, 1, 1)",
			cursor: "grab",
			transition: `transform ${motionDurationSlow} ${motionEaseOut} 0s`
		},
		[`&-moving ${previewCls}-img`]: { cursor: "grabbing" },
		[`${previewCls}-close`]: {
			...singleBtn,
			top: marginSM,
			insetInlineEnd: marginSM
		},
		[`${previewCls}-switch`]: {
			...singleBtn,
			top: "50%",
			transform: `translateY(-50%)`,
			"&-disabled": { "&, &:hover, &:active": {
				color: previewOperationColorDisabled,
				background: "transparent",
				cursor: "not-allowed"
			} },
			"&-prev": { insetInlineStart: marginSM },
			"&-next": { insetInlineEnd: marginSM }
		},
		[`${previewCls}-footer`]: {
			position: "absolute",
			bottom: marginXL,
			left: {
				_skip_check_: true,
				value: "50%"
			},
			display: "flex",
			flexDirection: "column",
			alignItems: "center",
			color: token$1.previewOperationColor,
			transform: "translateX(-50%)",
			gap: margin
		},
		[`${previewCls}-actions`]: {
			display: "flex",
			gap: paddingSM,
			padding: `0 ${unit(paddingLG)}`,
			backgroundColor: operationBg.toRgbString(),
			borderRadius: 100,
			fontSize: previewOperationSize,
			"&-action": {
				padding: paddingSM,
				cursor: "pointer",
				transition: `all ${motionDurationSlow}`,
				display: "flex",
				[`&:not(${previewCls}-actions-action-disabled):hover`]: { color: previewOperationHoverColor },
				"&-disabled": {
					color: previewOperationColorDisabled,
					cursor: "not-allowed"
				}
			}
		}
	} };
};
var genImageStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: {
		position: "relative",
		display: "inline-block",
		[`${componentCls}-img`]: {
			width: "100%",
			height: "auto",
			verticalAlign: "middle"
		},
		[`${componentCls}-img-placeholder`]: {
			backgroundColor: token$1.colorBgContainerDisabled,
			backgroundImage: "url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMTQuNSAyLjVoLTEzQS41LjUgMCAwIDAgMSAzdjEwYS41LjUgMCAwIDAgLjUuNWgxM2EuNS41IDAgMCAwIC41LS41VjNhLjUuNSAwIDAgMC0uNS0uNXpNNS4yODEgNC43NWExIDEgMCAwIDEgMCAyIDEgMSAwIDAgMSAwLTJ6bTguMDMgNi44M2EuMTI3LjEyNyAwIDAgMS0uMDgxLjAzSDIuNzY5YS4xMjUuMTI1IDAgMCAxLS4wOTYtLjIwN2wyLjY2MS0zLjE1NmEuMTI2LjEyNiAwIDAgMSAuMTc3LS4wMTZsLjAxNi4wMTZMNy4wOCAxMC4wOWwyLjQ3LTIuOTNhLjEyNi4xMjYgMCAwIDEgLjE3Ny0uMDE2bC4wMTUuMDE2IDMuNTg4IDQuMjQ0YS4xMjcuMTI3IDAgMCAxLS4wMi4xNzV6IiBmaWxsPSIjOEM4QzhDIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L3N2Zz4=')",
			backgroundRepeat: "no-repeat",
			backgroundPosition: "center center",
			backgroundSize: "30%"
		},
		[`${componentCls}-placeholder`]: { ...genBoxStyle() }
	} };
};
var genPreviewMotion = (token$1) => {
	const { previewCls, motionDurationSlow } = token$1;
	return { [previewCls]: { "&-fade": {
		transition: `opacity ${motionDurationSlow}`,
		"&-enter, &-appear": {
			opacity: 0,
			[`${previewCls}-body`]: { transform: "scale(0)" },
			"&-active": {
				opacity: 1,
				[`${previewCls}-body`]: {
					transform: "scale(1)",
					transition: `transform ${motionDurationSlow}`
				}
			}
		},
		"&-leave": {
			opacity: 1,
			"&-active": {
				opacity: 0,
				[`${previewCls}-body`]: {
					transform: "scale(0)",
					transition: `transform ${motionDurationSlow}`
				}
			}
		}
	} } };
};
const prepareComponentToken$21 = (token$1) => ({
	zIndexPopup: token$1.zIndexPopupBase + 80,
	previewOperationColor: new FastColor(token$1.colorTextLightSolid).setA(.65).toRgbString(),
	previewOperationHoverColor: new FastColor(token$1.colorTextLightSolid).setA(.85).toRgbString(),
	previewOperationColorDisabled: new FastColor(token$1.colorTextLightSolid).setA(.25).toRgbString(),
	previewOperationSize: token$1.fontSizeIcon * 1.5
});
var style_default$26 = genStyleHooks("Image", (token$1) => {
	const imageToken = merge(token$1, {
		previewCls: `${token$1.componentCls}-preview`,
		imagePreviewSwitchSize: token$1.controlHeightLG
	});
	return [
		genImageStyle(imageToken),
		genImageCoverStyle(imageToken),
		genImagePreviewStyle(imageToken),
		genPreviewMotion(imageToken)
	];
}, prepareComponentToken$21);

//#endregion
//#region node_modules/antd/es/image/PreviewGroup.js
const icons = {
	rotateLeft: /* @__PURE__ */ import_react.createElement(RotateLeftOutlined_default, null),
	rotateRight: /* @__PURE__ */ import_react.createElement(RotateRightOutlined_default, null),
	zoomIn: /* @__PURE__ */ import_react.createElement(ZoomInOutlined_default, null),
	zoomOut: /* @__PURE__ */ import_react.createElement(ZoomOutOutlined_default, null),
	close: /* @__PURE__ */ import_react.createElement(CloseOutlined_default, null),
	left: /* @__PURE__ */ import_react.createElement(LeftOutlined_default, null),
	right: /* @__PURE__ */ import_react.createElement(RightOutlined_default, null),
	flipX: /* @__PURE__ */ import_react.createElement(SwapOutlined_default, null),
	flipY: /* @__PURE__ */ import_react.createElement(SwapOutlined_default, { rotate: 90 })
};
var InternalPreviewGroup = ({ previewPrefixCls: customizePrefixCls, preview, classNames, styles, ...otherProps }) => {
	const { getPrefixCls, getPopupContainer: getContextPopupContainer, direction, preview: contextPreview, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("image");
	const prefixCls = getPrefixCls("image", customizePrefixCls);
	const previewPrefixCls = `${prefixCls}-preview`;
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$26(prefixCls, rootCls);
	const mergedRootClassName = clsx(hashId, cssVarCls, rootCls);
	const [previewConfig, previewRootClassName, previewMaskClassName] = usePreviewConfig(preview);
	const [contextPreviewConfig, contextPreviewRootClassName, contextPreviewMaskClassName] = usePreviewConfig(contextPreview);
	const memoizedIcons = import_react.useMemo(() => ({
		...icons,
		left: direction === "rtl" ? /* @__PURE__ */ import_react.createElement(RightOutlined_default, null) : /* @__PURE__ */ import_react.createElement(LeftOutlined_default, null),
		right: direction === "rtl" ? /* @__PURE__ */ import_react.createElement(LeftOutlined_default, null) : /* @__PURE__ */ import_react.createElement(RightOutlined_default, null)
	}), [direction]);
	const mergedPreview = useMergedPreviewConfig_default(previewConfig, contextPreviewConfig, prefixCls, mergedRootClassName, getContextPopupContainer, icons);
	const { mask: mergedMask, blurClassName } = mergedPreview ?? {};
	const mergedProps = {
		...otherProps,
		classNames,
		styles
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([
		contextClassNames,
		classNames,
		{
			cover: clsx(contextPreviewMaskClassName, previewMaskClassName),
			popup: {
				root: clsx(contextPreviewRootClassName, previewRootClassName),
				mask: clsx({ [`${prefixCls}-preview-mask-hidden`]: !mergedMask }, blurClassName)
			}
		}
	], [contextStyles, styles], { props: mergedProps }, { popup: { _default: "root" } });
	return /* @__PURE__ */ import_react.createElement(es_default$15.PreviewGroup, {
		preview: mergedPreview,
		previewPrefixCls,
		icons: memoizedIcons,
		...otherProps,
		classNames: mergedClassNames,
		styles: mergedStyles
	});
};
var PreviewGroup_default = InternalPreviewGroup;

//#endregion
//#region node_modules/antd/es/image/index.js
var Image$1 = (props) => {
	const { prefixCls: customizePrefixCls, preview, className, rootClassName, style: style$1, styles, classNames, wrapperStyle, fallback, ...otherProps } = props;
	const { getPrefixCls, getPopupContainer: getContextPopupContainer, className: contextClassName, style: contextStyle, preview: contextPreview, styles: contextStyles, classNames: contextClassNames, fallback: contextFallback } = useComponentConfig("image");
	const prefixCls = getPrefixCls("image", customizePrefixCls);
	devUseWarning("Image").deprecated(!wrapperStyle, "wrapperStyle", "styles.root");
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$26(prefixCls, rootCls);
	const mergedRootClassName = clsx(rootClassName, hashId, cssVarCls, rootCls);
	const mergedClassName = clsx(className, hashId, contextClassName);
	const [previewConfig, previewRootClassName, previewMaskClassName] = usePreviewConfig(preview);
	const [contextPreviewConfig, contextPreviewRootClassName, contextPreviewMaskClassName] = usePreviewConfig(contextPreview);
	const mergedPreviewConfig = useMergedPreviewConfig_default(previewConfig, contextPreviewConfig, prefixCls, mergedRootClassName, getContextPopupContainer, icons, true);
	const mergedProps = {
		...props,
		preview: mergedPreviewConfig
	};
	const mergedLegacyClassNames = import_react.useMemo(() => ({
		cover: clsx(contextPreviewMaskClassName, previewMaskClassName),
		popup: { root: clsx(contextPreviewRootClassName, previewRootClassName) }
	}), [
		previewRootClassName,
		previewMaskClassName,
		contextPreviewRootClassName,
		contextPreviewMaskClassName
	]);
	const { mask: mergedMask, blurClassName } = mergedPreviewConfig ?? {};
	const mergedPopupClassNames = import_react.useMemo(() => ({ mask: clsx({ [`${prefixCls}-preview-mask-hidden`]: !mergedMask }, blurClassName) }), [
		mergedMask,
		prefixCls,
		blurClassName
	]);
	const [mergedClassNames, mergedStyles] = useMergeSemantic(import_react.useMemo(() => [
		contextClassNames,
		classNames,
		mergedLegacyClassNames,
		{ popup: mergedPopupClassNames }
	], [
		contextClassNames,
		classNames,
		mergedLegacyClassNames,
		mergedPopupClassNames
	]), [
		contextStyles,
		{ root: wrapperStyle },
		styles
	], { props: mergedProps }, { popup: { _default: "root" } });
	const mergedStyle = {
		...contextStyle,
		...style$1
	};
	const mergedFallback = fallback ?? contextFallback;
	return /* @__PURE__ */ import_react.createElement(es_default$15, {
		prefixCls,
		preview: mergedPreviewConfig || false,
		rootClassName: mergedRootClassName,
		className: mergedClassName,
		style: mergedStyle,
		fallback: mergedFallback,
		...otherProps,
		classNames: mergedClassNames,
		styles: mergedStyles
	});
};
Image$1.PreviewGroup = PreviewGroup_default;
Image$1.displayName = "Image";
var image_default = Image$1;

//#endregion
//#region node_modules/antd/es/input/Group.js
/** @deprecated Please use `Space.Compact` */
var Group = (props) => {
	const { getPrefixCls, direction } = (0, import_react.useContext)(ConfigContext);
	const { prefixCls: customizePrefixCls, className } = props;
	const prefixCls = getPrefixCls("input-group", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$25(getPrefixCls("input"));
	const cls = clsx(prefixCls, cssVarCls, {
		[`${prefixCls}-lg`]: props.size === "large",
		[`${prefixCls}-sm`]: props.size === "small",
		[`${prefixCls}-compact`]: props.compact,
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, hashId, className);
	const formItemContext = (0, import_react.useContext)(FormItemInputContext);
	const groupFormItemContext = (0, import_react.useMemo)(() => ({
		...formItemContext,
		isFormItemInput: false
	}), [formItemContext]);
	devUseWarning("Input.Group").deprecated(false, "Input.Group", "Space.Compact");
	return /* @__PURE__ */ import_react.createElement(FormItemInputContext.Provider, { value: groupFormItemContext }, /* @__PURE__ */ import_react.createElement(space_default.Compact, {
		className: cls,
		style: props.style,
		onMouseEnter: props.onMouseEnter,
		onMouseLeave: props.onMouseLeave,
		onFocus: props.onFocus,
		onBlur: props.onBlur
	}, props.children));
};
var Group_default = Group;

//#endregion
//#region node_modules/antd/es/input/style/otp.js
var genOTPStyle = (token$1) => {
	const { componentCls, paddingXS } = token$1;
	return { [componentCls]: {
		display: "inline-flex",
		alignItems: "center",
		flexWrap: "nowrap",
		columnGap: paddingXS,
		[`${componentCls}-input-wrapper`]: {
			position: "relative",
			[`${componentCls}-mask-icon`]: {
				position: "absolute",
				zIndex: "1",
				top: "50%",
				right: "50%",
				transform: "translate(50%, -50%)",
				pointerEvents: "none"
			},
			[`${componentCls}-mask-input`]: {
				color: "transparent",
				caretColor: token$1.colorText
			},
			[`${componentCls}-mask-input[type=number]::-webkit-inner-spin-button`]: {
				"-webkit-appearance": "none",
				margin: 0
			},
			[`${componentCls}-mask-input[type=number]`]: { "-moz-appearance": "textfield" }
		},
		"&-rtl": { direction: "rtl" },
		[`${componentCls}-input`]: {
			textAlign: "center",
			paddingInline: token$1.paddingXXS
		},
		[`&${componentCls}-sm ${componentCls}-input`]: { paddingInline: token$1.calc(token$1.paddingXXS).div(2).equal() },
		[`&${componentCls}-lg ${componentCls}-input`]: { paddingInline: token$1.paddingXS }
	} };
};
var otp_default = genStyleHooks(["Input", "OTP"], (token$1) => {
	return genOTPStyle(merge(token$1, initInputToken(token$1)));
}, initComponentToken$1);

//#endregion
//#region node_modules/antd/es/input/OTP/OTPInput.js
var OTPInput = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { className, value, onChange, onActiveChange, index: index$1, mask, onFocus, ...restProps } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("otp");
	const maskValue = typeof mask === "string" ? mask : value;
	const inputRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => inputRef.current);
	const onInternalChange = (e$2) => {
		onChange(index$1, e$2.target.value);
	};
	const syncSelection = () => {
		raf_default(() => {
			const inputEle = inputRef.current?.input;
			if (document.activeElement === inputEle && inputEle) inputEle.select();
		});
	};
	const onInternalFocus = (e$2) => {
		onFocus?.(e$2);
		syncSelection();
	};
	const onInternalKeyDown = (event) => {
		const { key, ctrlKey, metaKey } = event;
		if (key === "ArrowLeft") onActiveChange(index$1 - 1);
		else if (key === "ArrowRight") onActiveChange(index$1 + 1);
		else if (key === "z" && (ctrlKey || metaKey)) event.preventDefault();
		else if (key === "Backspace" && !value) onActiveChange(index$1 - 1);
		syncSelection();
	};
	return /* @__PURE__ */ import_react.createElement("span", {
		className: `${prefixCls}-input-wrapper`,
		role: "presentation"
	}, mask && value !== "" && value !== void 0 && /* @__PURE__ */ import_react.createElement("span", {
		className: `${prefixCls}-mask-icon`,
		"aria-hidden": "true"
	}, maskValue), /* @__PURE__ */ import_react.createElement(Input_default, {
		"aria-label": `OTP Input ${index$1 + 1}`,
		type: mask === true ? "password" : "text",
		...restProps,
		ref: inputRef,
		value,
		onInput: onInternalChange,
		onFocus: onInternalFocus,
		onKeyDown: onInternalKeyDown,
		onMouseDown: syncSelection,
		onMouseUp: syncSelection,
		className: clsx(className, { [`${prefixCls}-mask-input`]: mask })
	}));
});
var OTPInput_default = OTPInput;

//#endregion
//#region node_modules/antd/es/input/OTP/index.js
function strToArr(str) {
	return (str || "").split("");
}
var Separator = (props) => {
	const { index: index$1, prefixCls, separator, className: semanticClassName, style: semanticStyle } = props;
	const separatorNode = typeof separator === "function" ? separator(index$1) : separator;
	if (!separatorNode) return null;
	return /* @__PURE__ */ import_react.createElement("span", {
		className: clsx(`${prefixCls}-separator`, semanticClassName),
		style: semanticStyle
	}, separatorNode);
};
var OTP = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, length: length$1 = 6, size: customSize, defaultValue, value, onChange, formatter, separator, variant, disabled, status: customStatus, autoFocus, mask, type: type$2, onInput, onFocus, inputMode, classNames, styles, className, style: style$1, ...restProps } = props;
	devUseWarning("Input.OTP")(!(typeof mask === "string" && mask.length > 1), "usage", "`mask` prop should be a single character.");
	const { classNames: contextClassNames, styles: contextStyles, getPrefixCls, direction, style: contextStyle, className: contextClassName } = useComponentConfig("otp");
	const prefixCls = getPrefixCls("otp", customizePrefixCls);
	const mergedProps = {
		...props,
		length: length$1
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const domAttrs = pickAttrs(restProps, {
		aria: true,
		data: true,
		attr: true
	});
	const [hashId, cssVarCls] = otp_default(prefixCls);
	const mergedSize = useSize_default((ctx) => customSize ?? ctx);
	const formContext = import_react.useContext(FormItemInputContext);
	const mergedStatus = getMergedStatus(formContext.status, customStatus);
	const proxyFormContext = import_react.useMemo(() => ({
		...formContext,
		status: mergedStatus,
		hasFeedback: false,
		feedbackIcon: null
	}), [formContext, mergedStatus]);
	const containerRef = import_react.useRef(null);
	const refs = import_react.useRef({});
	import_react.useImperativeHandle(ref, () => ({
		focus: () => {
			refs.current[0]?.focus();
		},
		blur: () => {
			for (let i = 0; i < length$1; i += 1) refs.current[i]?.blur();
		},
		nativeElement: containerRef.current
	}));
	const internalFormatter = (txt) => formatter ? formatter(txt) : txt;
	const [valueCells, setValueCells] = import_react.useState(() => strToArr(internalFormatter(defaultValue || "")));
	import_react.useEffect(() => {
		if (value !== void 0) setValueCells(strToArr(value));
	}, [value]);
	const triggerValueCellsChange = useEvent_default((nextValueCells) => {
		setValueCells(nextValueCells);
		if (onInput) onInput(nextValueCells);
		if (onChange && nextValueCells.length === length$1 && nextValueCells.every((c) => c) && nextValueCells.some((c, index$1) => valueCells[index$1] !== c)) onChange(nextValueCells.join(""));
	});
	const patchValue = useEvent_default((index$1, txt) => {
		let nextCells = _toConsumableArray(valueCells);
		for (let i = 0; i < index$1; i += 1) if (!nextCells[i]) nextCells[i] = "";
		if (txt.length <= 1) nextCells[index$1] = txt;
		else nextCells = nextCells.slice(0, index$1).concat(strToArr(txt));
		nextCells = nextCells.slice(0, length$1);
		for (let i = nextCells.length - 1; i >= 0; i -= 1) {
			if (nextCells[i]) break;
			nextCells.pop();
		}
		nextCells = strToArr(internalFormatter(nextCells.map((c) => c || " ").join(""))).map((c, i) => {
			if (c === " " && !nextCells[i]) return nextCells[i];
			return c;
		});
		return nextCells;
	});
	const onInputChange = (index$1, txt) => {
		const nextCells = patchValue(index$1, txt);
		const nextIndex = Math.min(index$1 + txt.length, length$1 - 1);
		if (nextIndex !== index$1 && nextCells[index$1] !== void 0) refs.current[nextIndex]?.focus();
		triggerValueCellsChange(nextCells);
	};
	const onInputActiveChange = (nextIndex) => {
		refs.current[nextIndex]?.focus();
	};
	const onInputFocus = (event, index$1) => {
		for (let i = 0; i < index$1; i += 1) if (!refs.current[i]?.input?.value) {
			refs.current[i]?.focus();
			break;
		}
		onFocus?.(event);
	};
	const inputSharedProps = {
		variant,
		disabled,
		status: mergedStatus,
		mask,
		type: type$2,
		inputMode
	};
	return /* @__PURE__ */ import_react.createElement("div", {
		...domAttrs,
		ref: containerRef,
		className: clsx(className, prefixCls, {
			[`${prefixCls}-sm`]: mergedSize === "small",
			[`${prefixCls}-lg`]: mergedSize === "large",
			[`${prefixCls}-rtl`]: direction === "rtl"
		}, cssVarCls, hashId, contextClassName, mergedClassNames.root),
		style: {
			...mergedStyles.root,
			...contextStyle,
			...style$1
		},
		role: "group"
	}, /* @__PURE__ */ import_react.createElement(FormItemInputContext.Provider, { value: proxyFormContext }, Array.from({ length: length$1 }).map((_, index$1) => {
		const key = `otp-${index$1}`;
		const singleValue = valueCells[index$1] || "";
		return /* @__PURE__ */ import_react.createElement(import_react.Fragment, { key }, /* @__PURE__ */ import_react.createElement(OTPInput_default, {
			ref: (inputEle) => {
				refs.current[index$1] = inputEle;
			},
			index: index$1,
			size: mergedSize,
			htmlSize: 1,
			className: clsx(mergedClassNames.input, `${prefixCls}-input`),
			style: mergedStyles.input,
			onChange: onInputChange,
			value: singleValue,
			onActiveChange: onInputActiveChange,
			autoFocus: index$1 === 0 && autoFocus,
			onFocus: (event) => onInputFocus(event, index$1),
			...inputSharedProps
		}), index$1 < length$1 - 1 && /* @__PURE__ */ import_react.createElement(Separator, {
			separator,
			index: index$1,
			prefixCls,
			className: clsx(mergedClassNames.separator),
			style: mergedStyles.separator
		}));
	})));
});
var OTP_default = OTP;

//#endregion
//#region node_modules/antd/es/input/Password.js
var defaultIconRender = (visible) => visible ? /* @__PURE__ */ import_react.createElement(EyeOutlined_default, null) : /* @__PURE__ */ import_react.createElement(EyeInvisibleOutlined_default, null);
var actionMap = {
	click: "onClick",
	hover: "onMouseOver"
};
var Password = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { disabled: customDisabled, action = "click", visibilityToggle = true, iconRender = defaultIconRender, suffix } = props;
	const disabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = customDisabled ?? disabled;
	const visibilityControlled = typeof visibilityToggle === "object" && visibilityToggle.visible !== void 0;
	const [visible, setVisible] = (0, import_react.useState)(() => visibilityControlled ? visibilityToggle.visible : false);
	const inputRef = (0, import_react.useRef)(null);
	import_react.useEffect(() => {
		if (visibilityControlled) setVisible(visibilityToggle.visible);
	}, [visibilityControlled, visibilityToggle]);
	const removePasswordTimeout = useRemovePasswordTimeout(inputRef);
	const onVisibleChange = () => {
		if (mergedDisabled) return;
		if (visible) removePasswordTimeout();
		const nextVisible = !visible;
		setVisible(nextVisible);
		if (typeof visibilityToggle === "object") visibilityToggle.onVisibleChange?.(nextVisible);
	};
	const getIcon$1 = (prefixCls$1) => {
		const iconTrigger = actionMap[action] || "";
		const icon = iconRender(visible);
		const iconProps = {
			[iconTrigger]: onVisibleChange,
			className: `${prefixCls$1}-icon`,
			key: "passwordIcon",
			onMouseDown: (e$2) => {
				e$2.preventDefault();
			},
			onMouseUp: (e$2) => {
				e$2.preventDefault();
			}
		};
		return /* @__PURE__ */ import_react.cloneElement(/* @__PURE__ */ import_react.isValidElement(icon) ? icon : /* @__PURE__ */ import_react.createElement("span", null, icon), iconProps);
	};
	const { className, prefixCls: customizePrefixCls, inputPrefixCls: customizeInputPrefixCls, size, ...restProps } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
	const prefixCls = getPrefixCls("input-password", customizePrefixCls);
	const suffixIcon = visibilityToggle && getIcon$1(prefixCls);
	const inputClassName = clsx(prefixCls, className, { [`${prefixCls}-${size}`]: !!size });
	const omittedProps = {
		...omit(restProps, [
			"suffix",
			"iconRender",
			"visibilityToggle"
		]),
		type: visible ? "text" : "password",
		className: inputClassName,
		prefixCls: inputPrefixCls,
		suffix: /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, suffixIcon, suffix)
	};
	if (size) omittedProps.size = size;
	return /* @__PURE__ */ import_react.createElement(Input_default, {
		ref: composeRef(ref, inputRef),
		...omittedProps
	});
});
Password.displayName = "Input.Password";
var Password_default = Password;

//#endregion
//#region node_modules/antd/es/input/style/search.js
var genSearchStyle = (token$1) => {
	const { componentCls } = token$1;
	const btnCls = `${componentCls}-btn`;
	return { [componentCls]: {
		width: "100%",
		[btnCls]: { "&-filled": {
			background: token$1.colorFillTertiary,
			"&:not(:disabled)": {
				"&:hover": { background: token$1.colorFillSecondary },
				"&:active": { background: token$1.colorFill }
			}
		} }
	} };
};
var search_default$1 = genStyleHooks(["Input", "Search"], (token$1) => {
	return [genSearchStyle(token$1)];
});

//#endregion
//#region node_modules/antd/es/input/Search.js
var Search$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, inputPrefixCls: customizeInputPrefixCls, className, size: customizeSize, style: style$1, enterButton = false, addonAfter, loading, disabled, onSearch: customOnSearch, onChange: customOnChange, onCompositionStart, onCompositionEnd, variant, onPressEnter: customOnPressEnter, classNames, styles, hidden, ...restProps } = props;
	const { direction, getPrefixCls, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("inputSearch");
	const mergedProps = {
		...props,
		enterButton
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps }, { button: { _default: "root" } });
	const composedRef = import_react.useRef(false);
	const prefixCls = getPrefixCls("input-search", customizePrefixCls);
	const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
	const [hashId, cssVarCls] = search_default$1(prefixCls);
	const { compactSize } = useCompactItemContext(prefixCls, direction);
	const size = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
	const inputRef = import_react.useRef(null);
	const onChange = (e$2) => {
		if (e$2?.target && e$2.type === "click" && customOnSearch) customOnSearch(e$2.target.value, e$2, { source: "clear" });
		customOnChange?.(e$2);
	};
	const onMouseDown = (e$2) => {
		if (document.activeElement === inputRef.current?.input) e$2.preventDefault();
	};
	const onSearch = (e$2) => {
		if (customOnSearch) customOnSearch(inputRef.current?.input?.value, e$2, { source: "input" });
	};
	const onPressEnter = (e$2) => {
		if (composedRef.current || loading) return;
		customOnPressEnter?.(e$2);
		onSearch(e$2);
	};
	const searchIcon = typeof enterButton === "boolean" ? /* @__PURE__ */ import_react.createElement(SearchOutlined_default, null) : null;
	const btnPrefixCls = `${prefixCls}-btn`;
	const btnClassName = clsx(btnPrefixCls, { [`${btnPrefixCls}-${variant}`]: variant });
	let button;
	const enterButtonAsElement = enterButton || {};
	const isAntdButton = enterButtonAsElement.type && enterButtonAsElement.type.__ANT_BUTTON === true;
	if (isAntdButton || enterButtonAsElement.type === "button") button = cloneElement(enterButtonAsElement, {
		onMouseDown,
		onClick: (e$2) => {
			enterButtonAsElement?.props?.onClick?.(e$2);
			onSearch(e$2);
		},
		key: "enterButton",
		...isAntdButton ? {
			className: btnClassName,
			size
		} : {}
	});
	else button = /* @__PURE__ */ import_react.createElement(Button_default, {
		classNames: mergedClassNames.button,
		styles: mergedStyles.button,
		className: btnClassName,
		color: enterButton ? "primary" : "default",
		size,
		disabled,
		key: "enterButton",
		onMouseDown,
		onClick: onSearch,
		loading,
		icon: searchIcon,
		variant: variant === "borderless" || variant === "filled" || variant === "underlined" ? "text" : enterButton ? "solid" : void 0
	}, enterButton);
	if (addonAfter) button = [button, cloneElement(addonAfter, { key: "addonAfter" })];
	const mergedClassName = clsx(prefixCls, cssVarCls, {
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-${size}`]: !!size,
		[`${prefixCls}-with-button`]: !!enterButton
	}, className, hashId, mergedClassNames.root);
	const handleOnCompositionStart = (e$2) => {
		composedRef.current = true;
		onCompositionStart?.(e$2);
	};
	const handleOnCompositionEnd = (e$2) => {
		composedRef.current = false;
		onCompositionEnd?.(e$2);
	};
	const rootProps = pickAttrs(restProps, { data: true });
	const inputProps = omit({
		...restProps,
		classNames: omit(mergedClassNames, ["button", "root"]),
		styles: omit(mergedStyles, ["button", "root"]),
		prefixCls: inputPrefixCls,
		type: "search",
		size,
		variant,
		onPressEnter,
		onCompositionStart: handleOnCompositionStart,
		onCompositionEnd: handleOnCompositionEnd,
		onChange,
		disabled
	}, Object.keys(rootProps));
	return /* @__PURE__ */ import_react.createElement(Compact_default, {
		className: mergedClassName,
		style: {
			...style$1,
			...mergedStyles.root
		},
		...rootProps,
		hidden
	}, /* @__PURE__ */ import_react.createElement(Input_default, {
		ref: composeRef(inputRef, ref),
		...inputProps
	}), button);
});
Search$1.displayName = "Search";
var Search_default = Search$1;

//#endregion
//#region node_modules/@rc-component/textarea/es/calculateNodeHeight.js
/**
* calculateNodeHeight(uiTextNode, useCache = false)
*/
var HIDDEN_TEXTAREA_STYLE = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
  pointer-events: none !important;
`;
var SIZING_STYLE = [
	"letter-spacing",
	"line-height",
	"padding-top",
	"padding-bottom",
	"font-family",
	"font-weight",
	"font-size",
	"font-variant",
	"text-rendering",
	"text-transform",
	"width",
	"text-indent",
	"padding-left",
	"padding-right",
	"border-width",
	"box-sizing",
	"word-break",
	"white-space"
];
var computedStyleCache = {};
var hiddenTextarea;
function calculateNodeStyling(node$1, useCache = false) {
	const nodeRef = node$1.getAttribute("id") || node$1.getAttribute("data-reactid") || node$1.getAttribute("name");
	if (useCache && computedStyleCache[nodeRef]) return computedStyleCache[nodeRef];
	const style$1 = window.getComputedStyle(node$1);
	const boxSizing = style$1.getPropertyValue("box-sizing") || style$1.getPropertyValue("-moz-box-sizing") || style$1.getPropertyValue("-webkit-box-sizing");
	const paddingSize = parseFloat(style$1.getPropertyValue("padding-bottom")) + parseFloat(style$1.getPropertyValue("padding-top"));
	const borderSize = parseFloat(style$1.getPropertyValue("border-bottom-width")) + parseFloat(style$1.getPropertyValue("border-top-width"));
	const nodeInfo = {
		sizingStyle: SIZING_STYLE.map((name) => `${name}:${style$1.getPropertyValue(name)}`).join(";"),
		paddingSize,
		borderSize,
		boxSizing
	};
	if (useCache && nodeRef) computedStyleCache[nodeRef] = nodeInfo;
	return nodeInfo;
}
function calculateAutoSizeStyle(uiTextNode, useCache = false, minRows = null, maxRows = null) {
	if (!hiddenTextarea) {
		hiddenTextarea = document.createElement("textarea");
		hiddenTextarea.setAttribute("tab-index", "-1");
		hiddenTextarea.setAttribute("aria-hidden", "true");
		hiddenTextarea.setAttribute("name", "hiddenTextarea");
		document.body.appendChild(hiddenTextarea);
	}
	if (uiTextNode.getAttribute("wrap")) hiddenTextarea.setAttribute("wrap", uiTextNode.getAttribute("wrap"));
	else hiddenTextarea.removeAttribute("wrap");
	const { paddingSize, borderSize, boxSizing, sizingStyle } = calculateNodeStyling(uiTextNode, useCache);
	hiddenTextarea.setAttribute("style", `${sizingStyle};${HIDDEN_TEXTAREA_STYLE}`);
	hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || "";
	let minHeight = void 0;
	let maxHeight = void 0;
	let overflowY;
	let height = hiddenTextarea.scrollHeight;
	if (boxSizing === "border-box") height += borderSize;
	else if (boxSizing === "content-box") height -= paddingSize;
	if (minRows !== null || maxRows !== null) {
		hiddenTextarea.value = " ";
		const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
		if (minRows !== null) {
			minHeight = singleRowHeight * minRows;
			if (boxSizing === "border-box") minHeight = minHeight + paddingSize + borderSize;
			height = Math.max(minHeight, height);
		}
		if (maxRows !== null) {
			maxHeight = singleRowHeight * maxRows;
			if (boxSizing === "border-box") maxHeight = maxHeight + paddingSize + borderSize;
			overflowY = height > maxHeight ? "" : "hidden";
			height = Math.min(maxHeight, height);
		}
	}
	const style$1 = {
		height,
		overflowY,
		resize: "none"
	};
	if (minHeight) style$1.minHeight = minHeight;
	if (maxHeight) style$1.maxHeight = maxHeight;
	return style$1;
}

//#endregion
//#region node_modules/@rc-component/textarea/es/ResizableTextArea.js
function _extends$32() {
	_extends$32 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$32.apply(this, arguments);
}
var RESIZE_START = 0;
var RESIZE_MEASURING = 1;
var RESIZE_STABLE = 2;
var ResizableTextArea = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls, defaultValue, value, autoSize, onResize: onResize$1, className, style: style$1, disabled, onChange, onInternalAutoSize, ...restProps } = props;
	const [internalValue, setMergedValue] = useControlledState(defaultValue, value);
	const mergedValue = internalValue ?? "";
	const onInternalChange = (event) => {
		setMergedValue(event.target.value);
		onChange?.(event);
	};
	const textareaRef = import_react.useRef();
	import_react.useImperativeHandle(ref, () => ({ textArea: textareaRef.current }));
	const [minRows, maxRows] = import_react.useMemo(() => {
		if (autoSize && typeof autoSize === "object") return [autoSize.minRows, autoSize.maxRows];
		return [];
	}, [autoSize]);
	const needAutoSize = !!autoSize;
	const [resizeState, setResizeState] = import_react.useState(RESIZE_STABLE);
	const [autoSizeStyle, setAutoSizeStyle] = import_react.useState();
	const startResize = () => {
		setResizeState(RESIZE_START);
	};
	useLayoutEffect_default(() => {
		if (needAutoSize) startResize();
	}, [
		value,
		minRows,
		maxRows,
		needAutoSize
	]);
	useLayoutEffect_default(() => {
		if (resizeState === RESIZE_START) setResizeState(RESIZE_MEASURING);
		else if (resizeState === RESIZE_MEASURING) {
			const textareaStyles = calculateAutoSizeStyle(textareaRef.current, false, minRows, maxRows);
			setResizeState(RESIZE_STABLE);
			setAutoSizeStyle(textareaStyles);
		}
	}, [resizeState]);
	const resizeRafRef = import_react.useRef();
	const cleanRaf = () => {
		raf_default.cancel(resizeRafRef.current);
	};
	const onInternalResize = (size) => {
		if (resizeState === RESIZE_STABLE) {
			onResize$1?.(size);
			if (autoSize) {
				cleanRaf();
				resizeRafRef.current = raf_default(() => {
					startResize();
				});
			}
		}
	};
	import_react.useEffect(() => cleanRaf, []);
	const mergedAutoSizeStyle = needAutoSize ? autoSizeStyle : null;
	const mergedStyle = {
		...style$1,
		...mergedAutoSizeStyle
	};
	if (resizeState === RESIZE_START || resizeState === RESIZE_MEASURING) {
		mergedStyle.overflowY = "hidden";
		mergedStyle.overflowX = "hidden";
	}
	return /* @__PURE__ */ import_react.createElement(es_default$2, {
		onResize: onInternalResize,
		disabled: !(autoSize || onResize$1)
	}, /* @__PURE__ */ import_react.createElement("textarea", _extends$32({}, restProps, {
		ref: textareaRef,
		style: mergedStyle,
		className: clsx(prefixCls, className, { [`${prefixCls}-disabled`]: disabled }),
		disabled,
		value: mergedValue,
		onChange: onInternalChange
	})));
});
var ResizableTextArea_default = ResizableTextArea;

//#endregion
//#region node_modules/@rc-component/textarea/es/TextArea.js
function _extends$31() {
	_extends$31 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$31.apply(this, arguments);
}
var TextArea$1 = /* @__PURE__ */ import_react.forwardRef(({ defaultValue, value: customValue, onFocus, onBlur, onChange, allowClear, maxLength, onCompositionStart, onCompositionEnd, suffix, prefixCls = "rc-textarea", showCount, count, className, style: style$1, disabled, hidden, classNames, styles, onResize: onResize$1, onClear, onPressEnter, readOnly, autoSize, onKeyDown: onKeyDown$1, ...rest }, ref) => {
	const [value, setValue] = useControlledState(defaultValue, customValue);
	const formatValue$1 = value === void 0 || value === null ? "" : String(value);
	const [focused, setFocused] = import_react.useState(false);
	const compositionRef = import_react.useRef(false);
	const [textareaResized, setTextareaResized] = import_react.useState(null);
	const holderRef = (0, import_react.useRef)(null);
	const resizableTextAreaRef = (0, import_react.useRef)(null);
	const getTextArea = () => resizableTextAreaRef.current?.textArea;
	const focus = () => {
		getTextArea().focus();
	};
	(0, import_react.useImperativeHandle)(ref, () => ({
		resizableTextArea: resizableTextAreaRef.current,
		focus,
		blur: () => {
			getTextArea().blur();
		},
		nativeElement: holderRef.current?.nativeElement || getTextArea()
	}));
	(0, import_react.useEffect)(() => {
		setFocused((prev$1) => !disabled && prev$1);
	}, [disabled]);
	const [selection, setSelection] = import_react.useState(null);
	import_react.useEffect(() => {
		if (selection) getTextArea().setSelectionRange(...selection);
	}, [selection]);
	const countConfig = useCount(count, showCount);
	const mergedMax = countConfig.max ?? maxLength;
	const hasMaxLength = Number(mergedMax) > 0;
	const valueLength = countConfig.strategy(formatValue$1);
	const isOutOfRange = !!mergedMax && valueLength > mergedMax;
	const triggerChange = (e$2, currentValue) => {
		let cutValue = currentValue;
		if (!compositionRef.current && countConfig.exceedFormatter && countConfig.max && countConfig.strategy(currentValue) > countConfig.max) {
			cutValue = countConfig.exceedFormatter(currentValue, { max: countConfig.max });
			if (currentValue !== cutValue) setSelection([getTextArea().selectionStart || 0, getTextArea().selectionEnd || 0]);
		}
		setValue(cutValue);
		resolveOnChange(e$2.currentTarget, e$2, onChange, cutValue);
	};
	const onInternalCompositionStart = (e$2) => {
		compositionRef.current = true;
		onCompositionStart?.(e$2);
	};
	const onInternalCompositionEnd = (e$2) => {
		compositionRef.current = false;
		triggerChange(e$2, e$2.currentTarget.value);
		onCompositionEnd?.(e$2);
	};
	const onInternalChange = (e$2) => {
		triggerChange(e$2, e$2.target.value);
	};
	const handleKeyDown = (e$2) => {
		if (e$2.key === "Enter" && onPressEnter && !e$2.nativeEvent.isComposing) onPressEnter(e$2);
		onKeyDown$1?.(e$2);
	};
	const handleFocus = (e$2) => {
		setFocused(true);
		onFocus?.(e$2);
	};
	const handleBlur = (e$2) => {
		setFocused(false);
		onBlur?.(e$2);
	};
	const handleReset = (e$2) => {
		setValue("");
		focus();
		resolveOnChange(getTextArea(), e$2, onChange);
	};
	let suffixNode = suffix;
	let dataCount;
	if (countConfig.show) {
		if (countConfig.showFormatter) dataCount = countConfig.showFormatter({
			value: formatValue$1,
			count: valueLength,
			maxLength: mergedMax
		});
		else dataCount = `${valueLength}${hasMaxLength ? ` / ${mergedMax}` : ""}`;
		suffixNode = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, suffixNode, /* @__PURE__ */ import_react.createElement("span", {
			className: clsx(`${prefixCls}-data-count`, classNames?.count),
			style: styles?.count
		}, dataCount));
	}
	const handleResize = (size) => {
		onResize$1?.(size);
		if (getTextArea()?.style.height) setTextareaResized(true);
	};
	const isPureTextArea = !autoSize && !showCount && !allowClear;
	return /* @__PURE__ */ import_react.createElement(BaseInput_default, {
		ref: holderRef,
		value: formatValue$1,
		allowClear,
		handleReset,
		suffix: suffixNode,
		prefixCls,
		classNames: {
			...classNames,
			affixWrapper: clsx(classNames?.affixWrapper, {
				[`${prefixCls}-show-count`]: showCount,
				[`${prefixCls}-textarea-allow-clear`]: allowClear
			})
		},
		disabled,
		focused,
		className: clsx(className, isOutOfRange && `${prefixCls}-out-of-range`),
		style: {
			...style$1,
			...textareaResized && !isPureTextArea ? { height: "auto" } : {}
		},
		dataAttrs: { affixWrapper: { "data-count": typeof dataCount === "string" ? dataCount : void 0 } },
		hidden,
		readOnly,
		onClear
	}, /* @__PURE__ */ import_react.createElement(ResizableTextArea_default, _extends$31({}, rest, {
		autoSize,
		maxLength,
		onKeyDown: handleKeyDown,
		onChange: onInternalChange,
		onFocus: handleFocus,
		onBlur: handleBlur,
		onCompositionStart: onInternalCompositionStart,
		onCompositionEnd: onInternalCompositionEnd,
		className: clsx(classNames?.textarea),
		style: {
			resize: style$1?.resize,
			...styles?.textarea
		},
		disabled,
		prefixCls,
		onResize: handleResize,
		ref: resizableTextAreaRef,
		readOnly
	})));
});
var TextArea_default$1 = TextArea$1;

//#endregion
//#region node_modules/@rc-component/textarea/es/index.js
var es_default$13 = TextArea_default$1;

//#endregion
//#region node_modules/antd/es/input/style/textarea.js
var genTextAreaStyle = (token$1) => {
	const { componentCls, paddingLG } = token$1;
	const textareaPrefixCls = `${componentCls}-textarea`;
	return {
		[`textarea${componentCls}`]: {
			maxWidth: "100%",
			height: "auto",
			minHeight: token$1.controlHeight,
			lineHeight: token$1.lineHeight,
			verticalAlign: "bottom",
			transition: `all ${token$1.motionDurationSlow}`,
			resize: "vertical",
			[`&${componentCls}-mouse-active`]: { transition: `all ${token$1.motionDurationSlow}, height 0s, width 0s` }
		},
		[`${componentCls}-textarea-affix-wrapper-resize-dirty`]: { width: "auto" },
		[textareaPrefixCls]: {
			position: "relative",
			"&-show-count": { [`${componentCls}-data-count`]: {
				position: "absolute",
				bottom: token$1.calc(token$1.fontSize).mul(token$1.lineHeight).mul(-1).equal(),
				insetInlineEnd: 0,
				color: token$1.colorTextDescription,
				whiteSpace: "nowrap",
				pointerEvents: "none"
			} },
			[`
        &-allow-clear > ${componentCls},
        &-affix-wrapper${textareaPrefixCls}-has-feedback ${componentCls}
      `]: { paddingInlineEnd: paddingLG },
			[`&-affix-wrapper${componentCls}-affix-wrapper`]: {
				padding: 0,
				[`> textarea${componentCls}`]: {
					fontSize: "inherit",
					border: "none",
					outline: "none",
					background: "transparent",
					minHeight: token$1.calc(token$1.controlHeight).sub(token$1.calc(token$1.lineWidth).mul(2)).equal(),
					"&:focus": { boxShadow: "none !important" }
				},
				[`${componentCls}-suffix`]: {
					margin: 0,
					"> *:not(:last-child)": { marginInline: 0 },
					[`${componentCls}-clear-icon`]: {
						position: "absolute",
						insetInlineEnd: token$1.paddingInline,
						insetBlockStart: token$1.paddingXS
					},
					[`${textareaPrefixCls}-suffix`]: {
						position: "absolute",
						top: 0,
						insetInlineEnd: token$1.paddingInline,
						bottom: 0,
						zIndex: 1,
						display: "inline-flex",
						alignItems: "center",
						margin: "auto",
						pointerEvents: "none"
					}
				}
			},
			[`&-affix-wrapper${componentCls}-affix-wrapper-rtl`]: { [`${componentCls}-suffix`]: { [`${componentCls}-data-count`]: {
				direction: "ltr",
				insetInlineStart: 0
			} } },
			[`&-affix-wrapper${componentCls}-affix-wrapper-sm`]: { [`${componentCls}-suffix`]: { [`${componentCls}-clear-icon`]: { insetInlineEnd: token$1.paddingInlineSM } } }
		}
	};
};
var textarea_default = genStyleHooks(["Input", "TextArea"], (token$1) => {
	return genTextAreaStyle(merge(token$1, initInputToken(token$1)));
}, initComponentToken$1, { resetFont: false });

//#endregion
//#region node_modules/antd/es/input/TextArea.js
var TextArea = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	const { prefixCls: customizePrefixCls, bordered = true, size: customizeSize, disabled: customDisabled, status: customStatus, allowClear, classNames, rootClassName, className, style: style$1, styles, variant: customVariant, showCount, onMouseDown, onResize: onResize$1, ...rest } = props;
	{
		const { deprecated } = devUseWarning("TextArea");
		deprecated(!("bordered" in props), "bordered", "variant");
	}
	const { getPrefixCls, direction, allowClear: contextAllowClear, autoComplete: contextAutoComplete, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("textArea");
	const disabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = customDisabled ?? disabled;
	const { status: contextStatus, hasFeedback, feedbackIcon } = import_react.useContext(FormItemInputContext);
	const mergedStatus = getMergedStatus(contextStatus, customStatus);
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props });
	const innerRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => ({
		resizableTextArea: innerRef.current?.resizableTextArea,
		focus: (option) => {
			triggerFocus(innerRef.current?.resizableTextArea?.textArea, option);
		},
		blur: () => innerRef.current?.blur()
	}));
	const prefixCls = getPrefixCls("input", customizePrefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = useSharedStyle(prefixCls, rootClassName);
	textarea_default(prefixCls, rootCls);
	const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
	const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
	const [variant, enableVariantCls] = useVariants_default("textArea", customVariant, bordered);
	const mergedAllowClear = getAllowClear_default(allowClear ?? contextAllowClear);
	const [isMouseDown, setIsMouseDown] = import_react.useState(false);
	const [resizeDirty, setResizeDirty] = import_react.useState(false);
	const onInternalMouseDown = (e$2) => {
		setIsMouseDown(true);
		onMouseDown?.(e$2);
		const onMouseUp = () => {
			setIsMouseDown(false);
			document.removeEventListener("mouseup", onMouseUp);
		};
		document.addEventListener("mouseup", onMouseUp);
	};
	const onInternalResize = (size) => {
		onResize$1?.(size);
		if (isMouseDown && typeof getComputedStyle === "function") {
			const ele = innerRef.current?.nativeElement?.querySelector("textarea");
			if (ele && getComputedStyle(ele).resize === "both") setResizeDirty(true);
		}
	};
	return /* @__PURE__ */ import_react.createElement(es_default$13, {
		autoComplete: contextAutoComplete,
		...rest,
		style: {
			...mergedStyles.root,
			...contextStyle,
			...style$1
		},
		styles: mergedStyles,
		disabled: mergedDisabled,
		allowClear: mergedAllowClear,
		className: clsx(cssVarCls, rootCls, className, rootClassName, compactItemClassnames, contextClassName, mergedClassNames.root, { [`${prefixCls}-textarea-affix-wrapper-resize-dirty`]: resizeDirty }),
		classNames: {
			...mergedClassNames,
			textarea: clsx({
				[`${prefixCls}-sm`]: mergedSize === "small",
				[`${prefixCls}-lg`]: mergedSize === "large"
			}, hashId, mergedClassNames.textarea, isMouseDown && `${prefixCls}-mouse-active`),
			variant: clsx({ [`${prefixCls}-${variant}`]: enableVariantCls }, getStatusClassNames(prefixCls, mergedStatus)),
			affixWrapper: clsx(`${prefixCls}-textarea-affix-wrapper`, {
				[`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
				[`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
				[`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
				[`${prefixCls}-textarea-show-count`]: showCount || props.count?.show
			}, hashId)
		},
		prefixCls,
		suffix: hasFeedback && /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-textarea-suffix` }, feedbackIcon),
		showCount,
		ref: innerRef,
		onResize: onInternalResize,
		onMouseDown: onInternalMouseDown
	});
});
var TextArea_default = TextArea;

//#endregion
//#region node_modules/antd/es/input/index.js
var Input = Input_default;
Input.Group = Group_default;
Input.Search = Search_default;
Input.TextArea = TextArea_default;
Input.Password = Password_default;
Input.OTP = OTP_default;
var input_default = Input;

//#endregion
//#region node_modules/antd/es/layout/hooks/useHasSider.js
function useHasSider(siders, children, hasSider) {
	if (typeof hasSider === "boolean") return hasSider;
	if (siders.length) return true;
	return toArray(children).some((node$1) => node$1.type === Sider_default);
}

//#endregion
//#region node_modules/antd/es/layout/layout.js
var generator = ({ suffixCls, tagName, displayName }) => {
	return (Component$2) => {
		const Adapter = /* @__PURE__ */ import_react.forwardRef((props, ref) => /* @__PURE__ */ import_react.createElement(Component$2, {
			ref,
			suffixCls,
			tagName,
			...props
		}));
		Adapter.displayName = displayName;
		return Adapter;
	};
};
var Basic = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, suffixCls, className, tagName: TagName, ...others } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("layout", customizePrefixCls);
	const [hashId] = style_default$24(prefixCls);
	const prefixWithSuffixCls = suffixCls ? `${prefixCls}-${suffixCls}` : prefixCls;
	return /* @__PURE__ */ import_react.createElement(TagName, {
		className: clsx(customizePrefixCls || prefixWithSuffixCls, className, hashId),
		ref,
		...others
	});
});
var BasicLayout = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { direction } = import_react.useContext(ConfigContext);
	const [siders, setSiders] = import_react.useState([]);
	const { prefixCls: customizePrefixCls, className, rootClassName, children, hasSider, tagName: Tag$1, style: style$1, ...others } = props;
	const passedProps = omit(others, ["suffixCls"]);
	const { getPrefixCls, className: contextClassName, style: contextStyle } = useComponentConfig("layout");
	const prefixCls = getPrefixCls("layout", customizePrefixCls);
	const mergedHasSider = useHasSider(siders, children, hasSider);
	const [hashId, cssVarCls] = style_default$24(prefixCls);
	const classString = clsx(prefixCls, {
		[`${prefixCls}-has-sider`]: mergedHasSider,
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, contextClassName, className, rootClassName, hashId, cssVarCls);
	const contextValue = import_react.useMemo(() => ({ siderHook: {
		addSider: (id) => {
			setSiders((prev$1) => [].concat(_toConsumableArray(prev$1), [id]));
		},
		removeSider: (id) => {
			setSiders((prev$1) => prev$1.filter((currentId) => currentId !== id));
		}
	} }), []);
	return /* @__PURE__ */ import_react.createElement(LayoutContext.Provider, { value: contextValue }, /* @__PURE__ */ import_react.createElement(Tag$1, {
		ref,
		className: classString,
		style: {
			...contextStyle,
			...style$1
		},
		...passedProps
	}, children));
});
var Layout$1 = generator({
	tagName: "div",
	displayName: "Layout"
})(BasicLayout);
var Header$1 = generator({
	suffixCls: "header",
	tagName: "header",
	displayName: "Header"
})(Basic);
var Footer$2 = generator({
	suffixCls: "footer",
	tagName: "footer",
	displayName: "Footer"
})(Basic);
var Content = generator({
	suffixCls: "content",
	tagName: "main",
	displayName: "Content"
})(Basic);
var layout_default$1 = Layout$1;

//#endregion
//#region node_modules/antd/es/layout/index.js
var Layout = layout_default$1;
Layout.Header = Header$1;
Layout.Footer = Footer$2;
Layout.Content = Content;
Layout.Sider = Sider_default;
Layout._InternalSiderContext = SiderContext;
var layout_default = Layout;

//#endregion
//#region node_modules/@rc-component/pagination/es/locale/zh_CN.js
var locale = {
	items_per_page: "/",
	jump_to: "",
	jump_to_confirm: "",
	page: "",
	prev_page: "",
	next_page: "",
	prev_5: " 5 ",
	next_5: " 5 ",
	prev_3: " 3 ",
	next_3: " 3 ",
	page_size: ""
};
var zh_CN_default = locale;

//#endregion
//#region node_modules/@rc-component/pagination/es/Options.js
var defaultPageSizeOptions = [
	10,
	20,
	50,
	100
];
var Options = (props) => {
	const { pageSizeOptions = defaultPageSizeOptions, locale: locale$5, changeSize, pageSize, goButton, quickGo, rootPrefixCls, disabled, buildOptionText, showSizeChanger, sizeChangerRender } = props;
	const [goInputText, setGoInputText] = import_react.useState("");
	const getValidValue = import_react.useMemo(() => {
		return !goInputText || Number.isNaN(goInputText) ? void 0 : Number(goInputText);
	}, [goInputText]);
	const mergeBuildOptionText = typeof buildOptionText === "function" ? buildOptionText : (value) => `${value} ${locale$5.items_per_page}`;
	const handleChange = (e$2) => {
		const value = e$2.target.value;
		if (/^\d*$/.test(value)) setGoInputText(value);
	};
	const handleBlur = (e$2) => {
		if (goButton || goInputText === "") return;
		setGoInputText("");
		if (e$2.relatedTarget && (e$2.relatedTarget.className.includes(`${rootPrefixCls}-item-link`) || e$2.relatedTarget.className.includes(`${rootPrefixCls}-item`))) return;
		quickGo?.(getValidValue);
	};
	const go = (e$2) => {
		if (goInputText === "") return;
		if (e$2.keyCode === KeyCode_default.ENTER || e$2.type === "click") {
			setGoInputText("");
			quickGo?.(getValidValue);
		}
	};
	const getPageSizeOptions = () => {
		if (pageSizeOptions.some((option) => option.toString() === pageSize.toString())) return pageSizeOptions;
		return pageSizeOptions.concat([pageSize]).sort((a, b) => {
			return (Number.isNaN(Number(a)) ? 0 : Number(a)) - (Number.isNaN(Number(b)) ? 0 : Number(b));
		});
	};
	const prefixCls = `${rootPrefixCls}-options`;
	if (!showSizeChanger && !quickGo) return null;
	let changeSelect = null;
	let goInput = null;
	let gotoButton = null;
	if (showSizeChanger && sizeChangerRender) changeSelect = sizeChangerRender({
		disabled,
		size: pageSize,
		onSizeChange: (nextValue) => {
			changeSize?.(Number(nextValue));
		},
		"aria-label": locale$5.page_size,
		className: `${prefixCls}-size-changer`,
		options: getPageSizeOptions().map((opt) => ({
			label: mergeBuildOptionText(opt),
			value: opt
		}))
	});
	if (quickGo) {
		if (goButton) gotoButton = typeof goButton === "boolean" ? /* @__PURE__ */ import_react.createElement("button", {
			type: "button",
			onClick: go,
			onKeyUp: go,
			disabled,
			className: `${prefixCls}-quick-jumper-button`
		}, locale$5.jump_to_confirm) : /* @__PURE__ */ import_react.createElement("span", {
			onClick: go,
			onKeyUp: go
		}, goButton);
		goInput = /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-quick-jumper` }, locale$5.jump_to, /* @__PURE__ */ import_react.createElement("input", {
			disabled,
			type: "text",
			value: goInputText,
			onChange: handleChange,
			onKeyUp: go,
			onBlur: handleBlur,
			"aria-label": locale$5.page
		}), locale$5.page, gotoButton);
	}
	return /* @__PURE__ */ import_react.createElement("li", { className: prefixCls }, changeSelect, goInput);
};
Options.displayName = "Options";
var Options_default = Options;

//#endregion
//#region node_modules/@rc-component/pagination/es/Pager.js
var Pager = (props) => {
	const { rootPrefixCls, page, active, className, style: style$1, showTitle, onClick, onKeyPress, itemRender } = props;
	const prefixCls = `${rootPrefixCls}-item`;
	const cls = clsx(prefixCls, `${prefixCls}-${page}`, {
		[`${prefixCls}-active`]: active,
		[`${prefixCls}-disabled`]: !page
	}, className);
	const handleClick = () => {
		onClick(page);
	};
	const handleKeyPress = (e$2) => {
		onKeyPress(e$2, onClick, page);
	};
	const pager = itemRender(page, "page", /* @__PURE__ */ import_react.createElement("a", { rel: "nofollow" }, page));
	return pager ? /* @__PURE__ */ import_react.createElement("li", {
		title: showTitle ? String(page) : null,
		className: cls,
		style: style$1,
		onClick: handleClick,
		onKeyDown: handleKeyPress,
		tabIndex: 0
	}, pager) : null;
};
Pager.displayName = "Pager";
var Pager_default = Pager;

//#endregion
//#region node_modules/@rc-component/pagination/es/Pagination.js
function _extends$30() {
	_extends$30 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$30.apply(this, arguments);
}
var defaultItemRender = (_, __, element) => element;
function noop$1() {}
function isInteger(v) {
	const value = Number(v);
	return typeof value === "number" && !Number.isNaN(value) && isFinite(value) && Math.floor(value) === value;
}
function calculatePage(p, pageSize, total) {
	const _pageSize = typeof p === "undefined" ? pageSize : p;
	return Math.floor((total - 1) / _pageSize) + 1;
}
var Pagination$1 = (props) => {
	const { prefixCls = "rc-pagination", selectPrefixCls = "rc-select", className, classNames: paginationClassNames, styles, current: currentProp, defaultCurrent = 1, total = 0, pageSize: pageSizeProp, defaultPageSize = 10, onChange = noop$1, hideOnSinglePage, align, showPrevNextJumpers = true, showQuickJumper, showLessItems, showTitle = true, onShowSizeChange = noop$1, locale: locale$5 = zh_CN_default, style: style$1, totalBoundaryShowSizeChanger = 50, disabled, simple, showTotal, showSizeChanger = total > totalBoundaryShowSizeChanger, sizeChangerRender, pageSizeOptions, itemRender = defaultItemRender, jumpPrevIcon, jumpNextIcon, prevIcon, nextIcon } = props;
	const paginationRef = import_react.useRef(null);
	const [pageSize, setPageSize] = useControlledState(defaultPageSize, pageSizeProp);
	const [internalCurrent, setCurrent] = useControlledState(defaultCurrent, currentProp);
	const current = Math.max(1, Math.min(internalCurrent, calculatePage(void 0, pageSize, total)));
	const [internalInputVal, setInternalInputVal] = import_react.useState(current);
	(0, import_react.useEffect)(() => {
		setInternalInputVal(current);
	}, [current]);
	const hasOnChange = onChange !== noop$1;
	warning_default$1("current" in props ? hasOnChange : true, "You provided a `current` prop to a Pagination component without an `onChange` handler. This will render a read-only component.");
	const jumpPrevPage = Math.max(1, current - (showLessItems ? 3 : 5));
	const jumpNextPage = Math.min(calculatePage(void 0, pageSize, total), current + (showLessItems ? 3 : 5));
	function getItemIcon(icon, label) {
		let iconNode = icon || /* @__PURE__ */ import_react.createElement("button", {
			type: "button",
			"aria-label": label,
			className: `${prefixCls}-item-link`
		});
		if (typeof icon === "function") iconNode = /* @__PURE__ */ import_react.createElement(icon, props);
		return iconNode;
	}
	function getValidValue(e$2) {
		const inputValue = e$2.target.value;
		const allPages$1 = calculatePage(void 0, pageSize, total);
		let value;
		if (inputValue === "") value = inputValue;
		else if (Number.isNaN(Number(inputValue))) value = internalInputVal;
		else if (inputValue >= allPages$1) value = allPages$1;
		else value = Number(inputValue);
		return value;
	}
	function isValid(page) {
		return isInteger(page) && page !== current && isInteger(total) && total > 0;
	}
	const shouldDisplayQuickJumper = total > pageSize ? showQuickJumper : false;
	/**
	* prevent "up arrow" key reseting cursor position within textbox
	* @see https://stackoverflow.com/a/1081114
	*/
	function handleKeyDown(event) {
		if (event.keyCode === KeyCode_default.UP || event.keyCode === KeyCode_default.DOWN) event.preventDefault();
	}
	function handleKeyUp(event) {
		const value = getValidValue(event);
		if (value !== internalInputVal) setInternalInputVal(value);
		switch (event.keyCode) {
			case KeyCode_default.ENTER:
				handleChange(value);
				break;
			case KeyCode_default.UP:
				handleChange(value - 1);
				break;
			case KeyCode_default.DOWN:
				handleChange(value + 1);
				break;
			default: break;
		}
	}
	function handleBlur(event) {
		handleChange(getValidValue(event));
	}
	function changePageSize(size) {
		const newCurrent = calculatePage(size, pageSize, total);
		const nextCurrent = current > newCurrent && newCurrent !== 0 ? newCurrent : current;
		setPageSize(size);
		setInternalInputVal(nextCurrent);
		onShowSizeChange?.(current, size);
		setCurrent(nextCurrent);
		onChange?.(nextCurrent, size);
	}
	function handleChange(page) {
		if (isValid(page) && !disabled) {
			const currentPage = calculatePage(void 0, pageSize, total);
			let newPage = page;
			if (page > currentPage) newPage = currentPage;
			else if (page < 1) newPage = 1;
			if (newPage !== internalInputVal) setInternalInputVal(newPage);
			setCurrent(newPage);
			onChange?.(newPage, pageSize);
			return newPage;
		}
		return current;
	}
	const hasPrev = current > 1;
	const hasNext = current < calculatePage(void 0, pageSize, total);
	function prevHandle() {
		if (hasPrev) handleChange(current - 1);
	}
	function nextHandle() {
		if (hasNext) handleChange(current + 1);
	}
	function jumpPrevHandle() {
		handleChange(jumpPrevPage);
	}
	function jumpNextHandle() {
		handleChange(jumpNextPage);
	}
	function runIfEnter(event, callback, ...restParams) {
		if (event.key === "Enter" || event.charCode === KeyCode_default.ENTER || event.keyCode === KeyCode_default.ENTER) callback(...restParams);
	}
	function runIfEnterPrev(event) {
		runIfEnter(event, prevHandle);
	}
	function runIfEnterNext(event) {
		runIfEnter(event, nextHandle);
	}
	function runIfEnterJumpPrev(event) {
		runIfEnter(event, jumpPrevHandle);
	}
	function runIfEnterJumpNext(event) {
		runIfEnter(event, jumpNextHandle);
	}
	function renderPrev(prevPage$1) {
		const prevButton = itemRender(prevPage$1, "prev", getItemIcon(prevIcon, "prev page"));
		return /* @__PURE__ */ import_react.isValidElement(prevButton) ? /* @__PURE__ */ import_react.cloneElement(prevButton, { disabled: !hasPrev }) : prevButton;
	}
	function renderNext(nextPage$1) {
		const nextButton = itemRender(nextPage$1, "next", getItemIcon(nextIcon, "next page"));
		return /* @__PURE__ */ import_react.isValidElement(nextButton) ? /* @__PURE__ */ import_react.cloneElement(nextButton, { disabled: !hasNext }) : nextButton;
	}
	function handleGoTO(event) {
		if (event.type === "click" || event.keyCode === KeyCode_default.ENTER) handleChange(internalInputVal);
	}
	let jumpPrev = null;
	const dataOrAriaAttributeProps = pickAttrs(props, {
		aria: true,
		data: true
	});
	const totalText = showTotal && /* @__PURE__ */ import_react.createElement("li", { className: `${prefixCls}-total-text` }, showTotal(total, [total === 0 ? 0 : (current - 1) * pageSize + 1, current * pageSize > total ? total : current * pageSize]));
	let jumpNext = null;
	const allPages = calculatePage(void 0, pageSize, total);
	if (hideOnSinglePage && total <= pageSize) return null;
	const pagerList = [];
	const pagerProps = {
		rootPrefixCls: prefixCls,
		onClick: handleChange,
		onKeyPress: runIfEnter,
		showTitle,
		itemRender,
		page: -1,
		className: paginationClassNames?.item,
		style: styles?.item
	};
	const prevPage = current - 1 > 0 ? current - 1 : 0;
	const nextPage = current + 1 < allPages ? current + 1 : allPages;
	const goButton = showQuickJumper && showQuickJumper.goButton;
	const isReadOnly = typeof simple === "object" ? simple.readOnly : !simple;
	let gotoButton = goButton;
	let simplePager = null;
	if (simple) {
		if (goButton) {
			if (typeof goButton === "boolean") gotoButton = /* @__PURE__ */ import_react.createElement("button", {
				type: "button",
				onClick: handleGoTO,
				onKeyUp: handleGoTO
			}, locale$5.jump_to_confirm);
			else gotoButton = /* @__PURE__ */ import_react.createElement("span", {
				onClick: handleGoTO,
				onKeyUp: handleGoTO
			}, goButton);
			gotoButton = /* @__PURE__ */ import_react.createElement("li", {
				title: showTitle ? `${locale$5.jump_to}${current}/${allPages}` : null,
				className: `${prefixCls}-simple-pager`
			}, gotoButton);
		}
		simplePager = /* @__PURE__ */ import_react.createElement("li", {
			title: showTitle ? `${current}/${allPages}` : null,
			className: clsx(`${prefixCls}-simple-pager`, paginationClassNames?.item),
			style: styles?.item
		}, isReadOnly ? internalInputVal : /* @__PURE__ */ import_react.createElement("input", {
			type: "text",
			"aria-label": locale$5.jump_to,
			value: internalInputVal,
			disabled,
			onKeyDown: handleKeyDown,
			onKeyUp: handleKeyUp,
			onChange: handleKeyUp,
			onBlur: handleBlur,
			size: 3
		}), /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-slash` }, "/"), allPages);
	}
	const pageBufferSize = showLessItems ? 1 : 2;
	if (allPages <= 3 + pageBufferSize * 2) {
		if (!allPages) pagerList.push(/* @__PURE__ */ import_react.createElement(Pager_default, _extends$30({}, pagerProps, {
			key: "noPager",
			page: 1,
			className: `${prefixCls}-item-disabled`
		})));
		for (let i = 1; i <= allPages; i += 1) pagerList.push(/* @__PURE__ */ import_react.createElement(Pager_default, _extends$30({}, pagerProps, {
			key: i,
			page: i,
			active: current === i
		})));
	} else {
		const prevItemTitle = showLessItems ? locale$5.prev_3 : locale$5.prev_5;
		const nextItemTitle = showLessItems ? locale$5.next_3 : locale$5.next_5;
		const jumpPrevContent = itemRender(jumpPrevPage, "jump-prev", getItemIcon(jumpPrevIcon, "prev page"));
		const jumpNextContent = itemRender(jumpNextPage, "jump-next", getItemIcon(jumpNextIcon, "next page"));
		if (showPrevNextJumpers) {
			jumpPrev = jumpPrevContent ? /* @__PURE__ */ import_react.createElement("li", {
				title: showTitle ? prevItemTitle : null,
				key: "prev",
				onClick: jumpPrevHandle,
				tabIndex: 0,
				onKeyDown: runIfEnterJumpPrev,
				className: clsx(`${prefixCls}-jump-prev`, { [`${prefixCls}-jump-prev-custom-icon`]: !!jumpPrevIcon })
			}, jumpPrevContent) : null;
			jumpNext = jumpNextContent ? /* @__PURE__ */ import_react.createElement("li", {
				title: showTitle ? nextItemTitle : null,
				key: "next",
				onClick: jumpNextHandle,
				tabIndex: 0,
				onKeyDown: runIfEnterJumpNext,
				className: clsx(`${prefixCls}-jump-next`, { [`${prefixCls}-jump-next-custom-icon`]: !!jumpNextIcon })
			}, jumpNextContent) : null;
		}
		let left = Math.max(1, current - pageBufferSize);
		let right = Math.min(current + pageBufferSize, allPages);
		if (current - 1 <= pageBufferSize) right = 1 + pageBufferSize * 2;
		if (allPages - current <= pageBufferSize) left = allPages - pageBufferSize * 2;
		for (let i = left; i <= right; i += 1) pagerList.push(/* @__PURE__ */ import_react.createElement(Pager_default, _extends$30({}, pagerProps, {
			key: i,
			page: i,
			active: current === i
		})));
		if (current - 1 >= pageBufferSize * 2 && current !== 3) {
			pagerList[0] = /* @__PURE__ */ import_react.cloneElement(pagerList[0], { className: clsx(`${prefixCls}-item-after-jump-prev`, pagerList[0].props.className) });
			pagerList.unshift(jumpPrev);
		}
		if (allPages - current >= pageBufferSize * 2 && current !== allPages - 2) {
			const lastOne = pagerList[pagerList.length - 1];
			pagerList[pagerList.length - 1] = /* @__PURE__ */ import_react.cloneElement(lastOne, { className: clsx(`${prefixCls}-item-before-jump-next`, lastOne.props.className) });
			pagerList.push(jumpNext);
		}
		if (left !== 1) pagerList.unshift(/* @__PURE__ */ import_react.createElement(Pager_default, _extends$30({}, pagerProps, {
			key: 1,
			page: 1
		})));
		if (right !== allPages) pagerList.push(/* @__PURE__ */ import_react.createElement(Pager_default, _extends$30({}, pagerProps, {
			key: allPages,
			page: allPages
		})));
	}
	let prev$1 = renderPrev(prevPage);
	if (prev$1) {
		const prevDisabled = !hasPrev || !allPages;
		prev$1 = /* @__PURE__ */ import_react.createElement("li", {
			title: showTitle ? locale$5.prev_page : null,
			onClick: prevHandle,
			tabIndex: prevDisabled ? null : 0,
			onKeyDown: runIfEnterPrev,
			className: clsx(`${prefixCls}-prev`, paginationClassNames?.item, { [`${prefixCls}-disabled`]: prevDisabled }),
			style: styles?.item,
			"aria-disabled": prevDisabled
		}, prev$1);
	}
	let next$1 = renderNext(nextPage);
	if (next$1) {
		let nextDisabled, nextTabIndex;
		if (simple) {
			nextDisabled = !hasNext;
			nextTabIndex = hasPrev ? 0 : null;
		} else {
			nextDisabled = !hasNext || !allPages;
			nextTabIndex = nextDisabled ? null : 0;
		}
		next$1 = /* @__PURE__ */ import_react.createElement("li", {
			title: showTitle ? locale$5.next_page : null,
			onClick: nextHandle,
			tabIndex: nextTabIndex,
			onKeyDown: runIfEnterNext,
			className: clsx(`${prefixCls}-next`, paginationClassNames?.item, { [`${prefixCls}-disabled`]: nextDisabled }),
			style: styles?.item,
			"aria-disabled": nextDisabled
		}, next$1);
	}
	const cls = clsx(prefixCls, className, {
		[`${prefixCls}-start`]: align === "start",
		[`${prefixCls}-center`]: align === "center",
		[`${prefixCls}-end`]: align === "end",
		[`${prefixCls}-simple`]: simple,
		[`${prefixCls}-disabled`]: disabled
	});
	return /* @__PURE__ */ import_react.createElement("ul", _extends$30({
		className: cls,
		style: style$1,
		ref: paginationRef
	}, dataOrAriaAttributeProps), totalText, prev$1, simple ? simplePager : pagerList, next$1, /* @__PURE__ */ import_react.createElement(Options_default, {
		locale: locale$5,
		rootPrefixCls: prefixCls,
		disabled,
		selectPrefixCls,
		changeSize: changePageSize,
		pageSize,
		pageSizeOptions,
		quickGo: shouldDisplayQuickJumper ? handleChange : null,
		goButton: gotoButton,
		showSizeChanger,
		sizeChangerRender
	}));
};
Pagination$1.displayName = "Pagination";
var Pagination_default$1 = Pagination$1;

//#endregion
//#region node_modules/antd/es/pagination/style/index.js
var genPaginationDisabledStyle = (token$1) => {
	const { componentCls } = token$1;
	return {
		[`${componentCls}-disabled`]: {
			"&, &:hover": {
				cursor: "not-allowed",
				[`${componentCls}-item-link`]: {
					color: token$1.colorTextDisabled,
					cursor: "not-allowed"
				}
			},
			"&:focus-visible": {
				cursor: "not-allowed",
				[`${componentCls}-item-link`]: {
					color: token$1.colorTextDisabled,
					cursor: "not-allowed"
				}
			}
		},
		[`&${componentCls}-disabled`]: {
			cursor: "not-allowed",
			[`${componentCls}-item`]: {
				cursor: "not-allowed",
				backgroundColor: "transparent",
				"&:hover, &:active": { backgroundColor: "transparent" },
				a: {
					color: token$1.colorTextDisabled,
					backgroundColor: "transparent",
					border: "none",
					cursor: "not-allowed"
				},
				"&-active": {
					borderColor: token$1.colorBorder,
					backgroundColor: token$1.itemActiveBgDisabled,
					"&:hover, &:active": { backgroundColor: token$1.itemActiveBgDisabled },
					a: { color: token$1.itemActiveColorDisabled }
				}
			},
			[`${componentCls}-item-link`]: {
				color: token$1.colorTextDisabled,
				cursor: "not-allowed",
				"&:hover, &:active": { backgroundColor: "transparent" },
				[`${componentCls}-simple&`]: {
					backgroundColor: "transparent",
					"&:hover, &:active": { backgroundColor: "transparent" }
				}
			},
			[`${componentCls}-simple-pager`]: { color: token$1.colorTextDisabled },
			[`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
				[`${componentCls}-item-link-icon`]: { opacity: 0 },
				[`${componentCls}-item-ellipsis`]: { opacity: 1 }
			}
		}
	};
};
var genPaginationMiniStyle = (token$1) => {
	const { componentCls } = token$1;
	return {
		[`&${componentCls}-mini ${componentCls}-total-text, &${componentCls}-mini ${componentCls}-simple-pager`]: {
			height: token$1.itemSizeSM,
			lineHeight: unit(token$1.itemSizeSM)
		},
		[`&${componentCls}-mini ${componentCls}-item`]: {
			minWidth: token$1.itemSizeSM,
			height: token$1.itemSizeSM,
			margin: 0,
			lineHeight: unit(token$1.calc(token$1.itemSizeSM).sub(2).equal())
		},
		[`&${componentCls}-mini ${componentCls}-prev, &${componentCls}-mini ${componentCls}-next`]: {
			minWidth: token$1.itemSizeSM,
			height: token$1.itemSizeSM,
			margin: 0,
			lineHeight: unit(token$1.itemSizeSM)
		},
		[`&${componentCls}-mini:not(${componentCls}-disabled)`]: { [`${componentCls}-prev, ${componentCls}-next`]: {
			[`&:hover ${componentCls}-item-link`]: { backgroundColor: token$1.colorBgTextHover },
			[`&:active ${componentCls}-item-link`]: { backgroundColor: token$1.colorBgTextActive },
			[`&${componentCls}-disabled:hover ${componentCls}-item-link`]: { backgroundColor: "transparent" }
		} },
		[`
    &${componentCls}-mini ${componentCls}-prev ${componentCls}-item-link,
    &${componentCls}-mini ${componentCls}-next ${componentCls}-item-link
    `]: {
			backgroundColor: "transparent",
			borderColor: "transparent",
			"&::after": {
				height: token$1.itemSizeSM,
				lineHeight: unit(token$1.itemSizeSM)
			}
		},
		[`&${componentCls}-mini ${componentCls}-jump-prev, &${componentCls}-mini ${componentCls}-jump-next`]: {
			height: token$1.itemSizeSM,
			marginInlineEnd: 0,
			lineHeight: unit(token$1.itemSizeSM)
		},
		[`&${componentCls}-mini ${componentCls}-options`]: {
			marginInlineStart: token$1.paginationMiniOptionsMarginInlineStart,
			"&-size-changer": { top: token$1.miniOptionsSizeChangerTop },
			"&-quick-jumper": {
				height: token$1.itemSizeSM,
				lineHeight: unit(token$1.itemSizeSM),
				input: {
					...genInputSmallStyle(token$1),
					width: token$1.paginationMiniQuickJumperInputWidth,
					height: token$1.controlHeightSM
				}
			}
		}
	};
};
var genPaginationSimpleStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`&${componentCls}-simple`]: {
		[`${componentCls}-prev, ${componentCls}-next`]: {
			height: token$1.itemSize,
			lineHeight: unit(token$1.itemSize),
			verticalAlign: "top",
			[`${componentCls}-item-link`]: {
				height: token$1.itemSize,
				backgroundColor: "transparent",
				border: 0,
				"&:hover": { backgroundColor: token$1.colorBgTextHover },
				"&:active": { backgroundColor: token$1.colorBgTextActive },
				"&::after": {
					height: token$1.itemSize,
					lineHeight: unit(token$1.itemSize)
				}
			}
		},
		[`${componentCls}-simple-pager`]: {
			display: "inline-flex",
			alignItems: "center",
			height: token$1.itemSize,
			marginInlineEnd: token$1.marginXS,
			input: {
				boxSizing: "border-box",
				height: "100%",
				width: token$1.quickJumperInputWidth,
				padding: `0 ${unit(token$1.paginationItemPaddingInline)}`,
				textAlign: "center",
				backgroundColor: token$1.itemInputBg,
				border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`,
				borderRadius: token$1.borderRadius,
				outline: "none",
				transition: `border-color ${token$1.motionDurationMid}`,
				color: "inherit",
				"&:hover": { borderColor: token$1.colorPrimary },
				"&:focus": {
					borderColor: token$1.colorPrimaryHover,
					boxShadow: `${unit(token$1.inputOutlineOffset)} 0 ${unit(token$1.controlOutlineWidth)} ${token$1.controlOutline}`
				},
				"&[disabled]": {
					color: token$1.colorTextDisabled,
					backgroundColor: token$1.colorBgContainerDisabled,
					borderColor: token$1.colorBorder,
					cursor: "not-allowed"
				}
			}
		},
		[`&${componentCls}-disabled`]: { [`${componentCls}-prev, ${componentCls}-next`]: { [`${componentCls}-item-link`]: { "&:hover, &:active": { backgroundColor: "transparent" } } } },
		[`&${componentCls}-mini`]: {
			[`${componentCls}-prev, ${componentCls}-next`]: {
				height: token$1.itemSizeSM,
				lineHeight: unit(token$1.itemSizeSM),
				[`${componentCls}-item-link`]: {
					height: token$1.itemSizeSM,
					"&::after": {
						height: token$1.itemSizeSM,
						lineHeight: unit(token$1.itemSizeSM)
					}
				}
			},
			[`${componentCls}-simple-pager`]: {
				height: token$1.itemSizeSM,
				input: { width: token$1.paginationMiniQuickJumperInputWidth }
			}
		}
	} };
};
var genPaginationJumpStyle = (token$1) => {
	const { componentCls } = token$1;
	return {
		[`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
			outline: 0,
			[`${componentCls}-item-container`]: {
				position: "relative",
				[`${componentCls}-item-link-icon`]: {
					color: token$1.colorPrimary,
					fontSize: token$1.fontSizeSM,
					opacity: 0,
					transition: `all ${token$1.motionDurationMid}`,
					"&-svg": {
						top: 0,
						insetInlineEnd: 0,
						bottom: 0,
						insetInlineStart: 0,
						margin: "auto"
					}
				},
				[`${componentCls}-item-ellipsis`]: {
					position: "absolute",
					top: 0,
					insetInlineEnd: 0,
					bottom: 0,
					insetInlineStart: 0,
					display: "block",
					margin: "auto",
					color: token$1.colorTextDisabled,
					letterSpacing: token$1.paginationEllipsisLetterSpacing,
					textAlign: "center",
					textIndent: token$1.paginationEllipsisTextIndent,
					opacity: 1,
					transition: `all ${token$1.motionDurationMid}`
				}
			},
			"&:hover": {
				[`${componentCls}-item-link-icon`]: { opacity: 1 },
				[`${componentCls}-item-ellipsis`]: { opacity: 0 }
			}
		},
		[`
    ${componentCls}-prev,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: { marginInlineEnd: token$1.marginXS },
		[`
    ${componentCls}-prev,
    ${componentCls}-next,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
			display: "inline-block",
			minWidth: token$1.itemSize,
			height: token$1.itemSize,
			color: token$1.colorText,
			fontFamily: token$1.fontFamily,
			lineHeight: unit(token$1.itemSize),
			textAlign: "center",
			verticalAlign: "middle",
			listStyle: "none",
			borderRadius: token$1.borderRadius,
			cursor: "pointer",
			transition: `all ${token$1.motionDurationMid}`
		},
		[`${componentCls}-prev, ${componentCls}-next`]: {
			outline: 0,
			button: {
				color: token$1.colorText,
				cursor: "pointer",
				userSelect: "none"
			},
			[`${componentCls}-item-link`]: {
				display: "block",
				width: "100%",
				height: "100%",
				padding: 0,
				fontSize: token$1.fontSizeSM,
				textAlign: "center",
				backgroundColor: "transparent",
				border: `${unit(token$1.lineWidth)} ${token$1.lineType} transparent`,
				borderRadius: token$1.borderRadius,
				outline: "none",
				transition: `all ${token$1.motionDurationMid}`
			},
			[`&:hover ${componentCls}-item-link`]: { backgroundColor: token$1.colorBgTextHover },
			[`&:active ${componentCls}-item-link`]: { backgroundColor: token$1.colorBgTextActive },
			[`&${componentCls}-disabled:hover`]: { [`${componentCls}-item-link`]: { backgroundColor: "transparent" } }
		},
		[`${componentCls}-slash`]: {
			marginInlineEnd: token$1.paginationSlashMarginInlineEnd,
			marginInlineStart: token$1.paginationSlashMarginInlineStart
		},
		[`${componentCls}-options`]: {
			display: "inline-block",
			marginInlineStart: token$1.margin,
			verticalAlign: "middle",
			"&-size-changer": { width: "auto" },
			"&-quick-jumper": {
				display: "inline-block",
				height: token$1.controlHeight,
				marginInlineStart: token$1.marginXS,
				lineHeight: unit(token$1.controlHeight),
				verticalAlign: "top",
				input: {
					...genBasicInputStyle(token$1),
					...genBaseOutlinedStyle(token$1, {
						borderColor: token$1.colorBorder,
						hoverBorderColor: token$1.colorPrimaryHover,
						activeBorderColor: token$1.colorPrimary,
						activeShadow: token$1.activeShadow
					}),
					"&[disabled]": { ...genDisabledStyle(token$1) },
					width: token$1.quickJumperInputWidth,
					height: token$1.controlHeight,
					boxSizing: "border-box",
					margin: 0,
					marginInlineStart: token$1.marginXS,
					marginInlineEnd: token$1.marginXS
				}
			}
		}
	};
};
var genPaginationItemStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-item`]: {
		display: "inline-block",
		minWidth: token$1.itemSize,
		height: token$1.itemSize,
		marginInlineEnd: token$1.marginXS,
		fontFamily: token$1.fontFamily,
		lineHeight: unit(token$1.calc(token$1.itemSize).sub(2).equal()),
		textAlign: "center",
		verticalAlign: "middle",
		listStyle: "none",
		backgroundColor: token$1.itemBg,
		border: `${unit(token$1.lineWidth)} ${token$1.lineType} transparent`,
		borderRadius: token$1.borderRadius,
		outline: 0,
		cursor: "pointer",
		userSelect: "none",
		a: {
			display: "block",
			padding: `0 ${unit(token$1.paginationItemPaddingInline)}`,
			color: token$1.colorText,
			"&:hover": { textDecoration: "none" }
		},
		[`&:not(${componentCls}-item-active)`]: {
			"&:hover": {
				transition: `all ${token$1.motionDurationMid}`,
				backgroundColor: token$1.colorBgTextHover
			},
			"&:active": { backgroundColor: token$1.colorBgTextActive }
		},
		"&-active": {
			fontWeight: token$1.fontWeightStrong,
			backgroundColor: token$1.itemActiveBg,
			borderColor: token$1.colorPrimary,
			a: { color: token$1.itemActiveColor },
			"&:hover": { borderColor: token$1.colorPrimaryHover },
			"&:hover a": { color: token$1.itemActiveColorHover }
		}
	} };
};
var genPaginationStyle$1 = (token$1) => {
	const { componentCls } = token$1;
	return {
		[componentCls]: {
			...resetComponent(token$1),
			display: "flex",
			"&-start": { justifyContent: "start" },
			"&-center": { justifyContent: "center" },
			"&-end": { justifyContent: "end" },
			"ul, ol": {
				margin: 0,
				padding: 0,
				listStyle: "none"
			},
			"&::after": {
				display: "block",
				clear: "both",
				height: 0,
				overflow: "hidden",
				visibility: "hidden",
				content: "\"\""
			},
			[`${componentCls}-total-text`]: {
				display: "inline-block",
				height: token$1.itemSize,
				marginInlineEnd: token$1.marginXS,
				lineHeight: unit(token$1.calc(token$1.itemSize).sub(2).equal()),
				verticalAlign: "middle"
			},
			...genPaginationItemStyle(token$1),
			...genPaginationJumpStyle(token$1),
			...genPaginationSimpleStyle(token$1),
			...genPaginationMiniStyle(token$1),
			...genPaginationDisabledStyle(token$1),
			[`@media only screen and (max-width: ${token$1.screenLG}px)`]: { [`${componentCls}-item`]: { "&-after-jump-prev, &-before-jump-next": { display: "none" } } },
			[`@media only screen and (max-width: ${token$1.screenSM}px)`]: { [`${componentCls}-options`]: { display: "none" } }
		},
		[`&${token$1.componentCls}-rtl`]: { direction: "rtl" }
	};
};
var genPaginationFocusStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}:not(${componentCls}-disabled)`]: {
		[`${componentCls}-item`]: { ...genFocusStyle(token$1) },
		[`${componentCls}-jump-prev, ${componentCls}-jump-next`]: { "&:focus-visible": {
			[`${componentCls}-item-link-icon`]: { opacity: 1 },
			[`${componentCls}-item-ellipsis`]: { opacity: 0 },
			...genFocusOutline(token$1)
		} },
		[`${componentCls}-prev, ${componentCls}-next`]: { [`&:focus-visible ${componentCls}-item-link`]: genFocusOutline(token$1) }
	} };
};
const prepareComponentToken$20 = (token$1) => ({
	itemBg: token$1.colorBgContainer,
	itemSize: token$1.controlHeight,
	itemSizeSM: token$1.controlHeightSM,
	itemActiveBg: token$1.colorBgContainer,
	itemActiveColor: token$1.colorPrimary,
	itemActiveColorHover: token$1.colorPrimaryHover,
	itemLinkBg: token$1.colorBgContainer,
	itemActiveColorDisabled: token$1.colorTextDisabled,
	itemActiveBgDisabled: token$1.controlItemBgActiveDisabled,
	itemInputBg: token$1.colorBgContainer,
	miniOptionsSizeChangerTop: 0,
	...initComponentToken$1(token$1)
});
const prepareToken$1 = (token$1) => merge(token$1, {
	inputOutlineOffset: 0,
	quickJumperInputWidth: token$1.calc(token$1.controlHeightLG).mul(1.25).equal(),
	paginationMiniOptionsMarginInlineStart: token$1.calc(token$1.marginXXS).div(2).equal(),
	paginationMiniQuickJumperInputWidth: token$1.calc(token$1.controlHeightLG).mul(1.1).equal(),
	paginationItemPaddingInline: token$1.calc(token$1.marginXXS).mul(1.5).equal(),
	paginationEllipsisLetterSpacing: token$1.calc(token$1.marginXXS).div(2).equal(),
	paginationSlashMarginInlineStart: token$1.marginSM,
	paginationSlashMarginInlineEnd: token$1.marginSM,
	paginationEllipsisTextIndent: "0.13em"
}, initInputToken(token$1));
var style_default$23 = genStyleHooks("Pagination", (token$1) => {
	const paginationToken = prepareToken$1(token$1);
	return [genPaginationStyle$1(paginationToken), genPaginationFocusStyle(paginationToken)];
}, prepareComponentToken$20);

//#endregion
//#region node_modules/antd/es/pagination/style/bordered.js
var genBorderedStyle$2 = (token$1) => {
	const { componentCls } = token$1;
	return {
		[`${componentCls}${componentCls}-bordered${componentCls}-disabled:not(${componentCls}-mini)`]: {
			"&, &:hover": { [`${componentCls}-item-link`]: { borderColor: token$1.colorBorder } },
			"&:focus-visible": { [`${componentCls}-item-link`]: { borderColor: token$1.colorBorder } },
			[`${componentCls}-item, ${componentCls}-item-link`]: {
				backgroundColor: token$1.colorBgContainerDisabled,
				borderColor: token$1.colorBorder,
				[`&:hover:not(${componentCls}-item-active)`]: {
					backgroundColor: token$1.colorBgContainerDisabled,
					borderColor: token$1.colorBorder,
					a: { color: token$1.colorTextDisabled }
				},
				[`&${componentCls}-item-active`]: { backgroundColor: token$1.itemActiveBgDisabled }
			},
			[`${componentCls}-prev, ${componentCls}-next`]: {
				"&:hover button": {
					backgroundColor: token$1.colorBgContainerDisabled,
					borderColor: token$1.colorBorder,
					color: token$1.colorTextDisabled
				},
				[`${componentCls}-item-link`]: {
					backgroundColor: token$1.colorBgContainerDisabled,
					borderColor: token$1.colorBorder
				}
			}
		},
		[`${componentCls}${componentCls}-bordered:not(${componentCls}-mini)`]: {
			[`${componentCls}-prev, ${componentCls}-next`]: {
				"&:hover button": {
					borderColor: token$1.colorPrimaryHover,
					backgroundColor: token$1.itemBg
				},
				[`${componentCls}-item-link`]: {
					backgroundColor: token$1.itemLinkBg,
					borderColor: token$1.colorBorder
				},
				[`&:hover ${componentCls}-item-link`]: {
					borderColor: token$1.colorPrimary,
					backgroundColor: token$1.itemBg,
					color: token$1.colorPrimary
				},
				[`&${componentCls}-disabled`]: { [`${componentCls}-item-link`]: {
					borderColor: token$1.colorBorder,
					color: token$1.colorTextDisabled
				} }
			},
			[`${componentCls}-item`]: {
				backgroundColor: token$1.itemBg,
				border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`,
				[`&:hover:not(${componentCls}-item-active)`]: {
					borderColor: token$1.colorPrimary,
					backgroundColor: token$1.itemBg,
					a: { color: token$1.colorPrimary }
				},
				"&-active": { borderColor: token$1.colorPrimary }
			}
		}
	};
};
var bordered_default$1 = genSubStyleComponent(["Pagination", "bordered"], (token$1) => {
	return genBorderedStyle$2(prepareToken$1(token$1));
}, prepareComponentToken$20);

//#endregion
//#region node_modules/antd/es/pagination/useShowSizeChanger.js
function useShowSizeChanger(showSizeChanger) {
	return (0, import_react.useMemo)(() => {
		if (typeof showSizeChanger === "boolean") return [showSizeChanger, {}];
		if (showSizeChanger && typeof showSizeChanger === "object") return [true, showSizeChanger];
		return [void 0, void 0];
	}, [showSizeChanger]);
}

//#endregion
//#region node_modules/antd/es/pagination/Pagination.js
var Pagination = (props) => {
	const { align, prefixCls: customizePrefixCls, selectPrefixCls: customizeSelectPrefixCls, className, rootClassName, style: style$1, size: customizeSize, locale: customLocale, responsive, showSizeChanger, selectComponentClass, pageSizeOptions, styles, classNames, ...restProps } = props;
	const { xs } = useBreakpoint_default(responsive);
	const [, token$1] = useToken();
	const { getPrefixCls, direction, showSizeChanger: contextShowSizeChangerConfig, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("pagination");
	const prefixCls = getPrefixCls("pagination", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$23(prefixCls);
	const mergedSize = useSize_default(customizeSize);
	const isSmall = mergedSize === "small" || !!(xs && !mergedSize && responsive);
	const mergedProps = {
		...props,
		size: mergedSize
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const [contextLocale] = useLocale_default("Pagination", en_US_default$1);
	const locale$5 = {
		...contextLocale,
		...customLocale
	};
	const [propShowSizeChanger, propSizeChangerSelectProps] = useShowSizeChanger(showSizeChanger);
	const [contextShowSizeChanger, contextSizeChangerSelectProps] = useShowSizeChanger(contextShowSizeChangerConfig);
	const mergedShowSizeChanger = propShowSizeChanger ?? contextShowSizeChanger;
	const mergedShowSizeChangerSelectProps = propSizeChangerSelectProps ?? contextSizeChangerSelectProps;
	const SizeChanger = selectComponentClass || select_default;
	const mergedPageSizeOptions = import_react.useMemo(() => {
		return pageSizeOptions ? pageSizeOptions.map((option) => Number(option)) : void 0;
	}, [pageSizeOptions]);
	const sizeChangerRender = (info) => {
		const { disabled, size: pageSize, onSizeChange, "aria-label": ariaLabel, className: sizeChangerClassName, options } = info;
		const { className: propSizeChangerClassName, onChange: propSizeChangerOnChange } = mergedShowSizeChangerSelectProps || {};
		const selectedValue = options.find((option) => String(option.value) === String(pageSize))?.value;
		return /* @__PURE__ */ import_react.createElement(SizeChanger, {
			disabled,
			showSearch: true,
			popupMatchSelectWidth: false,
			getPopupContainer: (triggerNode) => triggerNode.parentNode,
			"aria-label": ariaLabel,
			options,
			...mergedShowSizeChangerSelectProps,
			value: selectedValue,
			onChange: (nextSize, option) => {
				onSizeChange?.(nextSize);
				propSizeChangerOnChange?.(nextSize, option);
			},
			size: isSmall ? "small" : "middle",
			className: clsx(sizeChangerClassName, propSizeChangerClassName)
		});
	};
	devUseWarning("Pagination")(!selectComponentClass, "usage", "`selectComponentClass` is not official api which will be removed.");
	const iconsProps = import_react.useMemo(() => {
		const ellipsis = /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-item-ellipsis` }, "");
		return {
			prevIcon: /* @__PURE__ */ import_react.createElement("button", {
				className: `${prefixCls}-item-link`,
				type: "button",
				tabIndex: -1
			}, direction === "rtl" ? /* @__PURE__ */ import_react.createElement(RightOutlined_default, null) : /* @__PURE__ */ import_react.createElement(LeftOutlined_default, null)),
			nextIcon: /* @__PURE__ */ import_react.createElement("button", {
				className: `${prefixCls}-item-link`,
				type: "button",
				tabIndex: -1
			}, direction === "rtl" ? /* @__PURE__ */ import_react.createElement(LeftOutlined_default, null) : /* @__PURE__ */ import_react.createElement(RightOutlined_default, null)),
			jumpPrevIcon: /* @__PURE__ */ import_react.createElement("a", { className: `${prefixCls}-item-link` }, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-item-container` }, direction === "rtl" ? /* @__PURE__ */ import_react.createElement(DoubleRightOutlined_default, { className: `${prefixCls}-item-link-icon` }) : /* @__PURE__ */ import_react.createElement(DoubleLeftOutlined_default, { className: `${prefixCls}-item-link-icon` }), ellipsis)),
			jumpNextIcon: /* @__PURE__ */ import_react.createElement("a", { className: `${prefixCls}-item-link` }, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-item-container` }, direction === "rtl" ? /* @__PURE__ */ import_react.createElement(DoubleLeftOutlined_default, { className: `${prefixCls}-item-link-icon` }) : /* @__PURE__ */ import_react.createElement(DoubleRightOutlined_default, { className: `${prefixCls}-item-link-icon` }), ellipsis))
		};
	}, [direction, prefixCls]);
	const selectPrefixCls = getPrefixCls("select", customizeSelectPrefixCls);
	const extendedClassName = clsx({
		[`${prefixCls}-${align}`]: !!align,
		[`${prefixCls}-mini`]: isSmall,
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-bordered`]: token$1.wireframe
	}, contextClassName, className, rootClassName, mergedClassNames.root, hashId, cssVarCls);
	const mergedStyle = {
		...mergedStyles.root,
		...contextStyle,
		...style$1
	};
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, token$1.wireframe && /* @__PURE__ */ import_react.createElement(bordered_default$1, { prefixCls }), /* @__PURE__ */ import_react.createElement(Pagination_default$1, {
		...iconsProps,
		...restProps,
		styles: mergedStyles,
		classNames: mergedClassNames,
		style: mergedStyle,
		prefixCls,
		selectPrefixCls,
		className: extendedClassName,
		locale: locale$5,
		pageSizeOptions: mergedPageSizeOptions,
		showSizeChanger: mergedShowSizeChanger,
		sizeChangerRender
	}));
};
Pagination.displayName = "Pagination";
var Pagination_default = Pagination;

//#endregion
//#region node_modules/antd/es/pagination/index.js
var pagination_default = Pagination_default;

//#endregion
//#region node_modules/antd/es/spin/Indicator/Progress.js
var viewSize = 100;
var borderWidth = viewSize / 5;
var radius = viewSize / 2 - borderWidth / 2;
var circumference = radius * 2 * Math.PI;
var position = 50;
var CustomCircle = (props) => {
	const { dotClassName, style: style$1, hasCircleCls } = props;
	return /* @__PURE__ */ import_react.createElement("circle", {
		className: clsx(`${dotClassName}-circle`, { [`${dotClassName}-circle-bg`]: hasCircleCls }),
		r: radius,
		cx: position,
		cy: position,
		strokeWidth: borderWidth,
		style: style$1
	});
};
var Progress$1 = ({ percent, prefixCls }) => {
	const dotClassName = `${prefixCls}-dot`;
	const holderClassName = `${dotClassName}-holder`;
	const hideClassName = `${holderClassName}-hidden`;
	const [render$1, setRender] = import_react.useState(false);
	useLayoutEffect_default(() => {
		if (percent !== 0) setRender(true);
	}, [percent !== 0]);
	const safePtg = Math.max(Math.min(percent, 100), 0);
	if (!render$1) return null;
	const circleStyle = {
		strokeDashoffset: `${circumference / 4}`,
		strokeDasharray: `${circumference * safePtg / 100} ${circumference * (100 - safePtg) / 100}`
	};
	return /* @__PURE__ */ import_react.createElement("span", { className: clsx(holderClassName, `${dotClassName}-progress`, safePtg <= 0 && hideClassName) }, /* @__PURE__ */ import_react.createElement("svg", {
		viewBox: `0 0 ${viewSize} ${viewSize}`,
		role: "progressbar",
		"aria-valuemin": 0,
		"aria-valuemax": 100,
		"aria-valuenow": safePtg
	}, /* @__PURE__ */ import_react.createElement(CustomCircle, {
		dotClassName,
		hasCircleCls: true
	}), /* @__PURE__ */ import_react.createElement(CustomCircle, {
		dotClassName,
		style: circleStyle
	})));
};
var Progress_default = Progress$1;

//#endregion
//#region node_modules/antd/es/spin/Indicator/Looper.js
function Looper(props) {
	const { prefixCls, percent = 0, className, style: style$1 } = props;
	const dotClassName = `${prefixCls}-dot`;
	const holderClassName = `${dotClassName}-holder`;
	const hideClassName = `${holderClassName}-hidden`;
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("span", {
		className: clsx(holderClassName, className, percent > 0 && hideClassName),
		style: style$1
	}, /* @__PURE__ */ import_react.createElement("span", { className: clsx(dotClassName, `${prefixCls}-dot-spin`) }, [
		1,
		2,
		3,
		4
	].map((i) => /* @__PURE__ */ import_react.createElement("i", {
		className: `${prefixCls}-dot-item`,
		key: i
	})))), /* @__PURE__ */ import_react.createElement(Progress_default, {
		prefixCls,
		percent
	}));
}

//#endregion
//#region node_modules/antd/es/spin/Indicator/index.js
function Indicator(props) {
	const { prefixCls, indicator, percent, className, style: style$1 } = props;
	const dotClassName = `${prefixCls}-dot`;
	if (indicator && /* @__PURE__ */ import_react.isValidElement(indicator)) return cloneElement(indicator, (currentProps) => ({
		className: clsx(currentProps.className, dotClassName, className),
		style: {
			...currentProps.style,
			...style$1
		},
		percent
	}));
	return /* @__PURE__ */ import_react.createElement(Looper, {
		prefixCls,
		percent,
		className,
		style: style$1
	});
}

//#endregion
//#region node_modules/antd/es/spin/style/index.js
var antSpinMove = new Keyframes_default("antSpinMove", { to: { opacity: 1 } });
var antRotate = new Keyframes_default("antRotate", { to: { transform: "rotate(405deg)" } });
var genSpinStyle = (token$1) => {
	const { componentCls, calc } = token$1;
	return { [componentCls]: {
		...resetComponent(token$1),
		position: "absolute",
		display: "none",
		color: token$1.colorPrimary,
		fontSize: 0,
		textAlign: "center",
		verticalAlign: "middle",
		opacity: 0,
		transition: `transform ${token$1.motionDurationSlow} ${token$1.motionEaseInOutCirc}`,
		"&-spinning": {
			position: "relative",
			display: "inline-block",
			opacity: 1
		},
		[`${componentCls}-text`]: {
			fontSize: token$1.fontSize,
			paddingTop: calc(calc(token$1.dotSize).sub(token$1.fontSize)).div(2).add(2).equal()
		},
		"&-fullscreen": {
			position: "fixed",
			width: "100vw",
			height: "100vh",
			backgroundColor: token$1.colorBgMask,
			zIndex: token$1.zIndexPopupBase,
			inset: 0,
			display: "flex",
			alignItems: "center",
			flexDirection: "column",
			justifyContent: "center",
			opacity: 0,
			visibility: "hidden",
			transition: `all ${token$1.motionDurationMid}`,
			"&-show": {
				opacity: 1,
				visibility: "visible"
			},
			[componentCls]: {
				[`${componentCls}-dot-holder`]: { color: token$1.colorWhite },
				[`${componentCls}-text`]: { color: token$1.colorTextLightSolid }
			}
		},
		"&-nested-loading": {
			position: "relative",
			[`> div > ${componentCls}`]: {
				position: "absolute",
				top: 0,
				insetInlineStart: 0,
				zIndex: 4,
				display: "block",
				width: "100%",
				height: "100%",
				maxHeight: token$1.contentHeight,
				[`${componentCls}-dot`]: {
					position: "absolute",
					top: "50%",
					insetInlineStart: "50%",
					margin: calc(token$1.dotSize).mul(-1).div(2).equal()
				},
				[`${componentCls}-text`]: {
					position: "absolute",
					top: "50%",
					width: "100%",
					textShadow: `0 1px 2px ${token$1.colorBgContainer}`
				},
				[`&${componentCls}-show-text ${componentCls}-dot`]: { marginTop: calc(token$1.dotSize).div(2).mul(-1).sub(10).equal() },
				"&-sm": {
					[`${componentCls}-dot`]: { margin: calc(token$1.dotSizeSM).mul(-1).div(2).equal() },
					[`${componentCls}-text`]: { paddingTop: calc(calc(token$1.dotSizeSM).sub(token$1.fontSize)).div(2).add(2).equal() },
					[`&${componentCls}-show-text ${componentCls}-dot`]: { marginTop: calc(token$1.dotSizeSM).div(2).mul(-1).sub(10).equal() }
				},
				"&-lg": {
					[`${componentCls}-dot`]: { margin: calc(token$1.dotSizeLG).mul(-1).div(2).equal() },
					[`${componentCls}-text`]: { paddingTop: calc(calc(token$1.dotSizeLG).sub(token$1.fontSize)).div(2).add(2).equal() },
					[`&${componentCls}-show-text ${componentCls}-dot`]: { marginTop: calc(token$1.dotSizeLG).div(2).mul(-1).sub(10).equal() }
				}
			},
			[`${componentCls}-container`]: {
				position: "relative",
				transition: `opacity ${token$1.motionDurationSlow}`,
				"&::after": {
					position: "absolute",
					top: 0,
					insetInlineEnd: 0,
					bottom: 0,
					insetInlineStart: 0,
					zIndex: 10,
					width: "100%",
					height: "100%",
					background: token$1.colorBgContainer,
					opacity: 0,
					transition: `all ${token$1.motionDurationSlow}`,
					content: "\"\"",
					pointerEvents: "none"
				}
			},
			[`${componentCls}-blur`]: {
				clear: "both",
				opacity: .5,
				userSelect: "none",
				pointerEvents: "none",
				"&::after": {
					opacity: .4,
					pointerEvents: "auto"
				}
			}
		},
		"&-tip": { color: token$1.spinDotDefault },
		[`${componentCls}-dot-holder`]: {
			width: "1em",
			height: "1em",
			fontSize: token$1.dotSize,
			display: "inline-block",
			transition: `transform ${token$1.motionDurationSlow} ease, opacity ${token$1.motionDurationSlow} ease`,
			transformOrigin: "50% 50%",
			lineHeight: 1,
			color: token$1.colorPrimary,
			"&-hidden": {
				transform: "scale(0.3)",
				opacity: 0
			}
		},
		[`${componentCls}-dot-progress`]: {
			position: "absolute",
			inset: 0
		},
		[`${componentCls}-dot`]: {
			position: "relative",
			display: "inline-block",
			fontSize: token$1.dotSize,
			width: "1em",
			height: "1em",
			"&-item": {
				position: "absolute",
				display: "block",
				width: calc(token$1.dotSize).sub(calc(token$1.marginXXS).div(2)).div(2).equal(),
				height: calc(token$1.dotSize).sub(calc(token$1.marginXXS).div(2)).div(2).equal(),
				background: "currentColor",
				borderRadius: "100%",
				transform: "scale(0.75)",
				transformOrigin: "50% 50%",
				opacity: .3,
				animationName: antSpinMove,
				animationDuration: "1s",
				animationIterationCount: "infinite",
				animationTimingFunction: "linear",
				animationDirection: "alternate",
				"&:nth-child(1)": {
					top: 0,
					insetInlineStart: 0,
					animationDelay: "0s"
				},
				"&:nth-child(2)": {
					top: 0,
					insetInlineEnd: 0,
					animationDelay: "0.4s"
				},
				"&:nth-child(3)": {
					insetInlineEnd: 0,
					bottom: 0,
					animationDelay: "0.8s"
				},
				"&:nth-child(4)": {
					bottom: 0,
					insetInlineStart: 0,
					animationDelay: "1.2s"
				}
			},
			"&-spin": {
				transform: "rotate(45deg)",
				animationName: antRotate,
				animationDuration: "1.2s",
				animationIterationCount: "infinite",
				animationTimingFunction: "linear"
			},
			"&-circle": {
				strokeLinecap: "round",
				transition: [
					"stroke-dashoffset",
					"stroke-dasharray",
					"stroke",
					"stroke-width",
					"opacity"
				].map((item) => `${item} ${token$1.motionDurationSlow} ease`).join(","),
				fillOpacity: 0,
				stroke: "currentcolor"
			},
			"&-circle-bg": { stroke: token$1.colorFillSecondary }
		},
		[`&-sm ${componentCls}-dot`]: { "&, &-holder": { fontSize: token$1.dotSizeSM } },
		[`&-sm ${componentCls}-dot-holder`]: { i: {
			width: calc(calc(token$1.dotSizeSM).sub(calc(token$1.marginXXS).div(2))).div(2).equal(),
			height: calc(calc(token$1.dotSizeSM).sub(calc(token$1.marginXXS).div(2))).div(2).equal()
		} },
		[`&-lg ${componentCls}-dot`]: { "&, &-holder": { fontSize: token$1.dotSizeLG } },
		[`&-lg ${componentCls}-dot-holder`]: { i: {
			width: calc(calc(token$1.dotSizeLG).sub(token$1.marginXXS)).div(2).equal(),
			height: calc(calc(token$1.dotSizeLG).sub(token$1.marginXXS)).div(2).equal()
		} },
		[`&${componentCls}-show-text ${componentCls}-text`]: { display: "block" }
	} };
};
const prepareComponentToken$19 = (token$1) => {
	const { controlHeightLG, controlHeight } = token$1;
	return {
		contentHeight: 400,
		dotSize: controlHeightLG / 2,
		dotSizeSM: controlHeightLG * .35,
		dotSizeLG: controlHeight
	};
};
var style_default$22 = genStyleHooks("Spin", (token$1) => {
	return genSpinStyle(merge(token$1, { spinDotDefault: token$1.colorTextDescription }));
}, prepareComponentToken$19);

//#endregion
//#region node_modules/antd/es/spin/usePercent.js
var AUTO_INTERVAL = 200;
var STEP_BUCKETS = [
	[30, .05],
	[70, .03],
	[96, .01]
];
function usePercent(spinning, percent) {
	const [mockPercent, setMockPercent] = import_react.useState(0);
	const mockIntervalRef = import_react.useRef(null);
	const isAuto = percent === "auto";
	import_react.useEffect(() => {
		if (isAuto && spinning) {
			setMockPercent(0);
			mockIntervalRef.current = setInterval(() => {
				setMockPercent((prev$1) => {
					const restPTG = 100 - prev$1;
					for (let i = 0; i < STEP_BUCKETS.length; i += 1) {
						const [limit, stepPtg] = STEP_BUCKETS[i];
						if (prev$1 <= limit) return prev$1 + restPTG * stepPtg;
					}
					return prev$1;
				});
			}, AUTO_INTERVAL);
		}
		return () => {
			if (mockIntervalRef.current) {
				clearInterval(mockIntervalRef.current);
				mockIntervalRef.current = null;
			}
		};
	}, [isAuto, spinning]);
	return isAuto ? mockPercent : percent;
}

//#endregion
//#region node_modules/antd/es/spin/index.js
var defaultIndicator;
function shouldDelay(spinning, delay) {
	return !!spinning && !!delay && !Number.isNaN(Number(delay));
}
var Spin = (props) => {
	const { prefixCls: customizePrefixCls, spinning: customSpinning = true, delay = 0, className, rootClassName, size = "default", tip, wrapperClassName, style: style$1, children, fullscreen = false, indicator, percent, classNames, styles, ...restProps } = props;
	const { getPrefixCls, direction, indicator: contextIndicator, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("spin");
	const prefixCls = getPrefixCls("spin", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$22(prefixCls);
	const [spinning, setSpinning] = import_react.useState(() => customSpinning && !shouldDelay(customSpinning, delay));
	const mergedPercent = usePercent(spinning, percent);
	import_react.useEffect(() => {
		if (customSpinning) {
			const showSpinning = debounce(delay, () => {
				setSpinning(true);
			});
			showSpinning();
			return () => {
				showSpinning?.cancel?.();
			};
		}
		setSpinning(false);
	}, [delay, customSpinning]);
	const isNestedPattern = import_react.useMemo(() => typeof children !== "undefined" && !fullscreen, [children, fullscreen]);
	const mergedProps = {
		...props,
		size,
		spinning,
		tip,
		fullscreen,
		children,
		percent: mergedPercent
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	devUseWarning("Spin")(!tip || isNestedPattern || fullscreen, "usage", "`tip` only work in nest or fullscreen pattern.");
	const spinClassName = clsx(prefixCls, contextClassName, {
		[`${prefixCls}-sm`]: size === "small",
		[`${prefixCls}-lg`]: size === "large",
		[`${prefixCls}-spinning`]: spinning,
		[`${prefixCls}-show-text`]: !!tip,
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, className, !fullscreen && rootClassName, !fullscreen && mergedClassNames.root, hashId, cssVarCls);
	const containerClassName = clsx(`${prefixCls}-container`, { [`${prefixCls}-blur`]: spinning });
	const mergedIndicator = indicator ?? contextIndicator ?? defaultIndicator;
	const mergedStyle = {
		...contextStyle,
		...style$1
	};
	const spinElement = /* @__PURE__ */ import_react.createElement("div", {
		...restProps,
		style: fullscreen ? mergedStyle : {
			...mergedStyles.root,
			...mergedStyle
		},
		className: spinClassName,
		"aria-live": "polite",
		"aria-busy": spinning
	}, /* @__PURE__ */ import_react.createElement(Indicator, {
		className: mergedClassNames.indicator,
		style: mergedStyles.indicator,
		prefixCls,
		indicator: mergedIndicator,
		percent: mergedPercent
	}), tip && (isNestedPattern || fullscreen) ? /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-text`, mergedClassNames.tip),
		style: mergedStyles.tip
	}, tip) : null);
	if (isNestedPattern) return /* @__PURE__ */ import_react.createElement("div", {
		...restProps,
		className: clsx(`${prefixCls}-nested-loading`, wrapperClassName, mergedClassNames.wrapper, hashId, cssVarCls),
		style: mergedStyles.wrapper
	}, spinning && /* @__PURE__ */ import_react.createElement("div", { key: "loading" }, spinElement), /* @__PURE__ */ import_react.createElement("div", {
		className: containerClassName,
		key: "container"
	}, children));
	if (fullscreen) return /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-fullscreen`, { [`${prefixCls}-fullscreen-show`]: spinning }, rootClassName, hashId, cssVarCls, mergedClassNames.mask),
		style: mergedStyles.mask
	}, spinElement);
	return spinElement;
};
Spin.setDefaultIndicator = (indicator) => {
	defaultIndicator = indicator;
};
Spin.displayName = "Spin";
var spin_default = Spin;

//#endregion
//#region node_modules/antd/es/list/context.js
const ListContext = /* @__PURE__ */ import_react.createContext({});
const ListConsumer = ListContext.Consumer;

//#endregion
//#region node_modules/antd/es/list/Item.js
const Meta = ({ prefixCls: customizePrefixCls, className, avatar, title, description, ...others }) => {
	const { getPrefixCls } = (0, import_react.useContext)(ConfigContext);
	const prefixCls = getPrefixCls("list", customizePrefixCls);
	const classString = clsx(`${prefixCls}-item-meta`, className);
	const content = /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-item-meta-content` }, title && /* @__PURE__ */ import_react.createElement("h4", { className: `${prefixCls}-item-meta-title` }, title), description && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-item-meta-description` }, description));
	return /* @__PURE__ */ import_react.createElement("div", {
		...others,
		className: classString
	}, avatar && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-item-meta-avatar` }, avatar), (title || description) && content);
};
var Item = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, children, actions, extra, styles, className, classNames: customizeClassNames, colStyle, ...others } = props;
	const { grid, itemLayout } = (0, import_react.useContext)(ListContext);
	const { getPrefixCls, list } = (0, import_react.useContext)(ConfigContext);
	const moduleClass = (moduleName) => clsx(list?.item?.classNames?.[moduleName], customizeClassNames?.[moduleName]);
	const moduleStyle = (moduleName) => ({
		...list?.item?.styles?.[moduleName],
		...styles?.[moduleName]
	});
	const isItemContainsTextNodeAndNotSingular = () => {
		const childNodes = toArray(children);
		return childNodes.some((node$1) => typeof node$1 === "string") && childNodes.length > 1;
	};
	const isFlexMode = () => {
		if (itemLayout === "vertical") return !!extra;
		return !isItemContainsTextNodeAndNotSingular();
	};
	const prefixCls = getPrefixCls("list", customizePrefixCls);
	const actionsContent = actions && actions.length > 0 && /* @__PURE__ */ import_react.createElement("ul", {
		className: clsx(`${prefixCls}-item-action`, moduleClass("actions")),
		key: "actions",
		style: moduleStyle("actions")
	}, actions.map((action, i) => /* @__PURE__ */ import_react.createElement("li", { key: `${prefixCls}-item-action-${i}` }, action, i !== actions.length - 1 && /* @__PURE__ */ import_react.createElement("em", { className: `${prefixCls}-item-action-split` }))));
	const Element$2 = grid ? "div" : "li";
	const itemChildren = /* @__PURE__ */ import_react.createElement(Element$2, {
		...others,
		...!grid ? { ref } : {},
		className: clsx(`${prefixCls}-item`, { [`${prefixCls}-item-no-flex`]: !isFlexMode() }, className)
	}, itemLayout === "vertical" && extra ? [/* @__PURE__ */ import_react.createElement("div", {
		className: `${prefixCls}-item-main`,
		key: "content"
	}, children, actionsContent), /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-item-extra`, moduleClass("extra")),
		key: "extra",
		style: moduleStyle("extra")
	}, extra)] : [
		children,
		actionsContent,
		cloneElement(extra, { key: "extra" })
	]);
	return grid ? /* @__PURE__ */ import_react.createElement(col_default$1, {
		ref,
		flex: 1,
		style: colStyle
	}, itemChildren) : itemChildren;
});
Item.Meta = Meta;
var Item_default = Item;

//#endregion
//#region node_modules/antd/es/list/style/index.js
var genBorderedStyle$1 = (token$1) => {
	const { listBorderedCls, componentCls, paddingLG, margin, itemPaddingSM, itemPaddingLG, marginLG, borderRadiusLG } = token$1;
	const innerCornerBorderRadius = unit(token$1.calc(borderRadiusLG).sub(token$1.lineWidth).equal());
	return {
		[listBorderedCls]: {
			border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`,
			borderRadius: borderRadiusLG,
			[`${componentCls}-header`]: { borderRadius: `${innerCornerBorderRadius} ${innerCornerBorderRadius} 0 0` },
			[`${componentCls}-footer`]: { borderRadius: `0 0 ${innerCornerBorderRadius} ${innerCornerBorderRadius}` },
			[`${componentCls}-header,${componentCls}-footer,${componentCls}-item`]: { paddingInline: paddingLG },
			[`${componentCls}-pagination`]: { margin: `${unit(margin)} ${unit(marginLG)}` }
		},
		[`${listBorderedCls}${componentCls}-sm`]: { [`${componentCls}-item,${componentCls}-header,${componentCls}-footer`]: { padding: itemPaddingSM } },
		[`${listBorderedCls}${componentCls}-lg`]: { [`${componentCls}-item,${componentCls}-header,${componentCls}-footer`]: { padding: itemPaddingLG } }
	};
};
var genResponsiveStyle = (token$1) => {
	const { componentCls, screenSM, screenMD, marginLG, marginSM, margin } = token$1;
	return {
		[`@media screen and (max-width:${screenMD}px)`]: {
			[componentCls]: { [`${componentCls}-item`]: { [`${componentCls}-item-action`]: { marginInlineStart: marginLG } } },
			[`${componentCls}-vertical`]: { [`${componentCls}-item`]: { [`${componentCls}-item-extra`]: { marginInlineStart: marginLG } } }
		},
		[`@media screen and (max-width: ${screenSM}px)`]: {
			[componentCls]: { [`${componentCls}-item`]: {
				flexWrap: "wrap",
				[`${componentCls}-action`]: { marginInlineStart: marginSM }
			} },
			[`${componentCls}-vertical`]: { [`${componentCls}-item`]: {
				flexWrap: "wrap-reverse",
				[`${componentCls}-item-main`]: { minWidth: token$1.contentWidth },
				[`${componentCls}-item-extra`]: { margin: `auto auto ${unit(margin)}` }
			} }
		}
	};
};
var genBaseStyle$8 = (token$1) => {
	const { componentCls, antCls, controlHeight, minHeight, paddingSM, marginLG, padding, itemPadding, colorPrimary, itemPaddingSM, itemPaddingLG, paddingXS, margin, colorText, colorTextDescription, motionDurationSlow, lineWidth, headerBg, footerBg, emptyTextPadding, metaMarginBottom, avatarMarginRight, titleMarginBottom, descriptionFontSize } = token$1;
	return {
		[componentCls]: {
			...resetComponent(token$1),
			position: "relative",
			["--rc-virtual-list-scrollbar-bg"]: token$1.colorSplit,
			"*": { outline: "none" },
			[`${componentCls}-header`]: { background: headerBg },
			[`${componentCls}-footer`]: { background: footerBg },
			[`${componentCls}-header, ${componentCls}-footer`]: { paddingBlock: paddingSM },
			[`${componentCls}-pagination`]: {
				marginBlockStart: marginLG,
				[`${antCls}-pagination-options`]: { textAlign: "start" }
			},
			[`${componentCls}-spin`]: {
				minHeight,
				textAlign: "center"
			},
			[`${componentCls}-items`]: {
				margin: 0,
				padding: 0,
				listStyle: "none"
			},
			[`${componentCls}-item`]: {
				display: "flex",
				alignItems: "center",
				justifyContent: "space-between",
				padding: itemPadding,
				color: colorText,
				[`${componentCls}-item-meta`]: {
					display: "flex",
					flex: 1,
					alignItems: "flex-start",
					maxWidth: "100%",
					[`${componentCls}-item-meta-avatar`]: { marginInlineEnd: avatarMarginRight },
					[`${componentCls}-item-meta-content`]: {
						flex: "1 0",
						width: 0,
						color: colorText
					},
					[`${componentCls}-item-meta-title`]: {
						margin: `0 0 ${unit(token$1.marginXXS)} 0`,
						color: colorText,
						fontSize: token$1.fontSize,
						lineHeight: token$1.lineHeight,
						"> a": {
							color: colorText,
							transition: `all ${motionDurationSlow}`,
							"&:hover": { color: colorPrimary }
						}
					},
					[`${componentCls}-item-meta-description`]: {
						color: colorTextDescription,
						fontSize: descriptionFontSize,
						lineHeight: token$1.lineHeight
					}
				},
				[`${componentCls}-item-action`]: {
					flex: "0 0 auto",
					marginInlineStart: token$1.marginXXL,
					padding: 0,
					fontSize: 0,
					listStyle: "none",
					"& > li": {
						position: "relative",
						display: "inline-block",
						padding: `0 ${unit(paddingXS)}`,
						color: colorTextDescription,
						fontSize: token$1.fontSize,
						lineHeight: token$1.lineHeight,
						textAlign: "center",
						"&:first-child": { paddingInlineStart: 0 }
					},
					[`${componentCls}-item-action-split`]: {
						position: "absolute",
						insetBlockStart: "50%",
						insetInlineEnd: 0,
						width: lineWidth,
						height: token$1.calc(token$1.fontHeight).sub(token$1.calc(token$1.marginXXS).mul(2)).equal(),
						transform: "translateY(-50%)",
						backgroundColor: token$1.colorSplit
					}
				}
			},
			[`${componentCls}-empty`]: {
				padding: `${unit(padding)} 0`,
				color: colorTextDescription,
				fontSize: token$1.fontSizeSM,
				textAlign: "center"
			},
			[`${componentCls}-empty-text`]: {
				padding: emptyTextPadding,
				color: token$1.colorTextDisabled,
				fontSize: token$1.fontSize,
				textAlign: "center"
			},
			[`${componentCls}-item-no-flex`]: { display: "block" }
		},
		[`${componentCls}-grid ${antCls}-col > ${componentCls}-item`]: {
			display: "block",
			maxWidth: "100%",
			marginBlockEnd: margin,
			paddingBlock: 0,
			borderBlockEnd: "none"
		},
		[`${componentCls}-vertical ${componentCls}-item`]: {
			alignItems: "initial",
			[`${componentCls}-item-main`]: {
				display: "block",
				flex: 1
			},
			[`${componentCls}-item-extra`]: { marginInlineStart: marginLG },
			[`${componentCls}-item-meta`]: {
				marginBlockEnd: metaMarginBottom,
				[`${componentCls}-item-meta-title`]: {
					marginBlockStart: 0,
					marginBlockEnd: titleMarginBottom,
					color: colorText,
					fontSize: token$1.fontSizeLG,
					lineHeight: token$1.lineHeightLG
				}
			},
			[`${componentCls}-item-action`]: {
				marginBlockStart: padding,
				marginInlineStart: "auto",
				"> li": {
					padding: `0 ${unit(padding)}`,
					"&:first-child": { paddingInlineStart: 0 }
				}
			}
		},
		[`${componentCls}-split ${componentCls}-item`]: {
			borderBlockEnd: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}`,
			"&:last-child": { borderBlockEnd: "none" }
		},
		[`${componentCls}-split ${componentCls}-header`]: { borderBlockEnd: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}` },
		[`${componentCls}-split${componentCls}-empty ${componentCls}-footer`]: { borderTop: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}` },
		[`${componentCls}-loading ${componentCls}-spin-nested-loading`]: { minHeight: controlHeight },
		[`${componentCls}-split${componentCls}-something-after-last-item ${antCls}-spin-container > ${componentCls}-items > ${componentCls}-item:last-child`]: { borderBlockEnd: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}` },
		[`${componentCls}-lg ${componentCls}-item`]: { padding: itemPaddingLG },
		[`${componentCls}-sm ${componentCls}-item`]: { padding: itemPaddingSM },
		[`${componentCls}:not(${componentCls}-vertical)`]: { [`${componentCls}-item-no-flex`]: { [`${componentCls}-item-action`]: { float: "right" } } }
	};
};
const prepareComponentToken$18 = (token$1) => ({
	contentWidth: 220,
	itemPadding: `${unit(token$1.paddingContentVertical)} 0`,
	itemPaddingSM: `${unit(token$1.paddingContentVerticalSM)} ${unit(token$1.paddingContentHorizontal)}`,
	itemPaddingLG: `${unit(token$1.paddingContentVerticalLG)} ${unit(token$1.paddingContentHorizontalLG)}`,
	headerBg: "transparent",
	footerBg: "transparent",
	emptyTextPadding: token$1.padding,
	metaMarginBottom: token$1.padding,
	avatarMarginRight: token$1.padding,
	titleMarginBottom: token$1.paddingSM,
	descriptionFontSize: token$1.fontSize
});
var style_default$21 = genStyleHooks("List", (token$1) => {
	const listToken = merge(token$1, {
		listBorderedCls: `${token$1.componentCls}-bordered`,
		minHeight: token$1.controlHeightLG
	});
	return [
		genBaseStyle$8(listToken),
		genBorderedStyle$1(listToken),
		genResponsiveStyle(listToken)
	];
}, prepareComponentToken$18);

//#endregion
//#region node_modules/antd/es/list/index.js
var InternalList = (props, ref) => {
	const { pagination = false, prefixCls: customizePrefixCls, bordered = false, split = true, className, rootClassName, style: style$1, children, itemLayout, loadMore, grid, dataSource = [], size: customizeSize, header, footer, loading = false, rowKey, renderItem: renderItem$1, locale: locale$5, ...rest } = props;
	const paginationObj = pagination && typeof pagination === "object" ? pagination : {};
	const [paginationCurrent, setPaginationCurrent] = import_react.useState(paginationObj.defaultCurrent || 1);
	const [paginationSize, setPaginationSize] = import_react.useState(paginationObj.defaultPageSize || 10);
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle } = useComponentConfig("list");
	const { renderEmpty } = import_react.useContext(ConfigContext);
	const defaultPaginationProps = {
		current: 1,
		total: 0,
		position: "bottom"
	};
	const triggerPaginationEvent = (eventName) => (page, pageSize) => {
		setPaginationCurrent(page);
		setPaginationSize(pageSize);
		if (pagination) pagination?.[eventName]?.(page, pageSize);
	};
	const onPaginationChange = triggerPaginationEvent("onChange");
	const onPaginationShowSizeChange = triggerPaginationEvent("onShowSizeChange");
	const renderInternalItem = (item, index$1) => {
		if (!renderItem$1) return null;
		let key;
		if (typeof rowKey === "function") key = rowKey(item);
		else if (rowKey) key = item[rowKey];
		else key = item.key;
		if (!key) key = `list-item-${index$1}`;
		return /* @__PURE__ */ import_react.createElement(import_react.Fragment, { key }, renderItem$1(item, index$1));
	};
	const isSomethingAfterLastItem = !!(loadMore || pagination || footer);
	const prefixCls = getPrefixCls("list", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$21(prefixCls);
	let loadingProp = loading;
	if (typeof loadingProp === "boolean") loadingProp = { spinning: loadingProp };
	const isLoading = !!loadingProp?.spinning;
	const mergedSize = useSize_default(customizeSize);
	let sizeCls = "";
	switch (mergedSize) {
		case "large":
			sizeCls = "lg";
			break;
		case "small":
			sizeCls = "sm";
			break;
		default: break;
	}
	const classString = clsx(prefixCls, {
		[`${prefixCls}-vertical`]: itemLayout === "vertical",
		[`${prefixCls}-${sizeCls}`]: sizeCls,
		[`${prefixCls}-split`]: split,
		[`${prefixCls}-bordered`]: bordered,
		[`${prefixCls}-loading`]: isLoading,
		[`${prefixCls}-grid`]: !!grid,
		[`${prefixCls}-something-after-last-item`]: isSomethingAfterLastItem,
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, contextClassName, className, rootClassName, hashId, cssVarCls);
	const paginationProps = extendsObject_default(defaultPaginationProps, {
		total: dataSource.length,
		current: paginationCurrent,
		pageSize: paginationSize
	}, pagination || {});
	const largestPage = Math.ceil(paginationProps.total / paginationProps.pageSize);
	paginationProps.current = Math.min(paginationProps.current, largestPage);
	const paginationContent = pagination && /* @__PURE__ */ import_react.createElement("div", { className: clsx(`${prefixCls}-pagination`) }, /* @__PURE__ */ import_react.createElement(pagination_default, {
		align: "end",
		...paginationProps,
		onChange: onPaginationChange,
		onShowSizeChange: onPaginationShowSizeChange
	}));
	let splitDataSource = _toConsumableArray(dataSource);
	if (pagination) {
		if (dataSource.length > (paginationProps.current - 1) * paginationProps.pageSize) splitDataSource = _toConsumableArray(dataSource).splice((paginationProps.current - 1) * paginationProps.pageSize, paginationProps.pageSize);
	}
	const screens = useBreakpoint_default(Object.keys(grid || {}).some((key) => [
		"xs",
		"sm",
		"md",
		"lg",
		"xl",
		"xxl"
	].includes(key)));
	const currentBreakpoint = import_react.useMemo(() => {
		for (let i = 0; i < responsiveArray.length; i += 1) {
			const breakpoint = responsiveArray[i];
			if (screens[breakpoint]) return breakpoint;
		}
	}, [screens]);
	const colStyle = import_react.useMemo(() => {
		if (!grid) return;
		const columnCount = currentBreakpoint && grid[currentBreakpoint] ? grid[currentBreakpoint] : grid.column;
		if (columnCount) return {
			width: `${100 / columnCount}%`,
			maxWidth: `${100 / columnCount}%`
		};
	}, [JSON.stringify(grid), currentBreakpoint]);
	let childrenContent = isLoading && /* @__PURE__ */ import_react.createElement("div", { style: { minHeight: 53 } });
	if (splitDataSource.length > 0) {
		const items = splitDataSource.map(renderInternalItem);
		childrenContent = grid ? /* @__PURE__ */ import_react.createElement(row_default$1, { gutter: grid.gutter }, import_react.Children.map(items, (child) => /* @__PURE__ */ import_react.createElement("div", {
			key: child?.key,
			style: colStyle
		}, child))) : /* @__PURE__ */ import_react.createElement("ul", { className: `${prefixCls}-items` }, items);
	} else if (!children && !isLoading) childrenContent = /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-empty-text` }, locale$5?.emptyText || renderEmpty?.("List") || /* @__PURE__ */ import_react.createElement(defaultRenderEmpty_default, { componentName: "List" }));
	const paginationPosition = paginationProps.position;
	const contextValue = import_react.useMemo(() => ({
		grid,
		itemLayout
	}), [JSON.stringify(grid), itemLayout]);
	devUseWarning("List")(false, "deprecated", "The `List` component is deprecated. And will be removed in next major version.");
	return /* @__PURE__ */ import_react.createElement(ListContext.Provider, { value: contextValue }, /* @__PURE__ */ import_react.createElement("div", {
		ref,
		style: {
			...contextStyle,
			...style$1
		},
		className: classString,
		...rest
	}, (paginationPosition === "top" || paginationPosition === "both") && paginationContent, header && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-header` }, header), /* @__PURE__ */ import_react.createElement(spin_default, { ...loadingProp }, childrenContent, children), footer && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-footer` }, footer), loadMore || (paginationPosition === "bottom" || paginationPosition === "both") && paginationContent));
};
var ListWithForwardRef = /* @__PURE__ */ import_react.forwardRef(InternalList);
ListWithForwardRef.displayName = "Deprecated.List";
var List = ListWithForwardRef;
List.Item = Item_default;
var list_default = List;

//#endregion
//#region node_modules/antd/es/masonry/hooks/useDelay.js
function useDelay(callback) {
	const idRef = import_react.useRef(0);
	const clearRaf = () => {
		raf_default.cancel(idRef.current);
	};
	import_react.useEffect(() => clearRaf, []);
	return useEvent_default(() => {
		clearRaf();
		idRef.current = raf_default(callback);
	});
}

//#endregion
//#region node_modules/antd/es/masonry/hooks/usePositions.js
/**
* Auto arrange the items in the masonry layout.
* Always get stable positions by order
* instead of dynamic adjust for next item height.
*/
function usePositions(itemHeights, columnCount, verticalGutter) {
	const [orderItemPositions, orderTotalHeight] = import_react.useMemo(() => {
		const columnHeights = new Array(columnCount).fill(0);
		const itemPositions = /* @__PURE__ */ new Map();
		for (let i = 0; i < itemHeights.length; i += 1) {
			const [itemKey$2, itemHeight, itemColumn] = itemHeights[i];
			let targetColumnIndex = itemColumn ?? columnHeights.indexOf(Math.min.apply(Math, _toConsumableArray(columnHeights)));
			targetColumnIndex = Math.min(targetColumnIndex, columnCount - 1);
			const top = columnHeights[targetColumnIndex];
			itemPositions.set(itemKey$2, {
				column: targetColumnIndex,
				top
			});
			columnHeights[targetColumnIndex] += itemHeight + verticalGutter;
		}
		return [itemPositions, Math.max(0, Math.max.apply(Math, _toConsumableArray(columnHeights)) - verticalGutter)];
	}, [
		columnCount,
		itemHeights,
		verticalGutter
	]);
	return [orderItemPositions, orderTotalHeight];
}

//#endregion
//#region node_modules/antd/es/masonry/hooks/useRefs.js
function useRefs$1() {
	const refs = import_react.useRef(null);
	if (refs.current === null) refs.current = /* @__PURE__ */ new Map();
	const setRef = (key, element) => {
		refs.current.set(key, element);
	};
	const getRef = (key) => refs.current.get(key);
	return [setRef, getRef];
}

//#endregion
//#region node_modules/antd/es/masonry/MasonryItem.js
var MasonryItem = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { item, style: style$1, prefixCls, itemRender, className, index: index$1, column: column$1, onResize: onResize$1 } = props;
	const itemPrefix = `${prefixCls}-item`;
	const renderNode = (0, import_react.useMemo)(() => {
		return item.children ?? itemRender?.({
			...item,
			index: index$1,
			column: column$1
		});
	}, [
		item,
		itemRender,
		column$1,
		index$1
	]);
	let returnNode = /* @__PURE__ */ import_react.createElement("div", {
		ref,
		style: style$1,
		className: clsx(itemPrefix, className)
	}, renderNode);
	if (onResize$1) returnNode = /* @__PURE__ */ import_react.createElement(es_default$2, { onResize: onResize$1 }, returnNode);
	return returnNode;
});
MasonryItem.displayName = "MasonryItem";
var MasonryItem_default = MasonryItem;

//#endregion
//#region node_modules/antd/es/masonry/style/index.js
const genMasonryStyle = (token$1) => {
	const { componentCls } = token$1;
	const itemCls = `${componentCls}-item`;
	return { [componentCls]: {
		position: "relative",
		boxSizing: "border-box",
		display: "flex",
		flexDirection: "column",
		flexWrap: "wrap",
		"&-rtl": { direction: "rtl" },
		[`& > ${itemCls}`]: {
			boxSizing: "border-box",
			"&-fade": {
				"&-appear": {
					transition: `opacity ${token$1.motionDurationSlow} ${token$1.motionEaseOut}`,
					opacity: 0,
					"&-active": { opacity: 1 }
				},
				"&-leave": {
					transition: `opacity ${token$1.motionDurationFast} ${token$1.motionEaseOut}`,
					opacity: 1,
					"&-active": { opacity: 0 }
				}
			},
			[`&:not(${itemCls}-fade)`]: { transition: [
				"left",
				"right",
				"top"
			].map((prop) => `${prop} ${token$1.motionDurationSlow} ${token$1.motionEaseOut}`).join(",") }
		}
	} };
};
var style_default$20 = genStyleHooks("Masonry", (token$1) => [genMasonryStyle(token$1)]);

//#endregion
//#region node_modules/antd/es/masonry/Masonry.js
var Masonry = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { rootClassName, className, style: style$1, classNames, styles, columns, prefixCls: customizePrefixCls, gutter = 0, items, itemRender, onLayoutChange, fresh } = props;
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("masonry");
	const prefixCls = getPrefixCls("masonry", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$20(prefixCls, useCSSVarCls_default(prefixCls));
	const containerRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => ({ nativeElement: containerRef.current }));
	const [setItemRef, getItemRef] = useRefs$1();
	const [mergedItems, setMergedItems] = import_react.useState([]);
	import_react.useEffect(() => {
		setMergedItems(items || []);
	}, [items]);
	const screens = useBreakpoint_default();
	const [horizontalGutter = 0, verticalGutter = horizontalGutter] = useGutter(gutter, screens);
	const columnCount = import_react.useMemo(() => {
		if (!columns) return 3;
		if (typeof columns === "number") return columns;
		const matchingBreakpoint = responsiveArray.find((breakpoint) => screens[breakpoint] && columns[breakpoint] !== void 0);
		if (matchingBreakpoint) return columns[matchingBreakpoint];
		return columns.xs ?? 1;
	}, [columns, screens]);
	const mergedProps = {
		...props,
		columns: columnCount
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const [itemHeights, setItemHeights] = import_react.useState([]);
	const collectItemSize = useDelay(() => {
		const nextItemsHeight = mergedItems.map((item, index$1) => {
			const itemKey$2 = item.key ?? index$1;
			const rect = getItemRef(itemKey$2)?.getBoundingClientRect();
			return [
				itemKey$2,
				rect ? rect.height : 0,
				item.column
			];
		});
		setItemHeights((prevItemsHeight) => isEqual_default(prevItemsHeight, nextItemsHeight) ? prevItemsHeight : nextItemsHeight);
	});
	const [itemPositions, totalHeight] = usePositions(itemHeights, columnCount, verticalGutter);
	const itemWithPositions = import_react.useMemo(() => mergedItems.map((item, index$1) => {
		const key = item.key ?? index$1;
		return {
			item,
			itemIndex: index$1,
			itemKey: key,
			key,
			position: itemPositions.get(key)
		};
	}), [mergedItems, itemPositions]);
	import_react.useEffect(() => {
		collectItemSize();
	}, [mergedItems, columnCount]);
	const [itemColumns, setItemColumns] = import_react.useState([]);
	useLayoutEffect_default(() => {
		if (onLayoutChange && itemWithPositions.every(({ position: position$2 }) => position$2)) setItemColumns((prevItemColumns) => {
			const nextItemColumns = itemWithPositions.map(({ item, position: position$2 }) => [item, position$2.column]);
			return isEqual_default(prevItemColumns, nextItemColumns) ? prevItemColumns : nextItemColumns;
		});
	}, [itemWithPositions]);
	useLayoutEffect_default(() => {
		if (onLayoutChange && items && items.length === itemColumns.length) onLayoutChange(itemColumns.map(([item, column$1]) => ({
			...item,
			column: column$1
		})));
	}, [itemColumns]);
	return /* @__PURE__ */ import_react.createElement(es_default$2, { onResize: collectItemSize }, /* @__PURE__ */ import_react.createElement("div", {
		ref: containerRef,
		className: clsx(prefixCls, contextClassName, mergedClassNames.root, rootClassName, className, hashId, cssVarCls, { [`${prefixCls}-rtl`]: direction === "rtl" }),
		style: {
			height: totalHeight,
			...mergedStyles.root,
			...contextStyle,
			...style$1
		},
		onLoad: collectItemSize,
		onError: collectItemSize
	}, /* @__PURE__ */ import_react.createElement(CSSMotionList_default, {
		keys: itemWithPositions,
		component: false,
		motionAppear: true,
		motionLeave: true,
		motionName: `${prefixCls}-item-fade`
	}, (motionInfo, motionRef) => {
		const { item, itemKey: itemKey$2, position: position$2 = {}, itemIndex, key, className: motionClassName, style: motionStyle } = motionInfo;
		const { column: columnIndex = 0 } = position$2;
		const itemStyle = {
			"--item-width": `calc((100% + ${horizontalGutter}px) / ${columnCount})`,
			insetInlineStart: `calc(var(--item-width) * ${columnIndex})`,
			width: `calc(var(--item-width) - ${horizontalGutter}px)`,
			top: position$2.top,
			position: "absolute"
		};
		return /* @__PURE__ */ import_react.createElement(MasonryItem_default, {
			prefixCls,
			key,
			item,
			style: {
				...motionStyle,
				...mergedStyles.item,
				...itemStyle
			},
			className: clsx(mergedClassNames.item, motionClassName),
			ref: composeRef(motionRef, (ele) => setItemRef(itemKey$2, ele)),
			index: itemIndex,
			itemRender,
			column: columnIndex,
			onResize: fresh ? collectItemSize : null
		});
	})));
});
Masonry.displayName = "Masonry";
var Masonry_default = Masonry;

//#endregion
//#region node_modules/antd/es/masonry/index.js
var masonry_default = Masonry_default;

//#endregion
//#region node_modules/@rc-component/mentions/es/hooks/useEffectState.js
/**
* Trigger a callback on state change
*/
function useEffectState() {
	const [effectId, setEffectId] = (0, import_react.useState)({
		id: 0,
		callback: null
	});
	const update = (0, import_react.useCallback)((callback) => {
		setEffectId(({ id }) => ({
			id: id + 1,
			callback
		}));
	}, []);
	(0, import_react.useEffect)(() => {
		effectId.callback?.();
	}, [effectId]);
	return update;
}

//#endregion
//#region node_modules/@rc-component/mentions/es/MentionsContext.js
var MentionsContext = /* @__PURE__ */ import_react.createContext(null);
var MentionsContext_default = MentionsContext;

//#endregion
//#region node_modules/@rc-component/mentions/es/DropdownMenu.js
/**
* We only use Menu to display the candidate.
* The focus is controlled by textarea to make accessibility easy.
*/
function DropdownMenu(props) {
	const { notFoundContent, activeIndex, setActiveIndex, selectOption, onFocus, onBlur, onScroll } = import_react.useContext(MentionsContext_default);
	const { prefixCls, options, opened } = props;
	const activeOption = options[activeIndex] || {};
	const menuRef = (0, import_react.useRef)(null);
	(0, import_react.useEffect)(() => {
		if (activeIndex === -1 || !menuRef.current || !opened) return;
		const activeItem = menuRef.current?.findItem?.({ key: activeOption.key });
		if (activeItem) activeItem.scrollIntoView({
			block: "nearest",
			inline: "nearest"
		});
	}, [
		activeIndex,
		activeOption.key,
		opened
	]);
	return /* @__PURE__ */ import_react.createElement(es_default$14, {
		ref: menuRef,
		prefixCls: `${prefixCls}-menu`,
		activeKey: activeOption.key,
		onSelect: ({ key }) => {
			selectOption(options.find(({ key: optionKey }) => optionKey === key));
		},
		onFocus,
		onBlur,
		onScroll
	}, options.map((option, index$1) => {
		const { key, disabled, className, style: style$1, label } = option;
		return /* @__PURE__ */ import_react.createElement(MenuItem_default, {
			key,
			disabled,
			className,
			style: style$1,
			onMouseEnter: () => {
				setActiveIndex(index$1);
			}
		}, label);
	}), !options.length && /* @__PURE__ */ import_react.createElement(MenuItem_default, { disabled: true }, notFoundContent));
}
var DropdownMenu_default = DropdownMenu;

//#endregion
//#region node_modules/@rc-component/mentions/es/KeywordTrigger.js
var BUILT_IN_PLACEMENTS = {
	bottomRight: {
		points: ["tl", "br"],
		offset: [0, 4],
		overflow: {
			adjustX: 1,
			adjustY: 1
		}
	},
	bottomLeft: {
		points: ["tr", "bl"],
		offset: [0, 4],
		overflow: {
			adjustX: 1,
			adjustY: 1
		}
	},
	topRight: {
		points: ["bl", "tr"],
		offset: [0, -4],
		overflow: {
			adjustX: 1,
			adjustY: 1
		}
	},
	topLeft: {
		points: ["br", "tl"],
		offset: [0, -4],
		overflow: {
			adjustX: 1,
			adjustY: 1
		}
	}
};
var KeywordTrigger = (props) => {
	const { prefixCls, options, children, visible, transitionName, getPopupContainer, popupClassName, popupStyle, direction, placement } = props;
	const dropdownPrefix = `${prefixCls}-dropdown`;
	const [opened, setOpened] = import_react.useState(false);
	const dropdownElement = /* @__PURE__ */ import_react.createElement(DropdownMenu_default, {
		prefixCls: dropdownPrefix,
		options,
		opened
	});
	const dropdownPlacement = (0, import_react.useMemo)(() => {
		let popupPlacement;
		if (direction === "rtl") popupPlacement = placement === "top" ? "topLeft" : "bottomLeft";
		else popupPlacement = placement === "top" ? "topRight" : "bottomRight";
		return popupPlacement;
	}, [direction, placement]);
	return /* @__PURE__ */ import_react.createElement(es_default$6, {
		prefixCls: dropdownPrefix,
		popupVisible: visible,
		popup: dropdownElement,
		popupPlacement: dropdownPlacement,
		popupMotion: { motionName: transitionName },
		builtinPlacements: BUILT_IN_PLACEMENTS,
		getPopupContainer,
		popupClassName,
		popupStyle,
		afterOpenChange: setOpened
	}, children);
};
var KeywordTrigger_default = KeywordTrigger;

//#endregion
//#region node_modules/@rc-component/mentions/es/Option.js
var Option$1 = () => null;
var Option_default = Option$1;

//#endregion
//#region node_modules/@rc-component/mentions/es/util.js
/**
* Cut input selection into 2 part and return text before selection start
*/
function getBeforeSelectionText(input) {
	const { selectionStart } = input;
	return input.value.slice(0, selectionStart);
}
/**
* Find the last match prefix index
*/
function getLastMeasureIndex(text, prefix$1) {
	return prefix$1.reduce((lastMatch, prefixStr) => {
		const lastIndex = text.lastIndexOf(prefixStr);
		if (lastIndex > lastMatch.location) return {
			location: lastIndex,
			prefix: prefixStr
		};
		return lastMatch;
	}, {
		location: -1,
		prefix: ""
	});
}
function lower(char$1) {
	return (char$1 || "").toLowerCase();
}
function reduceText(text, targetText, split) {
	const firstChar = text[0];
	if (!firstChar || firstChar === split) return text;
	let restText = text;
	const targetTextLen = targetText.length;
	for (let i = 0; i < targetTextLen; i += 1) if (lower(restText[i]) !== lower(targetText[i])) {
		restText = restText.slice(i);
		break;
	} else if (i === targetTextLen - 1) restText = restText.slice(targetTextLen);
	return restText;
}
/**
* Paint targetText into current text:
*  text: little@litest
*  targetText: light
*  => little @light test
*/
function replaceWithMeasure(text, measureConfig) {
	const { measureLocation, prefix: prefix$1, targetText, selectionStart, split } = measureConfig;
	let beforeMeasureText = text.slice(0, measureLocation);
	if (beforeMeasureText[beforeMeasureText.length - split.length] === split) beforeMeasureText = beforeMeasureText.slice(0, beforeMeasureText.length - split.length);
	if (beforeMeasureText) beforeMeasureText = `${beforeMeasureText}${split}`;
	let restText = reduceText(text.slice(selectionStart), targetText.slice(selectionStart - measureLocation - prefix$1.length), split);
	if (restText.slice(0, split.length) === split) restText = restText.slice(split.length);
	const connectedStartText = `${beforeMeasureText}${prefix$1}${targetText}${split}`;
	return {
		text: `${connectedStartText}${restText}`,
		selectionLocation: connectedStartText.length
	};
}
function setInputSelection(input, location) {
	input.setSelectionRange(location, location);
	/**
	* Reset caret into view.
	* Since this function always called by user control, it's safe to focus element.
	*/
	input.blur();
	input.focus();
}
function validateSearch(text, split) {
	return !split || text.indexOf(split) === -1;
}
function filterOption(input, { value = "" }) {
	const lowerCase = input.toLowerCase();
	return value.toLowerCase().indexOf(lowerCase) !== -1;
}

//#endregion
//#region node_modules/@rc-component/mentions/es/context.js
const UnstableContext$2 = /* @__PURE__ */ import_react.createContext({});

//#endregion
//#region node_modules/@rc-component/mentions/es/Mentions.js
function _extends$29() {
	_extends$29 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$29.apply(this, arguments);
}
var InternalMentions = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	const { prefixCls, className, style: style$1, classNames: mentionClassNames, styles, prefix: prefix$1 = "@", split = " ", notFoundContent = "Not Found", value, defaultValue, children, options, allowClear, hasWrapper, silent, validateSearch: validateSearch$1 = validateSearch, filterOption: filterOption$1 = filterOption, onChange, onKeyDown: onKeyDown$1, onKeyUp, onPressEnter, onSearch, onSelect, onFocus, onBlur, transitionName, placement, direction, getPopupContainer, popupClassName, rows = 1, visible, onPopupScroll, ...restProps } = props;
	const mergedPrefix = (0, import_react.useMemo)(() => Array.isArray(prefix$1) ? prefix$1 : [prefix$1], [prefix$1]);
	const containerRef = (0, import_react.useRef)(null);
	const textareaRef = (0, import_react.useRef)(null);
	const measureRef = (0, import_react.useRef)(null);
	const getTextArea = () => textareaRef.current?.resizableTextArea?.textArea;
	import_react.useImperativeHandle(ref, () => ({
		focus: () => textareaRef.current?.focus(),
		blur: () => textareaRef.current?.blur(),
		textarea: textareaRef.current?.resizableTextArea?.textArea,
		nativeElement: containerRef.current
	}));
	const [measuring, setMeasuring] = (0, import_react.useState)(false);
	const [measureText, setMeasureText] = (0, import_react.useState)("");
	const [measurePrefix, setMeasurePrefix] = (0, import_react.useState)("");
	const [measureLocation, setMeasureLocation] = (0, import_react.useState)(0);
	const [activeIndex, setActiveIndex] = (0, import_react.useState)(0);
	const [isFocus, setIsFocus] = (0, import_react.useState)(false);
	const uniqueKey$1 = useId_default(props.id);
	const [mergedValue, setMergedValue] = useControlledState(defaultValue || "", value);
	const { open: open$2 } = (0, import_react.useContext)(UnstableContext$2);
	(0, import_react.useEffect)(() => {
		if (measuring && measureRef.current) measureRef.current.scrollTop = getTextArea().scrollTop;
	}, [measuring]);
	const [mergedMeasuring, mergedMeasureText, mergedMeasurePrefix, mergedMeasureLocation] = import_react.useMemo(() => {
		if (open$2) for (let i = 0; i < mergedPrefix.length; i += 1) {
			const curPrefix = mergedPrefix[i];
			const index$1 = mergedValue.lastIndexOf(curPrefix);
			if (index$1 >= 0) return [
				true,
				"",
				curPrefix,
				index$1
			];
		}
		return [
			measuring,
			measureText,
			measurePrefix,
			measureLocation
		];
	}, [
		open$2,
		measuring,
		mergedPrefix,
		mergedValue,
		measureText,
		measurePrefix,
		measureLocation
	]);
	const getOptions = import_react.useCallback((targetMeasureText) => {
		let list;
		if (options && options.length > 0) list = options.map((item) => ({
			...item,
			key: `${item?.key ?? item.value}-${uniqueKey$1}`
		}));
		else list = toArray(children).map(({ props: optionProps, key }) => ({
			...optionProps,
			label: optionProps.children,
			key: `${key || optionProps.value}-${uniqueKey$1}`
		}));
		return list.filter((option) => {
			/** Return all result if `filterOption` is false. */
			if (filterOption$1 === false) return true;
			return filterOption$1(targetMeasureText, option);
		});
	}, [
		options,
		uniqueKey$1,
		children,
		filterOption$1
	]);
	const mergedOptions = import_react.useMemo(() => getOptions(mergedMeasureText), [getOptions, mergedMeasureText]);
	const onSelectionEffect = useEffectState();
	const startMeasure = (nextMeasureText, nextMeasurePrefix, nextMeasureLocation) => {
		setMeasuring(true);
		setMeasureText(nextMeasureText);
		setMeasurePrefix(nextMeasurePrefix);
		setMeasureLocation(nextMeasureLocation);
		setActiveIndex(0);
	};
	const stopMeasure = (callback) => {
		setMeasuring(false);
		setMeasureLocation(0);
		setMeasureText("");
		onSelectionEffect(callback);
	};
	const triggerChange = (nextValue) => {
		setMergedValue(nextValue);
		onChange?.(nextValue);
	};
	const onInternalChange = ({ target: { value: nextValue } }) => {
		triggerChange(nextValue);
	};
	const selectOption = (option) => {
		const { value: mentionValue = "" } = option;
		const { text, selectionLocation } = replaceWithMeasure(mergedValue, {
			measureLocation: mergedMeasureLocation,
			targetText: mentionValue,
			prefix: mergedMeasurePrefix,
			selectionStart: getTextArea()?.selectionStart,
			split
		});
		triggerChange(text);
		stopMeasure(() => {
			setInputSelection(getTextArea(), selectionLocation);
		});
		onSelect?.(option, mergedMeasurePrefix);
	};
	const onInternalKeyDown = (event) => {
		const { which } = event;
		onKeyDown$1?.(event);
		if (!mergedMeasuring) return;
		if (which === KeyCode_default.UP || which === KeyCode_default.DOWN) {
			const optionLen = mergedOptions.length;
			setActiveIndex((activeIndex + (which === KeyCode_default.UP ? -1 : 1) + optionLen) % optionLen);
			event.preventDefault();
		} else if (which === KeyCode_default.ESC) stopMeasure();
		else if (which === KeyCode_default.ENTER) {
			event.preventDefault();
			if (silent) return;
			if (!mergedOptions.length) {
				stopMeasure();
				return;
			}
			const option = mergedOptions[activeIndex];
			selectOption(option);
		}
	};
	/**
	* When to start measure:
	* 1. When user press `prefix`
	* 2. When measureText !== prevMeasureText
	*  - If measure hit
	*  - If measuring
	*
	* When to stop measure:
	* 1. Selection is out of range
	* 2. Contains `space`
	* 3. ESC or select one
	*/
	const onInternalKeyUp = (event) => {
		const { key, which } = event;
		const target = event.target;
		const selectionStartText = getBeforeSelectionText(target);
		const { location: measureIndex, prefix: nextMeasurePrefix } = getLastMeasureIndex(selectionStartText, mergedPrefix);
		onKeyUp?.(event);
		if ([
			KeyCode_default.ESC,
			KeyCode_default.UP,
			KeyCode_default.DOWN,
			KeyCode_default.ENTER
		].indexOf(which) !== -1) return;
		if (measureIndex !== -1) {
			const nextMeasureText = selectionStartText.slice(measureIndex + nextMeasurePrefix.length);
			const validateMeasure = validateSearch$1(nextMeasureText, split);
			const matchOption = !!getOptions(nextMeasureText).length;
			if (validateMeasure) {
				if (key === nextMeasurePrefix || key === "Shift" || which === KeyCode_default.ALT || key === "AltGraph" || mergedMeasuring || nextMeasureText !== mergedMeasureText && matchOption) startMeasure(nextMeasureText, nextMeasurePrefix, measureIndex);
			} else if (mergedMeasuring) stopMeasure();
			/**
			* We will trigger `onSearch` to developer since they may use for async update.
			* If met `space` means user finished searching.
			*/
			if (onSearch && validateMeasure) onSearch(nextMeasureText, nextMeasurePrefix);
		} else if (mergedMeasuring) stopMeasure();
	};
	const onInternalPressEnter = (event) => {
		if (!mergedMeasuring && onPressEnter) onPressEnter(event);
	};
	const focusRef = (0, import_react.useRef)();
	const onInternalFocus = (event) => {
		window.clearTimeout(focusRef.current);
		if (!isFocus && event && onFocus) onFocus(event);
		setIsFocus(true);
	};
	const onInternalBlur = (event) => {
		focusRef.current = window.setTimeout(() => {
			setIsFocus(false);
			stopMeasure();
			onBlur?.(event);
		}, 0);
	};
	const onDropdownFocus = () => {
		onInternalFocus();
	};
	const onDropdownBlur = () => {
		onInternalBlur();
	};
	const onInternalPopupScroll = (event) => {
		onPopupScroll?.(event);
	};
	const mergedStyles = import_react.useMemo(() => {
		const resizeStyle = styles?.textarea?.resize ?? style$1?.resize;
		const mergedTextareaStyle = { ...styles?.textarea };
		if (resizeStyle !== void 0) mergedTextareaStyle.resize = resizeStyle;
		return {
			...styles,
			textarea: mergedTextareaStyle
		};
	}, [style$1, styles]);
	const mentionNode = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(es_default$13, _extends$29({
		classNames: { textarea: mentionClassNames?.textarea },
		styles: mergedStyles,
		ref: textareaRef,
		value: mergedValue
	}, restProps, {
		rows,
		onChange: onInternalChange,
		onKeyDown: onInternalKeyDown,
		onKeyUp: onInternalKeyUp,
		onPressEnter: onInternalPressEnter,
		onFocus: onInternalFocus,
		onBlur: onInternalBlur
	})), mergedMeasuring && /* @__PURE__ */ import_react.createElement("div", {
		ref: measureRef,
		className: `${prefixCls}-measure`
	}, mergedValue.slice(0, mergedMeasureLocation), /* @__PURE__ */ import_react.createElement(MentionsContext_default.Provider, { value: {
		notFoundContent,
		activeIndex,
		setActiveIndex,
		selectOption,
		onFocus: onDropdownFocus,
		onBlur: onDropdownBlur,
		onScroll: onInternalPopupScroll
	} }, /* @__PURE__ */ import_react.createElement(KeywordTrigger_default, {
		prefixCls,
		transitionName,
		placement,
		direction,
		options: mergedOptions,
		visible: true,
		getPopupContainer,
		popupClassName: clsx(popupClassName, mentionClassNames?.popup),
		popupStyle: styles?.popup
	}, /* @__PURE__ */ import_react.createElement("span", null, mergedMeasurePrefix))), mergedValue.slice(mergedMeasureLocation + mergedMeasurePrefix.length)));
	if (!hasWrapper) return /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(prefixCls, className),
		style: style$1,
		ref: containerRef
	}, mentionNode);
	return mentionNode;
});
var Mentions$1 = /* @__PURE__ */ (0, import_react.forwardRef)(({ suffix, prefixCls = "rc-mentions", defaultValue, value: customValue, id, allowClear, onChange, classNames: mentionsClassNames, styles, className, disabled, onClear, ...rest }, ref) => {
	const hasSuffix = !!(suffix || allowClear);
	const holderRef = (0, import_react.useRef)(null);
	const mentionRef = (0, import_react.useRef)(null);
	(0, import_react.useImperativeHandle)(ref, () => ({
		...mentionRef.current,
		nativeElement: holderRef.current?.nativeElement || mentionRef.current?.nativeElement
	}));
	const [mergedValue, setMergedValue] = useControlledState(defaultValue || "", customValue);
	const triggerChange = (currentValue) => {
		setMergedValue(currentValue);
		onChange?.(currentValue);
	};
	const handleReset = () => {
		triggerChange("");
	};
	return /* @__PURE__ */ import_react.createElement(BaseInput_default, {
		suffix,
		prefixCls,
		value: mergedValue,
		allowClear,
		handleReset,
		className: clsx(prefixCls, className, { [`${prefixCls}-has-suffix`]: hasSuffix }),
		classNames: mentionsClassNames,
		disabled,
		ref: holderRef,
		onClear
	}, /* @__PURE__ */ import_react.createElement(InternalMentions, _extends$29({
		className: mentionsClassNames?.mentions,
		styles,
		classNames: mentionsClassNames,
		prefixCls,
		id,
		ref: mentionRef,
		onChange: triggerChange,
		disabled,
		hasWrapper: hasSuffix
	}, rest)));
});
Mentions$1.Option = Option_default;
var Mentions_default = Mentions$1;

//#endregion
//#region node_modules/@rc-component/mentions/es/index.js
var es_default$12 = Mentions_default;

//#endregion
//#region node_modules/antd/es/_util/toList.js
var toList$1 = (candidate, skipEmpty = false) => {
	if (skipEmpty && !isNonNullable_default(candidate)) return [];
	return Array.isArray(candidate) ? candidate : [candidate];
};
var toList_default = toList$1;

//#endregion
//#region node_modules/antd/es/mentions/style/index.js
var genDropdownStyle = (token$1) => {
	const { componentCls, fontSize, paddingXXS, colorBgElevated, borderRadiusLG, boxShadowSecondary, itemPaddingVertical, controlPaddingHorizontal, colorText, borderRadius, lineHeight, colorTextDisabled, controlItemBgHover, motionDurationSlow } = token$1;
	return { [componentCls]: { "&-dropdown": {
		...resetComponent(token$1),
		position: "absolute",
		top: -9999,
		insetInlineStart: -9999,
		zIndex: token$1.zIndexPopup,
		boxSizing: "border-box",
		fontSize,
		fontVariant: "initial",
		padding: paddingXXS,
		backgroundColor: colorBgElevated,
		borderRadius: borderRadiusLG,
		outline: "none",
		boxShadow: boxShadowSecondary,
		"&-hidden": { display: "none" },
		[`${componentCls}-dropdown-menu`]: {
			maxHeight: token$1.dropdownHeight,
			margin: 0,
			paddingInlineStart: 0,
			overflow: "auto",
			listStyle: "none",
			outline: "none",
			"&-item": {
				...textEllipsis,
				position: "relative",
				display: "block",
				minWidth: token$1.controlItemWidth,
				padding: `${unit(itemPaddingVertical)} ${unit(controlPaddingHorizontal)}`,
				color: colorText,
				borderRadius,
				fontWeight: "normal",
				lineHeight,
				cursor: "pointer",
				transition: `background ${motionDurationSlow} ease`,
				"&:hover": { backgroundColor: controlItemBgHover },
				"&-disabled": {
					color: colorTextDisabled,
					cursor: "not-allowed",
					"&:hover": {
						color: colorTextDisabled,
						backgroundColor: controlItemBgHover,
						cursor: "not-allowed"
					}
				},
				"&-selected": {
					color: colorText,
					fontWeight: token$1.fontWeightStrong,
					backgroundColor: controlItemBgHover
				},
				"&-active": { backgroundColor: controlItemBgHover }
			}
		}
	} } };
};
var genMentionsStyle = (token$1) => {
	const { componentCls, calc, colorText, antCls, colorTextDisabled } = token$1;
	return { [componentCls]: [
		resetComponent(token$1),
		genBasicInputStyle(token$1, {
			largeStyle: { padding: void 0 },
			smallStyle: { padding: void 0 }
		}),
		genOutlinedStyle(token$1),
		genFilledStyle(token$1),
		genBorderlessStyle(token$1),
		genUnderlinedStyle(token$1),
		{
			"--mentions-padding-inline": token$1.paddingInline,
			"--mentions-padding-block": token$1.paddingBlock,
			"--mentions-control-height": token$1.controlHeight,
			display: "flex",
			padding: 0,
			whiteSpace: "pre-wrap",
			"> textarea": [
				resetComponent(token$1),
				genPlaceholderStyle(token$1.colorTextPlaceholder),
				{
					background: "transparent",
					border: "none",
					borderRadius: "inherit",
					outline: "none",
					flex: "auto",
					minWidth: 0,
					resize: "none",
					"&:disabled": { color: colorTextDisabled }
				}
			],
			[`> textarea, ${componentCls}-measure`]: {
				color: colorText,
				boxSizing: "border-box",
				margin: 0,
				minHeight: calc("var(--mentions-control-height)").sub(calc(token$1.lineWidth).mul(2).equal()).equal(),
				paddingInline: "var(--mentions-padding-inline)",
				paddingBlock: "var(--mentions-padding-block)",
				overflow: "inherit",
				overflowX: "hidden",
				overflowY: "auto",
				fontWeight: "inherit",
				fontSize: "inherit",
				fontFamily: "inherit",
				fontStyle: "inherit",
				fontVariant: "inherit",
				fontSizeAdjust: "inherit",
				fontStretch: "inherit",
				lineHeight: "inherit",
				direction: "inherit",
				letterSpacing: "inherit",
				whiteSpace: "inherit",
				textAlign: "inherit",
				verticalAlign: "top",
				wordWrap: "break-word",
				wordBreak: "inherit",
				tabSize: "inherit"
			},
			[`${componentCls}-measure`]: {
				position: "absolute",
				inset: 0,
				zIndex: -1,
				color: "transparent",
				pointerEvents: "none",
				"> span": {
					display: "inline-block",
					minHeight: "1em"
				}
			},
			[`${componentCls}-suffix`]: {
				display: "inline-flex",
				alignItems: "center",
				flex: "none",
				color: token$1.colorTextQuaternary,
				fontSize: token$1.fontSizeIcon,
				lineHeight: 1,
				position: "absolute",
				top: "50%",
				transform: "translateY(-50%)",
				insetInlineEnd: "var(--mentions-padding-inline)",
				columnGap: token$1.marginXS,
				[`${componentCls}-clear-icon`]: {
					cursor: "pointer",
					border: 0,
					background: "transparent",
					"&:hover": { color: token$1.colorIcon },
					"&:active": { color: token$1.colorText },
					"&-hidden": { visibility: "hidden" }
				},
				[`${antCls}-form-item-feedback-icon`]: {
					display: "inline-flex",
					alignItems: "center",
					justifyContent: "center"
				}
			}
		},
		{ "&-has-suffix": { "> textarea": { paddingInlineEnd: calc(token$1.paddingXXS).mul(1.5).add(token$1.fontSizeIcon).add("var(--mentions-padding-inline)").equal() } } },
		{ "&-disabled": { "> textarea": { ...genDisabledStyle(token$1) } } },
		{
			"&-lg": {
				"--mentions-padding-inline": token$1.paddingInlineLG,
				"--mentions-padding-block": token$1.paddingBlockLG,
				"--mentions-control-height": token$1.controlHeightLG
			},
			"&-sm": {
				"--mentions-padding-inline": token$1.paddingInlineSM,
				"--mentions-padding-block": token$1.paddingBlockSM,
				"--mentions-control-height": token$1.controlHeightSM
			}
		}
	] };
};
const prepareComponentToken$17 = (token$1) => ({
	...initComponentToken$1(token$1),
	dropdownHeight: 250,
	controlItemWidth: 100,
	zIndexPopup: token$1.zIndexPopupBase + 50,
	itemPaddingVertical: (token$1.controlHeight - token$1.fontHeight) / 2
});
var style_default$19 = genStyleHooks("Mentions", (token$1) => {
	const mentionsToken = merge(token$1, initInputToken(token$1));
	return [genMentionsStyle(mentionsToken), genDropdownStyle(mentionsToken)];
}, prepareComponentToken$17);

//#endregion
//#region node_modules/antd/es/mentions/index.js
const { Option } = es_default$12;
function loadingFilterOption() {
	return true;
}
var Mentions = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, disabled: customDisabled, loading, filterOption: filterOption$1, children, notFoundContent, options, status: customStatus, allowClear = false, popupClassName, style: style$1, variant: customVariant, classNames, styles, size: customSize, ...restProps } = props;
	const [focused, setFocused] = import_react.useState(false);
	const mergedRef = composeRef(ref, import_react.useRef(null));
	const mergedSize = useSize_default((ctx) => customSize ?? ctx);
	devUseWarning("Mentions").deprecated(!children, "Mentions.Option", "options");
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("mentions");
	const { renderEmpty } = import_react.useContext(ConfigContext);
	const { status: contextStatus, hasFeedback, feedbackIcon } = import_react.useContext(FormItemInputContext);
	const mergedStatus = getMergedStatus(contextStatus, customStatus);
	const contextDisabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = customDisabled ?? contextDisabled;
	const prefixCls = getPrefixCls("mentions", customizePrefixCls);
	const mergedProps = {
		...props,
		disabled: mergedDisabled,
		status: mergedStatus,
		loading,
		options,
		variant: customVariant
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const onFocus = (...args) => {
		if (restProps.onFocus) restProps.onFocus.apply(restProps, args);
		setFocused(true);
	};
	const onBlur = (...args) => {
		if (restProps.onBlur) restProps.onBlur.apply(restProps, args);
		setFocused(false);
	};
	const notFoundContentEle = import_react.useMemo(() => {
		if (notFoundContent !== void 0) return notFoundContent;
		return renderEmpty?.("Select") || /* @__PURE__ */ import_react.createElement(defaultRenderEmpty_default, { componentName: "Select" });
	}, [notFoundContent, renderEmpty]);
	const mentionOptions = import_react.useMemo(() => {
		if (loading) return /* @__PURE__ */ import_react.createElement(Option, {
			value: "ANTD_SEARCHING",
			disabled: true
		}, /* @__PURE__ */ import_react.createElement(spin_default, { size: "small" }));
		return children;
	}, [loading, children]);
	const mergedOptions = loading ? [{
		value: "ANTD_SEARCHING",
		disabled: true,
		label: /* @__PURE__ */ import_react.createElement(spin_default, { size: "small" })
	}] : options;
	const mentionsfilterOption = loading ? loadingFilterOption : filterOption$1;
	const mergedAllowClear = getAllowClear_default(allowClear);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$19(prefixCls, rootCls);
	const [variant, enableVariantCls] = useVariants_default("mentions", customVariant);
	const suffixNode = hasFeedback && /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, feedbackIcon);
	const mergedClassName = clsx(contextClassName, className, rootClassName, cssVarCls, rootCls, mergedClassNames.root, {
		[`${prefixCls}-sm`]: mergedSize === "small",
		[`${prefixCls}-lg`]: mergedSize === "large"
	});
	return /* @__PURE__ */ import_react.createElement(es_default$12, {
		silent: loading,
		prefixCls,
		notFoundContent: notFoundContentEle,
		className: mergedClassName,
		disabled: mergedDisabled,
		allowClear: mergedAllowClear,
		direction,
		style: {
			...mergedStyles.root,
			...contextStyle,
			...style$1
		},
		...restProps,
		filterOption: mentionsfilterOption,
		onFocus,
		onBlur,
		ref: mergedRef,
		options: mergedOptions,
		suffix: suffixNode,
		styles: {
			textarea: mergedStyles.textarea,
			popup: mergedStyles.popup,
			suffix: mergedStyles.suffix
		},
		classNames: {
			textarea: clsx(mergedClassNames.textarea),
			popup: clsx(mergedClassNames.popup, popupClassName, rootClassName, hashId, cssVarCls, rootCls),
			suffix: mergedClassNames.suffix,
			mentions: clsx({
				[`${prefixCls}-disabled`]: mergedDisabled,
				[`${prefixCls}-focused`]: focused,
				[`${prefixCls}-rtl`]: direction === "rtl"
			}, hashId),
			variant: clsx({ [`${prefixCls}-${variant}`]: enableVariantCls }, getStatusClassNames(prefixCls, mergedStatus)),
			affixWrapper: hashId
		}
	}, mentionOptions);
});
Mentions.displayName = "Mentions";
Mentions.Option = Option;
Mentions._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default(Mentions, void 0, void 0, "mentions");
Mentions.getMentions = (value = "", config = {}) => {
	const { prefix: prefix$1 = "@", split = " " } = config;
	const prefixList = toList_default(prefix$1);
	return value.split(split).map((str = "") => {
		let hitPrefix = null;
		prefixList.some((prefixStr) => {
			if (str.slice(0, prefixStr.length) === prefixStr) {
				hitPrefix = prefixStr;
				return true;
			}
			return false;
		});
		if (hitPrefix !== null) return {
			prefix: hitPrefix,
			value: str.slice(hitPrefix.length)
		};
		return null;
	}).filter((entity) => !!entity && !!entity.value);
};
var mentions_default = Mentions;

//#endregion
//#region node_modules/antd/es/message/index.js
var message = null;
var act$1 = (callback) => callback();
var taskQueue$1 = [];
var defaultGlobalConfig$1 = {};
function getGlobalContext$1() {
	const { getContainer, duration, rtl, maxCount, top } = defaultGlobalConfig$1;
	const mergedContainer = getContainer?.() || document.body;
	return {
		getContainer: () => mergedContainer,
		duration,
		rtl,
		maxCount,
		top
	};
}
var GlobalHolder$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { messageConfig, sync } = props;
	const { getPrefixCls } = (0, import_react.useContext)(ConfigContext);
	const prefixCls = defaultGlobalConfig$1.prefixCls || getPrefixCls("message");
	const appConfig = (0, import_react.useContext)(AppConfigContext);
	const [api, holder] = useInternalMessage({
		...messageConfig,
		prefixCls,
		...appConfig.message
	});
	import_react.useImperativeHandle(ref, () => {
		const instance = { ...api };
		Object.keys(instance).forEach((method$1) => {
			instance[method$1] = (...args) => {
				sync();
				return api[method$1].apply(api, args);
			};
		});
		return {
			instance,
			sync
		};
	});
	return holder;
});
var GlobalHolderWrapper$1 = /* @__PURE__ */ import_react.forwardRef((_, ref) => {
	const [messageConfig, setMessageConfig] = import_react.useState(getGlobalContext$1);
	const sync = () => {
		setMessageConfig(getGlobalContext$1);
	};
	import_react.useEffect(sync, []);
	const global = globalConfig();
	const rootPrefixCls = global.getRootPrefixCls();
	const rootIconPrefixCls = global.getIconPrefixCls();
	const theme = global.getTheme();
	const dom = /* @__PURE__ */ import_react.createElement(GlobalHolder$1, {
		ref,
		sync,
		messageConfig
	});
	return /* @__PURE__ */ import_react.createElement(config_provider_default, {
		prefixCls: rootPrefixCls,
		iconPrefixCls: rootIconPrefixCls,
		theme
	}, global.holderRender ? global.holderRender(dom) : dom);
});
var flushMessageQueue = () => {
	if (!message) {
		const holderFragment = document.createDocumentFragment();
		const newMessage = { fragment: holderFragment };
		message = newMessage;
		act$1(() => {
			render(/* @__PURE__ */ import_react.createElement(GlobalHolderWrapper$1, { ref: (node$1) => {
				const { instance, sync } = node$1 || {};
				Promise.resolve().then(() => {
					if (!newMessage.instance && instance) {
						newMessage.instance = instance;
						newMessage.sync = sync;
						flushMessageQueue();
					}
				});
			} }), holderFragment);
		});
		return;
	}
	if (!message.instance) return;
	taskQueue$1.forEach((task) => {
		const { type: type$2, skipped } = task;
		if (!skipped) switch (type$2) {
			case "open":
				act$1(() => {
					const closeFn = message.instance.open({
						...defaultGlobalConfig$1,
						...task.config
					});
					closeFn?.then(task.resolve);
					task.setCloseFn(closeFn);
				});
				break;
			case "destroy":
				act$1(() => {
					message?.instance.destroy(task.key);
				});
				break;
			default: act$1(() => {
				var _message$instance;
				const closeFn = (_message$instance = message.instance)[type$2].apply(_message$instance, _toConsumableArray(task.args));
				closeFn?.then(task.resolve);
				task.setCloseFn(closeFn);
			});
		}
	});
	taskQueue$1 = [];
};
function setMessageGlobalConfig(config) {
	defaultGlobalConfig$1 = {
		...defaultGlobalConfig$1,
		...config
	};
	act$1(() => {
		message?.sync?.();
	});
}
function open$1(config) {
	const result = wrapPromiseFn((resolve) => {
		let closeFn;
		const task = {
			type: "open",
			config,
			resolve,
			setCloseFn: (fn) => {
				closeFn = fn;
			}
		};
		taskQueue$1.push(task);
		return () => {
			if (closeFn) act$1(() => {
				closeFn();
			});
			else task.skipped = true;
		};
	});
	flushMessageQueue();
	return result;
}
function typeOpen(type$2, args) {
	if (!globalConfig().holderRender) warnContext("message");
	const result = wrapPromiseFn((resolve) => {
		let closeFn;
		const task = {
			type: type$2,
			args,
			resolve,
			setCloseFn: (fn) => {
				closeFn = fn;
			}
		};
		taskQueue$1.push(task);
		return () => {
			if (closeFn) act$1(() => {
				closeFn();
			});
			else task.skipped = true;
		};
	});
	flushMessageQueue();
	return result;
}
var destroy$1 = (key) => {
	taskQueue$1.push({
		type: "destroy",
		key
	});
	flushMessageQueue();
};
var methods$1 = [
	"success",
	"info",
	"warning",
	"error",
	"loading"
];
var staticMethods$1 = {
	open: open$1,
	destroy: destroy$1,
	config: setMessageGlobalConfig,
	useMessage,
	_InternalPanelDoNotUseOrYouWillBeFired: PurePanel_default$6
};
methods$1.forEach((type$2) => {
	staticMethods$1[type$2] = (...args) => typeOpen(type$2, args);
});
var message_default = staticMethods$1;

//#endregion
//#region node_modules/antd/es/modal/PurePanel.js
var PurePanel$4 = (props) => {
	const { prefixCls: customizePrefixCls, className, closeIcon, closable, type: type$2, title, children, footer, ...restProps } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const rootPrefixCls = getPrefixCls();
	const prefixCls = customizePrefixCls || getPrefixCls("modal");
	const rootCls = useCSSVarCls_default(rootPrefixCls);
	const [hashId, cssVarCls] = style_default$18(prefixCls, rootCls);
	const confirmPrefixCls = `${prefixCls}-confirm`;
	let additionalProps = {};
	if (type$2) additionalProps = {
		closable: closable ?? false,
		title: "",
		footer: "",
		children: /* @__PURE__ */ import_react.createElement(ConfirmContent, {
			...props,
			prefixCls,
			confirmPrefixCls,
			rootPrefixCls,
			content: children
		})
	};
	else additionalProps = {
		closable: closable ?? true,
		title,
		footer: footer !== null && /* @__PURE__ */ import_react.createElement(Footer$1, { ...props }),
		children
	};
	return /* @__PURE__ */ import_react.createElement(Panel_default$2, {
		prefixCls,
		className: clsx(hashId, `${prefixCls}-pure-panel`, type$2 && confirmPrefixCls, type$2 && `${confirmPrefixCls}-${type$2}`, className, cssVarCls, rootCls),
		...restProps,
		closeIcon: renderCloseIcon(prefixCls, closeIcon),
		closable,
		...additionalProps
	});
};
var PurePanel_default$5 = withPureRenderTheme(PurePanel$4);

//#endregion
//#region node_modules/antd/es/modal/index.js
function modalWarn(props) {
	return confirm(withWarn(props));
}
var Modal = Modal_default;
Modal.useModal = useModal_default;
Modal.info = function infoFn(props) {
	return confirm(withInfo(props));
};
Modal.success = function successFn(props) {
	return confirm(withSuccess(props));
};
Modal.error = function errorFn(props) {
	return confirm(withError(props));
};
Modal.warning = modalWarn;
Modal.warn = modalWarn;
Modal.confirm = function confirmFn(props) {
	return confirm(withConfirm(props));
};
Modal.destroyAll = function destroyAllFn() {
	while (destroyFns_default.length) {
		const close = destroyFns_default.pop();
		if (close) close();
	}
};
Modal.config = modalGlobalConfig;
Modal._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default$5;
Modal.displayName = "Modal";
var modal_default = Modal;

//#endregion
//#region node_modules/antd/es/notification/index.js
var notification = null;
var act = (callback) => callback();
var taskQueue = [];
var defaultGlobalConfig = {};
function getGlobalContext() {
	const { getContainer, rtl, maxCount, top, bottom, showProgress, pauseOnHover } = defaultGlobalConfig;
	const mergedContainer = getContainer?.() || document.body;
	return {
		getContainer: () => mergedContainer,
		rtl,
		maxCount,
		top,
		bottom,
		showProgress,
		pauseOnHover
	};
}
var GlobalHolder = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { notificationConfig, sync } = props;
	const { getPrefixCls } = (0, import_react.useContext)(ConfigContext);
	const prefixCls = defaultGlobalConfig.prefixCls || getPrefixCls("notification");
	const appConfig = (0, import_react.useContext)(AppConfigContext);
	const [api, holder] = useInternalNotification({
		...notificationConfig,
		prefixCls,
		...appConfig.notification
	});
	import_react.useEffect(sync, []);
	import_react.useImperativeHandle(ref, () => {
		const instance = { ...api };
		Object.keys(instance).forEach((method$1) => {
			instance[method$1] = (...args) => {
				sync();
				return api[method$1].apply(api, args);
			};
		});
		return {
			instance,
			sync
		};
	});
	return holder;
});
var GlobalHolderWrapper = /* @__PURE__ */ import_react.forwardRef((_, ref) => {
	const [notificationConfig, setNotificationConfig] = import_react.useState(getGlobalContext);
	const sync = () => {
		setNotificationConfig(getGlobalContext);
	};
	import_react.useEffect(sync, []);
	const global = globalConfig();
	const rootPrefixCls = global.getRootPrefixCls();
	const rootIconPrefixCls = global.getIconPrefixCls();
	const theme = global.getTheme();
	const dom = /* @__PURE__ */ import_react.createElement(GlobalHolder, {
		ref,
		sync,
		notificationConfig
	});
	return /* @__PURE__ */ import_react.createElement(config_provider_default, {
		prefixCls: rootPrefixCls,
		iconPrefixCls: rootIconPrefixCls,
		theme
	}, global.holderRender ? global.holderRender(dom) : dom);
});
var flushNotificationQueue = () => {
	if (!notification) {
		const holderFragment = document.createDocumentFragment();
		const newNotification = { fragment: holderFragment };
		notification = newNotification;
		act(() => {
			render(/* @__PURE__ */ import_react.createElement(GlobalHolderWrapper, { ref: (node$1) => {
				const { instance, sync } = node$1 || {};
				Promise.resolve().then(() => {
					if (!newNotification.instance && instance) {
						newNotification.instance = instance;
						newNotification.sync = sync;
						flushNotificationQueue();
					}
				});
			} }), holderFragment);
		});
		return;
	}
	if (!notification.instance) return;
	taskQueue.forEach((task) => {
		switch (task.type) {
			case "open":
				act(() => {
					notification.instance.open({
						...defaultGlobalConfig,
						...task.config
					});
				});
				break;
			case "destroy":
				act(() => {
					notification?.instance?.destroy(task.key);
				});
				break;
		}
	});
	taskQueue = [];
};
function setNotificationGlobalConfig(config) {
	defaultGlobalConfig = {
		...defaultGlobalConfig,
		...config
	};
	act(() => {
		notification?.sync?.();
	});
}
function open(config) {
	if (!globalConfig().holderRender) warnContext("notification");
	taskQueue.push({
		type: "open",
		config
	});
	flushNotificationQueue();
}
var destroy = (key) => {
	taskQueue.push({
		type: "destroy",
		key
	});
	flushNotificationQueue();
};
var methods = [
	"success",
	"info",
	"warning",
	"error"
];
var staticMethods = {
	open,
	destroy,
	config: setNotificationGlobalConfig,
	useNotification,
	_InternalPanelDoNotUseOrYouWillBeFired: PurePanel_default$4
};
methods.forEach((type$2) => {
	staticMethods[type$2] = (config) => open({
		...config,
		type: type$2
	});
});
var notification_default = staticMethods;

//#endregion
//#region node_modules/antd/es/popconfirm/style/index.js
var genBaseStyle$7 = (token$1) => {
	const { componentCls, iconCls, antCls, zIndexPopup, colorText, colorWarning, marginXXS, marginXS, fontSize, fontWeightStrong, colorTextHeading } = token$1;
	return { [componentCls]: {
		zIndex: zIndexPopup,
		[`&${antCls}-popover`]: { fontSize },
		[`${componentCls}-message`]: {
			marginBottom: marginXS,
			display: "flex",
			flexWrap: "nowrap",
			alignItems: "start",
			[`> ${componentCls}-message-icon ${iconCls}`]: {
				color: colorWarning,
				fontSize,
				lineHeight: 1,
				marginInlineEnd: marginXS
			},
			[`${componentCls}-title`]: {
				fontWeight: fontWeightStrong,
				color: colorTextHeading,
				"&:only-child": { fontWeight: "normal" }
			},
			[`${componentCls}-description`]: {
				marginTop: marginXXS,
				color: colorText
			}
		},
		[`${componentCls}-buttons`]: {
			textAlign: "end",
			whiteSpace: "nowrap",
			button: { marginInlineStart: marginXS }
		}
	} };
};
const prepareComponentToken$16 = (token$1) => {
	const { zIndexPopupBase } = token$1;
	return { zIndexPopup: zIndexPopupBase + 60 };
};
var style_default$17 = genStyleHooks("Popconfirm", (token$1) => genBaseStyle$7(token$1), prepareComponentToken$16, { resetStyle: false });

//#endregion
//#region node_modules/antd/es/popconfirm/PurePanel.js
const Overlay = (props) => {
	const { prefixCls, okButtonProps, cancelButtonProps, title, description, cancelText, okText, okType = "primary", icon = /* @__PURE__ */ import_react.createElement(ExclamationCircleFilled_default, null), showCancel = true, close, onConfirm, onCancel, onPopupClick, classNames, styles } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const [contextLocale] = useLocale_default("Popconfirm", en_US_default.Popconfirm);
	const titleNode = getRenderPropValue(title);
	const descriptionNode = getRenderPropValue(description);
	return /* @__PURE__ */ import_react.createElement("div", {
		className: `${prefixCls}-inner-content`,
		onClick: onPopupClick
	}, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-message` }, icon && /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-message-icon` }, icon), /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-message-text` }, titleNode && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-title`, classNames?.title),
		style: styles?.title
	}, titleNode), descriptionNode && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-description`, classNames?.content),
		style: styles?.content
	}, descriptionNode))), /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-buttons` }, showCancel && /* @__PURE__ */ import_react.createElement(Button_default, {
		onClick: onCancel,
		size: "small",
		...cancelButtonProps
	}, cancelText || contextLocale?.cancelText), /* @__PURE__ */ import_react.createElement(ActionButton_default, {
		buttonProps: {
			size: "small",
			...convertLegacyProps(okType),
			...okButtonProps
		},
		actionFn: onConfirm,
		close,
		prefixCls: getPrefixCls("btn"),
		quitOnNullishReturnValue: true,
		emitEvent: true
	}, okText || contextLocale?.okText)));
};
var PurePanel$3 = (props) => {
	const { prefixCls: customizePrefixCls, placement, className, style: style$1, ...restProps } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("popconfirm", customizePrefixCls);
	style_default$17(prefixCls);
	return /* @__PURE__ */ import_react.createElement(PurePanel_default$3, {
		placement,
		className: clsx(prefixCls, className),
		style: style$1,
		content: /* @__PURE__ */ import_react.createElement(Overlay, {
			prefixCls,
			...restProps
		})
	});
};
var PurePanel_default$2 = PurePanel$3;

//#endregion
//#region node_modules/antd/es/popconfirm/index.js
var Popconfirm = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, placement = "top", trigger, okType = "primary", icon = /* @__PURE__ */ import_react.createElement(ExclamationCircleFilled_default, null), children, overlayClassName, onOpenChange, overlayStyle, styles, arrow: popconfirmArrow, classNames, ...restProps } = props;
	const { getPrefixCls, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles, arrow: contextArrow, trigger: contextTrigger } = useComponentConfig("popconfirm");
	const [open$2, setOpen] = useControlledState(props.defaultOpen ?? false, props.open);
	const mergedArrow = useMergedArrow_default(popconfirmArrow, contextArrow);
	const mergedTrigger = trigger || contextTrigger || "click";
	const settingOpen = (value, e$2) => {
		setOpen(value);
		onOpenChange?.(value, e$2);
	};
	const close = (e$2) => {
		settingOpen(false, e$2);
	};
	const onConfirm = (e$2) => props.onConfirm?.call(void 0, e$2);
	const onCancel = (e$2) => {
		settingOpen(false, e$2);
		props.onCancel?.call(void 0, e$2);
	};
	const onInternalOpenChange = (value, e$2) => {
		const { disabled = false } = props;
		if (disabled) return;
		settingOpen(value, e$2);
	};
	const prefixCls = getPrefixCls("popconfirm", customizePrefixCls);
	const mergedProps = {
		...props,
		placement,
		trigger: mergedTrigger,
		okType,
		overlayStyle,
		styles,
		classNames
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const rootClassNames = clsx(prefixCls, contextClassName, overlayClassName, mergedClassNames.root);
	style_default$17(prefixCls);
	return /* @__PURE__ */ import_react.createElement(popover_default, {
		arrow: mergedArrow,
		...omit(restProps, ["title"]),
		trigger: mergedTrigger,
		placement,
		onOpenChange: onInternalOpenChange,
		open: open$2,
		ref,
		classNames: {
			root: rootClassNames,
			container: mergedClassNames.container,
			arrow: mergedClassNames.arrow
		},
		styles: {
			root: {
				...contextStyle,
				...mergedStyles.root,
				...overlayStyle
			},
			container: mergedStyles.container,
			arrow: mergedStyles.arrow
		},
		content: /* @__PURE__ */ import_react.createElement(Overlay, {
			okType,
			icon,
			...props,
			prefixCls,
			close,
			onConfirm,
			onCancel,
			classNames: mergedClassNames,
			styles: mergedStyles
		}),
		"data-popover-inject": true
	}, children);
});
/* istanbul ignore next */
Popconfirm._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default$2;
Popconfirm.displayName = "Popconfirm";
var popconfirm_default = Popconfirm;

//#endregion
//#region node_modules/@rc-component/progress/es/common.js
const defaultProps = {
	percent: 0,
	prefixCls: "rc-progress",
	strokeColor: "#2db7f5",
	strokeLinecap: "round",
	strokeWidth: 1,
	railColor: "#D9D9D9",
	railWidth: 1,
	gapPosition: "bottom",
	loading: false
};
const useTransitionDuration = () => {
	const pathsRef = (0, import_react.useRef)([]);
	const prevTimeStamp = (0, import_react.useRef)(null);
	(0, import_react.useEffect)(() => {
		const now$1 = Date.now();
		let updated = false;
		pathsRef.current.forEach((path$1) => {
			if (!path$1) return;
			updated = true;
			const pathStyle = path$1.style;
			pathStyle.transitionDuration = ".3s, .3s, .3s, .06s";
			if (prevTimeStamp.current && now$1 - prevTimeStamp.current < 100) pathStyle.transitionDuration = "0s, 0s";
		});
		if (updated) prevTimeStamp.current = Date.now();
	});
	return pathsRef.current;
};

//#endregion
//#region node_modules/@rc-component/progress/es/utils/getIndeterminateLine.js
var getIndeterminateLine_default = ((options) => {
	const { id, percent, strokeLinecap, strokeWidth, loading } = options;
	if (!loading) return {
		indeterminateStyleProps: {},
		indeterminateStyleAnimation: null
	};
	const animationName = `${id}-indeterminate-animate`;
	const strokeDashOffset = 100 - (percent + (strokeLinecap === "round" ? strokeWidth : 0));
	return {
		indeterminateStyleProps: {
			strokeDasharray: `${percent} 100`,
			animation: `${animationName} .6s linear alternate infinite`,
			strokeDashoffset: 0
		},
		indeterminateStyleAnimation: /* @__PURE__ */ import_react.createElement("style", null, `@keyframes ${animationName} {
            0% { stroke-dashoffset: 0; }
            100% { stroke-dashoffset: -${strokeDashOffset};
          }`)
	};
});

//#endregion
//#region node_modules/@rc-component/progress/es/Line.js
function _extends$28() {
	_extends$28 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$28.apply(this, arguments);
}
var Line$1 = (props) => {
	const { id, className, percent, prefixCls, strokeColor, strokeLinecap, strokeWidth, style: style$1, railColor, railWidth, transition, loading, ...restProps } = {
		...defaultProps,
		...props
	};
	const mergedId = useId_default(id);
	delete restProps.gapPosition;
	const percentList = Array.isArray(percent) ? percent : [percent];
	const strokeColorList = Array.isArray(strokeColor) ? strokeColor : [strokeColor];
	const paths = useTransitionDuration();
	const center = strokeWidth / 2;
	const right = 100 - strokeWidth / 2;
	const pathString = `M ${strokeLinecap === "round" ? center : 0},${center}
         L ${strokeLinecap === "round" ? right : 100},${center}`;
	const viewBoxString = `0 0 100 ${strokeWidth}`;
	let stackPtg = 0;
	const { indeterminateStyleProps, indeterminateStyleAnimation } = getIndeterminateLine_default({
		id: mergedId,
		loading,
		percent: percentList[0],
		strokeLinecap,
		strokeWidth
	});
	return /* @__PURE__ */ import_react.createElement("svg", _extends$28({
		className: clsx(`${prefixCls}-line`, className),
		viewBox: viewBoxString,
		preserveAspectRatio: "none",
		style: style$1
	}, restProps), /* @__PURE__ */ import_react.createElement("path", {
		className: `${prefixCls}-line-rail`,
		d: pathString,
		strokeLinecap,
		stroke: railColor,
		strokeWidth: railWidth || strokeWidth,
		fillOpacity: "0"
	}), percentList.map((ptg, index$1) => {
		let dashPercent = 1;
		switch (strokeLinecap) {
			case "round":
				dashPercent = 1 - strokeWidth / 100;
				break;
			case "square":
				dashPercent = 1 - strokeWidth / 2 / 100;
				break;
			default:
				dashPercent = 1;
				break;
		}
		const pathStyle = {
			strokeDasharray: `${ptg * dashPercent}px, 100px`,
			strokeDashoffset: `-${stackPtg}px`,
			transition: transition || "stroke-dashoffset 0.3s ease 0s, stroke-dasharray .3s ease 0s, stroke 0.3s linear",
			...indeterminateStyleProps
		};
		const color = strokeColorList[index$1] || strokeColorList[strokeColorList.length - 1];
		stackPtg += ptg;
		return /* @__PURE__ */ import_react.createElement("path", {
			key: index$1,
			className: `${prefixCls}-line-path`,
			d: pathString,
			strokeLinecap,
			stroke: color,
			strokeWidth,
			fillOpacity: "0",
			ref: (elem) => {
				paths[index$1] = elem;
			},
			style: pathStyle
		});
	}), indeterminateStyleAnimation);
};
Line$1.displayName = "Line";

//#endregion
//#region node_modules/@rc-component/progress/es/Circle/PtgCircle.js
var Block = ({ bg, children }) => /* @__PURE__ */ import_react.createElement("div", { style: {
	width: "100%",
	height: "100%",
	background: bg
} }, children);
function getPtgColors(color, scale) {
	return Object.keys(color).map((key) => {
		const parsedKey = parseFloat(key);
		const ptgKey = `${Math.floor(parsedKey * scale)}%`;
		return `${color[key]} ${ptgKey}`;
	});
}
var PtgCircle = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls, color, gradientId, radius: radius$1, className, style: circleStyleForStack, ptg, strokeLinecap, strokeWidth, size, gapDegree } = props;
	const isGradient = color && typeof color === "object";
	const stroke = isGradient ? `#FFF` : void 0;
	const halfSize = size / 2;
	const circleNode = /* @__PURE__ */ import_react.createElement("circle", {
		className: clsx(`${prefixCls}-circle-path`, className),
		r: radius$1,
		cx: halfSize,
		cy: halfSize,
		stroke,
		strokeLinecap,
		strokeWidth,
		opacity: ptg === 0 ? 0 : 1,
		style: circleStyleForStack,
		ref
	});
	if (!isGradient) return circleNode;
	const maskId = `${gradientId}-conic`;
	const fromDeg = gapDegree ? `${180 + gapDegree / 2}deg` : "0deg";
	const conicColors = getPtgColors(color, (360 - gapDegree) / 360);
	const linearColors = getPtgColors(color, 1);
	const conicColorBg = `conic-gradient(from ${fromDeg}, ${conicColors.join(", ")})`;
	const linearColorBg = `linear-gradient(to ${gapDegree ? "bottom" : "top"}, ${linearColors.join(", ")})`;
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("mask", { id: maskId }, circleNode), /* @__PURE__ */ import_react.createElement("foreignObject", {
		x: 0,
		y: 0,
		width: size,
		height: size,
		mask: `url(#${maskId})`
	}, /* @__PURE__ */ import_react.createElement(Block, { bg: linearColorBg }, /* @__PURE__ */ import_react.createElement(Block, { bg: conicColorBg }))));
});
PtgCircle.displayName = "PtgCircle";
var PtgCircle_default = PtgCircle;

//#endregion
//#region node_modules/@rc-component/progress/es/Circle/util.js
const VIEW_BOX_SIZE = 100;
const getCircleStyle = (perimeter, perimeterWithoutGap, offset$2, percent, rotateDeg, gapDegree, gapPosition, strokeColor, strokeLinecap, strokeWidth, stepSpace = 0) => {
	const offsetDeg = offset$2 / 100 * 360 * ((360 - gapDegree) / 360);
	const positionDeg = gapDegree === 0 ? 0 : {
		bottom: 0,
		top: 180,
		left: 90,
		right: -90
	}[gapPosition];
	let strokeDashoffset = (100 - percent) / 100 * perimeterWithoutGap;
	if (strokeLinecap === "round" && percent !== 100) {
		strokeDashoffset += strokeWidth / 2;
		if (strokeDashoffset >= perimeterWithoutGap) strokeDashoffset = perimeterWithoutGap - .01;
	}
	const halfSize = VIEW_BOX_SIZE / 2;
	return {
		stroke: typeof strokeColor === "string" ? strokeColor : void 0,
		strokeDasharray: `${perimeterWithoutGap}px ${perimeter}`,
		strokeDashoffset: strokeDashoffset + stepSpace,
		transform: `rotate(${rotateDeg + offsetDeg + positionDeg}deg)`,
		transformOrigin: `${halfSize}px ${halfSize}px`,
		transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s, opacity .3s ease 0s",
		fillOpacity: 0
	};
};

//#endregion
//#region node_modules/@rc-component/progress/es/utils/getIndeterminateCircle.js
var getIndeterminateCircle_default = (({ id, loading }) => {
	if (!loading) return {
		indeterminateStyleProps: {},
		indeterminateStyleAnimation: null
	};
	const animationName = `${id}-indeterminate-animate`;
	return {
		indeterminateStyleProps: {
			transform: "rotate(0deg)",
			animation: `${animationName} 1s linear infinite`
		},
		indeterminateStyleAnimation: /* @__PURE__ */ import_react.createElement("style", null, `@keyframes ${animationName} {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }`)
	};
});

//#endregion
//#region node_modules/@rc-component/progress/es/Circle/index.js
function _extends$27() {
	_extends$27 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$27.apply(this, arguments);
}
function toArray$3(value) {
	const mergedValue = value ?? [];
	return Array.isArray(mergedValue) ? mergedValue : [mergedValue];
}
var Circle$1 = (props) => {
	const { id, prefixCls, classNames = {}, styles = {}, steps, strokeWidth, railWidth, gapDegree = 0, gapPosition, railColor, strokeLinecap, style: style$1, className, strokeColor, percent, loading, ...restProps } = {
		...defaultProps,
		...props
	};
	const halfSize = VIEW_BOX_SIZE / 2;
	const mergedId = useId_default(id);
	const gradientId = `${mergedId}-gradient`;
	const radius$1 = halfSize - strokeWidth / 2;
	const perimeter = Math.PI * 2 * radius$1;
	const rotateDeg = gapDegree > 0 ? 90 + gapDegree / 2 : -90;
	const perimeterWithoutGap = perimeter * ((360 - gapDegree) / 360);
	const { count: stepCount, gap: stepGap } = typeof steps === "object" ? steps : {
		count: steps,
		gap: 2
	};
	const percentList = toArray$3(percent);
	const strokeColorList = toArray$3(strokeColor);
	const gradient = strokeColorList.find((color) => color && typeof color === "object");
	const mergedStrokeLinecap = gradient && typeof gradient === "object" ? "butt" : strokeLinecap;
	const { indeterminateStyleProps, indeterminateStyleAnimation } = getIndeterminateCircle_default({
		id: mergedId,
		loading
	});
	const circleStyle = getCircleStyle(perimeter, perimeterWithoutGap, 0, 100, rotateDeg, gapDegree, gapPosition, railColor, mergedStrokeLinecap, strokeWidth);
	const paths = useTransitionDuration();
	const getStokeList = () => {
		let stackPtg = 0;
		return percentList.map((ptg, index$1) => {
			const color = strokeColorList[index$1] || strokeColorList[strokeColorList.length - 1];
			const circleStyleForStack = getCircleStyle(perimeter, perimeterWithoutGap, stackPtg, ptg, rotateDeg, gapDegree, gapPosition, color, mergedStrokeLinecap, strokeWidth);
			stackPtg += ptg;
			return /* @__PURE__ */ import_react.createElement(PtgCircle_default, {
				key: index$1,
				color,
				ptg,
				radius: radius$1,
				prefixCls,
				gradientId,
				className: classNames.track,
				style: {
					...circleStyleForStack,
					...indeterminateStyleProps,
					...styles.track
				},
				strokeLinecap: mergedStrokeLinecap,
				strokeWidth,
				gapDegree,
				ref: (elem) => {
					paths[index$1] = elem;
				},
				size: VIEW_BOX_SIZE
			});
		}).reverse();
	};
	const getStepStokeList = () => {
		const current = Math.round(stepCount * (percentList[0] / 100));
		const stepPtg = 100 / stepCount;
		let stackPtg = 0;
		return new Array(stepCount).fill(null).map((_, index$1) => {
			const color = index$1 <= current - 1 ? strokeColorList[0] : railColor;
			const stroke = color && typeof color === "object" ? `url(#${gradientId})` : void 0;
			const circleStyleForStack = getCircleStyle(perimeter, perimeterWithoutGap, stackPtg, stepPtg, rotateDeg, gapDegree, gapPosition, color, "butt", strokeWidth, stepGap);
			stackPtg += (perimeterWithoutGap - circleStyleForStack.strokeDashoffset + stepGap) * 100 / perimeterWithoutGap;
			return /* @__PURE__ */ import_react.createElement("circle", {
				key: index$1,
				className: clsx(`${prefixCls}-circle-path`, classNames.track),
				r: radius$1,
				cx: halfSize,
				cy: halfSize,
				stroke,
				strokeWidth,
				opacity: 1,
				style: {
					...circleStyleForStack,
					...styles.track
				},
				ref: (elem) => {
					paths[index$1] = elem;
				}
			});
		});
	};
	return /* @__PURE__ */ import_react.createElement("svg", _extends$27({
		className: clsx(`${prefixCls}-circle`, classNames.root, className),
		viewBox: `0 0 ${VIEW_BOX_SIZE} ${VIEW_BOX_SIZE}`,
		style: {
			...styles.root,
			...style$1
		},
		id,
		role: "presentation"
	}, restProps), !stepCount && /* @__PURE__ */ import_react.createElement("circle", {
		className: clsx(`${prefixCls}-circle-rail`, classNames.rail),
		r: radius$1,
		cx: halfSize,
		cy: halfSize,
		stroke: railColor,
		strokeLinecap: mergedStrokeLinecap,
		strokeWidth: railWidth || strokeWidth,
		style: {
			...circleStyle,
			...styles.rail
		}
	}), stepCount ? getStepStokeList() : getStokeList(), indeterminateStyleAnimation);
};
Circle$1.displayName = "Circle";
var Circle_default$1 = Circle$1;

//#endregion
//#region node_modules/antd/es/progress/utils.js
function validProgress(progress) {
	if (!progress || progress < 0) return 0;
	if (progress > 100) return 100;
	return progress;
}
function getSuccessPercent({ success }) {
	let percent;
	if (success && "percent" in success) percent = success.percent;
	return percent;
}
const getPercentage = ({ percent, success }) => {
	const realSuccessPercent = validProgress(getSuccessPercent({ success }));
	return [realSuccessPercent, validProgress(validProgress(percent) - realSuccessPercent)];
};
const getStrokeColor = ({ success = {}, strokeColor }) => {
	const { strokeColor: successColor } = success;
	return [successColor || presetPrimaryColors.green, strokeColor || null];
};
const getSize = (size, type$2, extra) => {
	let width = -1;
	let height = -1;
	if (type$2 === "step") {
		const steps = extra.steps;
		const strokeWidth = extra.strokeWidth;
		if (typeof size === "string" || typeof size === "undefined") {
			width = size === "small" ? 2 : 14;
			height = strokeWidth ?? 8;
		} else if (typeof size === "number") [width, height] = [size, size];
		else [width = 14, height = 8] = Array.isArray(size) ? size : [size.width, size.height];
		width *= steps;
	} else if (type$2 === "line") {
		const strokeWidth = extra?.strokeWidth;
		if (typeof size === "string" || typeof size === "undefined") height = strokeWidth || (size === "small" ? 6 : 8);
		else if (typeof size === "number") [width, height] = [size, size];
		else [width = -1, height = 8] = Array.isArray(size) ? size : [size.width, size.height];
	} else if (type$2 === "circle" || type$2 === "dashboard") {
		if (typeof size === "string" || typeof size === "undefined") [width, height] = size === "small" ? [60, 60] : [120, 120];
		else if (typeof size === "number") [width, height] = [size, size];
		else if (Array.isArray(size)) {
			width = size[0] ?? size[1] ?? 120;
			height = size[0] ?? size[1] ?? 120;
		}
	}
	return [width, height];
};

//#endregion
//#region node_modules/antd/es/progress/Circle.js
var CIRCLE_MIN_STROKE_WIDTH = 3;
var getMinPercent = (width) => CIRCLE_MIN_STROKE_WIDTH / width * 100;
var OMIT_SEMANTIC_NAMES = [
	"root",
	"body",
	"indicator"
];
var Circle = (props) => {
	const { prefixCls, classNames, styles, railColor, trailColor, strokeLinecap = "round", gapPosition, gapPlacement, gapDegree, width: originWidth = 120, type: type$2, children, success, size = originWidth, steps } = props;
	const { direction } = useComponentConfig("progress");
	const mergedRailColor = railColor ?? trailColor;
	const [width, height] = getSize(size, "circle");
	let { strokeWidth } = props;
	if (strokeWidth === void 0) strokeWidth = Math.max(getMinPercent(width), 6);
	const circleStyle = {
		width,
		height,
		fontSize: width * .15 + 6
	};
	const realGapDegree = import_react.useMemo(() => {
		if (gapDegree || gapDegree === 0) return gapDegree;
		if (type$2 === "dashboard") return 75;
	}, [gapDegree, type$2]);
	const percentArray = getPercentage(props);
	const gapPos = import_react.useMemo(() => {
		const mergedPlacement = (gapPlacement ?? gapPosition) || type$2 === "dashboard" && "bottom" || void 0;
		const isRTL = direction === "rtl";
		switch (mergedPlacement) {
			case "start": return isRTL ? "right" : "left";
			case "end": return isRTL ? "left" : "right";
			default: return mergedPlacement;
		}
	}, [
		direction,
		gapPlacement,
		gapPosition,
		type$2
	]);
	const isGradient = Object.prototype.toString.call(props.strokeColor) === "[object Object]";
	const strokeColor = getStrokeColor({
		success,
		strokeColor: props.strokeColor
	});
	const wrapperClassName = clsx(`${prefixCls}-body`, { [`${prefixCls}-circle-gradient`]: isGradient }, classNames.body);
	const circleContent = /* @__PURE__ */ import_react.createElement(Circle_default$1, {
		steps,
		percent: steps ? percentArray[1] : percentArray,
		strokeWidth,
		railWidth: strokeWidth,
		strokeColor: steps ? strokeColor[1] : strokeColor,
		strokeLinecap,
		railColor: mergedRailColor,
		prefixCls,
		gapDegree: realGapDegree,
		gapPosition: gapPos,
		classNames: omit(classNames, OMIT_SEMANTIC_NAMES),
		styles: omit(styles, OMIT_SEMANTIC_NAMES)
	});
	const smallCircle = width <= 20;
	const node$1 = /* @__PURE__ */ import_react.createElement("div", {
		className: wrapperClassName,
		style: {
			...circleStyle,
			...styles.body
		}
	}, circleContent, !smallCircle && children);
	if (smallCircle) return /* @__PURE__ */ import_react.createElement(tooltip_default, { title: children }, node$1);
	return node$1;
};
var Circle_default = Circle;

//#endregion
//#region node_modules/antd/es/progress/style/index.js
const LineStrokeColorVar = "--progress-line-stroke-color";
var genAntProgressActive = (isRtl) => {
	const direction = isRtl ? "100%" : "-100%";
	return new Keyframes_default(`antProgress${isRtl ? "RTL" : "LTR"}Active`, {
		"0%": {
			transform: `translateX(${direction}) scaleX(0)`,
			opacity: .1
		},
		"20%": {
			transform: `translateX(${direction}) scaleX(0)`,
			opacity: .5
		},
		to: {
			transform: "translateX(0) scaleX(1)",
			opacity: 0
		}
	});
};
var genBaseStyle$6 = (token$1) => {
	const { componentCls: progressCls, iconCls: iconPrefixCls } = token$1;
	return { [progressCls]: {
		...resetComponent(token$1),
		display: "inline-flex",
		"&-rtl": { direction: "rtl" },
		[`${progressCls}-indicator`]: {
			color: token$1.colorText,
			lineHeight: 1,
			whiteSpace: "nowrap",
			verticalAlign: "middle",
			wordBreak: "normal",
			[iconPrefixCls]: { fontSize: token$1.fontSize }
		},
		[`&${progressCls}-status-exception`]: { [`${progressCls}-indicator`]: { color: token$1.colorError } },
		[`&${progressCls}-status-success`]: { [`${progressCls}-indicator`]: { color: token$1.colorSuccess } }
	} };
};
var genLineStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-line`]: {
		position: "relative",
		width: "100%",
		fontSize: token$1.fontSize,
		[`${componentCls}-body`]: {
			display: "inline-flex",
			alignItems: "center",
			width: "100%",
			gap: token$1.marginXS
		},
		[`${componentCls}-rail`]: {
			flex: "auto",
			background: token$1.remainingColor,
			borderRadius: token$1.lineBorderRadius,
			position: "relative",
			width: "100%"
		},
		[`&${componentCls}-status-active`]: { [`${componentCls}-track:after`]: {
			content: "\"\"",
			position: "absolute",
			inset: 0,
			backgroundColor: token$1.colorBgContainer,
			borderRadius: "inherit",
			opacity: 0,
			animationName: genAntProgressActive(),
			animationDuration: token$1.progressActiveMotionDuration,
			animationTimingFunction: token$1.motionEaseOutQuint,
			animationIterationCount: "infinite"
		} },
		[`${componentCls}-track`]: {
			position: "absolute",
			insetInlineStart: 0,
			insetBlock: 0,
			borderRadius: "inherit",
			background: token$1.defaultColor,
			transition: `all ${token$1.motionDurationSlow} ${token$1.motionEaseInOutCirc}`,
			minWidth: "max-content",
			display: "flex",
			alignItems: "center",
			"&-success": { background: token$1.colorSuccess }
		},
		[`&${componentCls}-status-exception`]: { [`${componentCls}-track`]: { background: token$1.colorError } },
		[`&${componentCls}-status-success`]: { [`${componentCls}-track`]: { background: token$1.colorSuccess } },
		[`${componentCls}-indicator-outer`]: { [`&${componentCls}-indicator-start`]: { order: -1 } },
		[`${componentCls}-body-layout-bottom`]: {
			flexDirection: "column",
			alignItems: "center",
			gap: token$1.marginXXS
		},
		[`${componentCls}-indicator${componentCls}-indicator-inner`]: {
			color: token$1.colorWhite,
			paddingInline: token$1.paddingXXS,
			width: "100%",
			display: "flex",
			justifyContent: "center",
			[`&${componentCls}-indicator-end`]: { justifyContent: "end" },
			[`&${componentCls}-indicator-start`]: { justifyContent: "start" },
			[`&${componentCls}-indicator-bright`]: { color: "rgba(0, 0, 0, 0.45)" }
		}
	} };
};
var genCircleStyle = (token$1) => {
	const { componentCls: progressCls, iconCls: iconPrefixCls } = token$1;
	return {
		[`${progressCls}-circle`]: {
			[`${progressCls}-circle-rail`]: { stroke: token$1.remainingColor },
			[`${progressCls}-body:not(${progressCls}-circle-gradient)`]: { [`${progressCls}-circle-path`]: { stroke: token$1.defaultColor } },
			[`${progressCls}-body`]: {
				position: "relative",
				lineHeight: 1,
				backgroundColor: "transparent"
			},
			[`${progressCls}-indicator`]: {
				position: "absolute",
				insetBlockStart: "50%",
				insetInlineStart: 0,
				width: "100%",
				margin: 0,
				padding: 0,
				color: token$1.circleTextColor,
				fontSize: token$1.circleTextFontSize,
				lineHeight: 1,
				whiteSpace: "normal",
				textAlign: "center",
				transform: "translateY(-50%)",
				[iconPrefixCls]: { fontSize: token$1.circleIconFontSize }
			},
			[`&${progressCls}-status-exception`]: { [`${progressCls}-body:not(${progressCls}-circle-gradient)`]: { [`${progressCls}-circle-path`]: { stroke: token$1.colorError } } },
			[`&${progressCls}-status-success`]: { [`${progressCls}-body:not(${progressCls}-circle-gradient)`]: { [`${progressCls}-circle-path`]: { stroke: token$1.colorSuccess } } }
		},
		[`${progressCls}-inline-circle`]: {
			lineHeight: 1,
			[`${progressCls}-inner`]: { verticalAlign: "bottom" }
		}
	};
};
var genStepStyle = (token$1) => {
	const { componentCls: progressCls } = token$1;
	return { [progressCls]: { [`${progressCls}-steps`]: {
		display: "inline-block",
		"&-body": {
			display: "flex",
			flexDirection: "row",
			alignItems: "center",
			gap: token$1.progressStepMarginInlineEnd,
			[`${progressCls}-indicator`]: { marginInlineStart: token$1.marginXS }
		},
		"&-item": {
			flexShrink: 0,
			minWidth: token$1.progressStepMinWidth,
			backgroundColor: token$1.remainingColor,
			transition: `all ${token$1.motionDurationSlow}`,
			"&-active": { backgroundColor: token$1.defaultColor }
		}
	} } };
};
var genSmallLine = (token$1) => {
	const { componentCls: progressCls, iconCls: iconPrefixCls } = token$1;
	return { [progressCls]: { [`${progressCls}-small&-line, ${progressCls}-small&-line ${progressCls}-indicator ${iconPrefixCls}`]: { fontSize: token$1.fontSizeSM } } };
};
const prepareComponentToken$15 = (token$1) => ({
	circleTextColor: token$1.colorText,
	defaultColor: token$1.colorInfo,
	remainingColor: token$1.colorFillSecondary,
	lineBorderRadius: 100,
	circleTextFontSize: "1em",
	circleIconFontSize: `${token$1.fontSize / token$1.fontSizeSM}em`
});
var style_default$16 = genStyleHooks("Progress", (token$1) => {
	const progressStepMarginInlineEnd = token$1.calc(token$1.marginXXS).div(2).equal();
	const progressToken = merge(token$1, {
		progressStepMarginInlineEnd,
		progressStepMinWidth: progressStepMarginInlineEnd,
		progressActiveMotionDuration: "2.4s"
	});
	return [
		genBaseStyle$6(progressToken),
		genLineStyle(progressToken),
		genCircleStyle(progressToken),
		genStepStyle(progressToken),
		genSmallLine(progressToken)
	];
}, prepareComponentToken$15);

//#endregion
//#region node_modules/antd/es/progress/Line.js
/**
* @example
*   {
*     "0%": "#afc163",
*     "75%": "#009900",
*     "50%": "green", // ====> '#afc163 0%, #66FF00 25%, #00CC00 50%, #009900 75%, #ffffff 100%'
*     "25%": "#66FF00",
*     "100%": "#ffffff"
*   }
*/
const sortGradient = (gradients) => {
	let tempArr = [];
	Object.keys(gradients).forEach((key) => {
		const formattedKey = Number.parseFloat(key.replace(/%/g, ""));
		if (!Number.isNaN(formattedKey)) tempArr.push({
			key: formattedKey,
			value: gradients[key]
		});
	});
	tempArr = tempArr.sort((a, b) => a.key - b.key);
	return tempArr.map(({ key, value }) => `${value} ${key}%`).join(", ");
};
/**
* Then this man came to realize the truth: Besides six pence, there is the moon. Besides bread and
* butter, there is the bug. And... Besides women, there is the code.
*
* @example
*   {
*     "0%": "#afc163",
*     "25%": "#66FF00",
*     "50%": "#00CC00", // ====>  linear-gradient(to right, #afc163 0%, #66FF00 25%,
*     "75%": "#009900", //        #00CC00 50%, #009900 75%, #ffffff 100%)
*     "100%": "#ffffff"
*   }
*/
const handleGradient = (strokeColor, directionConfig) => {
	const { from: from$1 = presetPrimaryColors.blue, to = presetPrimaryColors.blue, direction = directionConfig === "rtl" ? "to left" : "to right", ...rest } = strokeColor;
	if (Object.keys(rest).length !== 0) {
		const background$1 = `linear-gradient(${direction}, ${sortGradient(rest)})`;
		return {
			background: background$1,
			[LineStrokeColorVar]: background$1
		};
	}
	const background = `linear-gradient(${direction}, ${from$1}, ${to})`;
	return {
		background,
		[LineStrokeColorVar]: background
	};
};
var Line = (props) => {
	const { prefixCls, classNames, styles, direction: directionConfig, percent, size, strokeWidth, strokeColor, strokeLinecap = "round", children, railColor, trailColor, percentPosition, success } = props;
	const { align: infoAlign, type: infoPosition } = percentPosition;
	const mergedRailColor = railColor ?? trailColor;
	const borderRadius = strokeLinecap === "square" || strokeLinecap === "butt" ? 0 : void 0;
	devUseWarning("Progress").deprecated(!("strokeWidth" in props), "strokeWidth", "size");
	const [width, height] = getSize(size ?? [-1, strokeWidth || (size === "small" ? 6 : 8)], "line", { strokeWidth });
	const railStyle = {
		backgroundColor: mergedRailColor || void 0,
		borderRadius,
		height
	};
	const trackCls = `${prefixCls}-track`;
	const backgroundProps = strokeColor && typeof strokeColor !== "string" ? handleGradient(strokeColor, directionConfig) : {
		[LineStrokeColorVar]: strokeColor,
		background: strokeColor
	};
	const percentTrackStyle = {
		width: `${validProgress(percent)}%`,
		height,
		borderRadius,
		...backgroundProps
	};
	const successPercent = getSuccessPercent(props);
	const successTrackStyle = {
		width: `${validProgress(successPercent)}%`,
		height,
		borderRadius,
		backgroundColor: success?.strokeColor
	};
	return /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-body`, classNames.body, { [`${prefixCls}-body-layout-bottom`]: infoAlign === "center" && infoPosition === "outer" }),
		style: {
			width: width > 0 ? width : "100%",
			...styles.body
		}
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-rail`, classNames.rail),
		style: {
			...railStyle,
			...styles.rail
		}
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(trackCls, classNames.track),
		style: {
			...percentTrackStyle,
			...styles.track
		}
	}, infoPosition === "inner" && children), successPercent !== void 0 && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(trackCls, `${trackCls}-success`, classNames.track),
		style: {
			...successTrackStyle,
			...styles.track
		}
	})), infoPosition === "outer" && children);
};
var Line_default = Line;

//#endregion
//#region node_modules/antd/es/progress/Steps.js
var Steps$2 = (props) => {
	const { classNames, styles, size, steps, rounding: customRounding = Math.round, percent = 0, strokeWidth = 8, strokeColor, railColor, trailColor, prefixCls, children } = props;
	const current = customRounding(steps * (percent / 100));
	const [width, height] = getSize(size ?? [size === "small" ? 2 : 14, strokeWidth], "step", {
		steps,
		strokeWidth
	});
	const unitWidth = width / steps;
	const styledSteps = Array.from({ length: steps });
	const mergedRailColor = railColor ?? trailColor;
	for (let i = 0; i < steps; i++) {
		const color = Array.isArray(strokeColor) ? strokeColor[i] : strokeColor;
		styledSteps[i] = /* @__PURE__ */ import_react.createElement("div", {
			key: i,
			className: clsx(`${prefixCls}-steps-item`, { [`${prefixCls}-steps-item-active`]: i <= current - 1 }, classNames.track),
			style: {
				backgroundColor: i <= current - 1 ? color : mergedRailColor,
				width: unitWidth,
				height,
				...styles.track
			}
		});
	}
	return /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-steps-body`, classNames.body),
		style: styles.body
	}, styledSteps, children);
};
var Steps_default = Steps$2;

//#endregion
//#region node_modules/antd/es/progress/progress.js
var ProgressStatuses = [
	"normal",
	"exception",
	"active",
	"success"
];
var Progress = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, classNames, styles, steps, strokeColor, percent = 0, size = "default", showInfo = true, type: type$2 = "line", status, format: format$1, style: style$1, percentPosition = {}, ...restProps } = props;
	const { align: infoAlign = "end", type: infoPosition = "outer" } = percentPosition;
	const strokeColorNotArray = Array.isArray(strokeColor) ? strokeColor[0] : strokeColor;
	const strokeColorNotGradient = typeof strokeColor === "string" || Array.isArray(strokeColor) ? strokeColor : void 0;
	const strokeColorIsBright = import_react.useMemo(() => {
		if (strokeColorNotArray) return new FastColor(typeof strokeColorNotArray === "string" ? strokeColorNotArray : Object.values(strokeColorNotArray)[0]).isLight();
		return false;
	}, [strokeColor]);
	const percentNumber = import_react.useMemo(() => {
		const successPercent = getSuccessPercent(props);
		return Number.parseInt(successPercent !== void 0 ? (successPercent ?? 0)?.toString() : (percent ?? 0)?.toString(), 10);
	}, [percent, props.success]);
	const progressStatus = import_react.useMemo(() => {
		if (!ProgressStatuses.includes(status) && percentNumber >= 100) return "success";
		return status || "normal";
	}, [status, percentNumber]);
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("progress");
	const prefixCls = getPrefixCls("progress", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$16(prefixCls);
	const mergedProps = {
		...props,
		percent,
		type: type$2,
		size,
		showInfo,
		percentPosition
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const isLineType = type$2 === "line";
	const isPureLineType = isLineType && !steps;
	const progressInfo = import_react.useMemo(() => {
		if (!showInfo) return null;
		const successPercent = getSuccessPercent(props);
		let text;
		const textFormatter = format$1 || ((number$1) => `${number$1}%`);
		const isBrightInnerColor = isLineType && strokeColorIsBright && infoPosition === "inner";
		if (infoPosition === "inner" || format$1 || progressStatus !== "exception" && progressStatus !== "success") text = textFormatter(validProgress(percent), validProgress(successPercent));
		else if (progressStatus === "exception") text = isLineType ? /* @__PURE__ */ import_react.createElement(CloseCircleFilled_default, null) : /* @__PURE__ */ import_react.createElement(CloseOutlined_default, null);
		else if (progressStatus === "success") text = isLineType ? /* @__PURE__ */ import_react.createElement(CheckCircleFilled_default, null) : /* @__PURE__ */ import_react.createElement(CheckOutlined_default, null);
		return /* @__PURE__ */ import_react.createElement("span", {
			className: clsx(`${prefixCls}-indicator`, {
				[`${prefixCls}-indicator-bright`]: isBrightInnerColor,
				[`${prefixCls}-indicator-${infoAlign}`]: isPureLineType,
				[`${prefixCls}-indicator-${infoPosition}`]: isPureLineType
			}, mergedClassNames.indicator),
			style: mergedStyles.indicator,
			title: typeof text === "string" ? text : void 0
		}, text);
	}, [
		showInfo,
		percent,
		percentNumber,
		progressStatus,
		type$2,
		prefixCls,
		format$1,
		isLineType,
		strokeColorIsBright,
		infoPosition,
		infoAlign,
		isPureLineType,
		mergedClassNames.indicator,
		mergedStyles.indicator
	]);
	{
		const warning$3 = devUseWarning("Progress");
		[
			["width", "size"],
			["trailColor", "railColor"],
			["gapPosition", "gapPlacement"]
		].forEach(([deprecatedName, newName]) => {
			warning$3.deprecated(!(deprecatedName in props), deprecatedName, newName);
		});
		if (type$2 === "circle" || type$2 === "dashboard") {
			if (Array.isArray(size)) warning$3(false, "usage", "Type \"circle\" and \"dashboard\" do not accept array as `size`, please use number or preset size instead.");
			else if (typeof size === "object") warning$3(false, "usage", "Type \"circle\" and \"dashboard\" do not accept object as `size`, please use number or preset size instead.");
		}
	}
	const sharedProps = {
		...props,
		classNames: mergedClassNames,
		styles: mergedStyles
	};
	let progress;
	if (type$2 === "line") progress = steps ? /* @__PURE__ */ import_react.createElement(Steps_default, {
		...sharedProps,
		strokeColor: strokeColorNotGradient,
		prefixCls,
		steps: typeof steps === "object" ? steps.count : steps
	}, progressInfo) : /* @__PURE__ */ import_react.createElement(Line_default, {
		...sharedProps,
		strokeColor: strokeColorNotArray,
		prefixCls,
		direction,
		percentPosition: {
			align: infoAlign,
			type: infoPosition
		}
	}, progressInfo);
	else if (type$2 === "circle" || type$2 === "dashboard") progress = /* @__PURE__ */ import_react.createElement(Circle_default, {
		...sharedProps,
		strokeColor: strokeColorNotArray,
		prefixCls,
		progressStatus
	}, progressInfo);
	const classString = clsx(prefixCls, `${prefixCls}-status-${progressStatus}`, {
		[`${prefixCls}-${type$2 === "dashboard" && "circle" || type$2}`]: type$2 !== "line",
		[`${prefixCls}-inline-circle`]: type$2 === "circle" && getSize(size, "circle")[0] <= 20,
		[`${prefixCls}-line`]: isPureLineType,
		[`${prefixCls}-line-align-${infoAlign}`]: isPureLineType,
		[`${prefixCls}-line-position-${infoPosition}`]: isPureLineType,
		[`${prefixCls}-steps`]: steps,
		[`${prefixCls}-show-info`]: showInfo,
		[`${prefixCls}-${size}`]: typeof size === "string",
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, contextClassName, className, rootClassName, mergedClassNames.root, hashId, cssVarCls);
	return /* @__PURE__ */ import_react.createElement("div", {
		ref,
		style: {
			...contextStyle,
			...mergedStyles.root,
			...style$1
		},
		className: classString,
		role: "progressbar",
		"aria-valuenow": percentNumber,
		"aria-valuemin": 0,
		"aria-valuemax": 100,
		...omit(restProps, [
			"railColor",
			"trailColor",
			"strokeWidth",
			"width",
			"gapDegree",
			"gapPosition",
			"gapPlacement",
			"strokeLinecap",
			"success"
		])
	}, progress);
});
Progress.displayName = "Progress";
var progress_default$2 = Progress;

//#endregion
//#region node_modules/antd/es/progress/index.js
var progress_default = progress_default$2;

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js
function _createForOfIteratorHelper(r$1, e$2) {
	var t$1 = "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (!t$1) {
		if (Array.isArray(r$1) || (t$1 = _unsupportedIterableToArray(r$1)) || e$2 && r$1 && "number" == typeof r$1.length) {
			t$1 && (r$1 = t$1);
			var _n = 0, F = function F$1() {};
			return {
				s: F,
				n: function n$1() {
					return _n >= r$1.length ? { done: !0 } : {
						done: !1,
						value: r$1[_n++]
					};
				},
				e: function e$3(r$2) {
					throw r$2;
				},
				f: F
			};
		}
		throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}
	var o$2, a = !0, u = !1;
	return {
		s: function s() {
			t$1 = t$1.call(r$1);
		},
		n: function n$1() {
			var r$2 = t$1.next();
			return a = r$2.done, r$2;
		},
		e: function e$3(r$2) {
			u = !0, o$2 = r$2;
		},
		f: function f() {
			try {
				a || null == t$1["return"] || t$1["return"]();
			} finally {
				if (u) throw o$2;
			}
		}
	};
}

//#endregion
//#region node_modules/@rc-component/qrcode/es/libs/qrcodegen.js
var _class, _class2;
function appendBits(val, len, bb) {
	if (len < 0 || len > 31 || val >>> len != 0) throw new RangeError("Value out of range");
	for (var i = len - 1; i >= 0; i--) bb.push(val >>> i & 1);
}
function getBit(x, i) {
	return (x >>> i & 1) != 0;
}
function assert(cond) {
	if (!cond) throw new Error("Assertion error");
}
var Mode = /* @__PURE__ */ function() {
	function Mode$1(modeBits, numBitsCharCount) {
		_classCallCheck(this, Mode$1);
		_defineProperty(this, "modeBits", void 0);
		_defineProperty(this, "numBitsCharCount", void 0);
		this.modeBits = modeBits;
		this.numBitsCharCount = numBitsCharCount;
	}
	_createClass(Mode$1, [{
		key: "numCharCountBits",
		value: function numCharCountBits(ver) {
			return this.numBitsCharCount[Math.floor((ver + 7) / 17)];
		}
	}]);
	return Mode$1;
}();
_class = Mode;
_defineProperty(Mode, "NUMERIC", new _class(1, [
	10,
	12,
	14
]));
_defineProperty(Mode, "ALPHANUMERIC", new _class(2, [
	9,
	11,
	13
]));
_defineProperty(Mode, "BYTE", new _class(4, [
	8,
	16,
	16
]));
_defineProperty(Mode, "KANJI", new _class(8, [
	8,
	10,
	12
]));
_defineProperty(Mode, "ECI", new _class(7, [
	0,
	0,
	0
]));
var Ecc = /* @__PURE__ */ _createClass(function Ecc$1(ordinal, formatBits) {
	_classCallCheck(this, Ecc$1);
	_defineProperty(this, "ordinal", void 0);
	_defineProperty(this, "formatBits", void 0);
	this.ordinal = ordinal;
	this.formatBits = formatBits;
});
_class2 = Ecc;
_defineProperty(Ecc, "LOW", new _class2(0, 1));
_defineProperty(Ecc, "MEDIUM", new _class2(1, 0));
_defineProperty(Ecc, "QUARTILE", new _class2(2, 3));
_defineProperty(Ecc, "HIGH", new _class2(3, 2));
var QrSegment = /* @__PURE__ */ function() {
	function QrSegment$1(mode, numChars, bitData) {
		_classCallCheck(this, QrSegment$1);
		_defineProperty(this, "mode", void 0);
		_defineProperty(this, "numChars", void 0);
		_defineProperty(this, "bitData", void 0);
		this.mode = mode;
		this.numChars = numChars;
		this.bitData = bitData;
		if (numChars < 0) throw new RangeError("Invalid argument");
		this.bitData = bitData.slice();
	}
	_createClass(QrSegment$1, [{
		key: "getData",
		value: function getData() {
			return this.bitData.slice();
		}
	}], [
		{
			key: "makeBytes",
			value: function makeBytes(data) {
				var bb = [];
				var _iterator = _createForOfIteratorHelper(data), _step;
				try {
					for (_iterator.s(); !(_step = _iterator.n()).done;) {
						var b = _step.value;
						appendBits(b, 8, bb);
					}
				} catch (err) {
					_iterator.e(err);
				} finally {
					_iterator.f();
				}
				return new QrSegment$1(Mode.BYTE, data.length, bb);
			}
		},
		{
			key: "makeNumeric",
			value: function makeNumeric(digits) {
				if (!QrSegment$1.isNumeric(digits)) throw new RangeError("String contains non-numeric characters");
				var bb = [];
				for (var i = 0; i < digits.length;) {
					var n$1 = Math.min(digits.length - i, 3);
					appendBits(parseInt(digits.substring(i, i + n$1), 10), n$1 * 3 + 1, bb);
					i += n$1;
				}
				return new QrSegment$1(Mode.NUMERIC, digits.length, bb);
			}
		},
		{
			key: "makeAlphanumeric",
			value: function makeAlphanumeric(text) {
				if (!QrSegment$1.isAlphanumeric(text)) throw new RangeError("String contains unencodable characters in alphanumeric mode");
				var bb = [];
				var i;
				for (i = 0; i + 2 <= text.length; i += 2) {
					var temp = QrSegment$1.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;
					temp += QrSegment$1.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));
					appendBits(temp, 11, bb);
				}
				if (i < text.length) appendBits(QrSegment$1.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);
				return new QrSegment$1(Mode.ALPHANUMERIC, text.length, bb);
			}
		},
		{
			key: "makeSegments",
			value: function makeSegments(text) {
				if (text == "") return [];
				else if (QrSegment$1.isNumeric(text)) return [QrSegment$1.makeNumeric(text)];
				else if (QrSegment$1.isAlphanumeric(text)) return [QrSegment$1.makeAlphanumeric(text)];
				else return [QrSegment$1.makeBytes(QrSegment$1.toUtf8ByteArray(text))];
			}
		},
		{
			key: "makeEci",
			value: function makeEci(assignVal) {
				var bb = [];
				if (assignVal < 0) throw new RangeError("ECI assignment value out of range");
				else if (assignVal < 128) appendBits(assignVal, 8, bb);
				else if (assignVal < 16384) {
					appendBits(2, 2, bb);
					appendBits(assignVal, 14, bb);
				} else if (assignVal < 1e6) {
					appendBits(6, 3, bb);
					appendBits(assignVal, 21, bb);
				} else throw new RangeError("ECI assignment value out of range");
				return new QrSegment$1(Mode.ECI, 0, bb);
			}
		},
		{
			key: "isNumeric",
			value: function isNumeric$1(text) {
				return QrSegment$1.NUMERIC_REGEX.test(text);
			}
		},
		{
			key: "isAlphanumeric",
			value: function isAlphanumeric(text) {
				return QrSegment$1.ALPHANUMERIC_REGEX.test(text);
			}
		},
		{
			key: "getTotalBits",
			value: function getTotalBits(segs, version$1) {
				var result = 0;
				var _iterator2 = _createForOfIteratorHelper(segs), _step2;
				try {
					for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
						var seg = _step2.value;
						var ccbits = seg.mode.numCharCountBits(version$1);
						if (seg.numChars >= 1 << ccbits) return Infinity;
						result += 4 + ccbits + seg.bitData.length;
					}
				} catch (err) {
					_iterator2.e(err);
				} finally {
					_iterator2.f();
				}
				return result;
			}
		},
		{
			key: "toUtf8ByteArray",
			value: function toUtf8ByteArray(input) {
				var str = encodeURI(input);
				var result = [];
				for (var i = 0; i < str.length; i++) if (str.charAt(i) != "%") result.push(str.charCodeAt(i));
				else {
					result.push(parseInt(str.substring(i + 1, i + 3), 16));
					i += 2;
				}
				return result;
			}
		}
	]);
	return QrSegment$1;
}();
_defineProperty(QrSegment, "NUMERIC_REGEX", /^[0-9]*$/);
_defineProperty(QrSegment, "ALPHANUMERIC_REGEX", /^[A-Z0-9 $%*+.\/:-]*$/);
_defineProperty(QrSegment, "ALPHANUMERIC_CHARSET", "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:");
var QrCode = /* @__PURE__ */ function() {
	function QrCode$1(version$1, errorCorrectionLevel, dataCodewords, oriMsk) {
		_classCallCheck(this, QrCode$1);
		_defineProperty(this, "size", void 0);
		_defineProperty(this, "mask", void 0);
		_defineProperty(this, "modules", []);
		_defineProperty(this, "isFunction", []);
		_defineProperty(this, "version", void 0);
		_defineProperty(this, "errorCorrectionLevel", void 0);
		var msk = oriMsk;
		this.version = version$1;
		this.errorCorrectionLevel = errorCorrectionLevel;
		if (version$1 < QrCode$1.MIN_VERSION || version$1 > QrCode$1.MAX_VERSION) throw new RangeError("Version value out of range");
		if (msk < -1 || msk > 7) throw new RangeError("Mask value out of range");
		this.size = version$1 * 4 + 17;
		var row = [];
		for (var i = 0; i < this.size; i++) row.push(false);
		for (var _i = 0; _i < this.size; _i++) {
			this.modules.push(row.slice());
			this.isFunction.push(row.slice());
		}
		this.drawFunctionPatterns();
		var allCodewords = this.addEccAndInterleave(dataCodewords);
		this.drawCodewords(allCodewords);
		if (msk == -1) {
			var minPenalty = 1e9;
			for (var _i2 = 0; _i2 < 8; _i2++) {
				this.applyMask(_i2);
				this.drawFormatBits(_i2);
				var penalty = this.getPenaltyScore();
				if (penalty < minPenalty) {
					msk = _i2;
					minPenalty = penalty;
				}
				this.applyMask(_i2);
			}
		}
		assert(0 <= msk && msk <= 7);
		this.mask = msk;
		this.applyMask(msk);
		this.drawFormatBits(msk);
		this.isFunction = [];
	}
	_createClass(QrCode$1, [
		{
			key: "getModule",
			value: function getModule(x, y) {
				return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];
			}
		},
		{
			key: "getModules",
			value: function getModules() {
				return this.modules;
			}
		},
		{
			key: "drawFunctionPatterns",
			value: function drawFunctionPatterns() {
				for (var i = 0; i < this.size; i++) {
					this.setFunctionModule(6, i, i % 2 == 0);
					this.setFunctionModule(i, 6, i % 2 == 0);
				}
				this.drawFinderPattern(3, 3);
				this.drawFinderPattern(this.size - 4, 3);
				this.drawFinderPattern(3, this.size - 4);
				var alignPatPos = this.getAlignmentPatternPositions();
				var numAlign = alignPatPos.length;
				for (var _i3 = 0; _i3 < numAlign; _i3++) for (var j = 0; j < numAlign; j++) if (!(_i3 == 0 && j == 0 || _i3 == 0 && j == numAlign - 1 || _i3 == numAlign - 1 && j == 0)) this.drawAlignmentPattern(alignPatPos[_i3], alignPatPos[j]);
				this.drawFormatBits(0);
				this.drawVersion();
			}
		},
		{
			key: "drawFormatBits",
			value: function drawFormatBits(mask) {
				var data = this.errorCorrectionLevel.formatBits << 3 | mask;
				var rem = data;
				for (var i = 0; i < 10; i++) rem = rem << 1 ^ (rem >>> 9) * 1335;
				var bits = (data << 10 | rem) ^ 21522;
				assert(bits >>> 15 == 0);
				for (var _i4 = 0; _i4 <= 5; _i4++) this.setFunctionModule(8, _i4, getBit(bits, _i4));
				this.setFunctionModule(8, 7, getBit(bits, 6));
				this.setFunctionModule(8, 8, getBit(bits, 7));
				this.setFunctionModule(7, 8, getBit(bits, 8));
				for (var _i5 = 9; _i5 < 15; _i5++) this.setFunctionModule(14 - _i5, 8, getBit(bits, _i5));
				for (var _i6 = 0; _i6 < 8; _i6++) this.setFunctionModule(this.size - 1 - _i6, 8, getBit(bits, _i6));
				for (var _i7 = 8; _i7 < 15; _i7++) this.setFunctionModule(8, this.size - 15 + _i7, getBit(bits, _i7));
				this.setFunctionModule(8, this.size - 8, true);
			}
		},
		{
			key: "drawVersion",
			value: function drawVersion() {
				if (this.version < 7) return;
				var rem = this.version;
				for (var i = 0; i < 12; i++) rem = rem << 1 ^ (rem >>> 11) * 7973;
				var bits = this.version << 12 | rem;
				assert(bits >>> 18 == 0);
				for (var _i8 = 0; _i8 < 18; _i8++) {
					var color = getBit(bits, _i8);
					var a = this.size - 11 + _i8 % 3;
					var b = Math.floor(_i8 / 3);
					this.setFunctionModule(a, b, color);
					this.setFunctionModule(b, a, color);
				}
			}
		},
		{
			key: "drawFinderPattern",
			value: function drawFinderPattern(x, y) {
				for (var dy = -4; dy <= 4; dy++) for (var dx = -4; dx <= 4; dx++) {
					var dist = Math.max(Math.abs(dx), Math.abs(dy));
					var xx = x + dx;
					var yy = y + dy;
					if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size) this.setFunctionModule(xx, yy, dist != 2 && dist != 4);
				}
			}
		},
		{
			key: "drawAlignmentPattern",
			value: function drawAlignmentPattern(x, y) {
				for (var dy = -2; dy <= 2; dy++) for (var dx = -2; dx <= 2; dx++) this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);
			}
		},
		{
			key: "setFunctionModule",
			value: function setFunctionModule(x, y, isDark) {
				this.modules[y][x] = isDark;
				this.isFunction[y][x] = true;
			}
		},
		{
			key: "addEccAndInterleave",
			value: function addEccAndInterleave(data) {
				var ver = this.version;
				var ecl = this.errorCorrectionLevel;
				if (data.length != QrCode$1.getNumDataCodewords(ver, ecl)) throw new RangeError("Invalid argument");
				var numBlocks = QrCode$1.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
				var blockEccLen = QrCode$1.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];
				var rawCodewords = Math.floor(QrCode$1.getNumRawDataModules(ver) / 8);
				var numShortBlocks = numBlocks - rawCodewords % numBlocks;
				var shortBlockLen = Math.floor(rawCodewords / numBlocks);
				var blocks = [];
				var rsDiv = QrCode$1.reedSolomonComputeDivisor(blockEccLen);
				for (var i = 0, k = 0; i < numBlocks; i++) {
					var dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
					k += dat.length;
					var ecc = QrCode$1.reedSolomonComputeRemainder(dat, rsDiv);
					if (i < numShortBlocks) dat.push(0);
					blocks.push(dat.concat(ecc));
				}
				var result = [];
				var _loop = function _loop$1(_i9$1) {
					blocks.forEach(function(block, j) {
						if (_i9$1 != shortBlockLen - blockEccLen || j >= numShortBlocks) result.push(block[_i9$1]);
					});
				};
				for (var _i9 = 0; _i9 < blocks[0].length; _i9++) _loop(_i9);
				assert(result.length == rawCodewords);
				return result;
			}
		},
		{
			key: "drawCodewords",
			value: function drawCodewords(data) {
				if (data.length != Math.floor(QrCode$1.getNumRawDataModules(this.version) / 8)) throw new RangeError("Invalid argument");
				var i = 0;
				for (var right = this.size - 1; right >= 1; right -= 2) {
					if (right == 6) right = 5;
					for (var vert = 0; vert < this.size; vert++) for (var j = 0; j < 2; j++) {
						var x = right - j;
						var y = (right + 1 & 2) == 0 ? this.size - 1 - vert : vert;
						if (!this.isFunction[y][x] && i < data.length * 8) {
							this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));
							i++;
						}
					}
				}
				assert(i == data.length * 8);
			}
		},
		{
			key: "applyMask",
			value: function applyMask(mask) {
				if (mask < 0 || mask > 7) throw new RangeError("Mask value out of range");
				for (var y = 0; y < this.size; y++) for (var x = 0; x < this.size; x++) {
					var invert = void 0;
					switch (mask) {
						case 0:
							invert = (x + y) % 2 == 0;
							break;
						case 1:
							invert = y % 2 == 0;
							break;
						case 2:
							invert = x % 3 == 0;
							break;
						case 3:
							invert = (x + y) % 3 == 0;
							break;
						case 4:
							invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;
							break;
						case 5:
							invert = x * y % 2 + x * y % 3 == 0;
							break;
						case 6:
							invert = (x * y % 2 + x * y % 3) % 2 == 0;
							break;
						case 7:
							invert = ((x + y) % 2 + x * y % 3) % 2 == 0;
							break;
						default: throw new Error("Unreachable");
					}
					if (!this.isFunction[y][x] && invert) this.modules[y][x] = !this.modules[y][x];
				}
			}
		},
		{
			key: "getPenaltyScore",
			value: function getPenaltyScore() {
				var result = 0;
				for (var y = 0; y < this.size; y++) {
					var runColor = false;
					var runX = 0;
					var runHistory = [
						0,
						0,
						0,
						0,
						0,
						0,
						0
					];
					for (var x = 0; x < this.size; x++) if (this.modules[y][x] == runColor) {
						runX++;
						if (runX == 5) result += QrCode$1.PENALTY_N1;
						else if (runX > 5) result++;
					} else {
						this.finderPenaltyAddHistory(runX, runHistory);
						if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * QrCode$1.PENALTY_N3;
						runColor = this.modules[y][x];
						runX = 1;
					}
					result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * QrCode$1.PENALTY_N3;
				}
				for (var _x = 0; _x < this.size; _x++) {
					var _runColor = false;
					var runY = 0;
					var _runHistory = [
						0,
						0,
						0,
						0,
						0,
						0,
						0
					];
					for (var _y = 0; _y < this.size; _y++) if (this.modules[_y][_x] == _runColor) {
						runY++;
						if (runY == 5) result += QrCode$1.PENALTY_N1;
						else if (runY > 5) result++;
					} else {
						this.finderPenaltyAddHistory(runY, _runHistory);
						if (!_runColor) result += this.finderPenaltyCountPatterns(_runHistory) * QrCode$1.PENALTY_N3;
						_runColor = this.modules[_y][_x];
						runY = 1;
					}
					result += this.finderPenaltyTerminateAndCount(_runColor, runY, _runHistory) * QrCode$1.PENALTY_N3;
				}
				for (var _y2 = 0; _y2 < this.size - 1; _y2++) for (var _x2 = 0; _x2 < this.size - 1; _x2++) {
					var color = this.modules[_y2][_x2];
					if (color == this.modules[_y2][_x2 + 1] && color == this.modules[_y2 + 1][_x2] && color == this.modules[_y2 + 1][_x2 + 1]) result += QrCode$1.PENALTY_N2;
				}
				var dark = 0;
				var _iterator3 = _createForOfIteratorHelper(this.modules), _step3;
				try {
					for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) dark = _step3.value.reduce(function(sum, color$1) {
						return sum + (color$1 ? 1 : 0);
					}, dark);
				} catch (err) {
					_iterator3.e(err);
				} finally {
					_iterator3.f();
				}
				var total = this.size * this.size;
				var k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
				assert(0 <= k && k <= 9);
				result += k * QrCode$1.PENALTY_N4;
				assert(0 <= result && result <= 2568888);
				return result;
			}
		},
		{
			key: "getAlignmentPatternPositions",
			value: function getAlignmentPatternPositions() {
				if (this.version == 1) return [];
				else {
					var numAlign = Math.floor(this.version / 7) + 2;
					var step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
					var result = [6];
					for (var pos = this.size - 7; result.length < numAlign; pos -= step) result.splice(1, 0, pos);
					return result;
				}
			}
		},
		{
			key: "finderPenaltyCountPatterns",
			value: function finderPenaltyCountPatterns(runHistory) {
				var n$1 = runHistory[1];
				assert(n$1 <= this.size * 3);
				var core = n$1 > 0 && runHistory[2] == n$1 && runHistory[3] == n$1 * 3 && runHistory[4] == n$1 && runHistory[5] == n$1;
				return (core && runHistory[0] >= n$1 * 4 && runHistory[6] >= n$1 ? 1 : 0) + (core && runHistory[6] >= n$1 * 4 && runHistory[0] >= n$1 ? 1 : 0);
			}
		},
		{
			key: "finderPenaltyTerminateAndCount",
			value: function finderPenaltyTerminateAndCount(currentRunColor, oriCurrentRunLength, runHistory) {
				var currentRunLength = oriCurrentRunLength;
				if (currentRunColor) {
					this.finderPenaltyAddHistory(currentRunLength, runHistory);
					currentRunLength = 0;
				}
				currentRunLength += this.size;
				this.finderPenaltyAddHistory(currentRunLength, runHistory);
				return this.finderPenaltyCountPatterns(runHistory);
			}
		},
		{
			key: "finderPenaltyAddHistory",
			value: function finderPenaltyAddHistory(oriCurrentRunLength, runHistory) {
				var currentRunLength = oriCurrentRunLength;
				if (runHistory[0] == 0) currentRunLength += this.size;
				runHistory.pop();
				runHistory.unshift(currentRunLength);
			}
		}
	], [
		{
			key: "encodeText",
			value: function encodeText(text, ecl) {
				var segs = QrSegment.makeSegments(text);
				return QrCode$1.encodeSegments(segs, ecl);
			}
		},
		{
			key: "encodeBinary",
			value: function encodeBinary(data, ecl) {
				var seg = QrSegment.makeBytes(data);
				return QrCode$1.encodeSegments([seg], ecl);
			}
		},
		{
			key: "encodeSegments",
			value: function encodeSegments(segs, oriEcl) {
				var minVersion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
				var maxVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 40;
				var mask = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : -1;
				var boostEcl = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
				if (!(QrCode$1.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= QrCode$1.MAX_VERSION) || mask < -1 || mask > 7) throw new RangeError("Invalid value");
				var version$1;
				var dataUsedBits;
				for (version$1 = minVersion;; version$1++) {
					var _dataCapacityBits = QrCode$1.getNumDataCodewords(version$1, oriEcl) * 8;
					var usedBits = QrSegment.getTotalBits(segs, version$1);
					if (usedBits <= _dataCapacityBits) {
						dataUsedBits = usedBits;
						break;
					}
					if (version$1 >= maxVersion) throw new RangeError("Data too long");
				}
				var ecl = oriEcl;
				for (var _i10 = 0, _arr = [
					Ecc.MEDIUM,
					Ecc.QUARTILE,
					Ecc.HIGH
				]; _i10 < _arr.length; _i10++) {
					var newEcl = _arr[_i10];
					if (boostEcl && dataUsedBits <= QrCode$1.getNumDataCodewords(version$1, newEcl) * 8) ecl = newEcl;
				}
				var bb = [];
				var _iterator4 = _createForOfIteratorHelper(segs), _step4;
				try {
					for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
						var seg = _step4.value;
						appendBits(seg.mode.modeBits, 4, bb);
						appendBits(seg.numChars, seg.mode.numCharCountBits(version$1), bb);
						var _iterator5 = _createForOfIteratorHelper(seg.getData()), _step5;
						try {
							for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
								var b = _step5.value;
								bb.push(b);
							}
						} catch (err) {
							_iterator5.e(err);
						} finally {
							_iterator5.f();
						}
					}
				} catch (err) {
					_iterator4.e(err);
				} finally {
					_iterator4.f();
				}
				assert(bb.length == dataUsedBits);
				var dataCapacityBits = QrCode$1.getNumDataCodewords(version$1, ecl) * 8;
				assert(bb.length <= dataCapacityBits);
				appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
				appendBits(0, (8 - bb.length % 8) % 8, bb);
				assert(bb.length % 8 == 0);
				for (var padByte = 236; bb.length < dataCapacityBits; padByte ^= 253) appendBits(padByte, 8, bb);
				var dataCodewords = [];
				while (dataCodewords.length * 8 < bb.length) dataCodewords.push(0);
				bb.forEach(function(b$1, i) {
					dataCodewords[i >>> 3] |= b$1 << 7 - (i & 7);
				});
				return new QrCode$1(version$1, ecl, dataCodewords, mask);
			}
		},
		{
			key: "getNumRawDataModules",
			value: function getNumRawDataModules(ver) {
				if (ver < QrCode$1.MIN_VERSION || ver > QrCode$1.MAX_VERSION) throw new RangeError("Version number out of range");
				var result = (16 * ver + 128) * ver + 64;
				if (ver >= 2) {
					var numAlign = Math.floor(ver / 7) + 2;
					result -= (25 * numAlign - 10) * numAlign - 55;
					if (ver >= 7) result -= 36;
				}
				assert(208 <= result && result <= 29648);
				return result;
			}
		},
		{
			key: "getNumDataCodewords",
			value: function getNumDataCodewords(ver, ecl) {
				return Math.floor(QrCode$1.getNumRawDataModules(ver) / 8) - QrCode$1.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * QrCode$1.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
			}
		},
		{
			key: "reedSolomonComputeDivisor",
			value: function reedSolomonComputeDivisor(degree) {
				if (degree < 1 || degree > 255) throw new RangeError("Degree out of range");
				var result = [];
				for (var i = 0; i < degree - 1; i++) result.push(0);
				result.push(1);
				var root = 1;
				for (var _i11 = 0; _i11 < degree; _i11++) {
					for (var j = 0; j < result.length; j++) {
						result[j] = QrCode$1.reedSolomonMultiply(result[j], root);
						if (j + 1 < result.length) result[j] ^= result[j + 1];
					}
					root = QrCode$1.reedSolomonMultiply(root, 2);
				}
				return result;
			}
		},
		{
			key: "reedSolomonComputeRemainder",
			value: function reedSolomonComputeRemainder(data, divisor) {
				var result = divisor.map(function() {
					return 0;
				});
				var _iterator6 = _createForOfIteratorHelper(data), _step6;
				try {
					var _loop2 = function _loop2$1() {
						var factor = _step6.value ^ result.shift();
						result.push(0);
						divisor.forEach(function(coef, i) {
							result[i] ^= QrCode$1.reedSolomonMultiply(coef, factor);
						});
					};
					for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) _loop2();
				} catch (err) {
					_iterator6.e(err);
				} finally {
					_iterator6.f();
				}
				return result;
			}
		},
		{
			key: "reedSolomonMultiply",
			value: function reedSolomonMultiply(x, y) {
				if (x >>> 8 != 0 || y >>> 8 != 0) throw new RangeError("Byte out of range");
				var z = 0;
				for (var i = 7; i >= 0; i--) {
					z = z << 1 ^ (z >>> 7) * 285;
					z ^= (y >>> i & 1) * x;
				}
				assert(z >>> 8 == 0);
				return z;
			}
		}
	]);
	return QrCode$1;
}();
_defineProperty(QrCode, "MIN_VERSION", 1);
_defineProperty(QrCode, "MAX_VERSION", 40);
_defineProperty(QrCode, "PENALTY_N1", 3);
_defineProperty(QrCode, "PENALTY_N2", 3);
_defineProperty(QrCode, "PENALTY_N3", 40);
_defineProperty(QrCode, "PENALTY_N4", 10);
_defineProperty(QrCode, "ECC_CODEWORDS_PER_BLOCK", [
	[
		-1,
		7,
		10,
		15,
		20,
		26,
		18,
		20,
		24,
		30,
		18,
		20,
		24,
		26,
		30,
		22,
		24,
		28,
		30,
		28,
		28,
		28,
		28,
		30,
		30,
		26,
		28,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30
	],
	[
		-1,
		10,
		16,
		26,
		18,
		24,
		16,
		18,
		22,
		22,
		26,
		30,
		22,
		22,
		24,
		24,
		28,
		28,
		26,
		26,
		26,
		26,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28
	],
	[
		-1,
		13,
		22,
		18,
		26,
		18,
		24,
		18,
		22,
		20,
		24,
		28,
		26,
		24,
		20,
		30,
		24,
		28,
		28,
		26,
		30,
		28,
		30,
		30,
		30,
		30,
		28,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30
	],
	[
		-1,
		17,
		28,
		22,
		16,
		22,
		28,
		26,
		26,
		24,
		28,
		24,
		28,
		22,
		24,
		24,
		30,
		28,
		28,
		26,
		28,
		30,
		24,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30
	]
]);
_defineProperty(QrCode, "NUM_ERROR_CORRECTION_BLOCKS", [
	[
		-1,
		1,
		1,
		1,
		1,
		1,
		2,
		2,
		2,
		2,
		4,
		4,
		4,
		4,
		4,
		6,
		6,
		6,
		6,
		7,
		8,
		8,
		9,
		9,
		10,
		12,
		12,
		12,
		13,
		14,
		15,
		16,
		17,
		18,
		19,
		19,
		20,
		21,
		22,
		24,
		25
	],
	[
		-1,
		1,
		1,
		1,
		2,
		2,
		4,
		4,
		4,
		5,
		5,
		5,
		8,
		9,
		9,
		10,
		10,
		11,
		13,
		14,
		16,
		17,
		17,
		18,
		20,
		21,
		23,
		25,
		26,
		28,
		29,
		31,
		33,
		35,
		37,
		38,
		40,
		43,
		45,
		47,
		49
	],
	[
		-1,
		1,
		1,
		2,
		2,
		4,
		4,
		6,
		6,
		8,
		8,
		8,
		10,
		12,
		16,
		12,
		17,
		16,
		18,
		21,
		20,
		23,
		23,
		25,
		27,
		29,
		34,
		34,
		35,
		38,
		40,
		43,
		45,
		48,
		51,
		53,
		56,
		59,
		62,
		65,
		68
	],
	[
		-1,
		1,
		1,
		2,
		4,
		4,
		4,
		5,
		6,
		8,
		8,
		11,
		11,
		16,
		16,
		18,
		16,
		19,
		21,
		25,
		25,
		25,
		34,
		30,
		32,
		35,
		37,
		40,
		42,
		45,
		48,
		51,
		54,
		57,
		60,
		63,
		66,
		70,
		74,
		77,
		81
	]
]);

//#endregion
//#region node_modules/@rc-component/qrcode/es/utils.js
var ERROR_LEVEL_MAP = {
	L: Ecc.LOW,
	M: Ecc.MEDIUM,
	Q: Ecc.QUARTILE,
	H: Ecc.HIGH
};
var DEFAULT_SIZE = 128;
var DEFAULT_LEVEL = "L";
var DEFAULT_BACKGROUND_COLOR = "#FFFFFF";
var DEFAULT_FRONT_COLOR = "#000000";
var DEFAULT_NEED_MARGIN = false;
var DEFAULT_MINVERSION = 1;
var SPEC_MARGIN_SIZE = 4;
var DEFAULT_MARGIN_SIZE = 0;
var DEFAULT_IMG_SCALE = .1;
/**
* Generate a path string from modules
* @param modules
* @param margin
* @returns
*/
var generatePath = function generatePath$1(modules) {
	var margin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
	var ops = [];
	modules.forEach(function(row, y) {
		var start = null;
		row.forEach(function(cell, x) {
			if (!cell && start !== null) {
				ops.push("M".concat(start + margin, " ").concat(y + margin, "h").concat(x - start, "v1H").concat(start + margin, "z"));
				start = null;
				return;
			}
			if (x === row.length - 1) {
				if (!cell) return;
				if (start === null) ops.push("M".concat(x + margin, ",").concat(y + margin, " h1v1H").concat(x + margin, "z"));
				else ops.push("M".concat(start + margin, ",").concat(y + margin, " h").concat(x + 1 - start, "v1H").concat(start + margin, "z"));
				return;
			}
			if (cell && start === null) start = x;
		});
	});
	return ops.join("");
};
/**
* Excavate modules
* @param modules
* @param excavation
* @returns
*/
var excavateModules = function excavateModules$1(modules, excavation) {
	return modules.slice().map(function(row, y) {
		if (y < excavation.y || y >= excavation.y + excavation.h) return row;
		return row.map(function(cell, x) {
			if (x < excavation.x || x >= excavation.x + excavation.w) return cell;
			return false;
		});
	});
};
/**
* Get image settings
* @param cells The modules of the QR code
* @param size The size of the QR code
* @param margin
* @param imageSettings
* @returns
*/
var getImageSettings = function getImageSettings$1(cells, size, margin, imageSettings) {
	if (imageSettings == null) return null;
	var numCells = cells.length + margin * 2;
	var defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);
	var scale = numCells / size;
	var w = (imageSettings.width || defaultSize) * scale;
	var h = (imageSettings.height || defaultSize) * scale;
	var x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;
	var y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;
	var opacity = imageSettings.opacity == null ? 1 : imageSettings.opacity;
	var excavation = null;
	if (imageSettings.excavate) {
		var floorX = Math.floor(x);
		var floorY = Math.floor(y);
		excavation = {
			x: floorX,
			y: floorY,
			w: Math.ceil(w + x - floorX),
			h: Math.ceil(h + y - floorY)
		};
	}
	var crossOrigin = imageSettings.crossOrigin;
	return {
		x,
		y,
		h,
		w,
		excavation,
		opacity,
		crossOrigin
	};
};
/**
* Get margin size
* @param needMargin Whether need margin
* @param marginSize Custom margin size
* @returns
*/
var getMarginSize = function getMarginSize$1(needMargin, marginSize) {
	if (marginSize != null) return Math.max(Math.floor(marginSize), 0);
	return needMargin ? SPEC_MARGIN_SIZE : DEFAULT_MARGIN_SIZE;
};
/**
* Check if Path2D is supported
*/
var isSupportPath2d = function() {
	try {
		new Path2D().addPath(new Path2D());
	} catch (_unused) {
		return false;
	}
	return true;
}();

//#endregion
//#region node_modules/@rc-component/qrcode/es/hooks/useQRCode.js
var useQRCode = function useQRCode$1(opt) {
	var value = opt.value, level = opt.level, minVersion = opt.minVersion, includeMargin = opt.includeMargin, marginSize = opt.marginSize, imageSettings = opt.imageSettings, size = opt.size, boostLevel = opt.boostLevel;
	var memoizedQrcode = import_react.useMemo(function() {
		var segments = (Array.isArray(value) ? value : [value]).reduce(function(acc, val) {
			acc.push.apply(acc, _toConsumableArray(QrSegment.makeSegments(val)));
			return acc;
		}, []);
		return QrCode.encodeSegments(segments, ERROR_LEVEL_MAP[level], minVersion, void 0, void 0, boostLevel);
	}, [
		value,
		level,
		minVersion,
		boostLevel
	]);
	return import_react.useMemo(function() {
		var cs = memoizedQrcode.getModules();
		var mg = getMarginSize(includeMargin, marginSize);
		return {
			cells: cs,
			margin: mg,
			numCells: cs.length + mg * 2,
			calculatedImageSettings: getImageSettings(cs, size, mg, imageSettings),
			qrcode: memoizedQrcode
		};
	}, [
		memoizedQrcode,
		size,
		imageSettings,
		includeMargin,
		marginSize
	]);
};

//#endregion
//#region node_modules/@rc-component/qrcode/es/QRCodeCanvas.js
var _excluded$1 = [
	"value",
	"size",
	"level",
	"bgColor",
	"fgColor",
	"includeMargin",
	"minVersion",
	"marginSize",
	"style",
	"imageSettings",
	"boostLevel"
];
var QRCodeCanvas = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var value = props.value, _props$size = props.size, size = _props$size === void 0 ? DEFAULT_SIZE : _props$size, _props$level = props.level, level = _props$level === void 0 ? DEFAULT_LEVEL : _props$level, _props$bgColor = props.bgColor, bgColor = _props$bgColor === void 0 ? DEFAULT_BACKGROUND_COLOR : _props$bgColor, _props$fgColor = props.fgColor, fgColor = _props$fgColor === void 0 ? DEFAULT_FRONT_COLOR : _props$fgColor, _props$includeMargin = props.includeMargin, includeMargin = _props$includeMargin === void 0 ? DEFAULT_NEED_MARGIN : _props$includeMargin, _props$minVersion = props.minVersion, minVersion = _props$minVersion === void 0 ? DEFAULT_MINVERSION : _props$minVersion, marginSize = props.marginSize, style$1 = props.style, imageSettings = props.imageSettings, boostLevel = props.boostLevel, otherProps = _objectWithoutProperties(props, _excluded$1);
	var imgSrc = imageSettings === null || imageSettings === void 0 ? void 0 : imageSettings.src;
	var _canvas = import_react.useRef(null);
	var _image = import_react.useRef(null);
	var setCanvasRef = import_react.useCallback(function(node$1) {
		_canvas.current = node$1;
		if (typeof ref === "function") ref(node$1);
		else if (ref) ref.current = node$1;
	}, [ref]);
	var setIsImageLoaded = _slicedToArray(import_react.useState(false), 2)[1];
	var _useQRCode = useQRCode({
		value,
		level,
		minVersion,
		includeMargin,
		marginSize,
		imageSettings,
		size,
		boostLevel
	}), margin = _useQRCode.margin, cells = _useQRCode.cells, numCells = _useQRCode.numCells, calculatedImageSettings = _useQRCode.calculatedImageSettings;
	import_react.useEffect(function() {
		if (_canvas.current) {
			var canvas = _canvas.current;
			var ctx = canvas.getContext("2d");
			if (!ctx) return;
			var cellsToDraw = cells;
			var image = _image.current;
			var haveImageToRender = calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;
			if (haveImageToRender) {
				if (calculatedImageSettings.excavation != null) cellsToDraw = excavateModules(cells, calculatedImageSettings.excavation);
			}
			var pixelRatio = window.devicePixelRatio || 1;
			canvas.height = canvas.width = size * pixelRatio;
			var scale = size / numCells * pixelRatio;
			ctx.scale(scale, scale);
			ctx.fillStyle = bgColor;
			ctx.fillRect(0, 0, numCells, numCells);
			ctx.fillStyle = fgColor;
			if (isSupportPath2d) ctx.fill(new Path2D(generatePath(cellsToDraw, margin)));
			else cells.forEach(function(row, rdx) {
				row.forEach(function(cell, cdx) {
					if (cell) ctx.fillRect(cdx + margin, rdx + margin, 1, 1);
				});
			});
			if (calculatedImageSettings) ctx.globalAlpha = calculatedImageSettings.opacity;
			if (haveImageToRender) ctx.drawImage(image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);
		}
	});
	import_react.useEffect(function() {
		setIsImageLoaded(false);
	}, [imgSrc]);
	var canvasStyle = _objectSpread2({
		height: size,
		width: size
	}, style$1);
	var img = null;
	if (imgSrc != null) img = /* @__PURE__ */ import_react.createElement("img", {
		alt: "QR-Code",
		src: imgSrc,
		key: imgSrc,
		style: { display: "none" },
		onLoad: function onLoad() {
			setIsImageLoaded(true);
		},
		ref: _image,
		crossOrigin: calculatedImageSettings === null || calculatedImageSettings === void 0 ? void 0 : calculatedImageSettings.crossOrigin
	});
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("canvas", _extends$26({
		style: canvasStyle,
		height: size,
		width: size,
		ref: setCanvasRef,
		role: "img"
	}, otherProps)), img);
});
QRCodeCanvas.displayName = "QRCodeCanvas";

//#endregion
//#region node_modules/@rc-component/qrcode/es/QRCodeSVG.js
var _excluded = [
	"value",
	"size",
	"level",
	"bgColor",
	"fgColor",
	"includeMargin",
	"minVersion",
	"title",
	"marginSize",
	"imageSettings",
	"boostLevel"
];
var QRCodeSVG = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var value = props.value, _props$size = props.size, size = _props$size === void 0 ? DEFAULT_SIZE : _props$size, _props$level = props.level, level = _props$level === void 0 ? DEFAULT_LEVEL : _props$level, _props$bgColor = props.bgColor, bgColor = _props$bgColor === void 0 ? DEFAULT_BACKGROUND_COLOR : _props$bgColor, _props$fgColor = props.fgColor, fgColor = _props$fgColor === void 0 ? DEFAULT_FRONT_COLOR : _props$fgColor, _props$includeMargin = props.includeMargin, includeMargin = _props$includeMargin === void 0 ? DEFAULT_NEED_MARGIN : _props$includeMargin, _props$minVersion = props.minVersion, minVersion = _props$minVersion === void 0 ? DEFAULT_MINVERSION : _props$minVersion, title = props.title, marginSize = props.marginSize, imageSettings = props.imageSettings, boostLevel = props.boostLevel, otherProps = _objectWithoutProperties(props, _excluded);
	var _useQRCode = useQRCode({
		value,
		level,
		minVersion,
		includeMargin,
		marginSize,
		imageSettings,
		size,
		boostLevel
	}), margin = _useQRCode.margin, cells = _useQRCode.cells, numCells = _useQRCode.numCells, calculatedImageSettings = _useQRCode.calculatedImageSettings;
	var cellsToDraw = cells;
	var image = null;
	if (imageSettings != null && calculatedImageSettings != null) {
		if (calculatedImageSettings.excavation != null) cellsToDraw = excavateModules(cells, calculatedImageSettings.excavation);
		image = /* @__PURE__ */ import_react.createElement("image", {
			href: imageSettings.src,
			height: calculatedImageSettings.h,
			width: calculatedImageSettings.w,
			x: calculatedImageSettings.x + margin,
			y: calculatedImageSettings.y + margin,
			preserveAspectRatio: "none",
			opacity: calculatedImageSettings.opacity,
			crossOrigin: calculatedImageSettings.crossOrigin
		});
	}
	var fgPath = generatePath(cellsToDraw, margin);
	return /* @__PURE__ */ import_react.createElement("svg", _extends$26({
		height: size,
		width: size,
		viewBox: "0 0 ".concat(numCells, " ").concat(numCells),
		ref,
		role: "img"
	}, otherProps), !!title && /* @__PURE__ */ import_react.createElement("title", null, title), /* @__PURE__ */ import_react.createElement("path", {
		fill: bgColor,
		d: "M0,0 h".concat(numCells, "v").concat(numCells, "H0z"),
		shapeRendering: "crispEdges"
	}), /* @__PURE__ */ import_react.createElement("path", {
		fill: fgColor,
		d: fgPath,
		shapeRendering: "crispEdges"
	}), image);
});
QRCodeSVG.displayName = "QRCodeSVG";

//#endregion
//#region node_modules/antd/es/qr-code/QrcodeStatus.js
var defaultSpin = /* @__PURE__ */ import_react.createElement(spin_default, null);
function QRcodeStatus({ prefixCls, locale: locale$5, onRefresh, statusRender, status }) {
	const defaultNodes = {
		expired: /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("p", { className: `${prefixCls}-expired` }, locale$5?.expired), onRefresh && /* @__PURE__ */ import_react.createElement(Button_default, {
			type: "link",
			icon: /* @__PURE__ */ import_react.createElement(ReloadOutlined_default, null),
			onClick: onRefresh
		}, locale$5?.refresh)),
		loading: defaultSpin,
		scanned: /* @__PURE__ */ import_react.createElement("p", { className: `${prefixCls}-scanned` }, locale$5?.scanned)
	};
	const defaultStatusRender = (info) => defaultNodes[info.status];
	return (statusRender ?? defaultStatusRender)({
		status,
		locale: locale$5,
		onRefresh
	});
}

//#endregion
//#region node_modules/antd/es/qr-code/style/index.js
var genQRCodeStyle = (token$1) => {
	const { componentCls, lineWidth, lineType, colorSplit } = token$1;
	return {
		[componentCls]: {
			...resetComponent(token$1),
			display: "flex",
			justifyContent: "center",
			alignItems: "center",
			padding: token$1.paddingSM,
			backgroundColor: token$1.colorWhite,
			borderRadius: token$1.borderRadiusLG,
			border: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
			position: "relative",
			overflow: "hidden",
			[`& > ${componentCls}-cover`]: {
				position: "absolute",
				insetBlockStart: 0,
				insetInlineStart: 0,
				zIndex: 10,
				display: "flex",
				flexDirection: "column",
				justifyContent: "center",
				alignItems: "center",
				width: "100%",
				height: "100%",
				color: token$1.colorText,
				lineHeight: token$1.lineHeight,
				background: token$1.QRCodeCoverBackgroundColor,
				textAlign: "center",
				[`& > ${componentCls}-expired, & > ${componentCls}-scanned`]: { color: token$1.QRCodeTextColor }
			},
			"> canvas": {
				alignSelf: "stretch",
				flex: "auto",
				minWidth: 0
			},
			"&-icon": {
				marginBlockEnd: token$1.marginXS,
				fontSize: token$1.controlHeight
			}
		},
		[`${componentCls}-borderless`]: {
			borderColor: "transparent",
			padding: 0,
			borderRadius: 0
		}
	};
};
const prepareComponentToken$14 = (token$1) => ({ QRCodeCoverBackgroundColor: new FastColor(token$1.colorBgContainer).setA(.96).toRgbString() });
var style_default$15 = genStyleHooks("QRCode", (token$1) => {
	return genQRCodeStyle(merge(token$1, { QRCodeTextColor: token$1.colorText }));
}, prepareComponentToken$14);

//#endregion
//#region node_modules/antd/es/qr-code/index.js
var QRCode = (props) => {
	const [, token$1] = useToken();
	const { value, type: type$2 = "canvas", icon = "", size = 160, iconSize, color = token$1.colorText, errorLevel = "M", status = "active", bordered = true, onRefresh, style: style$1, className, rootClassName, prefixCls: customizePrefixCls, bgColor = "transparent", statusRender, classNames, styles, boostLevel, ...rest } = props;
	const { getPrefixCls, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("qrcode");
	const mergedProps = {
		...props,
		bgColor,
		type: type$2,
		size,
		status,
		bordered,
		errorLevel
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const prefixCls = getPrefixCls("qrcode", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$15(prefixCls);
	const imageSettings = {
		src: icon,
		x: void 0,
		y: void 0,
		height: typeof iconSize === "number" ? iconSize : iconSize?.height ?? 40,
		width: typeof iconSize === "number" ? iconSize : iconSize?.width ?? 40,
		excavate: true,
		crossOrigin: "anonymous"
	};
	const a11yProps = pickAttrs(rest, true);
	const restProps = omit(rest, Object.keys(a11yProps));
	const qrCodeProps = {
		value,
		size,
		level: errorLevel,
		bgColor,
		fgColor: color,
		style: {
			width: style$1?.width,
			height: style$1?.height
		},
		imageSettings: icon ? imageSettings : void 0,
		boostLevel,
		...a11yProps
	};
	const [locale$5] = useLocale_default("QRCode");
	{
		const warning$3 = devUseWarning("QRCode");
		warning$3(!!value, "usage", "need to receive `value` props");
		warning$3(!(icon && errorLevel === "L"), "usage", "ErrorLevel `L` is not recommended to be used with `icon`, for scanning result would be affected by low level.");
	}
	if (!value) return null;
	const rootClassNames = clsx(prefixCls, className, rootClassName, hashId, cssVarCls, contextClassName, mergedClassNames.root, { [`${prefixCls}-borderless`]: !bordered });
	const rootStyle = {
		backgroundColor: bgColor,
		...mergedStyles.root,
		...contextStyle,
		...style$1,
		width: style$1?.width ?? size,
		height: style$1?.height ?? size
	};
	return /* @__PURE__ */ import_react.createElement("div", {
		...restProps,
		className: rootClassNames,
		style: rootStyle
	}, status !== "active" && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-cover`, mergedClassNames.cover),
		style: mergedStyles.cover
	}, /* @__PURE__ */ import_react.createElement(QRcodeStatus, {
		prefixCls,
		locale: locale$5,
		status,
		onRefresh,
		statusRender
	})), type$2 === "canvas" ? /* @__PURE__ */ import_react.createElement(QRCodeCanvas, { ...qrCodeProps }) : /* @__PURE__ */ import_react.createElement(QRCodeSVG, { ...qrCodeProps }));
};
QRCode.displayName = "QRCode";
var qr_code_default = QRCode;

//#endregion
//#region node_modules/@rc-component/rate/es/Star.js
function Star(props, ref) {
	const { disabled, prefixCls, character: character$1, characterRender, index: index$1, count, value, allowHalf, focused, onHover, onClick } = props;
	const onInternalHover = (e$2) => {
		onHover(e$2, index$1);
	};
	const onInternalClick = (e$2) => {
		onClick(e$2, index$1);
	};
	const onInternalKeyDown = (e$2) => {
		if (e$2.keyCode === KeyCode_default.ENTER) onClick(e$2, index$1);
	};
	const starValue = index$1 + 1;
	const classNameList = new Set([prefixCls]);
	if (value === 0 && index$1 === 0 && focused) classNameList.add(`${prefixCls}-focused`);
	else if (allowHalf && value + .5 >= starValue && value < starValue) {
		classNameList.add(`${prefixCls}-half`);
		classNameList.add(`${prefixCls}-active`);
		if (focused) classNameList.add(`${prefixCls}-focused`);
	} else {
		if (starValue <= value) classNameList.add(`${prefixCls}-full`);
		else classNameList.add(`${prefixCls}-zero`);
		if (starValue === value && focused) classNameList.add(`${prefixCls}-focused`);
	}
	const characterNode = typeof character$1 === "function" ? character$1(props) : character$1;
	let start = /* @__PURE__ */ import_react.createElement("li", {
		className: clsx(Array.from(classNameList)),
		ref
	}, /* @__PURE__ */ import_react.createElement("div", {
		onClick: disabled ? null : onInternalClick,
		onKeyDown: disabled ? null : onInternalKeyDown,
		onMouseMove: disabled ? null : onInternalHover,
		role: "radio",
		"aria-checked": value > index$1 ? "true" : "false",
		"aria-posinset": index$1 + 1,
		"aria-setsize": count,
		tabIndex: disabled ? -1 : 0
	}, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-first` }, characterNode), /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-second` }, characterNode)));
	if (characterRender) start = characterRender(start, props);
	return start;
}
var Star_default = /* @__PURE__ */ import_react.forwardRef(Star);

//#endregion
//#region node_modules/@rc-component/rate/es/useRefs.js
function useRefs() {
	const nodeRef = import_react.useRef({});
	function getRef(index$1) {
		return nodeRef.current[index$1];
	}
	function setRef(index$1) {
		return (node$1) => {
			nodeRef.current[index$1] = node$1;
		};
	}
	return [getRef, setRef];
}

//#endregion
//#region node_modules/@rc-component/rate/es/util.js
function getScroll(w) {
	let ret = w.pageXOffset;
	const method$1 = "scrollLeft";
	if (typeof ret !== "number") {
		const d = w.document;
		ret = d.documentElement[method$1];
		if (typeof ret !== "number") ret = d.body[method$1];
	}
	return ret;
}
function getClientPosition(elem) {
	let x;
	let y;
	const doc = elem.ownerDocument;
	const { body } = doc;
	const docElem = doc && doc.documentElement;
	const box$1 = elem.getBoundingClientRect();
	x = box$1.left;
	y = box$1.top;
	x -= docElem.clientLeft || body.clientLeft || 0;
	y -= docElem.clientTop || body.clientTop || 0;
	return {
		left: x,
		top: y
	};
}
function getOffsetLeft(el) {
	const pos = getClientPosition(el);
	const doc = el.ownerDocument;
	const w = doc.defaultView || doc.parentWindow;
	pos.left += getScroll(w);
	return pos.left;
}

//#endregion
//#region node_modules/@rc-component/rate/es/Rate.js
function _extends$25() {
	_extends$25 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$25.apply(this, arguments);
}
function Rate$1(props, ref) {
	const { prefixCls = "rc-rate", className, defaultValue, value: propValue, count = 5, allowHalf = false, allowClear = true, keyboard = true, character: character$1 = "", characterRender, disabled, direction = "ltr", tabIndex = 0, autoFocus, onHoverChange, onChange, onFocus, onBlur, onKeyDown: onKeyDown$1, onMouseLeave, ...restProps } = props;
	const [getStarRef, setStarRef] = useRefs();
	const rateRef = import_react.useRef(null);
	const triggerFocus$1 = () => {
		if (!disabled) rateRef.current?.focus();
	};
	import_react.useImperativeHandle(ref, () => ({
		focus: triggerFocus$1,
		blur: () => {
			if (!disabled) rateRef.current?.blur();
		}
	}));
	const [value, setValue] = useControlledState(defaultValue || 0, propValue);
	const [cleanedValue, setCleanedValue] = useControlledState(null);
	const getStarValue = (index$1, x) => {
		const reverse = direction === "rtl";
		let starValue = index$1 + 1;
		if (allowHalf) {
			const starEle = getStarRef(index$1);
			const leftDis = getOffsetLeft(starEle);
			const width = starEle.clientWidth;
			if (reverse && x - leftDis > width / 2) starValue -= .5;
			else if (!reverse && x - leftDis < width / 2) starValue -= .5;
		}
		return starValue;
	};
	const changeValue = (nextValue) => {
		setValue(nextValue);
		onChange?.(nextValue);
	};
	const [focused, setFocused] = import_react.useState(false);
	const onInternalFocus = () => {
		setFocused(true);
		onFocus?.();
	};
	const onInternalBlur = () => {
		setFocused(false);
		onBlur?.();
	};
	const [hoverValue, setHoverValue] = import_react.useState(null);
	const onHover = (event, index$1) => {
		const nextHoverValue = getStarValue(index$1, event.pageX);
		if (nextHoverValue !== cleanedValue) {
			setHoverValue(nextHoverValue);
			setCleanedValue(null);
		}
		onHoverChange?.(nextHoverValue);
	};
	const onMouseLeaveCallback = (event) => {
		if (!disabled) {
			setHoverValue(null);
			setCleanedValue(null);
			onHoverChange?.(void 0);
		}
		if (event) onMouseLeave?.(event);
	};
	const onClick = (event, index$1) => {
		const newValue = getStarValue(index$1, event.pageX);
		let isReset = false;
		if (allowClear) isReset = newValue === value;
		onMouseLeaveCallback();
		changeValue(isReset ? 0 : newValue);
		setCleanedValue(isReset ? newValue : null);
	};
	const onInternalKeyDown = (event) => {
		const { keyCode } = event;
		const reverse = direction === "rtl";
		const step = allowHalf ? .5 : 1;
		if (keyboard) {
			if (keyCode === KeyCode_default.RIGHT && value < count && !reverse) {
				changeValue(value + step);
				event.preventDefault();
			} else if (keyCode === KeyCode_default.LEFT && value > 0 && !reverse) {
				changeValue(value - step);
				event.preventDefault();
			} else if (keyCode === KeyCode_default.RIGHT && value > 0 && reverse) {
				changeValue(value - step);
				event.preventDefault();
			} else if (keyCode === KeyCode_default.LEFT && value < count && reverse) {
				changeValue(value + step);
				event.preventDefault();
			}
		}
		onKeyDown$1?.(event);
	};
	import_react.useEffect(() => {
		if (autoFocus && !disabled) triggerFocus$1();
	}, []);
	const starNodes = new Array(count).fill(0).map((item, index$1) => /* @__PURE__ */ import_react.createElement(Star_default, {
		ref: setStarRef(index$1),
		index: index$1,
		count,
		disabled,
		prefixCls: `${prefixCls}-star`,
		allowHalf,
		value: hoverValue === null ? value : hoverValue,
		onClick,
		onHover,
		key: item || index$1,
		character: character$1,
		characterRender,
		focused
	}));
	const classString = clsx(prefixCls, className, {
		[`${prefixCls}-disabled`]: disabled,
		[`${prefixCls}-rtl`]: direction === "rtl"
	});
	return /* @__PURE__ */ import_react.createElement("ul", _extends$25({
		className: classString,
		onMouseLeave: onMouseLeaveCallback,
		tabIndex: disabled ? -1 : tabIndex,
		onFocus: disabled ? null : onInternalFocus,
		onBlur: disabled ? null : onInternalBlur,
		onKeyDown: disabled ? null : onInternalKeyDown,
		ref: rateRef
	}, pickAttrs(restProps, {
		aria: true,
		data: true,
		attr: true
	})), starNodes);
}
var Rate_default = /* @__PURE__ */ import_react.forwardRef(Rate$1);

//#endregion
//#region node_modules/@rc-component/rate/es/index.js
var es_default$11 = Rate_default;

//#endregion
//#region node_modules/antd/es/rate/style/index.js
var genRateStarStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-star`]: {
		position: "relative",
		display: "inline-block",
		color: "inherit",
		cursor: "pointer",
		"&:not(:last-child)": { marginInlineEnd: token$1.marginXS },
		"> div": {
			transition: `all ${token$1.motionDurationMid}, outline 0s`,
			"&:hover": { transform: token$1.starHoverScale },
			"&:focus": { outline: 0 },
			"&:focus-visible": {
				outline: `${unit(token$1.lineWidth)} dashed ${token$1.starColor}`,
				transform: token$1.starHoverScale
			}
		},
		"&-first, &-second": {
			color: token$1.starBg,
			transition: `all ${token$1.motionDurationMid}`,
			userSelect: "none"
		},
		"&-first": {
			position: "absolute",
			top: 0,
			insetInlineStart: 0,
			width: "50%",
			height: "100%",
			overflow: "hidden",
			opacity: 0
		},
		[`&-half ${componentCls}-star-first, &-half ${componentCls}-star-second`]: { opacity: 1 },
		[`&-half ${componentCls}-star-first, &-full ${componentCls}-star-second`]: { color: "inherit" }
	} };
};
var genRateRtlStyle = (token$1) => ({ [`&-rtl${token$1.componentCls}`]: { direction: "rtl" } });
var genRateStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: {
		...resetComponent(token$1),
		display: "inline-block",
		margin: 0,
		padding: 0,
		color: token$1.starColor,
		fontSize: token$1.starSize,
		lineHeight: 1,
		listStyle: "none",
		outline: "none",
		"&-small": { fontSize: token$1.starSizeSM },
		"&-large": { fontSize: token$1.starSizeLG },
		[`&-disabled${componentCls} ${componentCls}-star`]: {
			cursor: "default",
			"> div:hover": { transform: "scale(1)" }
		},
		...genRateStarStyle(token$1),
		...genRateRtlStyle(token$1)
	} };
};
const prepareComponentToken$13 = (token$1) => ({
	starColor: token$1.yellow6,
	starSize: token$1.controlHeight * .625,
	starSizeSM: token$1.controlHeightSM * .625,
	starSizeLG: token$1.controlHeightLG * .625,
	starHoverScale: "scale(1.1)",
	starBg: token$1.colorFillContent
});
var style_default$14 = genStyleHooks("Rate", (token$1) => {
	return genRateStyle(merge(token$1, {}));
}, prepareComponentToken$13);

//#endregion
//#region node_modules/antd/es/rate/index.js
var isTooltipProps = (item) => {
	return typeof item === "object" && item !== null;
};
var Rate = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls, className, rootClassName, style: style$1, tooltips, character: character$1 = /* @__PURE__ */ import_react.createElement(StarFilled_default, null), disabled: customDisabled, size = "middle", ...rest } = props;
	const characterRender = (node$1, { index: index$1 }) => {
		if (!tooltips) return node$1;
		const tooltipsItem = tooltips[index$1];
		if (isTooltipProps(tooltipsItem)) return /* @__PURE__ */ import_react.createElement(tooltip_default, { ...tooltipsItem }, node$1);
		return /* @__PURE__ */ import_react.createElement(tooltip_default, { title: tooltipsItem }, node$1);
	};
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle } = useComponentConfig("rate");
	const ratePrefixCls = getPrefixCls("rate", prefixCls);
	const [hashId, cssVarCls] = style_default$14(ratePrefixCls);
	const mergedStyle = {
		...contextStyle,
		...style$1
	};
	const disabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = customDisabled ?? disabled;
	return /* @__PURE__ */ import_react.createElement(es_default$11, {
		ref,
		character: character$1,
		characterRender,
		disabled: mergedDisabled,
		...rest,
		className: clsx(`${ratePrefixCls}-${size}`, className, rootClassName, hashId, cssVarCls, contextClassName),
		style: mergedStyle,
		prefixCls: ratePrefixCls,
		direction
	});
});
Rate.displayName = "Rate";
var rate_default = Rate;

//#endregion
//#region node_modules/antd/es/result/noFound.js
var NoFound = () => /* @__PURE__ */ import_react.createElement("svg", {
	width: "252",
	height: "294"
}, /* @__PURE__ */ import_react.createElement("title", null, "No Found"), /* @__PURE__ */ import_react.createElement("g", {
	fill: "none",
	fillRule: "evenodd"
}, /* @__PURE__ */ import_react.createElement("circle", {
	cx: "126.75",
	cy: "128.1",
	r: "126",
	fill: "#E4EBF7"
}), /* @__PURE__ */ import_react.createElement("circle", {
	cx: "31.55",
	cy: "130.8",
	r: "8.3",
	fill: "#FFF"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#FFF",
	d: "m37 134.3 10.5 6m.9 6.2-12.7 10.8",
	strokeWidth: "2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M39.9 159.4a5.7 5.7 0 1 1-11.3-1.2 5.7 5.7 0 0 1 11.3 1.2m17.7-16.2a5.7 5.7 0 1 1-11.4-1.1 5.7 5.7 0 0 1 11.4 1.1M99 27h29.8a4.6 4.6 0 1 0 0-9.2H99a4.6 4.6 0 1 0 0 9.2m11.4 18.3h29.8a4.6 4.6 0 0 0 0-9.2h-29.8a4.6 4.6 0 1 0 0 9.2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M112.8 26.9h15.8a4.6 4.6 0 1 0 0 9.1h-15.8a4.6 4.6 0 0 0 0-9.1m71.7 108.8a10 10 0 1 1-19.8-2 10 10 0 0 1 19.8 2"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#FFF",
	d: "m179.3 141.8 12.6 7.1m1.1 7.6-15.2 13",
	strokeWidth: "2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M184.7 170a6.8 6.8 0 1 1-13.6-1.3 6.8 6.8 0 0 1 13.6 1.4m18.6-16.8a6.9 6.9 0 1 1-13.7-1.4 6.9 6.9 0 0 1 13.7 1.4"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#FFF",
	d: "M152 192.3a2.2 2.2 0 1 1-4.5 0 2.2 2.2 0 0 1 4.4 0zm73.3-76.2a2.2 2.2 0 1 1-4.5 0 2.2 2.2 0 0 1 4.5 0zm-9 35a2.2 2.2 0 1 1-4.4 0 2.2 2.2 0 0 1 4.5 0zM177 107.6a2.2 2.2 0 1 1-4.4 0 2.2 2.2 0 0 1 4.4 0zm18.4-15.4a2.2 2.2 0 1 1-4.5 0 2.2 2.2 0 0 1 4.5 0zm6.8 88.5a2.2 2.2 0 1 1-4.5 0 2.2 2.2 0 0 1 4.5 0z",
	strokeWidth: "2"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#FFF",
	d: "m214.4 153.3-2 20.2-10.8 6m-28-4.7-6.3 9.8H156l-4.5 6.5m23.5-66v-15.7m46 7.8-13 8-15.2-8V94.4",
	strokeWidth: "2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M166.6 66h-4a4.8 4.8 0 0 1-4.7-4.8 4.8 4.8 0 0 1 4.7-4.7h4a4.8 4.8 0 0 1 4.7 4.7 4.8 4.8 0 0 1-4.7 4.7"
}), /* @__PURE__ */ import_react.createElement("circle", {
	cx: "204.3",
	cy: "30",
	r: "29.5",
	fill: "#1677ff"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M206 38.4c.5.5.7 1.1.7 2s-.2 1.4-.7 1.9a3 3 0 0 1-2 .7c-.8 0-1.5-.3-2-.8s-.8-1.1-.8-1.9.3-1.4.8-2c.5-.4 1.2-.7 2-.7.7 0 1.4.3 2 .8m4.2-19.5c1.5 1.3 2.2 3 2.2 5.2a7.2 7.2 0 0 1-1.5 4.5l-3 2.7a5 5 0 0 0-1.3 1.7 5.2 5.2 0 0 0-.6 2.4v.5h-4v-.5c0-1.4.1-2.5.6-3.5s1.9-2.5 4.2-4.5l.4-.5a4 4 0 0 0 1-2.6c0-1.2-.4-2-1-2.8-.7-.6-1.6-1-2.9-1-1.5 0-2.6.5-3.3 1.5-.4.5-.6 1-.8 1.9a2 2 0 0 1-2 1.6 2 2 0 0 1-2-2.4c.4-1.6 1-2.8 2.1-3.8a8.5 8.5 0 0 1 6.3-2.3c2.3 0 4.2.6 5.6 2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFB594",
	d: "M52 76.1s21.8 5.4 27.3 16c5.6 10.7-6.3 9.2-15.7 5C52.8 92 39 85 52 76"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "m90.5 67.5-.5 2.9c-.7.5-4.7-2.7-4.7-2.7l-1.7.8-1.3-5.7s6.8-4.6 9-5c2.4-.5 9.8 1 10.6 2.3 0 0 1.3.4-2.2.6-3.6.3-5 .5-6.8 3.2l-2.4 3.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M128 111.4a36.7 36.7 0 0 0-8.9-15.5c-3.5-3-9.3-2.2-11.3-4.2-1.3-1.2-3.2-1.2-3.2-1.2L87.7 87c-2.3-.4-2.1-.7-6-1.4-1.6-1.9-3-1.1-3-1.1l-7-1.4c-1-1.5-2.5-1-2.5-1l-2.4-.9C65 91.2 59 95 59 95c1.8 1.1 15.7 8.3 15.7 8.3l5.1 37.1s-3.3 5.7 1.4 9.1c0 0 19.9-3.7 34.9-.3 0 0 3-2.6 1-8.8.5-3 1.4-8.3 1.7-11.6.4.7 2 1.9 3.1 3.4 0 0 9.4-7.3 11-14a17 17 0 0 1-2.2-2.4c-.5-.8-.3-2-.7-2.8-.7-1-1.8-1.3-2-1.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#CBD1D1",
	d: "M101 290s4.4 2 7.4 1c2.9-1 4.6.7 7.1 1.2 2.6.5 6.9 1.1 11.7-1.3 0-5.5-6.9-4-12-6.7-2.5-1.4-3.7-4.7-3.5-8.8h-9.5s-1.2 10.6-1 14.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#2B0849",
	d: "M101 289.8s2.5 1.3 6.8.7c3-.5 3.7.5 7.4 1 3.8.6 10.8 0 11.9-.9.4 1.1-.4 2-.4 2s-1.5.7-4.8.9c-2 .1-5.8.3-7.6-.5-1.8-1.4-5.2-1.9-5.7-.2-4 1-7.4-.3-7.4-.3l-.1-2.7z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#A4AABA",
	d: "M108.3 276h3.1s0 6.7 4.6 8.6c-4.7.6-8.6-2.3-7.7-8.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#CBD1D1",
	d: "M57.5 272.4s-2 7.4-4.4 12.3c-1.8 3.7-4.3 7.5 5.4 7.5 6.7 0 9-.5 7.4-6.6-1.5-6.1.3-13.2.3-13.2h-8.7z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#2B0849",
	d: "M51.5 289.8s2 1.2 6.6 1.2c6 0 8.3-1.7 8.3-1.7s.6 1.1-.7 2.2c-1 .8-3.6 1.6-7.4 1.5-4.1 0-5.8-.5-6.7-1.1-.8-.6-.7-1.6-.1-2.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#A4AABA",
	d: "M58.4 274.3s0 1.5-.3 3c-.3 1.4-1 3-1.1 4 0 1.2 4.5 1.7 5.1.1.6-1.5 1.3-6.4 2-7.2.6-.9-5-2.2-5.7.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#7BB2F9",
	d: "m99.7 278.5 13.3.1s1.3-54.5 1.9-64.4c.5-9.9 3.8-43.4 1-63.1l-12.6-.7-22.8.8-1.2 10c0 .5-.7.8-.7 1.4-.1.5.4 1.3.3 2-2.4 14-6.4 33-8.8 46.6 0 .7-1.2 1-1.4 2.7 0 .3.2 1.5 0 1.8-6.8 18.7-10.9 47.8-14.2 61.9h14.6s2.2-8.6 4-17c2.9-12.9 23.2-85 23.2-85l3-.5 1 46.3s-.2 1.2.4 2c.5.8-.6 1.1-.4 2.3l.4 1.8-1 11.8c-.4 4.8 0 39.2 0 39.2"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M76 221.6c1.2.1 4.1-2 7-5m23.4 8.5s2.7-1 6-3.8",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M107.3 222.1s2.7-1.1 6-3.9",
	strokeLinecap: "round",
	strokeLinejoin: "round"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M74.7 224.8s2.7-.6 6.5-3.4m4.8-69.8c-.2 3.1.3 8.6-4.3 9.2m22-11s0 14-1.4 15.1a15 15 0 0 1-3 2m.5-16.5s0 13-1.2 24.4m-5 1.1s7.3-1.7 9.5-1.7M74.3 206a212 212 0 0 1-1 4.5s-1.4 1.9-1 3.8c.5 2-1 2-5 15.4A353 353 0 0 0 61 257l-.2 1.2m14.9-60.5a321 321 0 0 1-.9 4.8m7.8-50.4-1.2 10.5s-1.1.1-.5 2.2c.1 1.4-2.7 15.8-5.2 30.5m-19.6 79h13.3",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#192064",
	d: "M116.2 148.2s-17-3-35.9.2c.2 2.5 0 4.2 0 4.2s14.7-2.8 35.7-.3c.3-2.4.2-4 .2-4"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M106.3 151.2v-5a.8.8 0 0 0-.8-.8h-7.8a.8.8 0 0 0-.8.8v5a.8.8 0 0 0 .8.8h7.8a.8.8 0 0 0 .8-.8"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#192064",
	d: "M105.2 150.2v-3a.6.6 0 0 0-.6-.7 94.3 94.3 0 0 0-5.9 0 .7.7 0 0 0-.6.6v3.1a.6.6 0 0 0 .6.7 121.1 121.1 0 0 1 5.8 0c.4 0 .7-.3.7-.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M100.3 275.4h12.3m-11.2-4.9.1 6.5m0-12.5a915.8 915.8 0 0 0 0 4.4m-.5-94 .9 44.7s.7 1.6-.2 2.7c-1 1.1 2.4.7.9 2.2-1.6 1.6.9 1.2 0 3.4-.6 1.5-1 21.1-1.1 35.2",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "M46.9 83.4s-.5 6 7.2 5.6c11.2-.7 9.2-9.4 31.5-21.7-.7-2.7-2.4-4.7-2.4-4.7s-11 3-22.6 8c-6.8 3-13.4 6.4-13.7 12.8m57.6 7.7.9-5.4-8.9-11.4-5 5.3-1.8 7.9a.3.3 0 0 0 .1.3c1 .8 6.5 5 14.4 3.5a.3.3 0 0 0 .3-.2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "M94 79.4s-4.6-2.9-2.5-6.9c1.6-3 4.5 1.2 4.5 1.2s.5-3.7 3.1-3.7c.6-1 1.6-4.1 1.6-4.1l13.5 3c0 5.3-2.3 19.5-7.8 20-8.9.6-12.5-9.5-12.5-9.5"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#520038",
	d: "M113.9 73.4c2.6-2 3.4-9.7 3.4-9.7s-2.4-.5-6.6-2c-4.7-2.1-12.8-4.8-17.5 1-9.6 3.2-2 19.8-2 19.8l2.7-3s-4-3.3-2-6.3c2-3.5 3.8 1 3.8 1s.7-2.3 3.6-3.3c.4-.7 1-2.6 1.4-3.8a1 1 0 0 1 1.3-.7l11.4 2.6c.5.2.8.7.8 1.2l-.3 3.2z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#552950",
	d: "M105 76c-.1.7-.6 1.1-1 1-.6 0-.9-.6-.8-1.2.1-.6.6-1 1-1 .6 0 .9.7.8 1.3m7.1 1.6c0 .6-.5 1-1 1-.5-.1-.8-.7-.7-1.3 0-.6.5-1 1-1 .5.1.8.7.7 1.3"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "m110.1 74.8-.9 1.7-.3 4.3h-2.2",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#5C2552",
	d: "M110.8 74.5s1.8-.7 2.6.5",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "M92.4 74.3s.5-1.1 1.1-.7c.6.4 1.3 1.4.6 2-.8.5.1 1.6.1 1.6",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#5C2552",
	d: "M103.3 73s1.8 1 4.1.9",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "M103.7 81.8s2.2 1.2 4.4 1.2m-3.5 1.3s1 .4 1.6.3m-11.5-3.4s2.3 7.4 10.4 7.6",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E4EBF7",
	d: "M81.5 89.4s.4 5.6-5 12.8M69 82.7s-.7 9.2-8.2 14.2m68.6 26s-5.3 7.4-9.4 10.7m-.7-26.3s.5 4.4-2.1 32",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#F2D7AD",
	d: "M150 151.2h-49.8a1 1 0 0 1-1-1v-31.7c0-.5.4-1 1-1H150c.6 0 1 .5 1 1v31.7a1 1 0 0 1-1 1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#F4D19D",
	d: "M150.3 151.2h-19.9v-33.7h20.8v32.8a1 1 0 0 1-1 1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#F2D7AD",
	d: "M123.6 127.9H92.9a.5.5 0 0 1-.4-.8l6.4-9.1c.2-.3.5-.5.8-.5h31.1l-7.2 10.4z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#CC9B6E",
	d: "M123.7 128.4H99.2v-.5h24.2l7.2-10.2.4.3z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#F4D19D",
	d: "M158.3 127.9h-18.7a2 2 0 0 1-1.6-.8l-7.2-9.6h20c.5 0 1 .3 1.2.6l6.7 9a.5.5 0 0 1-.4.8"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#CC9B6E",
	d: "M157.8 128.5h-19.3l-7.9-10.5.4-.3 7.7 10.3h19.1zm-27.2 22.2v-8.2h.4v8.2zm-.1-10.9v-21.4h.4l.1 21.4zm-18.6 1.1-.5-.1 1.5-5.2.5.2zm-3.5.2-2.6-3 2.6-3.4.4.3-2.4 3.1 2.4 2.6zm8.2 0-.4-.4 2.4-2.6-2.4-3 .4-.4 2.7 3.4z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "m154.3 131.9-3.1-2v3.5l-1 .1a85 85 0 0 1-4.8.3c-1.9 0-2.7 2.2 2.2 2.6l-2.6-.6s-2.2 1.3.5 2.3c0 0-1.6 1.2.6 2.6-.6 3.5 5.2 4 7 3.6a6.1 6.1 0 0 0 4.6-5.2 8 8 0 0 0-3.4-7.2"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "M153.7 133.6s-6.5.4-8.4.3c-1.8 0-1.9 2.2 2.4 2.3 3.7.2 5.4 0 5.4 0",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "M145.2 135.9c-1.9 1.3.5 2.3.5 2.3s3.5 1 6.8.6m-.6 2.9s-6.3.1-6.7-2.1c-.3-1.4.4-1.4.4-1.4m.5 2.7s-1 3.1 5.5 3.5m-.4-14.5v3.5M52.8 89.3a18 18 0 0 0 13.6-7.8",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#5BA02E",
	d: "M168.6 248.3a6.6 6.6 0 0 1-6.7-6.6v-66.5a6.6 6.6 0 1 1 13.3 0v66.5a6.6 6.6 0 0 1-6.6 6.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#92C110",
	d: "M176.5 247.7a6.6 6.6 0 0 1-6.6-6.7v-33.2a6.6 6.6 0 1 1 13.3 0V241a6.6 6.6 0 0 1-6.7 6.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#F2D7AD",
	d: "M186.4 293.6H159a3.2 3.2 0 0 1-3.2-3.2v-46.1a3.2 3.2 0 0 1 3.2-3.2h27.5a3.2 3.2 0 0 1 3.2 3.2v46.1a3.2 3.2 0 0 1-3.2 3.2"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E4EBF7",
	d: "M89 89.5s7.8 5.4 16.6 2.8",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
})));
var noFound_default = NoFound;

//#endregion
//#region node_modules/antd/es/result/serverError.js
var ServerError = () => /* @__PURE__ */ import_react.createElement("svg", {
	width: "254",
	height: "294"
}, /* @__PURE__ */ import_react.createElement("title", null, "Server Error"), /* @__PURE__ */ import_react.createElement("g", {
	fill: "none",
	fillRule: "evenodd"
}, /* @__PURE__ */ import_react.createElement("path", {
	fill: "#E4EBF7",
	d: "M0 128.1v-2C0 56.5 56.3.2 125.7.2h2.1C197.2.3 253.5 56.6 253.5 126v2.1c0 69.5-56.3 125.7-125.7 125.7h-2.1A125.7 125.7 0 0 1 0 128.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M40 132.1a8.3 8.3 0 1 1-16.6-1.7 8.3 8.3 0 0 1 16.6 1.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#FFF",
	d: "m37.2 135.6 10.5 6m1 6.3-12.8 10.8",
	strokeWidth: "2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M40.1 160.8a5.7 5.7 0 1 1-11.3-1.1 5.7 5.7 0 0 1 11.3 1.1M58 144.6a5.7 5.7 0 1 1-11.4-1.2 5.7 5.7 0 0 1 11.4 1.2M99.7 27.4h30a4.6 4.6 0 1 0 0-9.2h-30a4.6 4.6 0 0 0 0 9.2M111 46h30a4.6 4.6 0 1 0 0-9.3h-30a4.6 4.6 0 1 0 0 9.3m2.5-18.6h16a4.6 4.6 0 1 0 0 9.3h-16a4.6 4.6 0 0 0 0-9.3m36.7 42.7h-4a4.8 4.8 0 0 1-4.8-4.8 4.8 4.8 0 0 1 4.8-4.8h4a4.8 4.8 0 0 1 4.7 4.8 4.8 4.8 0 0 1-4.7 4.8"
}), /* @__PURE__ */ import_react.createElement("circle", {
	cx: "201.35",
	cy: "30.2",
	r: "29.7",
	fill: "#FF603B"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "m203.6 19.4-.7 15a1.5 1.5 0 0 1-3 0l-.7-15a2.2 2.2 0 1 1 4.4 0m-.3 19.4c.5.5.8 1.1.8 1.9s-.3 1.4-.8 1.9a3 3 0 0 1-2 .7 2.5 2.5 0 0 1-1.8-.7c-.6-.6-.8-1.2-.8-2 0-.7.2-1.3.8-1.8.5-.5 1.1-.7 1.8-.7.8 0 1.5.2 2 .7"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFB594",
	d: "M119.3 133.3c4.4-.6 3.6-1.2 4-4.8.8-5.2-3-17-8.2-25.1-1-10.7-12.6-11.3-12.6-11.3s4.3 5 4.2 16.2c1.4 5.3.8 14.5.8 14.5s5.3 11.4 11.8 10.5"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M101 91.6s1.4-.6 3.2.6c8 1.4 10.3 6.7 11.3 11.4 1.8 1.2 1.8 2.3 1.8 3.5l1.5 3s-7.2 1.7-11 6.7c-1.3-6.4-6.9-25.2-6.9-25.2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFB594",
	d: "m94 90.5 1-5.8-9.2-11.9-5.2 5.6-2.6 9.9s8.4 5 16 2.2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "M83 78.2s-4.6-2.9-2.5-6.9c1.6-3 4.5 1.2 4.5 1.2s.5-3.7 3.2-3.7c.5-1 1.5-4.2 1.5-4.2l13.6 3.2c0 5.2-2.3 19.5-7.9 20-8.9.6-12.5-9.6-12.5-9.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#520038",
	d: "M103 72.2c2.6-2 3.5-9.7 3.5-9.7s-2.5-.5-6.7-2c-4.7-2.2-12.9-4.9-17.6.9-9.5 4.4-2 20-2 20l2.7-3.1s-4-3.3-2.1-6.3c2.2-3.5 4 1 4 1s.6-2.3 3.5-3.3c.4-.7 1-2.7 1.5-3.8A1 1 0 0 1 91 65l11.5 2.7c.5.1.8.6.8 1.2l-.3 3.2z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#552950",
	d: "M101.2 76.5c0 .6-.6 1-1 1-.5-.1-.9-.7-.8-1.3.1-.6.6-1 1.1-1 .5.1.8.7.7 1.3m-7-1.4c0 .6-.5 1-1 1-.5-.1-.8-.7-.7-1.3 0-.6.6-1 1-1 .5.1.9.7.8 1.3"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "m99.2 73.6-.9 1.7-.3 4.3h-2.2",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#5C2552",
	d: "M100 73.3s1.7-.7 2.4.5",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "M81.4 73s.4-1 1-.6c.7.4 1.4 1.4.6 2s.2 1.6.2 1.6",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#5C2552",
	d: "M92.3 71.7s1.9 1.1 4.2 1",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "M92.7 80.6s2.3 1.2 4.4 1.2m-3.4 1.4s1 .4 1.5.3M83.7 80s1.8 6.6 9.2 8",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E4EBF7",
	d: "M95.5 91.7s-1 2.8-8.2 2c-7.3-.6-10.3-5-10.3-5",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M78.1 87.5s6.6 5 16.5 2.5c0 0 9.6 1 11.5 5.3 5.4 11.8.6 36.8 0 40 3.5 4-.4 8.4-.4 8.4-15.7-3.5-35.8-.6-35.8-.6-4.9-3.5-1.3-9-1.3-9l-6.2-23.8c-2.5-15.2.8-19.8 3.5-20.7 3-1 8-1.3 8-1.3.6 0 1.1 0 1.4-.2 2.4-1.3 2.8-.6 2.8-.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "M65.8 89.8s-6.8.5-7.6 8.2c-.4 8.8 3 11 3 11s6.1 22 16.9 22.9c8.4-2.2 4.7-6.7 4.6-11.4-.2-11.3-7-17-7-17s-4.3-13.7-9.9-13.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "M71.7 124.2s.9 11.3 9.8 6.5c4.8-2.5 7.6-13.8 9.8-22.6A201 201 0 0 0 94 96l-5-1.7s-2.4 5.6-7.7 12.3c-4.4 5.5-9.2 11.1-9.5 17.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E4EBF7",
	d: "M108.5 105.2s1.7 2.7-2.4 30.5c2.4 2.2 1 6-.2 7.5",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "M123.3 131.5s-.5 2.8-11.8 2c-15.2-1-25.3-3.2-25.3-3.2l.9-5.8s.7.2 9.7-.1c11.9-.4 18.7-6 25-1 4 3.2 1.5 8.1 1.5 8.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M70.2 91s-5.6-4.8-11 2.7c-3.3 7.2.5 15.2 2.6 19.5-.3 3.8 2.4 4.3 2.4 4.3s0 1 1.5 2.7c4-7 6.7-9.1 13.7-12.5-.3-.7-1.9-3.3-1.8-3.8.2-1.7-1.3-2.6-1.3-2.6s-.3-.2-1.2-2.8c-.8-2.3-2-5.1-4.9-7.5"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#CBD1D1",
	d: "M90.2 288s4.9 2.3 8.3 1.2c3.2-1 5.2.7 8 1.3a20 20 0 0 0 13.3-1.4c-.2-6.2-7.8-4.5-13.6-7.6-2.9-1.6-4.2-5.3-4-10H91.5s-1.5 12-1.3 16.5"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#2B0849",
	d: "M90.2 287.8s2.8 1.5 7.6.8c3.5-.5 3.3.6 7.5 1.3 4.2.6 13-.2 14.3-1.2.5 1.3-.4 2.4-.4 2.4s-1.7.6-5.4.9c-2.3.1-8.1.3-10.2-.6-2-1.6-4.9-1.5-6-.3-4.5 1.1-7.2-.3-7.2-.3l-.2-3z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#A4AABA",
	d: "M98.4 272.3h3.5s0 7.5 5.2 9.6c-5.3.7-9.7-2.6-8.7-9.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#CBD1D1",
	d: "M44.4 272s-2.2 7.8-4.7 13c-1.9 3.8-4.4 7.8 5.8 7.8 7 0 9.3-.5 7.7-7-1.6-6.3.3-13.8.3-13.8h-9z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#2B0849",
	d: "M38 290.3s2.3 1.2 7 1.2c6.4 0 8.7-1.7 8.7-1.7s.6 1.1-.7 2.2c-1 1-3.8 1.7-7.7 1.7-4.4 0-6.1-.6-7-1.3-1-.5-.8-1.6-.2-2.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#A4AABA",
	d: "M45.3 274s0 1.6-.3 3.1-1.1 3.3-1.2 4.4c0 1.2 4.8 1.6 5.4 0 .7-1.6 1.4-6.8 2-7.6.7-.9-5.1-2.2-5.9.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#7BB2F9",
	d: "M89.5 277.6h13.9s1.3-56.6 1.9-66.8c.6-10.3 4-45.1 1-65.6l-13-.7-23.7.8-1.3 10.4c0 .5-.7.9-.8 1.4 0 .6.5 1.4.4 2L59.6 206c-.1.7-1.3 1-1.5 2.8 0 .3.2 1.6.1 1.8-7.1 19.5-12.2 52.6-15.6 67.2h15.1L62 259c3-13.3 24-88.3 24-88.3l3.2-1-.2 48.6s-.2 1.3.4 2.1c.5.8-.6 1.2-.4 2.4l.4 1.8-1 12.4c-.4 4.9 1.2 40.7 1.2 40.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M64.6 218.9c1.2 0 4.2-2.1 7.2-5.1m24.2 8.7s3-1.1 6.4-4",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M97 219.4s2.9-1.2 6.3-4",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M63.2 222.1s2.7-.6 6.7-3.5m5-72.4c-.3 3.2.3 8.8-4.5 9.4m22.8-11.3s.1 14.6-1.4 15.7c-2.3 1.7-3 2-3 2m.4-17s.3 13-1 25m-4.7.7s6.8-1 9.1-1M46 270l-.9 4.6m1.8-11.3-.8 4.1m16.6-64.9c-.3 1.6 0 2-.4 3.4 0 0-2.8 2-2.3 4s-.3 3.4-4.5 17.2c-1.8 5.8-4.3 19-6.2 28.3l-1.1 5.8m16-67-1 4.9m8.1-52.3-1.2 10.9s-1.2.1-.5 2.3c0 1.4-2.8 16.4-5.4 31.6m-20 82.1h13.9",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#192064",
	d: "M106.2 142.1c-3-.5-18.8-2.7-36.2.2a.6.6 0 0 0-.6.7v3a.6.6 0 0 0 .8.6c3.3-.5 17-2.4 35.6-.3.4 0 .7-.2.7-.5.2-1.4.2-2.5.2-3a.6.6 0 0 0-.5-.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M96.4 145.3v-5.1a.8.8 0 0 0-.8-.9 114.1 114.1 0 0 0-8.1 0 .8.8 0 0 0-.9.8v5.1c0 .5.4.9.9.9h8a.8.8 0 0 0 .9-.8"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#192064",
	d: "M95.2 144.3v-3.2a.7.7 0 0 0-.6-.7h-6.1a.7.7 0 0 0-.6.7v3.2c0 .4.3.7.6.7h6c.4 0 .7-.3.7-.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M90.1 273.5h12.8m-11.7-3.7v6.3m-.3-12.6v4.5m-.5-97.6 1 46.4s.7 1.6-.3 2.8c-.9 1.1 2.6.7 1 2.3-1.7 1.6.9 1.2 0 3.5-.6 1.6-1 22-1.2 36.5",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E4EBF7",
	d: "M73.7 98.7 76 103s2 .8 1.8 2.7l.8 2.2m-14.3 8.7c.2-1 2.2-7.1 12.6-10.5m.7-16s7.7 6 16.5 2.7",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "M92 87s5.5-.9 7.5-4.6c1.3-.3.8 2.2-.3 3.7l-1 1.5s.2.3.2.9c0 .6-.2.6-.3 1v1l-.4 1c-.1.2 0 .6-.2.9-.2.4-1.6 1.8-2.6 2.8-3.8 3.6-5 1.7-6-.4-1-1.8-.7-5.1-.9-6.9-.3-2.9-2.6-3-2-4.4.4-.7 3 .7 3.4 1.8.7 2 2.9 1.8 2.6 1.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "M99.8 82.4c-.5.1-.3.3-1 1.3-.6 1-4.8 2.9-6.4 3.2-2.5.5-2.2-1.6-4.2-2.9-1.7-1-3.6-.6-1.4 1.4 1 1 1 1.1 1.4 3.2.3 1.5-.7 3.7.7 5.6",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: ".8"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E59788",
	d: "M79.5 108.7c-2 2.9-4.2 6.1-5.5 8.7",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: ".8"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "M87.7 124.8s-2-2-5.1-2.8c-3-.7-3.6-.1-5.5.1-2 .3-4-.9-3.7.7.3 1.7 5 1 5.2 2.1.2 1.1-6.3 2.8-8.3 2.2-.8.8.5 1.9 2 2.2.3 1.5 2.3 1.5 2.3 1.5s.7 1 2.6 1.1c2.5 1.3 9-.7 11-1.5 2-.9-.5-5.6-.5-5.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E59788",
	d: "M73.4 122.8s.7 1.2 3.2 1.4c2.3.3 2.6.6 2.6.6s-2.6 3-9.1 2.3m2.3 2.2s3.8 0 5-.7m-2.4 2.2s2 0 3.3-.6m-1 1.7s1.7 0 2.8-.5m-6.8-9s-.6-1.1 1.3-.5c1.7.5 2.8 0 5.1.1 1.4.1 3-.2 4 .2 1.6.8 3.6 2.2 3.6 2.2s10.6 1.2 19-1.1M79 108s-8.4 2.8-13.2 12.1",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: ".8"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E4EBF7",
	d: "M109.3 112.5s3.4-3.6 7.6-4.6",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E59788",
	d: "M107.4 123s9.7-2.7 11.4-.9",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: ".8"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#BFCDDD",
	d: "m194.6 83.7 4-4M187.2 91l3.7-3.6m.9-3-4.5-4.7m11.2 11.5-4.2-4.3m-65 76.3 3.7-3.7M122.3 170l3.5-3.5m.8-2.9-4.3-4.2M133 170l-4-4",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#A3B4C6",
	d: "M190.2 211.8h-1.6a4 4 0 0 1-4-4v-32.1a4 4 0 0 1 4-4h1.6a4 4 0 0 1 4 4v32a4 4 0 0 1-4 4"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#A3B4C6",
	d: "M237.8 213a4.8 4.8 0 0 1-4.8 4.8h-86.6a4.8 4.8 0 0 1 0-9.6H233a4.8 4.8 0 0 1 4.8 4.8"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#A3B4C6",
	d: "M154.1 190.1h70.5v-84.6h-70.5z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#BFCDDD",
	d: "M225 190.1h-71.2a3.2 3.2 0 0 1-3.2-3.2v-19a3.2 3.2 0 0 1 3.2-3.2h71.1a3.2 3.2 0 0 1 3.2 3.2v19a3.2 3.2 0 0 1-3.2 3.2m0-59.3h-71.1a3.2 3.2 0 0 1-3.2-3.2v-19a3.2 3.2 0 0 1 3.2-3.2h71.1a3.2 3.2 0 0 1 3.2 3.3v19a3.2 3.2 0 0 1-3.2 3.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M159.6 120.5a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m7.4 0a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m7.4 0a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m48.1 0h-22.4a.8.8 0 0 1-.8-.8v-3.2c0-.4.3-.8.8-.8h22.4c.5 0 .8.4.8.8v3.2c0 .5-.3.8-.8.8"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#BFCDDD",
	d: "M225 160.5h-71.2a3.2 3.2 0 0 1-3.2-3.2v-19a3.2 3.2 0 0 1 3.2-3.2h71.1a3.2 3.2 0 0 1 3.2 3.2v19a3.2 3.2 0 0 1-3.2 3.2"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#7C90A5",
	d: "M173.5 130.8h49.3m-57.8 0h6m-15 0h6.7m11.1 29.8h49.3m-57.7 0h6m-15.8 0h6.7",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M159.6 151a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m7.4 0a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m7.4 0a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m48.1 0h-22.4a.8.8 0 0 1-.8-.8V147c0-.4.3-.8.8-.8h22.4c.5 0 .8.4.8.8v3.2c0 .5-.3.8-.8.8m-63 29a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m7.5 0a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m7.4 0a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m48.1 0h-22.4a.8.8 0 0 1-.8-.8V176c0-.5.3-.8.8-.8h22.4c.5 0 .8.3.8.8v3.2c0 .4-.3.8-.8.8"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#BFCDDD",
	d: "M203 221.1h-27.3a2.4 2.4 0 0 1-2.4-2.4v-11.4a2.4 2.4 0 0 1 2.4-2.5H203a2.4 2.4 0 0 1 2.4 2.5v11.4a2.4 2.4 0 0 1-2.4 2.4"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#A3B4C6",
	d: "M177.3 207.2v11.5m23.8-11.5v11.5",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#5BA02E",
	d: "M162.9 267.9a9.4 9.4 0 0 1-9.4-9.4v-14.8a9.4 9.4 0 0 1 18.8 0v14.8a9.4 9.4 0 0 1-9.4 9.4"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#92C110",
	d: "M171.2 267.8a9.4 9.4 0 0 1-9.4-9.4V255a9.4 9.4 0 0 1 18.8 0v3.4a9.4 9.4 0 0 1-9.4 9.4"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#F2D7AD",
	d: "M181.3 293.7h-27.7a3.2 3.2 0 0 1-3.2-3.2v-20.7a3.2 3.2 0 0 1 3.2-3.2h27.7a3.2 3.2 0 0 1 3.2 3.2v20.7a3.2 3.2 0 0 1-3.2 3.2"
})));
var serverError_default = ServerError;

//#endregion
//#region node_modules/antd/es/result/style/index.js
var genBaseStyle$5 = (token$1) => {
	const { componentCls, lineHeightHeading3, iconCls, padding, paddingXL, paddingXS, paddingLG, marginXS, lineHeight } = token$1;
	return {
		[componentCls]: {
			padding: `${unit(token$1.calc(paddingLG).mul(2).equal())} ${unit(paddingXL)}`,
			"&-rtl": { direction: "rtl" }
		},
		[`${componentCls} ${componentCls}-image`]: {
			width: token$1.imageWidth,
			height: token$1.imageHeight,
			margin: "auto"
		},
		[`${componentCls} ${componentCls}-icon`]: {
			marginBottom: paddingLG,
			textAlign: "center",
			[`& > ${iconCls}`]: { fontSize: token$1.iconFontSize }
		},
		[`${componentCls} ${componentCls}-title`]: {
			color: token$1.colorTextHeading,
			fontSize: token$1.titleFontSize,
			lineHeight: lineHeightHeading3,
			marginBlock: marginXS,
			textAlign: "center"
		},
		[`${componentCls} ${componentCls}-subtitle`]: {
			color: token$1.colorTextDescription,
			fontSize: token$1.subtitleFontSize,
			lineHeight,
			textAlign: "center"
		},
		[`${componentCls} ${componentCls}-body`]: {
			marginTop: paddingLG,
			padding: `${unit(paddingLG)} ${unit(token$1.calc(padding).mul(2.5).equal())}`,
			backgroundColor: token$1.colorFillAlter
		},
		[`${componentCls} ${componentCls}-extra`]: {
			margin: token$1.extraMargin,
			textAlign: "center",
			"& > *": {
				marginInlineEnd: paddingXS,
				"&:last-child": { marginInlineEnd: 0 }
			}
		}
	};
};
var genStatusIconStyle = (token$1) => {
	const { componentCls, iconCls } = token$1;
	return {
		[`${componentCls}-success ${componentCls}-icon > ${iconCls}`]: { color: token$1.resultSuccessIconColor },
		[`${componentCls}-error ${componentCls}-icon > ${iconCls}`]: { color: token$1.resultErrorIconColor },
		[`${componentCls}-info ${componentCls}-icon > ${iconCls}`]: { color: token$1.resultInfoIconColor },
		[`${componentCls}-warning ${componentCls}-icon > ${iconCls}`]: { color: token$1.resultWarningIconColor }
	};
};
var genResultStyle = (token$1) => [genBaseStyle$5(token$1), genStatusIconStyle(token$1)];
var getStyle$1 = (token$1) => genResultStyle(token$1);
const prepareComponentToken$12 = (token$1) => ({
	titleFontSize: token$1.fontSizeHeading3,
	subtitleFontSize: token$1.fontSize,
	iconFontSize: token$1.fontSizeHeading3 * 3,
	extraMargin: `${token$1.paddingLG}px 0 0 0`
});
var style_default$13 = genStyleHooks("Result", (token$1) => {
	const resultInfoIconColor = token$1.colorInfo;
	const resultErrorIconColor = token$1.colorError;
	const resultSuccessIconColor = token$1.colorSuccess;
	const resultWarningIconColor = token$1.colorWarning;
	return [getStyle$1(merge(token$1, {
		resultInfoIconColor,
		resultErrorIconColor,
		resultSuccessIconColor,
		resultWarningIconColor,
		imageWidth: 250,
		imageHeight: 295
	}))];
}, prepareComponentToken$12);

//#endregion
//#region node_modules/antd/es/result/unauthorized.js
var Unauthorized = () => /* @__PURE__ */ import_react.createElement("svg", {
	width: "251",
	height: "294"
}, /* @__PURE__ */ import_react.createElement("title", null, "Unauthorized"), /* @__PURE__ */ import_react.createElement("g", {
	fill: "none",
	fillRule: "evenodd"
}, /* @__PURE__ */ import_react.createElement("path", {
	fill: "#E4EBF7",
	d: "M0 129v-2C0 58.3 55.6 2.7 124.2 2.7h2c68.6 0 124.2 55.6 124.2 124.1v2.1c0 68.6-55.6 124.2-124.1 124.2h-2.1A124.2 124.2 0 0 1 0 129"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M41.4 133a8.2 8.2 0 1 1-16.4-1.7 8.2 8.2 0 0 1 16.4 1.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#FFF",
	d: "m38.7 136.4 10.4 5.9m.9 6.2-12.6 10.7",
	strokeWidth: "2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M41.5 161.3a5.6 5.6 0 1 1-11.2-1.2 5.6 5.6 0 0 1 11.2 1.2m17.7-16a5.7 5.7 0 1 1-11.3-1.2 5.7 5.7 0 0 1 11.3 1.2m41.2-115.8H130a4.6 4.6 0 1 0 0-9.1h-29.6a4.6 4.6 0 0 0 0 9.1m11.3 18.3h29.7a4.6 4.6 0 1 0 0-9.2h-29.7a4.6 4.6 0 1 0 0 9.2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M114 29.5h15.8a4.6 4.6 0 1 0 0 9.1H114a4.6 4.6 0 0 0 0-9.1m71.3 108.2a10 10 0 1 1-19.8-2 10 10 0 0 1 19.8 2"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#FFF",
	d: "m180.2 143.8 12.5 7.1m1.1 7.5-15.1 13",
	strokeWidth: "2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M185.6 172a6.8 6.8 0 1 1-13.6-1.4 6.8 6.8 0 0 1 13.5 1.3m18.6-16.6a6.8 6.8 0 1 1-13.6-1.4 6.8 6.8 0 0 1 13.6 1.4"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#FFF",
	d: "M153 194a2.2 2.2 0 1 1-4.4 0 2.2 2.2 0 0 1 4.4 0zm73-75.8a2.2 2.2 0 1 1-4.5 0 2.2 2.2 0 0 1 4.4 0zm-9 34.9a2.2 2.2 0 1 1-4.3 0 2.2 2.2 0 0 1 4.4 0zm-39.2-43.3a2.2 2.2 0 1 1-4.4 0 2.2 2.2 0 0 1 4.4 0zm18.3-15.3a2.2 2.2 0 1 1-4.4 0 2.2 2.2 0 0 1 4.4 0zm6.7 88a2.2 2.2 0 1 1-4.4 0 2.2 2.2 0 0 1 4.4 0z",
	strokeWidth: "2"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#FFF",
	d: "m215.1 155.3-1.9 20-10.8 6m-27.8-4.7-6.3 9.8H157l-4.5 6.4m23.4-65.5v-15.7m45.6 7.8-12.8 7.9-15.2-7.9V96.7",
	strokeWidth: "2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#A26EF4",
	d: "M180.7 29.3a29.3 29.3 0 1 1 58.6 0 29.3 29.3 0 0 1-58.6 0"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "m221.4 41.7-21.5-.1a1.7 1.7 0 0 1-1.7-1.8V27.6a1.7 1.7 0 0 1 1.8-1.7h21.5c1 0 1.8.9 1.8 1.8l-.1 12.3a1.7 1.7 0 0 1-1.7 1.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M215.1 29.2c0 2.6-2 4.6-4.5 4.6a4.6 4.6 0 0 1-4.5-4.7v-6.9c0-2.6 2-4.6 4.6-4.6 2.5 0 4.5 2 4.4 4.7v6.9zm-4.5-14a6.9 6.9 0 0 0-7 6.8v7.3a6.9 6.9 0 0 0 13.8.1V22a6.9 6.9 0 0 0-6.8-6.9zm-43 53.2h-4a4.7 4.7 0 0 1-4.7-4.8 4.7 4.7 0 0 1 4.7-4.7h4a4.7 4.7 0 0 1 4.7 4.8 4.7 4.7 0 0 1-4.7 4.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#5BA02E",
	d: "M168.2 248.8a6.6 6.6 0 0 1-6.6-6.6v-66a6.6 6.6 0 0 1 13.2 0v66a6.6 6.6 0 0 1-6.6 6.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#92C110",
	d: "M176.1 248.2a6.6 6.6 0 0 1-6.6-6.6v-33a6.6 6.6 0 1 1 13.3 0v33a6.6 6.6 0 0 1-6.7 6.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#F2D7AD",
	d: "M186 293.9h-27.4a3.2 3.2 0 0 1-3.2-3.2v-45.9a3.2 3.2 0 0 1 3.2-3.1H186a3.2 3.2 0 0 1 3.2 3.1v46a3.2 3.2 0 0 1-3.2 3"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M82 147.7s6.3-1 17.5-1.3c11.8-.4 17.6 1 17.6 1s3.7-3.8 1-8.3c1.3-12.1 6-32.9.3-48.3-1.1-1.4-3.7-1.5-7.5-.6-1.4.3-7.2-.2-8-.1l-15.3-.4-8-.5c-1.6-.1-4.3-1.7-5.5-.3-.4.4-2.4 5.6-2 16l8.7 35.7s-3.2 3.6 1.2 7"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "m75.8 73.3-1-6.4 12-6.5s7.4-.1 8 1.2c.8 1.3-5.5 1-5.5 1s-1.9 1.4-2.6 2.5c-1.7 2.4-1 6.5-8.4 6-1.7.3-2.5 2.2-2.5 2.2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFB594",
	d: "M52.4 77.7S66.7 87 77.4 92c1 .5-2 16.2-11.9 11.8-7.4-3.3-20.1-8.4-21.5-14.5-.7-3.2 2.6-7.6 8.4-11.7M142 80s-6.7 3-13.9 6.9c-3.9 2.1-10.1 4.7-12.3 8-6.2 9.3 3.5 11.2 13 7.5 6.6-2.7 29-12.1 13.2-22.4"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "m76.2 66.4 3 3.8S76.4 73 73 76c-7 6.2-12.8 14.3-16 16.4-4 2.7-9.7 3.3-12.2 0-3.5-5.1.5-14.7 31.5-26"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M64.7 85.1s-2.4 8.4-9 14.5c.7.5 18.6 10.5 22.2 10 5.2-.6 6.4-19 1.2-20.5-.8-.2-6-1.3-8.9-2.2-.9-.2-1.6-1.7-3.5-1l-2-.8zm63.7.7s5.3 2 7.3 13.8c-.6.2-17.6 12.3-21.8 7.8-6.6-7-.8-17.4 4.2-18.6 4.7-1.2 5-1.4 10.3-3"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E4EBF7",
	d: "M78.2 94.7s.9 7.4-5 13",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E4EBF7",
	d: "M87.4 94.7s3.1 2.6 10.3 2.6c7.1 0 9-3.5 9-3.5",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: ".9"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "m117.2 68.6-6.8-6.1s-5.4-4.4-9.2-1c-3.9 3.5 4.4 2.2 5.6 4.2 1.2 2.1.9 1.2-2 .5-5.7-1.4-2.1.9 3 5.3 2 1.9 7 1 7 1l2.4-3.9z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFB594",
	d: "m105.3 91.3-.3-11H89l-.5 10.5c0 .4.2.8.6 1 2 1.3 9.3 5 15.8.4.2-.2.4-.5.4-.9"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#5C2552",
	d: "M107.6 74.2c.8-1.1 1-9 1-11.9a1 1 0 0 0-1-1l-4.6-.4c-7.7-1-17 .6-18.3 6.3-5.4 5.9-.4 13.3-.4 13.3s2 3.5 4.3 6.8c.8 1 .4-3.8 3-6a47.9 47.9 0 0 1 16-7"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "M88.4 83.2s2.7 6.2 11.6 6.5c7.8.3 9-7 7.5-17.5l-1-5.5c-6-2.9-15.4.6-15.4.6s-.6 2-.2 5.5c-2.3 2-1.8 5.6-1.8 5.6s-1-2-2-2.3c-.9-.3-2 0-2.3 2-1 4.6 3.6 5.1 3.6 5.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "m100.8 77.1 1.7-1-1-4.3.7-1.4",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#552950",
	d: "M105.5 74c0 .8-.4 1.4-1 1.4-.4 0-.8-.7-.8-1.4s.5-1.2 1-1.2.9.6.8 1.3m-8 .2c0 .8-.4 1.3-.9 1.3s-.9-.6-.9-1.3c0-.7.5-1.3 1-1.3s1 .6.9 1.3"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "M91.1 86.8s5.3 5 12.7 2.3",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#DB836E",
	d: "M99.8 81.9s-3.6.2-1.5-2.8c1.6-1.5 5-.4 5-.4s1 3.9-3.5 3.2"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#5C2552",
	d: "M102.9 70.6s2.5.8 3.4.7m-12.4.7s2.5-1.2 4.8-1.1",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.5"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "M86.3 77.4s1 .9 1.5 2c-.4.6-1 1.2-.3 1.9m11.8 2.4s2 .2 2.5-.2",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E4EBF7",
	d: "m87.8 115.8 15.7-3m-3.3 3 10-2m-43.7-27s-1.6 8.8-6.7 14M128.3 88s3 4 4 11.7",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "M64 84.8s-6 10-13.5 10",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: ".8"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "m112.4 66-.2 5.2 12 9.2c4.5 3.6 8.9 7.5 11 8.7 4.8 2.8 8.9 3.3 11 1.8 4.1-2.9 4.4-9.9-8.1-15.3-4.3-1.8-16.1-6.3-25.7-9.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "M130.5 85.5s4.6 5.7 11.7 6.2",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: ".8"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E4EBF7",
	d: "M121.7 105.7s-.4 8.6-1.3 13.6",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M115.8 161.5s-3.6-1.5-2.7-7.1",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#CBD1D1",
	d: "M101.5 290.2s4.3 2.1 7.4 1c2.9-.9 4.6.7 7.2 1.3 2.5.5 6.9 1 11.7-1.3 0-5.6-7-4-12-6.8-2.6-1.4-3.8-4.7-3.6-8.8h-9.5s-1.4 10.6-1.2 14.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#2B0849",
	d: "M101.5 290s2.4 1.4 6.8.7c3-.4 3.7.5 7.5 1 3.7.6 10.8 0 11.9-.8.4 1-.4 2-.4 2s-1.5.7-4.8.9c-2 .1-5.8.3-7.7-.5-1.8-1.4-5.2-2-5.7-.3-4 1-7.4-.3-7.4-.3l-.2-2.6z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#A4AABA",
	d: "M108.8 276.2h3.1s0 6.7 4.6 8.6c-4.7.6-8.6-2.3-7.7-8.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#CBD1D1",
	d: "M57.6 272.5s-2 7.5-4.5 12.4c-1.8 3.7-4.2 7.6 5.5 7.6 6.7 0 9-.5 7.5-6.7-1.5-6.1.3-13.3.3-13.3h-8.8z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#2B0849",
	d: "M51.5 290s2.2 1.2 6.7 1.2c6.1 0 8.3-1.6 8.3-1.6s.6 1-.6 2.1c-1 .9-3.6 1.6-7.4 1.6-4.2 0-6-.6-6.8-1.2-.9-.5-.7-1.6-.2-2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#A4AABA",
	d: "M58.5 274.4s0 1.6-.3 3-1 3.1-1.1 4.2c0 1.1 4.5 1.5 5.2 0 .6-1.6 1.3-6.5 1.9-7.3.6-.8-5-2.1-5.7.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#7BB2F9",
	d: "m100.9 277 13.3.1s1.3-54.2 1.8-64c.6-9.9 3.8-43.2 1-62.8l-12.4-.7-22.8.8-1.2 10c0 .4-.6.8-.7 1.3 0 .6.4 1.3.3 2-2.3 14-6.3 32.9-8.7 46.4-.1.6-1.2 1-1.4 2.6 0 .3.2 1.6 0 1.8-6.8 18.7-10.8 47.6-14.1 61.6h14.5s2.2-8.6 4-17a3984 3984 0 0 1 23-84.5l3-.5 1 46.1s-.2 1.2.4 2c.5.8-.6 1.1-.4 2.3l.4 1.7-1 11.9c-.4 4.6 0 39 0 39"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M77.4 220.4c1.2.1 4-2 7-4.9m23.1 8.4s2.8-1 6.1-3.8",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M108.5 221s2.7-1.2 6-4",
	strokeLinecap: "round",
	strokeLinejoin: "round"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M76.1 223.6s2.6-.6 6.5-3.4m4.7-69.4c-.2 3.1.3 8.5-4.3 9m21.8-10.7s.1 14-1.3 15c-2.2 1.6-3 1.9-3 1.9m.5-16.4s0 12.8-1.2 24.3m-4.9 1s7.2-1.6 9.4-1.6m-28.6 31.5-1 4.5s-1.5 1.8-1 3.7c.4 2-1 2-5 15.3-1.7 5.6-4.4 18.5-6.3 27.5l-4 18.4M77 196.7a313.3 313.3 0 0 1-.8 4.8m7.7-50-1.2 10.3s-1 .2-.5 2.3c.1 1.3-2.6 15.6-5.1 30.2M57.6 273h13.2",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#192064",
	d: "M117.4 147.4s-17-3-35.7.2v4.2s14.6-2.9 35.5-.4l.2-4"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M107.5 150.4v-5a.8.8 0 0 0-.8-.7H99a.8.8 0 0 0-.7.8v4.8c0 .5.3.9.8.8a140.8 140.8 0 0 1 7.7 0 .8.8 0 0 0 .8-.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#192064",
	d: "M106.4 149.4v-3a.6.6 0 0 0-.6-.7 94.1 94.1 0 0 0-5.8 0 .6.6 0 0 0-.7.7v3c0 .4.3.7.7.7h5.7c.4 0 .7-.3.7-.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M101.5 274h12.3m-11.1-5v6.5m0-12.4v4.3m-.5-93.4.9 44.4s.7 1.6-.2 2.7c-1 1.1 2.4.7.9 2.2-1.6 1.6.9 1.1 0 3.4-.6 1.5-1 21-1.1 35",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
})));
var unauthorized_default = Unauthorized;

//#endregion
//#region node_modules/antd/es/result/index.js
const IconMap = {
	success: CheckCircleFilled_default,
	error: CloseCircleFilled_default,
	info: ExclamationCircleFilled_default,
	warning: WarningFilled_default
};
const ExceptionMap = {
	"404": noFound_default,
	"500": serverError_default,
	"403": unauthorized_default
};
var ExceptionStatus = Object.keys(ExceptionMap);
var Icon = ({ icon, status, className, style: style$1 }) => {
	devUseWarning("Result")(!(typeof icon === "string" && icon.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${icon}\` at https://ant.design/components/icon`);
	if (ExceptionStatus.includes(`${status}`)) {
		const SVGComponent = ExceptionMap[status];
		return /* @__PURE__ */ import_react.createElement("div", {
			className,
			style: style$1
		}, /* @__PURE__ */ import_react.createElement(SVGComponent, null));
	}
	const iconNode = /* @__PURE__ */ import_react.createElement(IconMap[status]);
	if (icon === null || icon === false) return null;
	return /* @__PURE__ */ import_react.createElement("div", {
		className,
		style: style$1
	}, icon || iconNode);
};
var Extra = ({ className, extra, style: style$1 }) => {
	if (!extra) return null;
	return /* @__PURE__ */ import_react.createElement("div", {
		className,
		style: style$1
	}, extra);
};
var Result = (props) => {
	const { prefixCls: customizePrefixCls, className: customizeClassName, rootClassName, subTitle, title, style: style$1, children, status = "info", icon, extra, styles, classNames, ...rest } = props;
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("result");
	const mergedProps = {
		...props,
		status
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const prefixCls = getPrefixCls("result", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$13(prefixCls);
	const rootClassNames = clsx(prefixCls, `${prefixCls}-${status}`, customizeClassName, contextClassName, rootClassName, { [`${prefixCls}-rtl`]: direction === "rtl" }, hashId, cssVarCls, mergedClassNames.root);
	const titleClassNames = clsx(`${prefixCls}-title`, mergedClassNames.title);
	const subTitleClassNames = clsx(`${prefixCls}-subtitle`, mergedClassNames.subTitle);
	const extraClassNames = clsx(`${prefixCls}-extra`, mergedClassNames.extra);
	const bodyClassNames = clsx(`${prefixCls}-body`, mergedClassNames.body);
	const iconClassNames = clsx(`${prefixCls}-icon`, { [`${prefixCls}-image`]: ExceptionStatus.includes(`${status}`) }, mergedClassNames.icon);
	const rootStyles = {
		...mergedStyles.root,
		...contextStyle,
		...style$1
	};
	const restProps = pickAttrs(rest, {
		aria: true,
		data: true
	});
	return /* @__PURE__ */ import_react.createElement("div", {
		...restProps,
		className: rootClassNames,
		style: rootStyles
	}, /* @__PURE__ */ import_react.createElement(Icon, {
		className: iconClassNames,
		style: mergedStyles.icon,
		status,
		icon
	}), /* @__PURE__ */ import_react.createElement("div", {
		className: titleClassNames,
		style: mergedStyles.title
	}, title), subTitle && /* @__PURE__ */ import_react.createElement("div", {
		className: subTitleClassNames,
		style: mergedStyles.subTitle
	}, subTitle), /* @__PURE__ */ import_react.createElement(Extra, {
		className: extraClassNames,
		extra,
		style: mergedStyles.extra
	}), children && /* @__PURE__ */ import_react.createElement("div", {
		className: bodyClassNames,
		style: mergedStyles.body
	}, children));
};
Result.PRESENTED_IMAGE_403 = ExceptionMap["403"];
Result.PRESENTED_IMAGE_404 = ExceptionMap["404"];
Result.PRESENTED_IMAGE_500 = ExceptionMap["500"];
Result.displayName = "Result";
var result_default = Result;

//#endregion
//#region node_modules/antd/es/row/index.js
var row_default = row_default$1;

//#endregion
//#region node_modules/antd/es/splitter/Panel.js
const InternalPanel = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	const { prefixCls, className, children, size, style: style$1 = {} } = props;
	const panelClassName = clsx(`${prefixCls}-panel`, { [`${prefixCls}-panel-hidden`]: size === 0 }, className);
	const hasSize = size !== void 0;
	return /* @__PURE__ */ import_react.createElement("div", {
		ref,
		className: panelClassName,
		style: {
			...style$1,
			flexBasis: hasSize ? size : "auto",
			flexGrow: hasSize ? 0 : 1
		}
	}, children);
});
InternalPanel.displayName = "Panel";
var Panel$1 = () => null;
var Panel_default$1 = Panel$1;

//#endregion
//#region node_modules/antd/es/splitter/hooks/useItems.js
function getCollapsible(collapsible) {
	if (collapsible && typeof collapsible === "object") return {
		...collapsible,
		showCollapsibleIcon: collapsible.showCollapsibleIcon === void 0 ? "auto" : collapsible.showCollapsibleIcon
	};
	const mergedCollapsible = !!collapsible;
	return {
		start: mergedCollapsible,
		end: mergedCollapsible,
		showCollapsibleIcon: "auto"
	};
}
/**
* Convert `children` into `items`.
*/
function useItems$1(children) {
	return import_react.useMemo(() => toArray(children).filter((item) => /* @__PURE__ */ import_react.isValidElement(item)).map((node$1) => {
		const { props } = node$1;
		const { collapsible, ...restProps } = props;
		return {
			...restProps,
			collapsible: getCollapsible(collapsible)
		};
	}), [children]);
}
var useItems_default = useItems$1;

//#endregion
//#region node_modules/antd/es/splitter/hooks/useResizable.js
function getShowCollapsibleIcon(prev$1, next$1) {
	if (prev$1.collapsible && next$1.collapsible) {
		if (prev$1.showCollapsibleIcon === true || next$1.showCollapsibleIcon === true) return true;
		if (prev$1.showCollapsibleIcon === "auto" || next$1.showCollapsibleIcon === "auto") return "auto";
		return false;
	}
	if (prev$1.collapsible) return prev$1.showCollapsibleIcon;
	if (next$1.collapsible) return next$1.showCollapsibleIcon;
	return false;
}
function useResizable(items, pxSizes, reverse) {
	return import_react.useMemo(() => {
		const resizeInfos = [];
		for (let i = 0; i < items.length - 1; i += 1) {
			const prevItem = items[i];
			const nextItem = items[i + 1];
			const prevSize = pxSizes[i];
			const nextSize = pxSizes[i + 1];
			const { resizable: prevResizable = true, min: prevMin, collapsible: prevCollapsible } = prevItem;
			const { resizable: nextResizable = true, min: nextMin, collapsible: nextCollapsible } = nextItem;
			const mergedResizable = prevResizable && nextResizable && (prevSize !== 0 || !prevMin) && (nextSize !== 0 || !nextMin);
			const prevEndCollapsible = !!prevCollapsible.end && prevSize > 0;
			const nextStartExpandable = !!nextCollapsible.start && nextSize === 0 && prevSize > 0;
			const startCollapsible = prevEndCollapsible || nextStartExpandable;
			const nextStartCollapsible = !!nextCollapsible.start && nextSize > 0;
			const prevEndExpandable = !!prevCollapsible.end && prevSize === 0 && nextSize > 0;
			const endCollapsible = nextStartCollapsible || prevEndExpandable;
			const showStartCollapsibleIcon = getShowCollapsibleIcon({
				collapsible: prevEndCollapsible,
				showCollapsibleIcon: prevCollapsible.showCollapsibleIcon
			}, {
				collapsible: nextStartExpandable,
				showCollapsibleIcon: nextCollapsible.showCollapsibleIcon
			});
			const showEndCollapsibleIcon = getShowCollapsibleIcon({
				collapsible: nextStartCollapsible,
				showCollapsibleIcon: nextCollapsible.showCollapsibleIcon
			}, {
				collapsible: prevEndExpandable,
				showCollapsibleIcon: prevCollapsible.showCollapsibleIcon
			});
			resizeInfos[i] = {
				resizable: mergedResizable,
				startCollapsible: !!(reverse ? endCollapsible : startCollapsible),
				endCollapsible: !!(reverse ? startCollapsible : endCollapsible),
				showStartCollapsibleIcon: reverse ? showEndCollapsibleIcon : showStartCollapsibleIcon,
				showEndCollapsibleIcon: reverse ? showStartCollapsibleIcon : showEndCollapsibleIcon
			};
		}
		return resizeInfos;
	}, [
		pxSizes,
		items,
		reverse
	]);
}

//#endregion
//#region node_modules/antd/es/splitter/hooks/sizeUtil.js
function autoPtgSizes(ptgSizes, minPtgSizes, maxPtgSizes) {
	let currentTotalPtg = 0;
	const undefinedIndexes = [];
	ptgSizes.forEach((size, index$1) => {
		if (size === void 0) undefinedIndexes.push(index$1);
		else currentTotalPtg += size;
	});
	const restPtg = 1 - currentTotalPtg;
	const undefinedCount = undefinedIndexes.length;
	if (ptgSizes.length && !undefinedIndexes.length && currentTotalPtg !== 1) {
		if (currentTotalPtg === 0) {
			const avg = 1 / ptgSizes.length;
			return ptgSizes.map(() => avg);
		}
		const scale = 1 / currentTotalPtg;
		return ptgSizes.map((size) => size * scale);
	}
	if (restPtg < 0) {
		const scale = 1 / currentTotalPtg;
		return ptgSizes.map((size) => size === void 0 ? 0 : size * scale);
	}
	let sumMin = 0;
	let sumMax = 0;
	let limitMin = 0;
	let limitMax = 1;
	for (const index$1 of undefinedIndexes) {
		const min = minPtgSizes[index$1] || 0;
		const max = maxPtgSizes[index$1] || 1;
		sumMin += min;
		sumMax += max;
		limitMin = Math.max(limitMin, min);
		limitMax = Math.min(limitMax, max);
	}
	if (sumMin > 1 && sumMax < 1) {
		const avg = 1 / undefinedCount;
		return ptgSizes.map((size) => size === void 0 ? avg : size);
	}
	const restAvg = restPtg / undefinedCount;
	if (limitMin <= restAvg && restAvg <= limitMax) return ptgSizes.map((size) => size === void 0 ? restAvg : size);
	const result = _toConsumableArray(ptgSizes);
	let remain = restPtg - sumMin;
	for (let i = 0; i < undefinedCount; i += 1) {
		const index$1 = undefinedIndexes[i];
		const min = minPtgSizes[index$1] || 0;
		const max = maxPtgSizes[index$1] || 1;
		result[index$1] = min;
		const canAdd = max - min;
		const add = Math.min(canAdd, remain);
		result[index$1] += add;
		remain -= add;
	}
	return result;
}

//#endregion
//#region node_modules/antd/es/splitter/hooks/useSizes.js
function getPtg(str) {
	return Number(str.slice(0, -1)) / 100;
}
function isPtg(itemSize) {
	return typeof itemSize === "string" && itemSize.endsWith("%");
}
/**
* Save the size state.
* Align the size into flex percentage base.
*/
function useSizes(items, containerSize) {
	const propSizes = items.map((item) => item.size);
	const itemsCount = items.length;
	const mergedContainerSize = containerSize || 0;
	const ptg2px = (ptg) => ptg * mergedContainerSize;
	const [innerSizes, setInnerSizes] = import_react.useState(() => items.map((item) => item.defaultSize));
	const sizes$1 = import_react.useMemo(() => {
		const mergedSizes = [];
		for (let i = 0; i < itemsCount; i += 1) mergedSizes[i] = propSizes[i] ?? innerSizes[i];
		return mergedSizes;
	}, [
		itemsCount,
		innerSizes,
		propSizes
	]);
	const postPercentMinSizes = import_react.useMemo(() => items.map((item) => {
		if (isPtg(item.min)) return getPtg(item.min);
		return (item.min || 0) / mergedContainerSize;
	}), [items, mergedContainerSize]);
	const postPercentMaxSizes = import_react.useMemo(() => items.map((item) => {
		if (isPtg(item.max)) return getPtg(item.max);
		return (item.max || mergedContainerSize) / mergedContainerSize;
	}), [items, mergedContainerSize]);
	const postPercentSizes = import_react.useMemo(() => {
		const ptgList = [];
		for (let i = 0; i < itemsCount; i += 1) {
			const itemSize = sizes$1[i];
			if (isPtg(itemSize)) ptgList[i] = getPtg(itemSize);
			else if (itemSize || itemSize === 0) {
				const num = Number(itemSize);
				if (!Number.isNaN(num)) ptgList[i] = num / mergedContainerSize;
			} else ptgList[i] = void 0;
		}
		return autoPtgSizes(ptgList, postPercentMinSizes, postPercentMaxSizes);
	}, [
		itemsCount,
		sizes$1,
		mergedContainerSize,
		postPercentMinSizes,
		postPercentMaxSizes
	]);
	const postPxSizes = import_react.useMemo(() => postPercentSizes.map(ptg2px), [postPercentSizes, mergedContainerSize]);
	return [
		import_react.useMemo(() => containerSize ? postPxSizes : sizes$1, [
			postPxSizes,
			sizes$1,
			containerSize
		]),
		postPxSizes,
		postPercentSizes,
		postPercentMinSizes,
		postPercentMaxSizes,
		setInnerSizes
	];
}

//#endregion
//#region node_modules/antd/es/splitter/hooks/useResize.js
/**
* Handle user drag resize logic.
*/
function useResize(items, resizableInfos, percentSizes, containerSize, updateSizes, reverse) {
	const limitSizes = items.map((item) => [item.min, item.max]);
	const mergedContainerSize = containerSize || 0;
	const ptg2px = (ptg) => ptg * mergedContainerSize;
	function getLimitSize(str, defaultLimit) {
		if (typeof str === "string") return ptg2px(getPtg(str));
		return str ?? defaultLimit;
	}
	const [cacheSizes, setCacheSizes] = import_react.useState([]);
	const cacheCollapsedSize = import_react.useRef([]);
	/**
	* When start drag, check the direct is `start` or `end`.
	* This will handle when 2 splitter bar are in the same position.
	*/
	const [movingIndex, setMovingIndex] = import_react.useState(null);
	const getPxSizes = () => percentSizes.map(ptg2px);
	const onOffsetStart = (index$1) => {
		setCacheSizes(getPxSizes());
		setMovingIndex({
			index: index$1,
			confirmed: false
		});
	};
	const onOffsetUpdate = (index$1, offset$2) => {
		let confirmedIndex = null;
		if ((!movingIndex || !movingIndex.confirmed) && offset$2 !== 0) {
			if (offset$2 > 0) {
				confirmedIndex = index$1;
				setMovingIndex({
					index: index$1,
					confirmed: true
				});
			} else for (let i = index$1; i >= 0; i -= 1) if (cacheSizes[i] > 0 && resizableInfos[i].resizable) {
				confirmedIndex = i;
				setMovingIndex({
					index: i,
					confirmed: true
				});
				break;
			}
		}
		const mergedIndex = confirmedIndex ?? movingIndex?.index ?? index$1;
		const numSizes = _toConsumableArray(cacheSizes);
		const nextIndex = mergedIndex + 1;
		const startMinSize = getLimitSize(limitSizes[mergedIndex][0], 0);
		const endMinSize = getLimitSize(limitSizes[nextIndex][0], 0);
		const startMaxSize = getLimitSize(limitSizes[mergedIndex][1], mergedContainerSize);
		const endMaxSize = getLimitSize(limitSizes[nextIndex][1], mergedContainerSize);
		let mergedOffset = offset$2;
		if (numSizes[mergedIndex] + mergedOffset < startMinSize) mergedOffset = startMinSize - numSizes[mergedIndex];
		if (numSizes[nextIndex] - mergedOffset < endMinSize) mergedOffset = numSizes[nextIndex] - endMinSize;
		if (numSizes[mergedIndex] + mergedOffset > startMaxSize) mergedOffset = startMaxSize - numSizes[mergedIndex];
		if (numSizes[nextIndex] - mergedOffset > endMaxSize) mergedOffset = numSizes[nextIndex] - endMaxSize;
		numSizes[mergedIndex] += mergedOffset;
		numSizes[nextIndex] -= mergedOffset;
		updateSizes(numSizes);
		return numSizes;
	};
	const onOffsetEnd = () => {
		setMovingIndex(null);
	};
	const onCollapse = (index$1, type$2) => {
		const currentSizes = getPxSizes();
		const adjustedType = reverse ? type$2 === "start" ? "end" : "start" : type$2;
		const currentIndex = adjustedType === "start" ? index$1 : index$1 + 1;
		const targetIndex = adjustedType === "start" ? index$1 + 1 : index$1;
		const currentSize = currentSizes[currentIndex];
		const targetSize = currentSizes[targetIndex];
		if (currentSize !== 0 && targetSize !== 0) {
			currentSizes[currentIndex] = 0;
			currentSizes[targetIndex] += currentSize;
			cacheCollapsedSize.current[index$1] = currentSize;
		} else {
			const totalSize = currentSize + targetSize;
			const currentSizeMin = getLimitSize(limitSizes[currentIndex][0], 0);
			const currentSizeMax = getLimitSize(limitSizes[currentIndex][1], mergedContainerSize);
			const targetSizeMin = getLimitSize(limitSizes[targetIndex][0], 0);
			const targetSizeMax = getLimitSize(limitSizes[targetIndex][1], mergedContainerSize);
			const limitStart = Math.max(currentSizeMin, totalSize - targetSizeMax);
			const limitEnd = Math.min(currentSizeMax, totalSize - targetSizeMin);
			const halfOffset = targetSizeMin || (limitEnd - limitStart) / 2;
			const targetCacheCollapsedSize = cacheCollapsedSize.current[index$1];
			const currentCacheCollapsedSize = totalSize - targetCacheCollapsedSize;
			if (targetCacheCollapsedSize && targetCacheCollapsedSize <= targetSizeMax && targetCacheCollapsedSize >= targetSizeMin && currentCacheCollapsedSize <= currentSizeMax && currentCacheCollapsedSize >= currentSizeMin) {
				currentSizes[targetIndex] = targetCacheCollapsedSize;
				currentSizes[currentIndex] = currentCacheCollapsedSize;
			} else {
				currentSizes[currentIndex] -= halfOffset;
				currentSizes[targetIndex] += halfOffset;
			}
		}
		updateSizes(currentSizes);
		return currentSizes;
	};
	return [
		onOffsetStart,
		onOffsetUpdate,
		onOffsetEnd,
		onCollapse,
		movingIndex?.index
	];
}

//#endregion
//#region node_modules/antd/es/splitter/SplitBar.js
function getValidNumber(num) {
	return typeof num === "number" && !Number.isNaN(num) && Number.isFinite(num) ? Math.round(num) : 0;
}
var SplitBar = (props) => {
	const { prefixCls, vertical, index: index$1, active, ariaNow, ariaMin, ariaMax, resizable, draggerIcon, draggerStyle, draggerClassName, collapsibleIcon, startCollapsible, endCollapsible, onOffsetStart, onOffsetUpdate, onOffsetEnd, onCollapse, lazy, containerSize, showStartCollapsibleIcon, showEndCollapsibleIcon } = props;
	const splitBarPrefixCls = `${prefixCls}-bar`;
	const [startPos, setStartPos] = (0, import_react.useState)(null);
	const [constrainedOffset, setConstrainedOffset] = (0, import_react.useState)(0);
	const constrainedOffsetX = vertical ? 0 : constrainedOffset;
	const constrainedOffsetY = vertical ? constrainedOffset : 0;
	const onMouseDown = (e$2) => {
		if (resizable && e$2.currentTarget) {
			setStartPos([e$2.pageX, e$2.pageY]);
			onOffsetStart(index$1);
		}
	};
	const onTouchStart = (e$2) => {
		if (resizable && e$2.touches.length === 1) {
			const touch = e$2.touches[0];
			setStartPos([touch.pageX, touch.pageY]);
			onOffsetStart(index$1);
		}
	};
	const getConstrainedOffset = (rawOffset) => {
		const currentPos = containerSize * ariaNow / 100;
		const newPos = currentPos + rawOffset;
		const minAllowed = Math.max(0, containerSize * ariaMin / 100);
		const maxAllowed = Math.min(containerSize, containerSize * ariaMax / 100);
		return Math.max(minAllowed, Math.min(maxAllowed, newPos)) - currentPos;
	};
	const handleLazyMove = useEvent_default((offsetX, offsetY) => {
		setConstrainedOffset(getConstrainedOffset(vertical ? offsetY : offsetX));
	});
	const handleLazyEnd = useEvent_default(() => {
		onOffsetUpdate(index$1, constrainedOffsetX, constrainedOffsetY, true);
		setConstrainedOffset(0);
		onOffsetEnd(true);
	});
	const getVisibilityClass = (mode) => {
		switch (mode) {
			case true: return `${splitBarPrefixCls}-collapse-bar-always-visible`;
			case false: return `${splitBarPrefixCls}-collapse-bar-always-hidden`;
			case "auto": return `${splitBarPrefixCls}-collapse-bar-hover-only`;
		}
	};
	useLayoutEffect_default(() => {
		if (!startPos) return;
		const onMouseMove = (e$2) => {
			const { pageX, pageY } = e$2;
			const offsetX = pageX - startPos[0];
			const offsetY = pageY - startPos[1];
			if (lazy) handleLazyMove(offsetX, offsetY);
			else onOffsetUpdate(index$1, offsetX, offsetY);
		};
		const onMouseUp = () => {
			if (lazy) handleLazyEnd();
			else onOffsetEnd();
			setStartPos(null);
		};
		const handleTouchMove = (e$2) => {
			if (e$2.touches.length === 1) {
				const touch = e$2.touches[0];
				const offsetX = touch.pageX - startPos[0];
				const offsetY = touch.pageY - startPos[1];
				if (lazy) handleLazyMove(offsetX, offsetY);
				else onOffsetUpdate(index$1, offsetX, offsetY);
			}
		};
		const handleTouchEnd = () => {
			if (lazy) handleLazyEnd();
			else onOffsetEnd();
			setStartPos(null);
		};
		const eventHandlerMap = {
			mousemove: onMouseMove,
			mouseup: onMouseUp,
			touchmove: handleTouchMove,
			touchend: handleTouchEnd
		};
		for (const [event, handler] of Object.entries(eventHandlerMap)) window.addEventListener(event, handler);
		return () => {
			for (const [event, handler] of Object.entries(eventHandlerMap)) window.removeEventListener(event, handler);
		};
	}, [
		startPos,
		index$1,
		lazy
	]);
	const transformStyle = { [`--${splitBarPrefixCls}-preview-offset`]: `${constrainedOffset}px` };
	const [startIcon, endIcon, startCustomize, endCustomize] = import_react.useMemo(() => {
		let startIcon$1 = null;
		let endIcon$1 = null;
		const startCustomize$1 = collapsibleIcon?.start !== void 0;
		const endCustomize$1 = collapsibleIcon?.end !== void 0;
		if (vertical) {
			startIcon$1 = startCustomize$1 ? collapsibleIcon.start : /* @__PURE__ */ import_react.createElement(UpOutlined_default, null);
			endIcon$1 = endCustomize$1 ? collapsibleIcon.end : /* @__PURE__ */ import_react.createElement(DownOutlined_default, null);
		} else {
			startIcon$1 = startCustomize$1 ? collapsibleIcon.start : /* @__PURE__ */ import_react.createElement(LeftOutlined_default, null);
			endIcon$1 = endCustomize$1 ? collapsibleIcon.end : /* @__PURE__ */ import_react.createElement(RightOutlined_default, null);
		}
		return [
			startIcon$1,
			endIcon$1,
			startCustomize$1,
			endCustomize$1
		];
	}, [collapsibleIcon, vertical]);
	return /* @__PURE__ */ import_react.createElement("div", {
		className: splitBarPrefixCls,
		role: "separator",
		"aria-valuenow": getValidNumber(ariaNow),
		"aria-valuemin": getValidNumber(ariaMin),
		"aria-valuemax": getValidNumber(ariaMax)
	}, lazy && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${splitBarPrefixCls}-preview`, { [`${splitBarPrefixCls}-preview-active`]: !!constrainedOffset }),
		style: transformStyle
	}), /* @__PURE__ */ import_react.createElement("div", {
		style: draggerStyle,
		className: clsx(`${splitBarPrefixCls}-dragger`, {
			[`${splitBarPrefixCls}-dragger-disabled`]: !resizable,
			[`${splitBarPrefixCls}-dragger-active`]: active,
			[`${splitBarPrefixCls}-dragger-customize`]: draggerIcon !== void 0
		}, draggerClassName?.default, active && draggerClassName?.active),
		onMouseDown,
		onTouchStart
	}, draggerIcon !== void 0 ? /* @__PURE__ */ import_react.createElement("div", { className: clsx(`${splitBarPrefixCls}-dragger-icon`) }, draggerIcon) : null), startCollapsible && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${splitBarPrefixCls}-collapse-bar`, `${splitBarPrefixCls}-collapse-bar-start`, { [`${splitBarPrefixCls}-collapse-bar-customize`]: startCustomize }, getVisibilityClass(showStartCollapsibleIcon)),
		onClick: () => onCollapse(index$1, "start")
	}, /* @__PURE__ */ import_react.createElement("span", { className: clsx(`${splitBarPrefixCls}-collapse-icon`, `${splitBarPrefixCls}-collapse-start`) }, startIcon)), endCollapsible && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${splitBarPrefixCls}-collapse-bar`, `${splitBarPrefixCls}-collapse-bar-end`, { [`${splitBarPrefixCls}-collapse-bar-customize`]: endCustomize }, getVisibilityClass(showEndCollapsibleIcon)),
		onClick: () => onCollapse(index$1, "end")
	}, /* @__PURE__ */ import_react.createElement("span", { className: clsx(`${splitBarPrefixCls}-collapse-icon`, `${splitBarPrefixCls}-collapse-end`) }, endIcon)));
};
var SplitBar_default = SplitBar;

//#endregion
//#region node_modules/antd/es/splitter/style/index.js
var centerStyle = {
	position: "absolute",
	top: "50%",
	left: {
		_skip_check_: true,
		value: "50%"
	},
	transform: "translate(-50%, -50%)"
};
var genSplitterStyle = (token$1) => {
	const { componentCls, colorFill, splitBarDraggableSize, splitBarSize, splitTriggerSize, controlItemBgHover, controlItemBgActive, controlItemBgActiveHover, prefixCls, colorPrimary } = token$1;
	const splitBarCls = `${componentCls}-bar`;
	const splitMaskCls = `${componentCls}-mask`;
	const splitPanelCls = `${componentCls}-panel`;
	const halfTriggerSize = token$1.calc(splitTriggerSize).div(2).equal();
	const splitterBarPreviewOffsetVar = `${prefixCls}-bar-preview-offset`;
	const splitterBarPreviewStyle = {
		position: "absolute",
		background: token$1.colorPrimary,
		opacity: .2,
		pointerEvents: "none",
		transition: "none",
		zIndex: 1,
		display: "none"
	};
	return { [componentCls]: {
		...resetComponent(token$1),
		display: "flex",
		width: "100%",
		height: "100%",
		alignItems: "stretch",
		[`> ${splitBarCls}`]: {
			flex: "none",
			position: "relative",
			userSelect: "none",
			[`${splitBarCls}-dragger`]: {
				...centerStyle,
				zIndex: 1,
				"&::before": {
					content: "\"\"",
					background: controlItemBgHover,
					...centerStyle
				},
				"&::after": {
					content: "\"\"",
					background: colorFill,
					...centerStyle
				},
				[`&:hover:not(${splitBarCls}-dragger-active)`]: { "&::before": { background: controlItemBgActive } },
				"&-active": {
					zIndex: 2,
					"&::before": { background: controlItemBgActiveHover }
				},
				[`&-active${splitBarCls}-dragger-customize`]: { [`${splitBarCls}-dragger-icon`]: { color: colorPrimary } },
				[`&-disabled${splitBarCls}-dragger`]: {
					zIndex: 0,
					"&, &:hover, &-active": {
						cursor: "default",
						"&::before": { background: controlItemBgHover }
					},
					"&::after": { display: "none" },
					[`${splitBarCls}-dragger-icon`]: { display: "none" }
				},
				"&-customize": {
					[`${splitBarCls}-dragger-icon`]: {
						...centerStyle,
						display: "flex",
						alignItems: "center",
						color: colorFill
					},
					"&::after": { display: "none" }
				}
			},
			[`${splitBarCls}-collapse-bar`]: {
				...centerStyle,
				zIndex: token$1.zIndexPopupBase,
				background: controlItemBgHover,
				fontSize: token$1.fontSizeSM,
				borderRadius: token$1.borderRadiusXS,
				color: token$1.colorText,
				cursor: "pointer",
				opacity: 0,
				display: "flex",
				alignItems: "center",
				justifyContent: "center",
				[`&:hover:not(${splitBarCls}-collapse-bar-customize)`]: { background: controlItemBgActive },
				[`&:active:not(${splitBarCls}-collapse-bar-customize)`]: { background: controlItemBgActiveHover },
				[`${splitBarCls}-collapse-icon`]: {
					display: "flex",
					alignItems: "center"
				}
			},
			[`${splitBarCls}-collapse-bar-customize`]: { background: "transparent" },
			"&:hover, &:active": { [`${splitBarCls}-collapse-bar-hover-only`]: { opacity: 1 } },
			[`${splitBarCls}-collapse-bar-hover-only`]: { "@media(hover:none)": { opacity: 1 } },
			[`${splitBarCls}-collapse-bar-always-hidden`]: { display: "none" },
			[`${splitBarCls}-collapse-bar-always-visible`]: { opacity: 1 }
		},
		[splitMaskCls]: {
			position: "fixed",
			zIndex: token$1.zIndexPopupBase,
			inset: 0,
			"&-horizontal": { cursor: "col-resize" },
			"&-vertical": { cursor: "row-resize" }
		},
		"&-horizontal": {
			flexDirection: "row",
			[`> ${splitBarCls}`]: {
				width: 0,
				[`${splitBarCls}-preview`]: {
					height: "100%",
					width: splitBarSize,
					...splitterBarPreviewStyle,
					[`&${splitBarCls}-preview-active`]: {
						display: "block",
						transform: `translateX(var(--${splitterBarPreviewOffsetVar}))`
					}
				},
				[`${splitBarCls}-dragger`]: {
					cursor: "col-resize",
					height: "100%",
					width: splitTriggerSize,
					"&::before": {
						height: "100%",
						width: splitBarSize
					},
					"&::after": {
						height: splitBarDraggableSize,
						width: splitBarSize
					}
				},
				[`${splitBarCls}-collapse-bar`]: {
					width: token$1.fontSizeSM,
					height: token$1.controlHeightSM,
					"&-start": {
						left: {
							_skip_check_: true,
							value: "auto"
						},
						right: {
							_skip_check_: true,
							value: halfTriggerSize
						},
						transform: "translateY(-50%)"
					},
					"&-end": {
						left: {
							_skip_check_: true,
							value: halfTriggerSize
						},
						right: {
							_skip_check_: true,
							value: "auto"
						},
						transform: "translateY(-50%)"
					}
				}
			}
		},
		"&-vertical": {
			flexDirection: "column",
			[`> ${splitBarCls}`]: {
				height: 0,
				[`${splitBarCls}-preview`]: {
					height: splitBarSize,
					width: "100%",
					...splitterBarPreviewStyle,
					[`&${splitBarCls}-preview-active`]: {
						display: "block",
						transform: `translateY(var(--${splitterBarPreviewOffsetVar}))`
					}
				},
				[`${splitBarCls}-dragger`]: {
					cursor: "row-resize",
					width: "100%",
					height: splitTriggerSize,
					"&::before": {
						width: "100%",
						height: splitBarSize
					},
					"&::after": {
						width: splitBarDraggableSize,
						height: splitBarSize
					}
				},
				[`${splitBarCls}-collapse-bar`]: {
					height: token$1.fontSizeSM,
					width: token$1.controlHeightSM,
					"&-start": {
						top: "auto",
						bottom: halfTriggerSize,
						transform: "translateX(-50%)"
					},
					"&-end": {
						top: halfTriggerSize,
						bottom: "auto",
						transform: "translateX(-50%)"
					}
				}
			}
		},
		[splitPanelCls]: {
			overflow: "auto",
			padding: "0 1px",
			scrollbarWidth: "thin",
			boxSizing: "border-box",
			"&-hidden": {
				padding: 0,
				overflow: "hidden"
			},
			[`&:has(${componentCls}:only-child)`]: { overflow: "hidden" }
		}
	} };
};
const prepareComponentToken$11 = (token$1) => {
	const splitBarSize = token$1.splitBarSize || 2;
	const splitTriggerSize = token$1.splitTriggerSize || 6;
	const resizeSpinnerSize = token$1.resizeSpinnerSize || 20;
	return {
		splitBarSize,
		splitTriggerSize,
		splitBarDraggableSize: token$1.splitBarDraggableSize ?? resizeSpinnerSize,
		resizeSpinnerSize
	};
};
var style_default$12 = genStyleHooks("Splitter", genSplitterStyle, prepareComponentToken$11);

//#endregion
//#region node_modules/antd/es/splitter/Splitter.js
var Splitter$1 = (props) => {
	const { prefixCls: customizePrefixCls, className, classNames, style: style$1, styles, layout, orientation, vertical, children, draggerIcon, collapsibleIcon, rootClassName, onResizeStart, onResize: onResize$1, onResizeEnd, lazy } = props;
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("splitter");
	const prefixCls = getPrefixCls("splitter", customizePrefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$12(prefixCls, rootCls);
	const [mergedOrientation, isVertical] = useOrientation(orientation, vertical, layout);
	const isRTL = direction === "rtl";
	const reverse = !isVertical && isRTL;
	const items = useItems_default(children);
	{
		const warning$3 = devUseWarning("Splitter");
		const existSize = items.some((item) => item.size !== void 0);
		const existUndefinedSize = items.some((item) => item.size === void 0);
		if (existSize && existUndefinedSize && !onResize$1) warning$3(false, "usage", "When part of `Splitter.Panel` has `size`, `onResize` is required or change `size` to `defaultSize`.");
		warning$3.deprecated(!layout, "layout", "orientation");
	}
	const [containerSize, setContainerSize] = (0, import_react.useState)();
	const onContainerResize = (size) => {
		const { offsetWidth, offsetHeight } = size;
		const containerSize$1 = isVertical ? offsetHeight : offsetWidth;
		if (containerSize$1 === 0) return;
		setContainerSize(containerSize$1);
	};
	const [panelSizes, itemPxSizes, itemPtgSizes, itemPtgMinSizes, itemPtgMaxSizes, updateSizes] = useSizes(items, containerSize);
	const resizableInfos = useResizable(items, itemPxSizes, reverse);
	const [onOffsetStart, onOffsetUpdate, onOffsetEnd, onCollapse, movingIndex] = useResize(items, resizableInfos, itemPtgSizes, containerSize, updateSizes, reverse);
	const onInternalResizeStart = useEvent_default((index$1) => {
		onOffsetStart(index$1);
		onResizeStart?.(itemPxSizes);
	});
	const onInternalResizeUpdate = useEvent_default((index$1, offset$2, lazyEnd) => {
		const nextSizes = onOffsetUpdate(index$1, offset$2);
		if (lazyEnd) onResizeEnd?.(nextSizes);
		else onResize$1?.(nextSizes);
	});
	const onInternalResizeEnd = useEvent_default((lazyEnd) => {
		onOffsetEnd();
		if (!lazyEnd) onResizeEnd?.(itemPxSizes);
	});
	const onInternalCollapse = useEvent_default((index$1, type$2) => {
		const nextSizes = onCollapse(index$1, type$2);
		onResize$1?.(nextSizes);
		onResizeEnd?.(nextSizes);
		const collapsed = nextSizes.map((size) => Math.abs(size) < Number.EPSILON);
		props.onCollapse?.(collapsed, nextSizes);
	});
	const mergedProps = {
		...props,
		vertical: isVertical,
		orientation: mergedOrientation
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps }, { dragger: { _default: "default" } });
	const containerClassName = clsx(prefixCls, className, `${prefixCls}-${mergedOrientation}`, { [`${prefixCls}-rtl`]: isRTL }, rootClassName, mergedClassNames.root, contextClassName, cssVarCls, rootCls, hashId);
	const maskCls = `${prefixCls}-mask`;
	const stackSizes = import_react.useMemo(() => {
		const mergedSizes = [];
		let stack$1 = 0;
		const len = items.length;
		for (let i = 0; i < len; i += 1) {
			stack$1 += itemPtgSizes[i];
			mergedSizes.push(stack$1);
		}
		return mergedSizes;
	}, [itemPtgSizes, items.length]);
	const mergedStyle = {
		...mergedStyles.root,
		...contextStyle,
		...style$1
	};
	return /* @__PURE__ */ import_react.createElement(es_default$2, { onResize: onContainerResize }, /* @__PURE__ */ import_react.createElement("div", {
		style: mergedStyle,
		className: containerClassName
	}, items.map((item, idx) => {
		const panelProps = {
			...item,
			className: clsx(mergedClassNames.panel, item.className),
			style: {
				...mergedStyles.panel,
				...item.style
			}
		};
		const panel = /* @__PURE__ */ import_react.createElement(InternalPanel, {
			...panelProps,
			prefixCls,
			size: panelSizes[idx]
		});
		let splitBar = null;
		const resizableInfo = resizableInfos[idx];
		if (resizableInfo) {
			const ariaMinStart = (stackSizes[idx - 1] || 0) + itemPtgMinSizes[idx];
			const ariaMinEnd = (stackSizes[idx + 1] || 100) - itemPtgMaxSizes[idx + 1];
			const ariaMaxStart = (stackSizes[idx - 1] || 0) + itemPtgMaxSizes[idx];
			const ariaMaxEnd = (stackSizes[idx + 1] || 100) - itemPtgMinSizes[idx + 1];
			splitBar = /* @__PURE__ */ import_react.createElement(SplitBar_default, {
				lazy,
				index: idx,
				active: movingIndex === idx,
				prefixCls,
				vertical: isVertical,
				resizable: resizableInfo.resizable,
				draggerStyle: mergedStyles.dragger,
				draggerClassName: mergedClassNames.dragger,
				draggerIcon,
				collapsibleIcon,
				ariaNow: stackSizes[idx] * 100,
				ariaMin: Math.max(ariaMinStart, ariaMinEnd) * 100,
				ariaMax: Math.min(ariaMaxStart, ariaMaxEnd) * 100,
				startCollapsible: resizableInfo.startCollapsible,
				endCollapsible: resizableInfo.endCollapsible,
				showStartCollapsibleIcon: resizableInfo.showStartCollapsibleIcon,
				showEndCollapsibleIcon: resizableInfo.showEndCollapsibleIcon,
				onOffsetStart: onInternalResizeStart,
				onOffsetUpdate: (index$1, offsetX, offsetY, lazyEnd) => {
					let offset$2 = isVertical ? offsetY : offsetX;
					if (reverse) offset$2 = -offset$2;
					onInternalResizeUpdate(index$1, offset$2, lazyEnd);
				},
				onOffsetEnd: onInternalResizeEnd,
				onCollapse: onInternalCollapse,
				containerSize: containerSize || 0
			});
		}
		return /* @__PURE__ */ import_react.createElement(import_react.Fragment, { key: `split-panel-${idx}` }, panel, splitBar);
	}), typeof movingIndex === "number" && /* @__PURE__ */ import_react.createElement("div", {
		"aria-hidden": true,
		className: clsx(maskCls, `${maskCls}-${mergedOrientation}`)
	})));
};
Splitter$1.displayName = "Splitter";
var Splitter_default = Splitter$1;

//#endregion
//#region node_modules/antd/es/splitter/index.js
var Splitter = Splitter_default;
Splitter.Panel = Panel_default$1;
var splitter_default = Splitter;

//#endregion
//#region node_modules/antd/es/statistic/Number.js
var StatisticNumber = (props) => {
	const { value, formatter, precision, decimalSeparator, groupSeparator = "", prefixCls } = props;
	let valueNode;
	if (typeof formatter === "function") valueNode = formatter(value);
	else {
		const val = String(value);
		const cells = val.match(/^(-?)(\d*)(\.(\d+))?$/);
		if (!cells || val === "-") valueNode = val;
		else {
			const negative = cells[1];
			let int = cells[2] || "0";
			let decimal = cells[4] || "";
			int = int.replace(/\B(?=(\d{3})+(?!\d))/g, groupSeparator);
			if (typeof precision === "number") decimal = decimal.padEnd(precision, "0").slice(0, precision > 0 ? precision : 0);
			if (decimal) decimal = `${decimalSeparator}${decimal}`;
			valueNode = [/* @__PURE__ */ import_react.createElement("span", {
				key: "int",
				className: `${prefixCls}-content-value-int`
			}, negative, int), decimal && /* @__PURE__ */ import_react.createElement("span", {
				key: "decimal",
				className: `${prefixCls}-content-value-decimal`
			}, decimal)];
		}
	}
	return /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-content-value` }, valueNode);
};
var Number_default = StatisticNumber;

//#endregion
//#region node_modules/antd/es/statistic/style/index.js
var genStatisticStyle = (token$1) => {
	const { componentCls, marginXXS, padding, colorTextDescription, titleFontSize, colorTextHeading, contentFontSize, fontFamily } = token$1;
	return { [componentCls]: {
		...resetComponent(token$1),
		[`${componentCls}-header`]: {
			paddingBottom: marginXXS,
			[`${componentCls}-title`]: {
				color: colorTextDescription,
				fontSize: titleFontSize
			}
		},
		[`${componentCls}-skeleton`]: { paddingTop: padding },
		[`${componentCls}-content`]: {
			color: colorTextHeading,
			fontSize: contentFontSize,
			fontFamily,
			[`${componentCls}-content-value`]: {
				display: "inline-block",
				direction: "ltr"
			},
			[`${componentCls}-content-prefix, ${componentCls}-content-suffix`]: { display: "inline-block" },
			[`${componentCls}-content-prefix`]: { marginInlineEnd: marginXXS },
			[`${componentCls}-content-suffix`]: { marginInlineStart: marginXXS }
		}
	} };
};
const prepareComponentToken$10 = (token$1) => {
	const { fontSizeHeading3, fontSize } = token$1;
	return {
		titleFontSize: fontSize,
		contentFontSize: fontSizeHeading3
	};
};
var style_default$11 = genStyleHooks("Statistic", (token$1) => {
	return genStatisticStyle(merge(token$1, {}));
}, prepareComponentToken$10);

//#endregion
//#region node_modules/antd/es/statistic/Statistic.js
var Statistic = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, style: style$1, valueStyle, value = 0, title, valueRender, prefix: prefix$1, suffix, loading = false, formatter, precision, decimalSeparator = ".", groupSeparator = ",", onMouseEnter, onMouseLeave, styles, classNames, ...rest } = props;
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("statistic");
	const prefixCls = getPrefixCls("statistic", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$11(prefixCls);
	const mergedProps = {
		...props,
		decimalSeparator,
		groupSeparator,
		loading,
		value
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	{
		const warning$3 = devUseWarning("Statistic");
		[["valueStyle", "styles.content"]].forEach(([deprecatedName, newName]) => {
			warning$3.deprecated(!(deprecatedName in props), deprecatedName, newName);
		});
	}
	const valueNode = /* @__PURE__ */ import_react.createElement(Number_default, {
		decimalSeparator,
		groupSeparator,
		prefixCls,
		formatter,
		precision,
		value
	});
	const rootClassNames = clsx(prefixCls, { [`${prefixCls}-rtl`]: direction === "rtl" }, contextClassName, className, rootClassName, mergedClassNames.root, hashId, cssVarCls);
	const headerClassNames = clsx(`${prefixCls}-header`, mergedClassNames.header);
	const titleClassNames = clsx(`${prefixCls}-title`, mergedClassNames.title);
	const contentClassNames = clsx(`${prefixCls}-content`, mergedClassNames.content);
	const prefixClassNames = clsx(`${prefixCls}-content-prefix`, mergedClassNames.prefix);
	const suffixClassNames = clsx(`${prefixCls}-content-suffix`, mergedClassNames.suffix);
	const internalRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => ({ nativeElement: internalRef.current }));
	const restProps = pickAttrs(rest, {
		aria: true,
		data: true
	});
	return /* @__PURE__ */ import_react.createElement("div", {
		...restProps,
		className: rootClassNames,
		style: {
			...mergedStyles.root,
			...contextStyle,
			...style$1
		},
		ref: internalRef,
		onMouseEnter,
		onMouseLeave
	}, title && /* @__PURE__ */ import_react.createElement("div", {
		className: headerClassNames,
		style: mergedStyles.header
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: titleClassNames,
		style: mergedStyles.title
	}, title)), /* @__PURE__ */ import_react.createElement(skeleton_default, {
		paragraph: false,
		loading,
		className: `${prefixCls}-skeleton`,
		active: true
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: contentClassNames,
		style: {
			...valueStyle,
			...mergedStyles.content
		}
	}, prefix$1 && /* @__PURE__ */ import_react.createElement("span", {
		className: prefixClassNames,
		style: mergedStyles.prefix
	}, prefix$1), valueRender ? valueRender(valueNode) : valueNode, suffix && /* @__PURE__ */ import_react.createElement("span", {
		className: suffixClassNames,
		style: mergedStyles.suffix
	}, suffix))));
});
Statistic.displayName = "Statistic";
var Statistic_default = Statistic;

//#endregion
//#region node_modules/antd/es/statistic/utils.js
var timeUnits = [
	["Y", 1e3 * 60 * 60 * 24 * 365],
	["M", 1e3 * 60 * 60 * 24 * 30],
	["D", 1e3 * 60 * 60 * 24],
	["H", 1e3 * 60 * 60],
	["m", 1e3 * 60],
	["s", 1e3],
	["S", 1]
];
function formatTimeStr(duration, format$1) {
	let leftDuration = duration;
	const escapeRegex = /\[[^\]]*]/g;
	const keepList = (format$1.match(escapeRegex) || []).map((str) => str.slice(1, -1));
	const templateText = format$1.replace(escapeRegex, "[]");
	const replacedText = timeUnits.reduce((current, [name, unit$2]) => {
		if (current.includes(name)) {
			const value = Math.floor(leftDuration / unit$2);
			leftDuration -= value * unit$2;
			return current.replace(new RegExp(`${name}+`, "g"), (match$2) => {
				const len = match$2.length;
				return value.toString().padStart(len, "0");
			});
		}
		return current;
	}, templateText);
	let index$1 = 0;
	return replacedText.replace(escapeRegex, () => {
		const match$2 = keepList[index$1];
		index$1 += 1;
		return match$2;
	});
}
function formatCounter(value, config, down) {
	const { format: format$1 = "" } = config;
	const target = new Date(value).getTime();
	const current = Date.now();
	return formatTimeStr(down ? Math.max(target - current, 0) : Math.max(current - target, 0), format$1);
}

//#endregion
//#region node_modules/antd/es/statistic/Timer.js
var UPDATE_INTERVAL = 1e3 / 60;
function getTime(value) {
	return new Date(value).getTime();
}
var StatisticTimer = (props) => {
	const { value, format: format$1 = "HH:mm:ss", onChange, onFinish, type: type$2, ...rest } = props;
	const down = type$2 === "countdown";
	const [showTime, setShowTime] = import_react.useState(null);
	const update = useEvent_default(() => {
		const now$1 = Date.now();
		const timestamp = getTime(value);
		setShowTime({});
		const timeDiff = !down ? now$1 - timestamp : timestamp - now$1;
		onChange?.(timeDiff);
		if (down && timestamp < now$1) {
			onFinish?.();
			return false;
		}
		return true;
	});
	import_react.useEffect(() => {
		let intervalId;
		const tick = () => {
			if (!update()) window.clearInterval(intervalId);
		};
		const startTimer = () => {
			intervalId = window.setInterval(tick, UPDATE_INTERVAL);
		};
		const stopTimer = () => {
			window.clearInterval(intervalId);
		};
		startTimer();
		return () => {
			stopTimer();
		};
	}, [value, down]);
	import_react.useEffect(() => {
		setShowTime({});
	}, []);
	const formatter = (formatValue$1, config) => showTime ? formatCounter(formatValue$1, {
		...config,
		format: format$1
	}, down) : "-";
	const valueRender = (node$1) => cloneElement(node$1, { title: void 0 });
	return /* @__PURE__ */ import_react.createElement(Statistic_default, {
		...rest,
		value,
		valueRender,
		formatter
	});
};
var Timer_default = StatisticTimer;

//#endregion
//#region node_modules/antd/es/statistic/Countdown.js
var Countdown = (props) => {
	devUseWarning("Countdown").deprecated(false, "<Statistic.Countdown />", "<Statistic.Timer type=\"countdown\" />");
	return /* @__PURE__ */ import_react.createElement(Timer_default, {
		...props,
		type: "countdown"
	});
};
var Countdown_default = /* @__PURE__ */ import_react.memo(Countdown);

//#endregion
//#region node_modules/antd/es/statistic/index.js
Statistic_default.Timer = Timer_default;
Statistic_default.Countdown = Countdown_default;
var statistic_default = Statistic_default;

//#endregion
//#region node_modules/@rc-component/steps/es/Rail.js
function Rail(props) {
	const { prefixCls, className, style: style$1, status } = props;
	const railCls = `${prefixCls}-rail`;
	return /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(railCls, `${railCls}-${status}`, className),
		style: style$1
	});
}

//#endregion
//#region node_modules/@rc-component/steps/es/UnstableContext.js
const UnstableContext$1 = /* @__PURE__ */ import_react.createContext({});

//#endregion
//#region node_modules/@rc-component/steps/es/Context.js
const StepsContext = /* @__PURE__ */ import_react.createContext(null);

//#endregion
//#region node_modules/@rc-component/steps/es/StepIcon.js
function _extends$24() {
	_extends$24 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$24.apply(this, arguments);
}
const StepIconSemanticContext = /* @__PURE__ */ import_react.createContext({});
var StepIcon = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { className, style: style$1, children, ...restProps } = props;
	const { prefixCls, classNames, styles } = import_react.useContext(StepsContext);
	const { className: itemClassName, style: itemStyle } = import_react.useContext(StepIconSemanticContext);
	const itemCls = `${prefixCls}-item`;
	return /* @__PURE__ */ import_react.createElement("div", _extends$24({}, pickAttrs(restProps, false), {
		ref,
		className: clsx(`${itemCls}-icon`, classNames.itemIcon, itemClassName, className),
		style: {
			...styles.itemIcon,
			...itemStyle,
			...style$1
		}
	}), children);
});
var StepIcon_default = StepIcon;

//#endregion
//#region node_modules/@rc-component/steps/es/Step.js
function _extends$23() {
	_extends$23 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$23.apply(this, arguments);
}
function hasContent(value) {
	return value !== void 0 && value !== null;
}
function Step(props) {
	const { prefixCls, classNames, styles, data, last, nextStatus, active, index: index$1, itemRender, iconRender, itemWrapperRender, onClick } = props;
	const itemCls = `${prefixCls}-item`;
	const { railFollowPrevStatus } = import_react.useContext(UnstableContext$1);
	const { ItemComponent } = import_react.useContext(StepsContext);
	const { onClick: onItemClick, title, subTitle, content, description, disabled, icon, status, className, style: style$1, classNames: itemClassNames = {}, styles: itemStyles = {}, ...restItemProps } = data;
	const mergedContent = content ?? description;
	const renderInfo = {
		item: {
			...data,
			content: mergedContent
		},
		index: index$1,
		active
	};
	const clickable = !!(onClick || onItemClick) && !disabled;
	const accessibilityProps = {};
	if (clickable) {
		accessibilityProps.role = "button";
		accessibilityProps.tabIndex = 0;
		accessibilityProps.onClick = (e$2) => {
			onItemClick?.(e$2);
			onClick(index$1);
		};
		accessibilityProps.onKeyDown = (e$2) => {
			const { which } = e$2;
			if (which === KeyCode_default.ENTER || which === KeyCode_default.SPACE) onClick(index$1);
		};
	}
	const mergedStatus = status || "wait";
	const hasTitle = hasContent(title);
	const hasSubTitle = hasContent(subTitle);
	const classString = clsx(itemCls, `${itemCls}-${mergedStatus}`, {
		[`${itemCls}-custom`]: icon,
		[`${itemCls}-active`]: active,
		[`${itemCls}-disabled`]: disabled === true,
		[`${itemCls}-empty-header`]: !hasTitle && !hasSubTitle
	}, className, classNames.item, itemClassNames.root);
	let iconNode = /* @__PURE__ */ import_react.createElement(StepIcon_default, null);
	if (iconRender) iconNode = iconRender(iconNode, {
		...renderInfo,
		components: { Icon: StepIcon_default }
	});
	const wrapperNode = /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${itemCls}-wrapper`, classNames.itemWrapper, itemClassNames.wrapper),
		style: {
			...styles.itemWrapper,
			...itemStyles.wrapper
		}
	}, /* @__PURE__ */ import_react.createElement(StepIconSemanticContext.Provider, { value: {
		className: itemClassNames.icon,
		style: itemStyles.icon
	} }, iconNode), /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${itemCls}-section`, classNames.itemSection, itemClassNames.section),
		style: {
			...styles.itemSection,
			...itemStyles.section
		}
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${itemCls}-header`, classNames.itemHeader, itemClassNames.header),
		style: {
			...styles.itemHeader,
			...itemStyles.header
		}
	}, hasTitle && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${itemCls}-title`, classNames.itemTitle, itemClassNames.title),
		style: {
			...styles.itemTitle,
			...itemStyles.title
		}
	}, title), hasSubTitle && /* @__PURE__ */ import_react.createElement("div", {
		title: typeof subTitle === "string" ? subTitle : void 0,
		className: clsx(`${itemCls}-subtitle`, classNames.itemSubtitle, itemClassNames.subtitle),
		style: {
			...styles.itemSubtitle,
			...itemStyles.subtitle
		}
	}, subTitle), !last && /* @__PURE__ */ import_react.createElement(Rail, {
		prefixCls: itemCls,
		className: clsx(classNames.itemRail, itemClassNames.rail),
		style: {
			...styles.itemRail,
			...itemStyles.rail
		},
		status: railFollowPrevStatus ? status : nextStatus
	})), hasContent(mergedContent) && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${itemCls}-content`, classNames.itemContent, itemClassNames.content),
		style: {
			...styles.itemContent,
			...itemStyles.content
		}
	}, mergedContent)));
	let stepNode = /* @__PURE__ */ import_react.createElement(ItemComponent, _extends$23({}, restItemProps, accessibilityProps, {
		className: classString,
		style: {
			...styles.item,
			...itemStyles.root,
			...style$1
		}
	}), itemWrapperRender ? itemWrapperRender(wrapperNode) : wrapperNode);
	if (itemRender) stepNode = itemRender(stepNode, renderInfo) || null;
	return stepNode;
}

//#endregion
//#region node_modules/@rc-component/steps/es/Steps.js
function _extends$22() {
	_extends$22 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$22.apply(this, arguments);
}
var EmptyObject = {};
function Steps$1(props) {
	const { prefixCls = "rc-steps", style: style$1, className, classNames = EmptyObject, styles = EmptyObject, rootClassName, orientation, titlePlacement, components: components$1, status = "process", current = 0, initial = 0, onChange, items, iconRender, itemRender, itemWrapperRender, ...restProps } = props;
	const isVertical = orientation === "vertical";
	const mergedOrientation = isVertical ? "vertical" : "horizontal";
	const mergeTitlePlacement = !isVertical && titlePlacement === "vertical" ? "vertical" : "horizontal";
	const classString = clsx(prefixCls, `${prefixCls}-${mergedOrientation}`, `${prefixCls}-title-${mergeTitlePlacement}`, rootClassName, className, classNames.root);
	const mergedItems = import_react.useMemo(() => (items || []).filter(Boolean), [items]);
	const statuses = import_react.useMemo(() => mergedItems.map(({ status: itemStatus }, index$1) => {
		const stepNumber = initial + index$1;
		if (!itemStatus) {
			if (stepNumber === current) return status;
			else if (stepNumber < current) return "finish";
			return "wait";
		}
		return itemStatus;
	}), [
		mergedItems,
		status,
		current,
		initial
	]);
	const onStepClick = (next$1) => {
		if (onChange && current !== next$1) onChange(next$1);
	};
	const { root: RootComponent = "div", item: ItemComponent = "div" } = components$1 || {};
	const stepIconContext = import_react.useMemo(() => ({
		prefixCls,
		classNames,
		styles,
		ItemComponent
	}), [
		prefixCls,
		classNames,
		styles,
		ItemComponent
	]);
	const renderStep = (item, index$1) => {
		const stepIndex = initial + index$1;
		const itemStatus = statuses[index$1];
		const nextStatus = statuses[index$1 + 1];
		const data = {
			...item,
			status: itemStatus
		};
		return /* @__PURE__ */ import_react.createElement(Step, {
			key: stepIndex,
			prefixCls,
			classNames,
			styles,
			data,
			nextStatus,
			active: stepIndex === current,
			index: stepIndex,
			last: mergedItems.length - 1 === index$1,
			iconRender,
			itemRender,
			itemWrapperRender,
			onClick: onChange && onStepClick
		});
	};
	return /* @__PURE__ */ import_react.createElement(RootComponent, _extends$22({
		className: classString,
		style: {
			...style$1,
			...styles?.root
		}
	}, restProps), /* @__PURE__ */ import_react.createElement(StepsContext.Provider, { value: stepIconContext }, mergedItems.map(renderStep)));
}

//#endregion
//#region node_modules/@rc-component/steps/es/index.js
var es_default$10 = Steps$1;

//#endregion
//#region node_modules/antd/es/steps/context.js
/**
* When use this context. Will trade as sub component instead of root Steps component.
*/
const InternalContext = /* @__PURE__ */ import_react.createContext(null);

//#endregion
//#region node_modules/antd/es/steps/PanelArrow.js
function PanelArrow(props) {
	const { prefixCls } = props;
	return /* @__PURE__ */ import_react.createElement("svg", {
		className: `${prefixCls}-panel-arrow`,
		viewBox: "0 0 100 100",
		xmlns: "http://www.w3.org/2000/svg",
		preserveAspectRatio: "none"
	}, /* @__PURE__ */ import_react.createElement("title", null, "Arrow"), /* @__PURE__ */ import_react.createElement("path", { d: "M 0 0 L 100 50 L 0 100" }));
}

//#endregion
//#region node_modules/antd/es/steps/ProgressIcon.js
function ProgressIcon(props) {
	const { prefixCls, children, percent } = props;
	const progressCls = `${prefixCls}-item-progress-icon`;
	const circleCls = `${progressCls}-circle`;
	const dashArray = `calc(var(--progress-r) * 2 * ${Math.PI * percent / 100}) 9999`;
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("svg", {
		className: `${progressCls}-svg`,
		viewBox: "0 0 100 100",
		width: "100%",
		height: "100%",
		xmlns: "http://www.w3.org/2000/svg",
		"aria-valuemax": 100,
		"aria-valuemin": 0,
		"aria-valuenow": percent
	}, /* @__PURE__ */ import_react.createElement("title", null, "Progress"), /* @__PURE__ */ import_react.createElement("circle", { className: clsx(circleCls, `${circleCls}-rail`) }), /* @__PURE__ */ import_react.createElement("circle", {
		className: clsx(circleCls, `${circleCls}-ptg`),
		strokeDasharray: dashArray,
		transform: "rotate(-90 50 50)"
	})), children);
}

//#endregion
//#region node_modules/antd/es/steps/style/horizontal.js
var genHorizontalStyle$1 = (token$1) => {
	const { componentCls } = token$1;
	const itemCls = `${componentCls}-item`;
	return { [`${componentCls}-horizontal`]: { [`> ${itemCls}`]: {
		flex: "1 1 auto",
		minWidth: token$1.iconSize,
		[`${itemCls}-rail`]: {
			"--steps-horizontal-rail-margin": "calc(var(--steps-icon-size-max) / 2 + var(--steps-item-wrapper-padding-top))",
			position: "static",
			marginTop: "var(--steps-horizontal-rail-margin)",
			width: "auto",
			borderBlockStartWidth: "var(--steps-rail-size)",
			flex: 1,
			minWidth: 0,
			alignSelf: "flex-start",
			transform: "translateY(-50%)"
		}
	} } };
};
var horizontal_default$1 = genHorizontalStyle$1;

//#endregion
//#region node_modules/antd/es/steps/style/icon.js
var genIconStyle = (token$1) => {
	const { componentCls, customIconFontSize, motionDurationSlow } = token$1;
	const itemCls = `${componentCls}-item`;
	return { [componentCls]: {
		"--steps-icon-size": token$1.iconSize,
		"--steps-icon-border-width": token$1.lineWidth,
		[`${itemCls}-icon`]: {
			width: "var(--steps-icon-size)",
			height: "var(--steps-icon-size)",
			margin: 0,
			flex: "none",
			display: "flex",
			alignItems: "center",
			justifyContent: "center",
			fontSize: token$1.iconFontSize,
			fontFamily: token$1.fontFamily,
			lineHeight: "var(--steps-icon-size)",
			textAlign: "center",
			borderRadius: "var(--steps-icon-size)",
			border: `var(--steps-icon-border-width) ${token$1.lineType} transparent`,
			transition: [
				"background",
				"border",
				"color",
				"inset",
				"transform"
			].map((key) => `${key} ${motionDurationSlow}`).join(", "),
			zIndex: 1
		},
		[`${itemCls}-custom ${itemCls}-icon`]: {
			background: "none",
			border: 0,
			fontSize: customIconFontSize
		}
	} };
};
var icon_default = genIconStyle;

//#endregion
//#region node_modules/antd/es/steps/style/inline.js
var genInlineStyle = (token$1) => {
	const { componentCls, inlineDotSize } = token$1;
	const containerPaddingTop = token$1.calc(token$1.paddingXS).add(token$1.lineWidth).equal();
	const itemCls = `${componentCls}-item`;
	return { [`${componentCls}-inline`]: {
		"--steps-items-offset": "0",
		"--steps-item-wrapper-padding-top": containerPaddingTop,
		display: "inline-flex",
		"&:before": {
			content: "\"\"",
			flex: "var(--steps-items-offset)"
		},
		[itemCls]: {
			"--steps-title-vertical-row-gap": token$1.paddingXS,
			"--steps-icon-size": inlineDotSize,
			"--steps-icon-size-active": inlineDotSize,
			"--steps-title-font-size": token$1.fontSizeSM,
			"--steps-title-line-height": token$1.lineHeightSM,
			"--steps-item-title-color": token$1.colorTextSecondary,
			"--steps-subtitle-font-size": token$1.fontSizeSM,
			"--steps-subtitle-line-height": token$1.lineHeightSM,
			"--steps-item-subtitle-color": token$1.colorTextQuaternary,
			"--steps-rail-size": token$1.lineWidth,
			"--steps-title-horizontal-rail-gap": "0px",
			flex: 1,
			"&-wrapper": {
				paddingInline: token$1.paddingXXS,
				marginInline: token$1.calc(token$1.marginXXS).div(2).equal(),
				borderRadius: token$1.borderRadiusSM,
				cursor: "pointer",
				transition: `background ${token$1.motionDurationMid}`,
				"&:hover": { background: token$1.controlItemBgHover }
			},
			"&-icon": { [`${itemCls}-icon-dot`]: { "&:after": { display: "none" } } },
			"&-title": {
				fontWeight: "normal",
				whiteSpace: "nowrap"
			},
			"&-content": { display: "none" }
		}
	} };
};
var inline_default = genInlineStyle;

//#endregion
//#region node_modules/antd/es/steps/style/util.js
function withoutVar(cssVar) {
	return (cssVar || "--ant-not-exist").replace(/var\((.*)\)/, "$1");
}
/**
* Force override the width related styles.
* This should be multiple since will conflict with other `rail` styles.
*/
function getItemWithWidthStyle(token$1, marginSize, optionalStyle) {
	const { calc, componentCls, descriptionMaxWidth } = token$1;
	const itemCls = `${componentCls}-item`;
	return { [`@container style(${withoutVar(descriptionMaxWidth)})`]: [{
		[`${itemCls}-icon`]: { marginInlineStart: calc(descriptionMaxWidth).sub(`var(--steps-icon-size)`).div(2).equal() },
		[`${itemCls}-rail`]: {
			width: "auto",
			insetInlineStart: calc(descriptionMaxWidth).add(`var(--steps-icon-size)`).div(2).add(marginSize).equal(),
			insetInlineEnd: calc(descriptionMaxWidth).sub(`var(--steps-icon-size)`).div(2).sub(marginSize).mul(-1).equal()
		}
	}, optionalStyle] };
}

//#endregion
//#region node_modules/antd/es/steps/style/label-placement.js
var genLabelPlacementStyle = (token$1) => {
	const { componentCls, descriptionMaxWidth, marginXS, fontHeightLG, calc } = token$1;
	const itemCls = `${componentCls}-item`;
	return {
		[componentCls]: {
			"--steps-icon-size-max": "max(var(--steps-icon-size), var(--steps-icon-size-active, var(--steps-icon-size)))",
			[`${itemCls}-icon`]: { marginBlockStart: `calc((var(--steps-heading-height) - var(--steps-icon-size)) / 2)` }
		},
		[`${componentCls}-title-horizontal`]: {
			"--steps-title-horizontal-item-margin": token$1.margin,
			"--steps-title-horizontal-rail-margin": token$1.margin,
			"--steps-title-horizontal-title-height": fontHeightLG,
			"--steps-heading-height": `max(var(--steps-icon-size), var(--steps-title-horizontal-title-height))`,
			[`&${componentCls}-horizontal, &${componentCls}-horizontal-alternate`]: {
				[`${itemCls}:not(:first-child)`]: { marginInlineStart: `var(--steps-title-horizontal-item-margin)` },
				[`${itemCls}:last-child`]: { flex: "0 1 auto" },
				[`${itemCls}-wrapper`]: { columnGap: token$1.marginXS }
			},
			[`&${componentCls}-vertical`]: {
				[`${itemCls}-wrapper`]: { columnGap: token$1.margin },
				[`${itemCls}-empty-header`]: {
					[`${itemCls}-header`]: { minHeight: "auto" },
					[`${itemCls}-content`]: { marginTop: calc("var(--steps-heading-height)").sub(token$1.fontHeight).div(2).equal() }
				}
			},
			[`${itemCls}-section`]: {
				flex: 1,
				minWidth: 0
			},
			[`${itemCls}-header`]: { minHeight: "var(--steps-heading-height)" },
			[`${itemCls}-title`]: { flex: "0 1 auto" },
			[`${itemCls}-content`]: { maxWidth: descriptionMaxWidth },
			[`${itemCls}-subtitle`]: { flex: "0 9999 auto" },
			[`&${componentCls}-horizontal ${itemCls}-rail`]: {
				"--steps-item-wrapper-padding-top": "0px",
				flex: 1,
				marginInlineStart: `var(--steps-title-horizontal-rail-margin)`
			}
		},
		[`${componentCls}-title-vertical`]: {
			"--steps-title-vertical-row-gap": token$1.paddingSM,
			"--steps-title-horizontal-rail-gap": token$1.marginXXS,
			"--steps-heading-height": "var(--steps-icon-size-max)",
			[`> ${itemCls}`]: {
				flex: 1,
				[`${itemCls}-wrapper`]: {
					flexDirection: "column",
					rowGap: `var(--steps-title-vertical-row-gap)`,
					alignItems: "center"
				},
				[`${itemCls}-section`]: { alignSelf: "stretch" },
				[`${itemCls}-header`]: {
					flexDirection: "column",
					alignItems: "center"
				},
				[`${itemCls}-title, ${itemCls}-subtitle, ${itemCls}-content`]: {
					textAlign: "center",
					maxWidth: "100%"
				},
				[`${itemCls}-subtitle`]: { margin: 0 },
				[`${itemCls}-rail`]: {
					position: "absolute",
					top: 0,
					width: `calc(100% - var(--steps-icon-size) - var(--steps-title-horizontal-rail-gap) * 2)`,
					insetInlineStart: `calc(50% + var(--steps-icon-size) / 2 + var(--steps-title-horizontal-rail-gap))`
				}
			},
			...getItemWithWidthStyle(token$1, marginXS, {
				[`${itemCls}:last-child`]: { flex: "none" },
				[`${itemCls}-icon`]: { alignSelf: "flex-start" },
				[`${itemCls}-section`]: { width: descriptionMaxWidth }
			})
		}
	};
};
var label_placement_default = genLabelPlacementStyle;

//#endregion
//#region node_modules/antd/es/steps/style/nav.js
var genLegacyNavStyle = (token$1) => {
	const { componentCls, fontSizeIcon, calc, navContentMaxWidth, navArrowColor, colorPrimary, motionDurationSlow } = token$1;
	const itemCls = `${componentCls}-item`;
	const stepsNavActiveColor = colorPrimary;
	return { [`${componentCls}${componentCls}-navigation`]: {
		[itemCls.repeat(4)]: {
			display: "flex",
			justifyContent: "center",
			position: "relative",
			flex: 1,
			marginInlineStart: 0,
			[`${itemCls}-wrapper`]: { paddingBlock: token$1.paddingSM },
			[`${itemCls}-section`]: { maxWidth: navContentMaxWidth },
			[`${itemCls}-rail`]: { display: "none" },
			"&:before": {
				position: "absolute",
				display: "block",
				backgroundColor: stepsNavActiveColor,
				transition: `all ${motionDurationSlow}`,
				transitionTimingFunction: "ease-out",
				content: "\"\""
			},
			"&:not(:last-child):after": {
				position: "absolute",
				display: "block",
				borderTop: `${unit(token$1.lineWidth)} ${token$1.lineType} ${navArrowColor}`,
				borderBottom: "none",
				borderInlineStart: "none",
				borderInlineEnd: `${unit(token$1.lineWidth)} ${token$1.lineType} ${navArrowColor}`,
				content: "\"\""
			},
			[`&${itemCls}-active`]: {
				"--steps-item-content-active-color": `var(--steps-item-content-color)`,
				"--steps-item-icon-active-bg-color": "var(--steps-item-icon-bg-color)",
				"--steps-item-icon-active-border-color": "var(--steps-item-icon-border-color)",
				"--steps-item-icon-active-text-color": "var(--steps-item-icon-text-color)"
			}
		},
		[`&${componentCls}-horizontal`]: { [itemCls]: {
			"&:before": {
				bottom: 0,
				insetInlineStart: "50%",
				width: 0,
				height: token$1.lineWidthBold
			},
			[`&${itemCls}-active:before`]: {
				insetInlineStart: 0,
				width: "100%"
			},
			"&:not(:last-child):after": {
				top: `50%`,
				insetInlineStart: calc(fontSizeIcon).div(2).mul(-1).add("100%").equal(),
				width: fontSizeIcon,
				height: fontSizeIcon,
				transform: "translateY(-50%) rotate(45deg)"
			}
		} },
		[`&${componentCls}-vertical`]: { [itemCls.repeat(4)]: {
			[`${itemCls}-content`]: { padding: 0 },
			"&:before": {
				insetInlineEnd: 0,
				top: "50%",
				width: token$1.lineWidthBold,
				height: 0
			},
			[`&${itemCls}-active::before`]: {
				top: 0,
				height: "100%"
			},
			"&:not(:last-child):after": {
				left: {
					_skip_check_: true,
					value: "50%"
				},
				top: "100%",
				width: calc(fontSizeIcon).div(3).mul(2).equal(),
				height: calc(fontSizeIcon).div(3).mul(2).equal(),
				transform: "translateY(-50%) translateX(-50%) rotate(135deg)"
			}
		} }
	} };
};
var nav_default = genLegacyNavStyle;

//#endregion
//#region node_modules/antd/es/steps/style/panel.js
var genPanelStyle = (token$1) => {
	const { componentCls, calc, lineWidthBold, borderRadius, borderRadiusSM, motionDurationMid } = token$1;
	const itemCls = `${componentCls}-item`;
	const borderStyle = `${unit(lineWidthBold)} ${token$1.lineType} var(--steps-panel-border-color)`;
	return { [`${componentCls}${componentCls}-panel`]: [
		{
			[`${itemCls}-rail`]: { display: "none" },
			[`&${componentCls}-horizontal`]: {
				alignItems: "stretch",
				[itemCls]: {
					flex: 1,
					margin: 0
				}
			}
		},
		{
			"&": {
				"--steps-panel-padding": token$1.paddingSM,
				"--steps-item-border-radius": borderRadius,
				[itemCls]: {
					"--steps-panel-bg-color": "var(--steps-item-icon-bg-color)",
					"--steps-panel-border-color": "var(--steps-item-icon-border-color)",
					"--steps-panel-active-bg-color": "var(--steps-item-icon-active-bg-color)",
					"--steps-panel-active-border-color": "var(--steps-item-icon-active-border-color)",
					"--steps-panel-title-height": `calc(var(--steps-title-font-size) * var(--steps-title-line-height))`,
					"--steps-item-base-height": calc("var(--steps-panel-padding)").mul(2).add("var(--steps-icon-size)").add("var(--steps-panel-title-height)").equal(),
					"--steps-item-base-width": "calc(var(--steps-item-base-height) * 0.7071)",
					transition: `background ${motionDurationMid}`
				}
			},
			[`${itemCls}-icon`]: { display: "none" },
			[`${itemCls}-header`]: { minHeight: "auto" },
			[`${componentCls}-panel-arrow`]: {
				position: "absolute",
				top: calc(lineWidthBold).mul(-1).equal(),
				insetInlineStart: "100%",
				zIndex: 1,
				height: calc(lineWidthBold).mul(2).add("100%").equal(),
				width: "var(--steps-item-base-width)",
				overflow: "visible",
				strokeLinecap: "round",
				path: {
					fill: "var(--steps-panel-bg-color)",
					stroke: "var(--steps-panel-border-color)",
					strokeWidth: lineWidthBold,
					vectorEffect: "non-scaling-stroke",
					transition: `fill ${motionDurationMid}`
				}
			},
			[`${itemCls}:last-child ${componentCls}-panel-arrow`]: { display: "none" },
			[itemCls]: {
				padding: "var(--steps-panel-padding)",
				background: "var(--steps-panel-bg-color)",
				position: "relative",
				borderBlock: borderStyle,
				"&:not(:first-child)": { paddingInlineStart: `calc(var(--steps-panel-padding) + var(--steps-item-base-width))` },
				"&:first-child": {
					borderInlineStart: borderStyle,
					borderStartStartRadius: "var(--steps-item-border-radius)",
					borderEndStartRadius: "var(--steps-item-border-radius)"
				},
				"&:last-child": {
					borderInlineEnd: borderStyle,
					borderStartEndRadius: "var(--steps-item-border-radius)",
					borderEndEndRadius: "var(--steps-item-border-radius)"
				},
				"&-active": {
					background: "var(--steps-panel-active-bg-color)",
					borderColor: "var(--steps-panel-active-border-color)",
					[`${componentCls}-panel-arrow`]: { path: {
						fill: "var(--steps-panel-active-bg-color)",
						stroke: "var(--steps-panel-active-border-color)"
					} },
					[`${itemCls}-title, ${itemCls}-subtitle, ${itemCls}-content`]: { color: "var(--steps-item-icon-active-text-color)" }
				}
			}
		},
		{ [`&${componentCls}-small`]: {
			"--steps-panel-padding": token$1.paddingXS,
			"--steps-item-border-radius": borderRadiusSM
		} },
		{ [`&${componentCls}-filled`]: { [itemCls]: { "&:not(:first-child)": { clipPath: `polygon(${[
			`${unit(lineWidthBold)} 0`,
			"calc(100% + var(--steps-item-base-width)) 0",
			"calc(100% + var(--steps-item-base-width)) 100%",
			`${unit(lineWidthBold)} 100%`,
			`calc(var(--steps-item-base-width) + ${unit(lineWidthBold)}) 50%`
		].join(",")})` } } } },
		{ [`&${componentCls}-outlined`]: { [`${componentCls}-panel-arrow`]: {
			top: calc(lineWidthBold).div(2).mul(-1).equal(),
			height: calc(lineWidthBold).add("100%").equal()
		} } }
	] };
};
var panel_default = genPanelStyle;

//#endregion
//#region node_modules/antd/es/steps/style/progress.js
var genStepsProgressStyle = (token$1) => {
	const { calc, antCls, componentCls, iconSize, iconSizeSM, lineWidthBold, paddingXXS } = token$1;
	const itemCls = `${componentCls}-item`;
	const progressSize = token$1.calc(iconSize).add(token$1.calc(lineWidthBold).mul(4).equal()).equal();
	const progressSizeSM = token$1.calc(iconSizeSM).add(token$1.calc(token$1.lineWidth).mul(4).equal()).equal();
	const enhanceSize = calc(lineWidthBold).add(lineWidthBold).equal();
	return {
		[`${componentCls}${componentCls}-with-progress`]: {
			"--steps-item-wrapper-padding-top": enhanceSize,
			[`${itemCls}${itemCls}-process`]: { [`${itemCls}-icon`]: { position: "relative" } },
			[`${itemCls}-progress-icon`]: {
				"&-svg": {
					"--steps-svg-size": calc(enhanceSize).mul(2).add(`var(--steps-icon-size)`).equal(),
					"--icon-size-ptg-unitless": `calc(100 / tan(atan2(var(--steps-svg-size),1px)))`,
					fontSize: `var(--steps-svg-size)`,
					lineHeight: `var(--icon-size-ptg-unitless)`,
					position: "absolute",
					inset: calc(enhanceSize).mul(-1).equal(),
					width: "auto",
					height: "auto"
				},
				"&-circle": {
					lineHeight: `var(--icon-size-ptg-unitless)`,
					strokeWidth: calc(`var(--icon-size-ptg-unitless)`).mul(lineWidthBold).equal(),
					"--progress-r": calc(`var(--steps-svg-size)`).sub(lineWidthBold).mul(`var(--icon-size-ptg-unitless)`).div(2).equal(),
					r: `var(--progress-r)`,
					fill: "none",
					cx: 50,
					cy: 50,
					transition: `all ${token$1.motionDurationSlow} ease-in-out`,
					"&-rail": { stroke: token$1.colorSplit },
					"&-ptg": { stroke: token$1.colorPrimary }
				}
			}
		},
		[`&${componentCls}-with-progress11`]: {
			[itemCls]: {
				paddingTop: paddingXXS,
				paddingInlineStart: paddingXXS
			},
			[`${itemCls}-icon`]: {
				position: "relative",
				[`${antCls}-progress`]: {
					position: "absolute",
					left: {
						_skip_check_: true,
						value: "50%"
					},
					top: "50%",
					transform: "translate(-50%, -50%)",
					"&-body": {
						width: `${unit(progressSize)} !important`,
						height: `${unit(progressSize)} !important`
					}
				}
			},
			[`&${componentCls}-small`]: { [`${itemCls}-icon ${antCls}-progress-body`]: {
				width: `${unit(progressSizeSM)} !important`,
				height: `${unit(progressSizeSM)} !important`
			} }
		}
	};
};
var progress_default$1 = genStepsProgressStyle;

//#endregion
//#region node_modules/antd/es/steps/style/progress-dot.js
var genDotStyle = (token$1) => {
	const { componentCls, iconSize, dotSize, dotCurrentSize, marginXXS, lineWidthBold, fontSizeSM } = token$1;
	const itemCls = `${componentCls}-item`;
	return { [`${componentCls}${componentCls}-dot`]: {
		"--steps-icon-size-active": dotCurrentSize,
		"--steps-icon-size": dotSize,
		"--steps-dot-icon-size": dotSize,
		"--steps-dot-icon-border-width": token$1.lineWidthBold,
		"--steps-rail-size": lineWidthBold,
		"--steps-icon-border-width": lineWidthBold,
		[`${itemCls}-custom ${itemCls}-icon`]: { fontSize: fontSizeSM },
		[`${itemCls}-icon`]: {
			position: "relative",
			"&:after": {
				content: "\"\"",
				width: iconSize,
				height: iconSize,
				display: "block",
				position: "absolute",
				top: "50%",
				left: {
					_skip_check_: true,
					value: "50%"
				},
				transform: "translate(-50%, -50%)"
			}
		},
		[`${itemCls}-active ${itemCls}-icon`]: { "--steps-icon-size": "var(--steps-icon-size-active)" },
		[`&${componentCls}-horizontal`]: { [`&, &${componentCls}-small`]: getItemWithWidthStyle(token$1, marginXXS) }
	} };
};
var progress_dot_default = genDotStyle;

//#endregion
//#region node_modules/antd/es/steps/style/rtl.js
var genRTLStyle = (token$1) => {
	const { componentCls, lineWidthBold } = token$1;
	const itemCls = `${componentCls}-item`;
	return { [`${componentCls}${componentCls}-rtl`]: {
		direction: "rtl",
		[`&${componentCls}-navigation${componentCls}-horizontal`]: { [`${itemCls}:after`]: { transform: "translateY(-50%) rotate(-45deg)" } },
		[`&${componentCls}-panel`]: {
			[`${componentCls}-panel-arrow`]: { transform: `scaleX(-1)` },
			[`&${componentCls}-filled`]: { [itemCls]: { "&:not(:first-child)": { clipPath: `polygon(${[
				`calc(0px - var(--steps-item-base-width)) 0px`,
				`calc(100% - ${unit(lineWidthBold)}) 0px`,
				`calc(100% - var(--steps-item-base-width) - ${unit(lineWidthBold)}) 50%`,
				`calc(100% - ${unit(lineWidthBold)}) 100%`,
				`calc(0px - var(--steps-item-base-width)) 100%`
			].join(",")})` } } }
		}
	} };
};
var rtl_default$2 = genRTLStyle;

//#endregion
//#region node_modules/antd/es/steps/style/small.js
var genSmallStyle = (token$1) => {
	const { componentCls, iconSizeSM, fontSize, lineHeight, marginXS } = token$1;
	return { [`${componentCls}${componentCls}-small`]: {
		"--steps-icon-size": iconSizeSM,
		"--steps-title-horizontal-item-margin": token$1.marginSM,
		"--steps-title-vertical-row-gap": token$1.paddingXS,
		"--steps-title-font-size": fontSize,
		"--steps-title-line-height": lineHeight,
		"--steps-title-horizontal-rail-margin": token$1.marginXS,
		"--steps-title-horizontal-title-height": token$1.fontHeight,
		[`&${componentCls}-horizontal${componentCls}-title-vertical`]: getItemWithWidthStyle(token$1, marginXS)
	} };
};
var small_default = genSmallStyle;

//#endregion
//#region node_modules/antd/es/steps/style/status.js
const STATUS_WAIT = "wait";
const STATUS_PROCESS = "process";
const STATUS_FINISH = "finish";
const STATUS_ERROR = "error";
var genStatusStyle = (token$1) => {
	const { componentCls, colorTextDisabled, colorTextLightSolid, colorPrimary, colorTextLabel, colorError, colorText, colorTextDescription, colorBgContainer, colorPrimaryHover } = token$1;
	const itemCls = `${componentCls}-item`;
	return { [componentCls]: [
		{
			[itemCls]: {
				"--steps-item-solid-line-color": "#000",
				"--steps-item-title-color": "#000",
				"--steps-item-content-color": "#000",
				"--steps-item-subtitle-color": "var(--steps-item-content-color)",
				"--steps-item-icon-custom-color": "#000",
				"--steps-item-icon-bg-color": "#000",
				"--steps-item-icon-border-color": "#000",
				"--steps-item-icon-text-color": "#fff",
				"--steps-item-icon-dot-color": "#000",
				"--steps-item-icon-dot-bg-color": "var(--steps-item-icon-dot-color)",
				"--steps-item-icon-dot-border-color": "var(--steps-item-icon-dot-color)",
				"--steps-item-text-hover-color": "#000",
				"--steps-item-icon-bg-hover-color": `var(--steps-item-icon-bg-color)`,
				"--steps-item-icon-border-hover-color": `var(--steps-item-icon-border-color)`,
				"--steps-item-icon-text-hover-color": `var(--steps-item-icon-text-color)`,
				"--steps-item-content-active-color": `var(--steps-item-content-color)`,
				"--steps-item-icon-active-bg-color": "var(--steps-item-icon-bg-color)",
				"--steps-item-icon-active-border-color": "var(--steps-item-icon-border-color)",
				"--steps-item-icon-active-text-color": "var(--steps-item-icon-text-color)",
				"--steps-item-process-rail-line-style": token$1.lineType
			},
			[`${itemCls}-rail`]: { borderColor: `var(--steps-item-solid-line-color)` },
			[`${itemCls}-custom ${itemCls}-icon`]: { color: `var(--steps-item-icon-custom-color)` },
			[`${itemCls}-title`]: { color: `var(--steps-item-title-color)` },
			[`${itemCls}-subtitle`]: { color: `var(--steps-item-subtitle-color)` },
			[`${itemCls}-content`]: { color: `var(--steps-item-content-color)` },
			[`${itemCls}-active ${itemCls}-icon`]: {},
			[`${itemCls}-active ${itemCls}-content`]: { color: `var(--steps-item-content-active-color)` },
			[`${itemCls}[role='button']:not(${itemCls}-active):hover`]: { [`${itemCls}-title, ${itemCls}-content`]: { color: `var(--steps-item-text-hover-color)` } },
			[`&:not(${componentCls}-dot)`]: { [`${itemCls}:not(${itemCls}-custom)`]: {
				[`${itemCls}-icon`]: {
					background: `var(--steps-item-icon-bg-color)`,
					borderColor: `var(--steps-item-icon-border-color)`,
					color: `var(--steps-item-icon-text-color)`
				},
				[`&[role='button']:not(${itemCls}-active):hover`]: { [`${itemCls}-icon`]: {
					background: `var(--steps-item-icon-bg-hover-color)`,
					borderColor: `var(--steps-item-icon-border-hover-color)`,
					color: `var(--steps-item-icon-text-hover-color)`
				} },
				[`&${itemCls}-active`]: { [`${itemCls}-icon`]: {
					background: `var(--steps-item-icon-active-bg-color)`,
					borderColor: `var(--steps-item-icon-active-border-color)`,
					color: `var(--steps-item-icon-active-text-color)`
				} }
			} },
			[`&${componentCls}-dot`]: { [`${itemCls}-icon`]: {
				background: `var(--steps-item-icon-dot-bg-color)`,
				borderColor: `var(--steps-item-icon-dot-border-color)`,
				color: `var(--steps-item-icon-dot-color)`,
				[`&${itemCls}-icon-dot-custom`]: {
					background: "transparent",
					border: "none"
				}
			} }
		},
		{
			[`${itemCls}-${STATUS_WAIT}`]: {
				"--steps-item-icon-custom-color": colorTextDisabled,
				"--steps-item-title-color": colorTextDescription,
				"--steps-item-content-color": colorTextDescription,
				"--steps-item-content-active-color": colorText,
				"--steps-item-text-hover-color": colorPrimaryHover
			},
			[`${itemCls}-rail-${STATUS_WAIT}`]: { "--steps-item-solid-line-color": colorTextDisabled },
			[`${itemCls}-${STATUS_PROCESS}`]: {
				"--steps-item-icon-custom-color": colorPrimary,
				"--steps-item-title-color": colorText,
				"--steps-item-content-color": colorTextDescription,
				"--steps-item-content-active-color": colorText,
				"--steps-item-text-hover-color": colorPrimaryHover
			},
			[`${itemCls}-rail-${STATUS_PROCESS}`]: {
				"--steps-item-solid-line-color": colorPrimary,
				"--steps-rail-line-style": "var(--steps-item-process-rail-line-style)"
			},
			[`${itemCls}-${STATUS_FINISH}`]: {
				"--steps-item-icon-custom-color": colorPrimary,
				"--steps-item-title-color": colorText,
				"--steps-item-content-color": colorTextDescription,
				"--steps-item-content-active-color": colorText,
				"--steps-item-text-hover-color": colorPrimaryHover
			},
			[`${itemCls}-rail-${STATUS_FINISH}`]: { "--steps-item-solid-line-color": colorPrimary },
			[`${itemCls}-${STATUS_ERROR}`]: {
				"--steps-item-icon-custom-color": colorError,
				"--steps-item-title-color": colorError,
				"--steps-item-content-color": colorError,
				"--steps-item-content-active-color": colorError,
				"--steps-item-text-hover-color": token$1.colorErrorHover
			},
			[`${itemCls}-rail-${STATUS_ERROR}`]: { "--steps-item-solid-line-color": colorError }
		},
		{ [`&${componentCls}-filled`]: {
			[itemCls]: { "--steps-item-icon-dot-border-color": "transparent" },
			[`${itemCls}-${STATUS_WAIT}`]: {
				"--steps-item-icon-bg-color": token$1.colorFillTertiary,
				"--steps-item-icon-border-color": "transparent",
				"--steps-item-icon-text-color": colorTextLabel,
				"--steps-item-icon-dot-bg-color": colorTextDisabled,
				"--steps-item-icon-bg-hover-color": token$1.colorPrimaryBgHover,
				"--steps-item-icon-border-hover-color": "transparent",
				"--steps-item-icon-text-hover-color": colorPrimary,
				"--steps-item-icon-active-bg-color": colorPrimary,
				"--steps-item-icon-active-border-color": "transparent",
				"--steps-item-icon-active-text-color": colorTextLightSolid
			},
			[`${itemCls}-${STATUS_PROCESS}, ${itemCls}-${STATUS_FINISH}`]: {
				"--steps-item-icon-bg-color": token$1.colorPrimaryBg,
				"--steps-item-icon-border-color": "transparent",
				"--steps-item-icon-text-color": colorPrimary,
				"--steps-item-icon-dot-bg-color": colorPrimary,
				"--steps-item-icon-bg-hover-color": token$1.colorPrimaryBgHover,
				"--steps-item-icon-border-hover-color": "transparent",
				"--steps-item-icon-text-hover-color": colorPrimary,
				"--steps-item-icon-active-bg-color": colorPrimary,
				"--steps-item-icon-active-border-color": "transparent",
				"--steps-item-icon-active-text-color": colorTextLightSolid
			},
			[`${itemCls}-${STATUS_ERROR}`]: {
				"--steps-item-icon-bg-color": token$1.colorErrorBg,
				"--steps-item-icon-border-color": "transparent",
				"--steps-item-icon-text-color": colorError,
				"--steps-item-icon-dot-bg-color": colorError,
				"--steps-item-icon-bg-hover-color": token$1.colorErrorBgFilledHover,
				"--steps-item-icon-border-hover-color": "transparent",
				"--steps-item-icon-text-hover-color": colorError,
				"--steps-item-icon-active-bg-color": colorError,
				"--steps-item-icon-active-border-color": "transparent",
				"--steps-item-icon-active-text-color": colorTextLightSolid
			}
		} },
		{ [`&${componentCls}-outlined`]: {
			[itemCls]: { "--steps-item-icon-dot-bg-color": "transparent" },
			[`${itemCls}-${STATUS_WAIT}`]: {
				"--steps-item-icon-bg-color": colorBgContainer,
				"--steps-item-icon-border-color": colorTextDisabled,
				"--steps-item-icon-text-color": colorTextDisabled,
				"--steps-item-icon-dot-color": colorTextDisabled,
				"--steps-item-icon-bg-hover-color": "transparent",
				"--steps-item-icon-border-hover-color": colorPrimaryHover,
				"--steps-item-icon-text-hover-color": colorPrimaryHover,
				"--steps-item-icon-active-bg-color": token$1.colorFillTertiary
			},
			[`${itemCls}-${STATUS_PROCESS}, ${itemCls}-${STATUS_FINISH}`]: {
				"--steps-item-icon-bg-color": colorBgContainer,
				"--steps-item-icon-border-color": colorPrimary,
				"--steps-item-icon-text-color": colorPrimary,
				"--steps-item-icon-dot-color": colorPrimary,
				"--steps-item-icon-bg-hover-color": "transparent",
				"--steps-item-icon-border-hover-color": token$1.colorPrimaryHover,
				"--steps-item-icon-text-hover-color": token$1.colorPrimaryHover,
				"--steps-item-icon-active-bg-color": token$1.colorPrimaryBg
			},
			[`${itemCls}-${STATUS_ERROR}`]: {
				"--steps-item-icon-bg-color": colorBgContainer,
				"--steps-item-icon-border-color": colorError,
				"--steps-item-icon-text-color": colorError,
				"--steps-item-icon-dot-color": colorError,
				"--steps-item-icon-bg-hover-color": "transparent",
				"--steps-item-icon-border-hover-color": token$1.colorErrorHover,
				"--steps-item-icon-text-hover-color": token$1.colorErrorHover,
				"--steps-item-icon-active-bg-color": token$1.colorErrorBg
			}
		} }
	] };
};
var status_default = genStatusStyle;

//#endregion
//#region node_modules/antd/es/steps/style/vertical.js
var genVerticalStyle$1 = (token$1) => {
	const { componentCls, calc } = token$1;
	const itemCls = `${componentCls}-item`;
	return { [`${componentCls}-vertical`]: {
		"--steps-vertical-rail-margin": calc(token$1.marginXXS).mul(1.5).equal(),
		flexDirection: "column",
		alignItems: "stretch",
		[`> ${itemCls}`]: {
			minHeight: calc(token$1.controlHeight).mul(1.5).equal(),
			paddingBottom: token$1.paddingSM,
			"&:last-child": { paddingBottom: 0 },
			[`${itemCls}-icon`]: { marginInlineStart: "calc((var(--steps-icon-size-max) - var(--steps-icon-size)) / 2)" },
			[`${itemCls}-rail`]: {
				"--steps-rail-offset": calc("var(--steps-heading-height)").sub("var(--steps-icon-size)").div(2).equal(),
				borderInlineStartWidth: "var(--steps-rail-size)",
				position: "absolute",
				top: calc(`var(--steps-icon-size)`).add("var(--steps-item-wrapper-padding-top)").add("var(--steps-rail-offset)").add("var(--steps-vertical-rail-margin)").equal(),
				insetInlineStart: calc(`var(--steps-icon-size-max)`).div(2).equal(),
				bottom: calc("var(--steps-vertical-rail-margin)").sub("var(--steps-rail-offset)").equal(),
				marginInlineStart: `calc(var(--steps-rail-size) / -2)`
			}
		}
	} };
};
var vertical_default = genVerticalStyle$1;

//#endregion
//#region node_modules/antd/es/steps/style/index.js
var genBasicStyle = (token$1) => {
	const { componentCls } = token$1;
	const itemCls = `${componentCls}-item`;
	return { [componentCls]: {
		"--steps-title-font-size": token$1.fontSizeLG,
		"--steps-title-line-height": token$1.lineHeightLG,
		"--steps-subtitle-font-size": token$1.fontSize,
		"--steps-subtitle-line-height": token$1.lineHeight,
		"--steps-item-wrapper-padding-top": "0px",
		"--steps-rail-size": token$1.lineWidth,
		"--steps-rail-line-style": token$1.lineType,
		...resetComponent(token$1),
		display: "flex",
		flexWrap: "nowrap",
		alignItems: "flex-start",
		[itemCls]: {
			flex: "none",
			position: "relative"
		},
		[`${itemCls}-wrapper`]: {
			display: "flex",
			flexWrap: "nowrap",
			paddingTop: `var(--steps-item-wrapper-padding-top)`
		},
		[`${itemCls}-header`]: {
			display: "flex",
			flexWrap: "nowrap",
			alignItems: "center"
		},
		[`${itemCls}-title`]: {
			color: token$1.colorText,
			fontSize: `var(--steps-title-font-size)`,
			lineHeight: `var(--steps-title-line-height)`,
			wordBreak: "break-word"
		},
		[`${itemCls}-subtitle`]: {
			color: token$1.colorTextDescription,
			fontWeight: "normal",
			fontSize: `var(--steps-subtitle-font-size)`,
			lineHeight: `var(--steps-subtitle-line-height)`,
			marginInlineStart: token$1.marginXS,
			wordBreak: "break-word"
		},
		[`${itemCls}-content`]: {
			color: token$1.colorTextDescription,
			fontSize: token$1.fontSize,
			lineHeight: token$1.lineHeight,
			wordBreak: "break-word"
		},
		[`${itemCls}-rail`]: {
			borderStyle: "var(--steps-rail-line-style)",
			borderWidth: 0
		},
		[`${itemCls}-title, ${itemCls}-subtitle, ${itemCls}-content, ${itemCls}-rail`]: { transition: `all ${token$1.motionDurationSlow}` },
		[`&${componentCls}-ellipsis`]: { [`${itemCls}-title, ${itemCls}-subtitle, ${itemCls}-content`]: textEllipsis },
		[`${itemCls}[role='button']:not(${itemCls}-active):hover`]: { cursor: "pointer" }
	} };
};
const prepareComponentToken$9 = (token$1) => ({
	titleLineHeight: token$1.controlHeight,
	customIconSize: token$1.controlHeight,
	customIconTop: 0,
	customIconFontSize: token$1.controlHeightSM,
	iconSize: token$1.controlHeight,
	iconTop: -.5,
	iconFontSize: token$1.fontSize,
	iconSizeSM: token$1.fontSizeHeading3,
	dotSize: token$1.controlHeight / 4,
	dotCurrentSize: token$1.controlHeightLG / 4,
	navArrowColor: token$1.colorTextDisabled,
	navContentMaxWidth: "unset",
	descriptionMaxWidth: void 0,
	waitIconColor: token$1.wireframe ? token$1.colorTextDisabled : token$1.colorTextLabel,
	waitIconBgColor: token$1.wireframe ? token$1.colorBgContainer : token$1.colorFillContent,
	waitIconBorderColor: token$1.wireframe ? token$1.colorTextDisabled : "transparent",
	finishIconBgColor: token$1.wireframe ? token$1.colorBgContainer : token$1.controlItemBgActive,
	finishIconBorderColor: token$1.wireframe ? token$1.colorPrimary : token$1.controlItemBgActive
});
var style_default$10 = genStyleHooks("Steps", (token$1) => {
	const stepsToken = merge(token$1, { inlineDotSize: 6 });
	return [
		genBasicStyle(stepsToken),
		icon_default(stepsToken),
		vertical_default(stepsToken),
		horizontal_default$1(stepsToken),
		label_placement_default(stepsToken),
		small_default(stepsToken),
		progress_dot_default(stepsToken),
		status_default(stepsToken),
		nav_default(stepsToken),
		panel_default(stepsToken),
		inline_default(stepsToken),
		progress_default$1(stepsToken),
		rtl_default$2(stepsToken)
	];
}, prepareComponentToken$9);

//#endregion
//#region node_modules/antd/es/steps/index.js
var waveEffectClassNames = { itemIcon: TARGET_CLS };
var Steps = (props) => {
	const { size, className, rootClassName, style: style$1, variant = "filled", type: type$2, classNames, styles, direction, orientation, responsive = true, progressDot, labelPlacement, titlePlacement, ellipsis, offset: offset$2 = 0, items, percent, current = 0, onChange, iconRender, ...restProps } = props;
	const internalContent = import_react.useContext(InternalContext);
	const contextContent = useComponentConfig("steps");
	const { getPrefixCls, direction: rtlDirection, className: contextClassName, style: contextStyle } = contextContent;
	let contextClassNames;
	let contextStyles;
	let components$1 = {};
	if (internalContent) components$1 = {
		root: internalContent.rootComponent,
		item: internalContent.itemComponent
	};
	else ({classNames: contextClassNames, styles: contextStyles} = contextContent);
	const prefixCls = getPrefixCls("steps", props.prefixCls);
	const itemIconCls = `${prefixCls}-item-icon`;
	const [hashId, cssVarCls] = style_default$10(prefixCls);
	const mergedSize = useSize_default(size);
	const mergedItems = import_react.useMemo(() => (items || []).filter(Boolean), [items]);
	const { xs } = useBreakpoint_default(responsive);
	const mergedType = import_react.useMemo(() => {
		if (type$2 && type$2 !== "default") return type$2;
		if (progressDot) return "dot";
		return type$2;
	}, [progressDot, type$2]);
	const isInline = mergedType === "inline";
	const isDot = mergedType === "dot" || mergedType === "inline";
	const legacyProgressDotRender = import_react.useMemo(() => {
		return mergedType === "dot" && typeof progressDot === "function" ? progressDot : void 0;
	}, [mergedType, progressDot]);
	const mergedOrientation = import_react.useMemo(() => {
		const nextOrientation = orientation || direction;
		if (mergedType === "panel") return "horizontal";
		return responsive && xs || nextOrientation === "vertical" ? "vertical" : "horizontal";
	}, [
		orientation,
		direction,
		mergedType,
		responsive,
		xs
	]);
	const mergedTitlePlacement = import_react.useMemo(() => {
		if (isDot || mergedOrientation === "vertical") return mergedOrientation === "vertical" ? "horizontal" : "vertical";
		if (type$2 === "navigation") return "horizontal";
		return titlePlacement || labelPlacement || "horizontal";
	}, [
		isDot,
		labelPlacement,
		mergedOrientation,
		titlePlacement,
		type$2
	]);
	const mergedPercent = isInline ? void 0 : percent;
	const mergedProps = {
		...props,
		variant,
		size: mergedSize,
		type: mergedType,
		orientation: mergedOrientation,
		titlePlacement: mergedTitlePlacement,
		current,
		percent: mergedPercent,
		responsive,
		offset: offset$2
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([
		waveEffectClassNames,
		contextClassNames,
		classNames
	], [contextStyles, styles], { props: mergedProps });
	const internalIconRender = (_, info) => {
		const { item, index: index$1, active, components: { Icon: StepIcon$1 } } = info;
		const { status, icon } = item;
		let iconContent = null;
		if (isDot || icon) iconContent = icon;
		else switch (status) {
			case "finish":
				iconContent = /* @__PURE__ */ import_react.createElement(CheckOutlined_default, { className: `${itemIconCls}-finish` });
				break;
			case "error":
				iconContent = /* @__PURE__ */ import_react.createElement(CloseOutlined_default, { className: `${itemIconCls}-error` });
				break;
			default: {
				let numNode = /* @__PURE__ */ import_react.createElement("span", { className: `${itemIconCls}-number` }, info.index + 1);
				if (status === "process" && mergedPercent !== void 0) numNode = /* @__PURE__ */ import_react.createElement(ProgressIcon, {
					prefixCls,
					percent: mergedPercent
				}, numNode);
				iconContent = numNode;
			}
		}
		let iconNode = /* @__PURE__ */ import_react.createElement(StepIcon$1, null, iconContent);
		if (iconRender) iconNode = iconRender(iconNode, {
			index: index$1,
			active,
			item,
			components: { Icon: StepIcon$1 }
		});
		else if (typeof legacyProgressDotRender === "function") iconNode = legacyProgressDotRender(iconNode, {
			index: index$1,
			...item
		});
		return iconNode;
	};
	const itemRender = (itemNode, itemInfo) => {
		let content = itemNode;
		if (isInline && itemInfo.item.content) content = /* @__PURE__ */ import_react.createElement(tooltip_default, {
			destroyOnHidden: true,
			title: itemInfo.item.content
		}, itemNode);
		return /* @__PURE__ */ import_react.createElement(wave_default, {
			component: "Steps",
			disabled: itemInfo.item.disabled || !onChange,
			colorSource: variant === "filled" ? "color" : null
		}, content);
	};
	const itemWrapperRender = mergedType === "panel" ? (itemNode) => {
		return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, itemNode, /* @__PURE__ */ import_react.createElement(PanelArrow, { prefixCls }));
	} : void 0;
	const mergedStyle = {
		"--steps-items-offset": `${offset$2}`,
		...contextStyle,
		...style$1
	};
	const stepsClassName = clsx(contextClassName, `${prefixCls}-${variant}`, {
		[`${prefixCls}-${mergedType}`]: mergedType !== "dot" ? mergedType : false,
		[`${prefixCls}-rtl`]: rtlDirection === "rtl",
		[`${prefixCls}-dot`]: isDot,
		[`${prefixCls}-ellipsis`]: ellipsis,
		[`${prefixCls}-with-progress`]: mergedPercent !== void 0,
		[`${prefixCls}-${mergedSize}`]: mergedSize
	}, className, rootClassName, hashId, cssVarCls);
	{
		const warning$3 = devUseWarning("Steps");
		warning$3.deprecated(!labelPlacement, "labelPlacement", "titlePlacement");
		warning$3.deprecated(!progressDot, "progressDot", "type=\"dot\"");
		warning$3.deprecated(!direction, "direction", "orientation");
		warning$3.deprecated(mergedItems.every((item) => !item.description), "items.description", "items.content");
	}
	return /* @__PURE__ */ import_react.createElement(es_default$10, {
		...restProps,
		prefixCls,
		className: stepsClassName,
		style: mergedStyle,
		classNames: mergedClassNames,
		styles: mergedStyles,
		orientation: mergedOrientation,
		titlePlacement: mergedTitlePlacement,
		components: components$1,
		current,
		items: mergedItems,
		onChange,
		iconRender: internalIconRender,
		itemRender,
		itemWrapperRender
	});
};
Steps.displayName = "Steps";
var steps_default = Steps;

//#endregion
//#region node_modules/@rc-component/switch/es/index.js
function _extends$21() {
	_extends$21 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$21.apply(this, arguments);
}
var Switch$1 = /* @__PURE__ */ import_react.forwardRef(({ prefixCls = "rc-switch", className, checked, defaultChecked, disabled, loadingIcon, checkedChildren, unCheckedChildren, onClick, onChange, onKeyDown: onKeyDown$1, styles, classNames: switchClassNames, ...restProps }, ref) => {
	const [innerChecked, setInnerChecked] = useControlledState(defaultChecked ?? false, checked);
	function triggerChange(newChecked, event) {
		let mergedChecked = innerChecked;
		if (!disabled) {
			mergedChecked = newChecked;
			setInnerChecked(mergedChecked);
			onChange?.(mergedChecked, event);
		}
		return mergedChecked;
	}
	function onInternalKeyDown(e$2) {
		if (e$2.which === KeyCode_default.LEFT) triggerChange(false, e$2);
		else if (e$2.which === KeyCode_default.RIGHT) triggerChange(true, e$2);
		onKeyDown$1?.(e$2);
	}
	function onInternalClick(e$2) {
		const ret = triggerChange(!innerChecked, e$2);
		onClick?.(ret, e$2);
	}
	const switchClassName = clsx(prefixCls, className, {
		[`${prefixCls}-checked`]: innerChecked,
		[`${prefixCls}-disabled`]: disabled
	});
	return /* @__PURE__ */ import_react.createElement("button", _extends$21({}, restProps, {
		type: "button",
		role: "switch",
		"aria-checked": innerChecked,
		disabled,
		className: switchClassName,
		ref,
		onKeyDown: onInternalKeyDown,
		onClick: onInternalClick
	}), loadingIcon, /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-inner` }, /* @__PURE__ */ import_react.createElement("span", {
		className: clsx(`${prefixCls}-inner-checked`, switchClassNames?.content),
		style: styles?.content
	}, checkedChildren), /* @__PURE__ */ import_react.createElement("span", {
		className: clsx(`${prefixCls}-inner-unchecked`, switchClassNames?.content),
		style: styles?.content
	}, unCheckedChildren)));
});
Switch$1.displayName = "Switch";
var es_default$9 = Switch$1;

//#endregion
//#region node_modules/antd/es/switch/style/index.js
var genSwitchSmallStyle = (token$1) => {
	const { componentCls, trackHeightSM, trackPadding, trackMinWidthSM, innerMinMarginSM, innerMaxMarginSM, handleSizeSM, calc } = token$1;
	const switchInnerCls = `${componentCls}-inner`;
	const trackPaddingCalc = unit(calc(handleSizeSM).add(calc(trackPadding).mul(2)).equal());
	const innerMaxMarginCalc = unit(calc(innerMaxMarginSM).mul(2).equal());
	return { [componentCls]: { [`&${componentCls}-small`]: {
		minWidth: trackMinWidthSM,
		height: trackHeightSM,
		lineHeight: unit(trackHeightSM),
		[`${componentCls}-inner`]: {
			paddingInlineStart: innerMaxMarginSM,
			paddingInlineEnd: innerMinMarginSM,
			[`${switchInnerCls}-checked, ${switchInnerCls}-unchecked`]: { minHeight: trackHeightSM },
			[`${switchInnerCls}-checked`]: {
				marginInlineStart: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`,
				marginInlineEnd: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`
			},
			[`${switchInnerCls}-unchecked`]: {
				marginTop: calc(trackHeightSM).mul(-1).equal(),
				marginInlineStart: 0,
				marginInlineEnd: 0
			}
		},
		[`${componentCls}-handle`]: {
			width: handleSizeSM,
			height: handleSizeSM
		},
		[`${componentCls}-loading-icon`]: {
			top: calc(calc(handleSizeSM).sub(token$1.switchLoadingIconSize)).div(2).equal(),
			fontSize: token$1.switchLoadingIconSize
		},
		[`&${componentCls}-checked`]: {
			[`${componentCls}-inner`]: {
				paddingInlineStart: innerMinMarginSM,
				paddingInlineEnd: innerMaxMarginSM,
				[`${switchInnerCls}-checked`]: {
					marginInlineStart: 0,
					marginInlineEnd: 0
				},
				[`${switchInnerCls}-unchecked`]: {
					marginInlineStart: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`,
					marginInlineEnd: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`
				}
			},
			[`${componentCls}-handle`]: { insetInlineStart: `calc(100% - ${unit(calc(handleSizeSM).add(trackPadding).equal())})` }
		},
		[`&:not(${componentCls}-disabled):active`]: {
			[`&:not(${componentCls}-checked) ${switchInnerCls}`]: { [`${switchInnerCls}-unchecked`]: {
				marginInlineStart: calc(token$1.marginXXS).div(2).equal(),
				marginInlineEnd: calc(token$1.marginXXS).mul(-1).div(2).equal()
			} },
			[`&${componentCls}-checked ${switchInnerCls}`]: { [`${switchInnerCls}-checked`]: {
				marginInlineStart: calc(token$1.marginXXS).mul(-1).div(2).equal(),
				marginInlineEnd: calc(token$1.marginXXS).div(2).equal()
			} }
		}
	} } };
};
var genSwitchLoadingStyle = (token$1) => {
	const { componentCls, handleSize, calc } = token$1;
	return { [componentCls]: {
		[`${componentCls}-loading-icon${token$1.iconCls}`]: {
			position: "relative",
			top: calc(calc(handleSize).sub(token$1.fontSize)).div(2).equal(),
			color: token$1.switchLoadingIconColor,
			verticalAlign: "top"
		},
		[`&${componentCls}-checked ${componentCls}-loading-icon`]: { color: token$1.switchColor }
	} };
};
var genSwitchHandleStyle = (token$1) => {
	const { componentCls, trackPadding, handleBg, handleShadow, handleSize, calc } = token$1;
	const switchHandleCls = `${componentCls}-handle`;
	return { [componentCls]: {
		[switchHandleCls]: {
			position: "absolute",
			top: trackPadding,
			insetInlineStart: trackPadding,
			width: handleSize,
			height: handleSize,
			transition: `all ${token$1.switchDuration} ease-in-out`,
			"&::before": {
				position: "absolute",
				top: 0,
				insetInlineEnd: 0,
				bottom: 0,
				insetInlineStart: 0,
				backgroundColor: handleBg,
				borderRadius: calc(handleSize).div(2).equal(),
				boxShadow: handleShadow,
				transition: `all ${token$1.switchDuration} ease-in-out`,
				content: "\"\""
			}
		},
		[`&${componentCls}-checked ${switchHandleCls}`]: { insetInlineStart: `calc(100% - ${unit(calc(handleSize).add(trackPadding).equal())})` },
		[`&:not(${componentCls}-disabled):active`]: {
			[`${switchHandleCls}::before`]: {
				insetInlineEnd: token$1.switchHandleActiveInset,
				insetInlineStart: 0
			},
			[`&${componentCls}-checked ${switchHandleCls}::before`]: {
				insetInlineEnd: 0,
				insetInlineStart: token$1.switchHandleActiveInset
			}
		}
	} };
};
var genSwitchInnerStyle = (token$1) => {
	const { componentCls, trackHeight, trackPadding, innerMinMargin, innerMaxMargin, handleSize, calc } = token$1;
	const switchInnerCls = `${componentCls}-inner`;
	const trackPaddingCalc = unit(calc(handleSize).add(calc(trackPadding).mul(2)).equal());
	const innerMaxMarginCalc = unit(calc(innerMaxMargin).mul(2).equal());
	return { [componentCls]: {
		[switchInnerCls]: {
			display: "block",
			overflow: "hidden",
			borderRadius: 100,
			height: "100%",
			paddingInlineStart: innerMaxMargin,
			paddingInlineEnd: innerMinMargin,
			transition: `padding-inline-start ${token$1.switchDuration} ease-in-out, padding-inline-end ${token$1.switchDuration} ease-in-out`,
			[`${switchInnerCls}-checked, ${switchInnerCls}-unchecked`]: {
				display: "block",
				color: token$1.colorTextLightSolid,
				fontSize: token$1.fontSizeSM,
				transition: `margin-inline-start ${token$1.switchDuration} ease-in-out, margin-inline-end ${token$1.switchDuration} ease-in-out`,
				pointerEvents: "none",
				minHeight: trackHeight
			},
			[`${switchInnerCls}-checked`]: {
				marginInlineStart: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`,
				marginInlineEnd: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`
			},
			[`${switchInnerCls}-unchecked`]: {
				marginTop: calc(trackHeight).mul(-1).equal(),
				marginInlineStart: 0,
				marginInlineEnd: 0
			}
		},
		[`&${componentCls}-checked ${switchInnerCls}`]: {
			paddingInlineStart: innerMinMargin,
			paddingInlineEnd: innerMaxMargin,
			[`${switchInnerCls}-checked`]: {
				marginInlineStart: 0,
				marginInlineEnd: 0
			},
			[`${switchInnerCls}-unchecked`]: {
				marginInlineStart: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`,
				marginInlineEnd: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`
			}
		},
		[`&:not(${componentCls}-disabled):active`]: {
			[`&:not(${componentCls}-checked) ${switchInnerCls}`]: { [`${switchInnerCls}-unchecked`]: {
				marginInlineStart: calc(trackPadding).mul(2).equal(),
				marginInlineEnd: calc(trackPadding).mul(-1).mul(2).equal()
			} },
			[`&${componentCls}-checked ${switchInnerCls}`]: { [`${switchInnerCls}-checked`]: {
				marginInlineStart: calc(trackPadding).mul(-1).mul(2).equal(),
				marginInlineEnd: calc(trackPadding).mul(2).equal()
			} }
		}
	} };
};
var genSwitchStyle = (token$1) => {
	const { componentCls, trackHeight, trackMinWidth } = token$1;
	return { [componentCls]: {
		...resetComponent(token$1),
		position: "relative",
		display: "inline-block",
		boxSizing: "border-box",
		minWidth: trackMinWidth,
		height: trackHeight,
		lineHeight: unit(trackHeight),
		verticalAlign: "middle",
		background: token$1.colorTextQuaternary,
		border: "0",
		borderRadius: 100,
		cursor: "pointer",
		transition: `all ${token$1.motionDurationMid}`,
		userSelect: "none",
		[`&:hover:not(${componentCls}-disabled)`]: { background: token$1.colorTextTertiary },
		...genFocusStyle(token$1),
		[`&${componentCls}-checked`]: {
			background: token$1.switchColor,
			[`&:hover:not(${componentCls}-disabled)`]: { background: token$1.colorPrimaryHover }
		},
		[`&${componentCls}-loading, &${componentCls}-disabled`]: {
			cursor: "not-allowed",
			opacity: token$1.switchDisabledOpacity,
			"*": {
				boxShadow: "none",
				cursor: "not-allowed"
			}
		},
		[`&${componentCls}-rtl`]: { direction: "rtl" }
	} };
};
const prepareComponentToken$8 = (token$1) => {
	const { fontSize, lineHeight, controlHeight, colorWhite } = token$1;
	const height = fontSize * lineHeight;
	const heightSM = controlHeight / 2;
	const padding = 2;
	const handleSize = height - padding * 2;
	const handleSizeSM = heightSM - padding * 2;
	return {
		trackHeight: height,
		trackHeightSM: heightSM,
		trackMinWidth: handleSize * 2 + padding * 4,
		trackMinWidthSM: handleSizeSM * 2 + padding * 2,
		trackPadding: padding,
		handleBg: colorWhite,
		handleSize,
		handleSizeSM,
		handleShadow: `0 2px 4px 0 ${new FastColor("#00230b").setA(.2).toRgbString()}`,
		innerMinMargin: handleSize / 2,
		innerMaxMargin: handleSize + padding + padding * 2,
		innerMinMarginSM: handleSizeSM / 2,
		innerMaxMarginSM: handleSizeSM + padding + padding * 2
	};
};
var style_default$9 = genStyleHooks("Switch", (token$1) => {
	const switchToken = merge(token$1, {
		switchDuration: token$1.motionDurationMid,
		switchColor: token$1.colorPrimary,
		switchDisabledOpacity: token$1.opacityLoading,
		switchLoadingIconSize: token$1.calc(token$1.fontSizeIcon).mul(.75).equal(),
		switchLoadingIconColor: `rgba(0, 0, 0, ${token$1.opacityLoading})`,
		switchHandleActiveInset: "-30%"
	});
	return [
		genSwitchStyle(switchToken),
		genSwitchInnerStyle(switchToken),
		genSwitchHandleStyle(switchToken),
		genSwitchLoadingStyle(switchToken),
		genSwitchSmallStyle(switchToken)
	];
}, prepareComponentToken$8);

//#endregion
//#region node_modules/antd/es/switch/index.js
var Switch = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, size: customizeSize, disabled: customDisabled, loading, className, rootClassName, style: style$1, checked: checkedProp, value, defaultChecked: defaultCheckedProp, defaultValue, onChange, styles, classNames, ...restProps } = props;
	const [checked, setChecked] = useControlledState(defaultCheckedProp ?? defaultValue ?? false, checkedProp ?? value);
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("switch");
	const disabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = (customDisabled ?? disabled) || loading;
	const prefixCls = getPrefixCls("switch", customizePrefixCls);
	const loadingIcon = /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-handle` }, loading && /* @__PURE__ */ import_react.createElement(LoadingOutlined_default, { className: `${prefixCls}-loading-icon` }));
	const [hashId, cssVarCls] = style_default$9(prefixCls);
	const mergedSize = useSize_default(customizeSize);
	const mergedProps = {
		...props,
		size: mergedSize,
		disabled: mergedDisabled
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const classes = clsx(contextClassName, {
		[`${prefixCls}-small`]: mergedSize === "small",
		[`${prefixCls}-loading`]: loading,
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, className, rootClassName, mergedClassNames.root, hashId, cssVarCls);
	const mergedStyle = {
		...mergedStyles.root,
		...contextStyle,
		...style$1
	};
	const changeHandler = (...args) => {
		setChecked(args[0]);
		onChange?.(...args);
	};
	return /* @__PURE__ */ import_react.createElement(wave_default, {
		component: "Switch",
		disabled: mergedDisabled
	}, /* @__PURE__ */ import_react.createElement(es_default$9, {
		...restProps,
		classNames: mergedClassNames,
		styles: mergedStyles,
		checked,
		onChange: changeHandler,
		prefixCls,
		className: classes,
		style: mergedStyle,
		disabled: mergedDisabled,
		ref,
		loadingIcon
	}));
});
Switch.__ANT_SWITCH = true;
Switch.displayName = "Switch";
var switch_default = Switch;

//#endregion
//#region node_modules/@rc-component/table/es/constant.js
const EXPAND_COLUMN = {};
const INTERNAL_HOOKS = "rc-table-internal-hook";

//#endregion
//#region node_modules/@rc-component/context/es/context.js
var import_react_dom$1 = require_react_dom();
function createContext(defaultValue) {
	const Context$2 = /* @__PURE__ */ import_react.createContext(void 0);
	const Provider = ({ value, children }) => {
		const valueRef = import_react.useRef(value);
		valueRef.current = value;
		const [context] = import_react.useState(() => ({
			getValue: () => valueRef.current,
			listeners: /* @__PURE__ */ new Set()
		}));
		useLayoutEffect_default(() => {
			(0, import_react_dom$1.unstable_batchedUpdates)(() => {
				context.listeners.forEach((listener) => {
					listener(value);
				});
			});
		}, [value]);
		return /* @__PURE__ */ import_react.createElement(Context$2.Provider, { value: context }, children);
	};
	return {
		Context: Context$2,
		Provider,
		defaultValue
	};
}
/** e.g. useSelect(userContext) => user */
/** e.g. useSelect(userContext, user => user.name) => user.name */
/** e.g. useSelect(userContext, ['name', 'age']) => user { name, age } */
/** e.g. useSelect(userContext, 'name') => user.name */
function useContext$1(holder, selector) {
	const eventSelector = useEvent_default(typeof selector === "function" ? selector : (ctx) => {
		if (selector === void 0) return ctx;
		if (!Array.isArray(selector)) return ctx[selector];
		const obj = {};
		selector.forEach((key) => {
			obj[key] = ctx[key];
		});
		return obj;
	});
	const context = import_react.useContext(holder?.Context);
	const { listeners, getValue: getValue$1 } = context || {};
	const valueRef = import_react.useRef();
	valueRef.current = eventSelector(context ? getValue$1() : holder?.defaultValue);
	const [, forceUpdate] = import_react.useState({});
	useLayoutEffect_default(() => {
		if (!context) return;
		function trigger(nextValue) {
			const nextSelectorValue = eventSelector(nextValue);
			if (!isEqual_default(valueRef.current, nextSelectorValue, true)) forceUpdate({});
		}
		listeners.add(trigger);
		return () => {
			listeners.delete(trigger);
		};
	}, [context]);
	return valueRef.current;
}

//#endregion
//#region node_modules/@rc-component/context/es/Immutable.js
function _extends$20() {
	_extends$20 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$20.apply(this, arguments);
}
/**
* Create Immutable pair for `makeImmutable` and `responseImmutable`.
*/
function createImmutable() {
	const ImmutableContext = /* @__PURE__ */ import_react.createContext(null);
	/**
	* Get render update mark by `makeImmutable` root.
	* Do not deps on the return value as render times
	* but only use for `useMemo` or `useCallback` deps.
	*/
	function useImmutableMark$2() {
		return import_react.useContext(ImmutableContext);
	}
	/**
	* Wrapped Component will be marked as Immutable.
	* When Component parent trigger render,
	* it will notice children component (use with `responseImmutable`) node that parent has updated.
	* @param Component Passed Component
	* @param triggerRender Customize trigger `responseImmutable` children re-render logic. Default will always trigger re-render when this component re-render.
	*/
	function makeImmutable$2(Component$2, shouldTriggerRender) {
		const refAble = supportRef(Component$2);
		const ImmutableComponent = (props, ref) => {
			const refProps = refAble ? { ref } : {};
			const renderTimesRef = import_react.useRef(0);
			const prevProps = import_react.useRef(props);
			if (useImmutableMark$2() !== null) return /* @__PURE__ */ import_react.createElement(Component$2, _extends$20({}, props, refProps));
			if (!shouldTriggerRender || shouldTriggerRender(prevProps.current, props)) renderTimesRef.current += 1;
			prevProps.current = props;
			return /* @__PURE__ */ import_react.createElement(ImmutableContext.Provider, { value: renderTimesRef.current }, /* @__PURE__ */ import_react.createElement(Component$2, _extends$20({}, props, refProps)));
		};
		ImmutableComponent.displayName = `ImmutableRoot(${Component$2.displayName || Component$2.name})`;
		return refAble ? /* @__PURE__ */ import_react.forwardRef(ImmutableComponent) : ImmutableComponent;
	}
	/**
	* Wrapped Component with `React.memo`.
	* But will rerender when parent with `makeImmutable` rerender.
	*/
	function responseImmutable$2(Component$2, propsAreEqual) {
		const refAble = supportRef(Component$2);
		const ImmutableComponent = (props, ref) => {
			const refProps = refAble ? { ref } : {};
			useImmutableMark$2();
			return /* @__PURE__ */ import_react.createElement(Component$2, _extends$20({}, props, refProps));
		};
		ImmutableComponent.displayName = `ImmutableResponse(${Component$2.displayName || Component$2.name})`;
		return /* @__PURE__ */ import_react.memo(refAble ? /* @__PURE__ */ import_react.forwardRef(ImmutableComponent) : ImmutableComponent, propsAreEqual);
	}
	return {
		makeImmutable: makeImmutable$2,
		responseImmutable: responseImmutable$2,
		useImmutableMark: useImmutableMark$2
	};
}

//#endregion
//#region node_modules/@rc-component/context/es/index.js
var { makeImmutable: makeImmutable$1, responseImmutable: responseImmutable$1, useImmutableMark: useImmutableMark$1 } = createImmutable();

//#endregion
//#region node_modules/@rc-component/table/es/context/TableContext.js
var { makeImmutable, responseImmutable, useImmutableMark } = createImmutable();
var TableContext = createContext();
var TableContext_default = TableContext;

//#endregion
//#region node_modules/@rc-component/table/es/hooks/useRenderTimes.js
/* istanbul ignore file */
function useRenderTimes(props, debug) {
	const timesRef = import_react.useRef(0);
	timesRef.current += 1;
	const propsRef = import_react.useRef(props);
	const keys$1 = [];
	Object.keys(props || {}).map((key) => {
		if (props?.[key] !== propsRef.current?.[key]) keys$1.push(key);
	});
	propsRef.current = props;
	const keysRef = import_react.useRef([]);
	if (keys$1.length) keysRef.current = keys$1;
	import_react.useDebugValue(timesRef.current);
	import_react.useDebugValue(keysRef.current.join(", "));
	if (debug) console.log(`${debug}:`, timesRef.current, keysRef.current);
	return timesRef.current;
}
var useRenderTimes_default = useRenderTimes;
const RenderBlock = /* @__PURE__ */ import_react.memo(() => {
	const times = useRenderTimes();
	return /* @__PURE__ */ import_react.createElement("h1", null, "Render Times: ", times);
});
RenderBlock.displayName = "RenderBlock";

//#endregion
//#region node_modules/@rc-component/table/es/context/PerfContext.js
var PerfContext = /* @__PURE__ */ import_react.createContext({ renderWithProps: false });
var PerfContext_default = PerfContext;

//#endregion
//#region node_modules/@rc-component/table/es/utils/valueUtil.js
var INTERNAL_KEY_PREFIX = "RC_TABLE_KEY";
function toArray$2(arr) {
	if (arr === void 0 || arr === null) return [];
	return Array.isArray(arr) ? arr : [arr];
}
function getColumnsKey(columns) {
	const columnKeys = [];
	const keys$1 = {};
	columns.forEach((column$1) => {
		const { key, dataIndex } = column$1 || {};
		let mergedKey = key || toArray$2(dataIndex).join("-") || INTERNAL_KEY_PREFIX;
		while (keys$1[mergedKey]) mergedKey = `${mergedKey}_next`;
		keys$1[mergedKey] = true;
		columnKeys.push(mergedKey);
	});
	return columnKeys;
}
function validateValue(val) {
	return val !== null && val !== void 0;
}
function validNumberValue(value) {
	return typeof value === "number" && !Number.isNaN(value);
}

//#endregion
//#region node_modules/@rc-component/table/es/Cell/useCellRender.js
function isRenderCell(data) {
	return data && typeof data === "object" && !Array.isArray(data) && !/* @__PURE__ */ import_react.isValidElement(data);
}
function useCellRender(record, dataIndex, renderIndex, children, render$1, shouldCellUpdate) {
	const perfRecord = import_react.useContext(PerfContext_default);
	return useMemo$1(() => {
		if (validateValue(children)) return [children];
		const value = get(record, dataIndex === null || dataIndex === void 0 || dataIndex === "" ? [] : Array.isArray(dataIndex) ? dataIndex : [dataIndex]);
		let returnChildNode = value;
		let returnCellProps = void 0;
		if (render$1) {
			const renderData = render$1(value, record, renderIndex);
			if (isRenderCell(renderData)) {
				warning_default$1(false, "`columns.render` return cell props is deprecated with perf issue, please use `onCell` instead.");
				returnChildNode = renderData.children;
				returnCellProps = renderData.props;
				perfRecord.renderWithProps = true;
			} else returnChildNode = renderData;
		}
		return [returnChildNode, returnCellProps];
	}, [
		useImmutableMark(),
		record,
		children,
		dataIndex,
		render$1,
		renderIndex
	], (prev$1, next$1) => {
		if (shouldCellUpdate) {
			const [, prevRecord] = prev$1;
			const [, nextRecord] = next$1;
			return shouldCellUpdate(nextRecord, prevRecord);
		}
		if (perfRecord.renderWithProps) return true;
		return !isEqual_default(prev$1, next$1, true);
	});
}

//#endregion
//#region node_modules/@rc-component/table/es/Cell/useHoverState.js
/** Check if cell is in hover range */
function inHoverRange(cellStartRow, cellRowSpan, startRow, endRow) {
	const cellEndRow = cellStartRow + cellRowSpan - 1;
	return cellStartRow <= endRow && cellEndRow >= startRow;
}
function useHoverState(rowIndex, rowSpan) {
	return useContext$1(TableContext_default, (ctx) => {
		return [inHoverRange(rowIndex, rowSpan || 1, ctx.hoverStartRow, ctx.hoverEndRow), ctx.onHover];
	});
}

//#endregion
//#region node_modules/@rc-component/table/es/Cell/index.js
function _extends$19() {
	_extends$19 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$19.apply(this, arguments);
}
var getTitleFromCellRenderChildren = ({ ellipsis, rowType, children }) => {
	let title;
	const ellipsisConfig = ellipsis === true ? { showTitle: true } : ellipsis;
	if (ellipsisConfig && (ellipsisConfig.showTitle || rowType === "header")) {
		if (typeof children === "string" || typeof children === "number") title = children.toString();
		else if (/* @__PURE__ */ import_react.isValidElement(children) && typeof children.props?.children === "string") title = children.props?.children;
	}
	return title;
};
var Cell = (props) => {
	useRenderTimes_default(props);
	const { component: Component$2, children, ellipsis, scope, prefixCls, className, style: style$1, align, record, render: render$1, dataIndex, renderIndex, shouldCellUpdate, index: index$1, rowType, colSpan, rowSpan, fixStart, fixEnd, fixedStartShadow, fixedEndShadow, offsetFixedStartShadow, offsetFixedEndShadow, zIndex, zIndexReverse, appendNode, additionalProps = {}, isSticky } = props;
	const cellPrefixCls = `${prefixCls}-cell`;
	const { allColumnsFixedLeft, rowHoverable } = useContext$1(TableContext_default, ["allColumnsFixedLeft", "rowHoverable"]);
	const [childNode, legacyCellProps] = useCellRender(record, dataIndex, renderIndex, children, render$1, shouldCellUpdate);
	const fixedStyle$1 = {};
	const isFixStart = typeof fixStart === "number" && !allColumnsFixedLeft;
	const isFixEnd = typeof fixEnd === "number" && !allColumnsFixedLeft;
	const [showFixStartShadow, showFixEndShadow] = useContext$1(TableContext_default, ({ scrollInfo }) => {
		if (!isFixStart && !isFixEnd) return [false, false];
		const [absScroll, scrollWidth] = scrollInfo;
		return [(isFixStart && fixedStartShadow && absScroll) - offsetFixedStartShadow >= 1, (isFixEnd && fixedEndShadow && scrollWidth - absScroll) - offsetFixedEndShadow > 1];
	});
	if (isFixStart) {
		fixedStyle$1.insetInlineStart = fixStart;
		fixedStyle$1["--z-offset"] = zIndex;
		fixedStyle$1["--z-offset-reverse"] = zIndexReverse;
	}
	if (isFixEnd) {
		fixedStyle$1.insetInlineEnd = fixEnd;
		fixedStyle$1["--z-offset"] = zIndex;
		fixedStyle$1["--z-offset-reverse"] = zIndexReverse;
	}
	const mergedColSpan = legacyCellProps?.colSpan ?? additionalProps.colSpan ?? colSpan ?? 1;
	const mergedRowSpan = legacyCellProps?.rowSpan ?? additionalProps.rowSpan ?? rowSpan ?? 1;
	const [hovering, onHover] = useHoverState(index$1, mergedRowSpan);
	const onMouseEnter = useEvent_default((event) => {
		if (record) onHover(index$1, index$1 + mergedRowSpan - 1);
		additionalProps?.onMouseEnter?.(event);
	});
	const onMouseLeave = useEvent_default((event) => {
		if (record) onHover(-1, -1);
		additionalProps?.onMouseLeave?.(event);
	});
	if (mergedColSpan === 0 || mergedRowSpan === 0) return null;
	const title = additionalProps.title ?? getTitleFromCellRenderChildren({
		rowType,
		ellipsis,
		children: childNode
	});
	const mergedClassName = clsx(cellPrefixCls, className, {
		[`${cellPrefixCls}-fix`]: isFixStart || isFixEnd,
		[`${cellPrefixCls}-fix-start`]: isFixStart,
		[`${cellPrefixCls}-fix-end`]: isFixEnd,
		[`${cellPrefixCls}-fix-start-shadow`]: fixedStartShadow,
		[`${cellPrefixCls}-fix-start-shadow-show`]: fixedStartShadow && showFixStartShadow,
		[`${cellPrefixCls}-fix-end-shadow`]: fixedEndShadow,
		[`${cellPrefixCls}-fix-end-shadow-show`]: fixedEndShadow && showFixEndShadow,
		[`${cellPrefixCls}-ellipsis`]: ellipsis,
		[`${cellPrefixCls}-with-append`]: appendNode,
		[`${cellPrefixCls}-fix-sticky`]: (isFixStart || isFixEnd) && isSticky,
		[`${cellPrefixCls}-row-hover`]: !legacyCellProps && hovering
	}, additionalProps.className, legacyCellProps?.className);
	const alignStyle = {};
	if (align) alignStyle.textAlign = align;
	const mergedStyle = {
		...legacyCellProps?.style,
		...fixedStyle$1,
		...alignStyle,
		...additionalProps.style,
		...style$1
	};
	let mergedChildNode = childNode;
	if (typeof mergedChildNode === "object" && !Array.isArray(mergedChildNode) && !/* @__PURE__ */ import_react.isValidElement(mergedChildNode)) mergedChildNode = null;
	if (ellipsis && (fixedStartShadow || fixedEndShadow)) mergedChildNode = /* @__PURE__ */ import_react.createElement("span", { className: `${cellPrefixCls}-content` }, mergedChildNode);
	return /* @__PURE__ */ import_react.createElement(Component$2, _extends$19({}, legacyCellProps, additionalProps, {
		className: mergedClassName,
		style: mergedStyle,
		title,
		scope,
		onMouseEnter: rowHoverable ? onMouseEnter : void 0,
		onMouseLeave: rowHoverable ? onMouseLeave : void 0,
		colSpan: mergedColSpan !== 1 ? mergedColSpan : null,
		rowSpan: mergedRowSpan !== 1 ? mergedRowSpan : null
	}), appendNode, mergedChildNode);
};
var Cell_default = /* @__PURE__ */ import_react.memo(Cell);

//#endregion
//#region node_modules/@rc-component/table/es/utils/fixUtil.js
function isFixedStart(column$1) {
	return column$1.fixed === "start";
}
function isFixedEnd(column$1) {
	return column$1.fixed === "end";
}
function getCellFixedInfo(colStart, colEnd, columns, stickyOffsets) {
	const startColumn = columns[colStart] || {};
	const endColumn = columns[colEnd] || {};
	let fixStart = null;
	let fixEnd = null;
	if (isFixedStart(startColumn) && isFixedStart(endColumn)) fixStart = stickyOffsets.start[colStart];
	else if (isFixedEnd(endColumn) && isFixedEnd(startColumn)) fixEnd = stickyOffsets.end[colEnd];
	let fixedStartShadow = false;
	let fixedEndShadow = false;
	let zIndex = 0;
	let zIndexReverse = 0;
	if (fixStart !== null) {
		fixedStartShadow = !columns[colEnd + 1] || !isFixedStart(columns[colEnd + 1]);
		zIndex = columns.length * 2 - colStart;
		zIndexReverse = columns.length + colStart;
	}
	if (fixEnd !== null) {
		fixedEndShadow = !columns[colStart - 1] || !isFixedEnd(columns[colStart - 1]);
		zIndex = colEnd;
		zIndexReverse = columns.length - colEnd;
	}
	let offsetFixedStartShadow = 0;
	let offsetFixedEndShadow = 0;
	if (fixedStartShadow) {
		for (let i = 0; i < colStart; i += 1) if (!isFixedStart(columns[i])) offsetFixedStartShadow += stickyOffsets.widths[i] || 0;
	}
	if (fixedEndShadow) {
		for (let i = columns.length - 1; i > colEnd; i -= 1) if (!isFixedEnd(columns[i])) offsetFixedEndShadow += stickyOffsets.widths[i] || 0;
	}
	return {
		fixStart,
		fixEnd,
		fixedStartShadow,
		fixedEndShadow,
		offsetFixedStartShadow,
		offsetFixedEndShadow,
		isSticky: stickyOffsets.isSticky,
		zIndex,
		zIndexReverse
	};
}

//#endregion
//#region node_modules/@rc-component/table/es/Footer/SummaryContext.js
var SummaryContext = /* @__PURE__ */ import_react.createContext({});
var SummaryContext_default = SummaryContext;

//#endregion
//#region node_modules/@rc-component/table/es/Footer/Cell.js
function _extends$18() {
	_extends$18 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$18.apply(this, arguments);
}
var SummaryCell = (props) => {
	const { className, index: index$1, children, colSpan = 1, rowSpan, align } = props;
	const { prefixCls } = useContext$1(TableContext_default, ["prefixCls"]);
	const { scrollColumnIndex, stickyOffsets, flattenColumns } = import_react.useContext(SummaryContext_default);
	const mergedColSpan = index$1 + colSpan - 1 + 1 === scrollColumnIndex ? colSpan + 1 : colSpan;
	const fixedInfo = import_react.useMemo(() => getCellFixedInfo(index$1, index$1 + mergedColSpan - 1, flattenColumns, stickyOffsets), [
		index$1,
		mergedColSpan,
		flattenColumns,
		stickyOffsets
	]);
	return /* @__PURE__ */ import_react.createElement(Cell_default, _extends$18({
		className,
		index: index$1,
		component: "td",
		prefixCls,
		record: null,
		dataIndex: null,
		align,
		colSpan: mergedColSpan,
		rowSpan,
		render: () => children
	}, fixedInfo));
};
var Cell_default$1 = SummaryCell;

//#endregion
//#region node_modules/@rc-component/table/es/Footer/Row.js
var FooterRow = (props) => {
	const { children, ...restProps } = props;
	return /* @__PURE__ */ import_react.createElement("tr", restProps, children);
};
var Row_default = FooterRow;

//#endregion
//#region node_modules/@rc-component/table/es/Footer/Summary.js
/**
* Syntactic sugar. Do not support HOC.
*/
var Summary = (props) => {
	const { children } = props;
	return children;
};
Summary.Row = Row_default;
Summary.Cell = Cell_default$1;
var Summary_default = Summary;

//#endregion
//#region node_modules/@rc-component/table/es/Footer/index.js
var Footer = (props) => {
	useRenderTimes_default(props);
	const { children, stickyOffsets, flattenColumns } = props;
	const prefixCls = useContext$1(TableContext_default, "prefixCls");
	const lastColumnIndex = flattenColumns.length - 1;
	const scrollColumn = flattenColumns[lastColumnIndex];
	const summaryContext = import_react.useMemo(() => ({
		stickyOffsets,
		flattenColumns,
		scrollColumnIndex: scrollColumn?.scrollbar ? lastColumnIndex : null
	}), [
		scrollColumn,
		flattenColumns,
		lastColumnIndex,
		stickyOffsets
	]);
	return /* @__PURE__ */ import_react.createElement(SummaryContext_default.Provider, { value: summaryContext }, /* @__PURE__ */ import_react.createElement("tfoot", { className: `${prefixCls}-summary` }, children));
};
var Footer_default = responseImmutable(Footer);
const FooterComponents = Summary_default;

//#endregion
//#region node_modules/@rc-component/table/es/sugar/Column.js
/* istanbul ignore next */
/**
* This is a syntactic sugar for `columns` prop.
* So HOC will not work on this.
*/
function Column$1(_) {
	return null;
}
var Column_default$1 = Column$1;

//#endregion
//#region node_modules/@rc-component/table/es/sugar/ColumnGroup.js
/* istanbul ignore next */
/**
* This is a syntactic sugar for `columns` prop.
* So HOC will not work on this.
*/
function ColumnGroup$1(_) {
	return null;
}
var ColumnGroup_default$1 = ColumnGroup$1;

//#endregion
//#region node_modules/@rc-component/table/es/hooks/useFlattenRecords.js
function fillRecords(list, record, indent, childrenColumnName, expandedKeys, getRowKey, index$1) {
	const key = getRowKey(record, index$1);
	list.push({
		record,
		indent,
		index: index$1,
		rowKey: key
	});
	const expanded = expandedKeys?.has(key);
	if (record && Array.isArray(record[childrenColumnName]) && expanded) for (let i = 0; i < record[childrenColumnName].length; i += 1) fillRecords(list, record[childrenColumnName][i], indent + 1, childrenColumnName, expandedKeys, getRowKey, i);
}
/**
* flat tree data on expanded state
*
* @export
* @template T
* @param {*} data : table data
* @param {string} childrenColumnName : 
* @param {Set<Key>} expandedKeys : keys
* @param {GetRowKey<T>} getRowKey  : rowKey
* @returns flattened data
*/
function useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey) {
	return import_react.useMemo(() => {
		if (expandedKeys?.size) {
			const list = [];
			for (let i = 0; i < data?.length; i += 1) {
				const record = data[i];
				fillRecords(list, record, 0, childrenColumnName, expandedKeys, getRowKey, i);
			}
			return list;
		}
		return data?.map((item, index$1) => {
			return {
				record: item,
				indent: 0,
				index: index$1,
				rowKey: getRowKey(item, index$1)
			};
		});
	}, [
		data,
		childrenColumnName,
		expandedKeys,
		getRowKey
	]);
}

//#endregion
//#region node_modules/@rc-component/table/es/hooks/useRowInfo.js
function useRowInfo(record, rowKey, recordIndex, indent) {
	const context = useContext$1(TableContext_default, [
		"prefixCls",
		"fixedInfoList",
		"flattenColumns",
		"expandableType",
		"expandRowByClick",
		"onTriggerExpand",
		"rowClassName",
		"expandedRowClassName",
		"indentSize",
		"expandIcon",
		"expandedRowRender",
		"expandIconColumnIndex",
		"expandedKeys",
		"childrenColumnName",
		"rowExpandable",
		"onRow"
	]);
	const { flattenColumns, expandableType, expandedKeys, childrenColumnName, onTriggerExpand, rowExpandable, onRow, expandRowByClick, rowClassName } = context;
	const nestExpandable = expandableType === "nest";
	const rowSupportExpand = expandableType === "row" && (!rowExpandable || rowExpandable(record));
	const mergedExpandable = rowSupportExpand || nestExpandable;
	const expanded = expandedKeys && expandedKeys.has(rowKey);
	const hasNestChildren = childrenColumnName && record && record[childrenColumnName];
	const onInternalTriggerExpand = useEvent_default(onTriggerExpand);
	const rowProps = onRow?.(record, recordIndex);
	const onRowClick = rowProps?.onClick;
	const onClick = (event, ...args) => {
		if (expandRowByClick && mergedExpandable) onTriggerExpand(record, event);
		onRowClick?.(event, ...args);
	};
	let computeRowClassName;
	if (typeof rowClassName === "string") computeRowClassName = rowClassName;
	else if (typeof rowClassName === "function") computeRowClassName = rowClassName(record, recordIndex, indent);
	const columnsKey = getColumnsKey(flattenColumns);
	return {
		...context,
		columnsKey,
		nestExpandable,
		expanded,
		hasNestChildren,
		record,
		onTriggerExpand: onInternalTriggerExpand,
		rowSupportExpand,
		expandable: mergedExpandable,
		rowProps: {
			...rowProps,
			className: clsx(computeRowClassName, rowProps?.className),
			onClick
		}
	};
}

//#endregion
//#region node_modules/@rc-component/table/es/Body/ExpandedRow.js
var ExpandedRow = (props) => {
	useRenderTimes_default(props);
	const { prefixCls, children, component: Component$2, cellComponent, className, expanded, colSpan, isEmpty: isEmpty$1, stickyOffset = 0 } = props;
	const { scrollbarSize, fixHeader, fixColumn, componentWidth, horizonScroll } = useContext$1(TableContext_default, [
		"scrollbarSize",
		"fixHeader",
		"fixColumn",
		"componentWidth",
		"horizonScroll"
	]);
	let contentNode = children;
	if (isEmpty$1 ? horizonScroll && componentWidth : fixColumn) contentNode = /* @__PURE__ */ import_react.createElement("div", {
		style: {
			width: componentWidth - stickyOffset - (fixHeader && !isEmpty$1 ? scrollbarSize : 0),
			position: "sticky",
			left: stickyOffset,
			overflow: "hidden"
		},
		className: `${prefixCls}-expanded-row-fixed`
	}, contentNode);
	return /* @__PURE__ */ import_react.createElement(Component$2, {
		className,
		style: { display: expanded ? null : "none" }
	}, /* @__PURE__ */ import_react.createElement(Cell_default, {
		component: cellComponent,
		prefixCls,
		colSpan
	}, contentNode));
};
var ExpandedRow_default = ExpandedRow;

//#endregion
//#region node_modules/@rc-component/table/es/utils/expandUtil.js
function renderExpandIcon$1({ prefixCls, record, onExpand, expanded, expandable }) {
	const expandClassName = `${prefixCls}-row-expand-icon`;
	if (!expandable) return /* @__PURE__ */ import_react.createElement("span", { className: clsx(expandClassName, `${prefixCls}-row-spaced`) });
	const onClick = (event) => {
		onExpand(record, event);
		event.stopPropagation();
	};
	return /* @__PURE__ */ import_react.createElement("span", {
		className: clsx(expandClassName, {
			[`${prefixCls}-row-expanded`]: expanded,
			[`${prefixCls}-row-collapsed`]: !expanded
		}),
		onClick
	});
}
function findAllChildrenKeys(data, getRowKey, childrenColumnName) {
	const keys$1 = [];
	function dig(list) {
		(list || []).forEach((item, index$1) => {
			keys$1.push(getRowKey(item, index$1));
			dig(item[childrenColumnName]);
		});
	}
	dig(data);
	return keys$1;
}
function computedExpandedClassName(cls, record, index$1, indent) {
	if (typeof cls === "string") return cls;
	if (typeof cls === "function") return cls(record, index$1, indent);
	return "";
}

//#endregion
//#region node_modules/@rc-component/table/es/Body/BodyRow.js
function _extends$17() {
	_extends$17 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$17.apply(this, arguments);
}
function getCellProps(rowInfo, column$1, colIndex, indent, index$1, rowKeys = [], expandedRowOffset = 0) {
	const { record, prefixCls, columnsKey, fixedInfoList, expandIconColumnIndex, nestExpandable, indentSize, expandIcon, expanded, hasNestChildren, onTriggerExpand, expandable, expandedKeys } = rowInfo;
	const key = columnsKey[colIndex];
	const fixedInfo = fixedInfoList[colIndex];
	let appendCellNode;
	if (colIndex === (expandIconColumnIndex || 0) && nestExpandable) appendCellNode = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("span", {
		style: { paddingLeft: `${indentSize * indent}px` },
		className: `${prefixCls}-row-indent indent-level-${indent}`
	}), expandIcon({
		prefixCls,
		expanded,
		expandable: hasNestChildren,
		record,
		onExpand: onTriggerExpand
	}));
	const additionalCellProps = column$1.onCell?.(record, index$1) || {};
	if (expandedRowOffset) {
		const { rowSpan = 1 } = additionalCellProps;
		if (expandable && rowSpan && colIndex < expandedRowOffset) {
			let currentRowSpan = rowSpan;
			for (let i = index$1; i < index$1 + rowSpan; i += 1) {
				const rowKey = rowKeys[i];
				if (expandedKeys.has(rowKey)) currentRowSpan += 1;
			}
			additionalCellProps.rowSpan = currentRowSpan;
		}
	}
	return {
		key,
		fixedInfo,
		appendCellNode,
		additionalCellProps
	};
}
var BodyRow = (props) => {
	useRenderTimes_default(props);
	const { className, style: style$1, classNames, styles, record, index: index$1, renderIndex, rowKey, rowKeys, indent = 0, rowComponent: RowComponent, cellComponent, scopeCellComponent, expandedRowInfo } = props;
	const rowInfo = useRowInfo(record, rowKey, index$1, indent);
	const { prefixCls, flattenColumns, expandedRowClassName, expandedRowRender, rowProps, expanded, rowSupportExpand } = rowInfo;
	const expandedRef = import_react.useRef(false);
	expandedRef.current ||= expanded;
	useRenderTimes_default(props);
	const expandedClsName = computedExpandedClassName(expandedRowClassName, record, index$1, indent);
	const baseRowNode = /* @__PURE__ */ import_react.createElement(RowComponent, _extends$17({}, rowProps, {
		"data-row-key": rowKey,
		className: clsx(className, `${prefixCls}-row`, `${prefixCls}-row-level-${indent}`, rowProps?.className, classNames.row, { [expandedClsName]: indent >= 1 }),
		style: {
			...style$1,
			...rowProps?.style,
			...styles.row
		}
	}), flattenColumns.map((column$1, colIndex) => {
		const { render: render$1, dataIndex, className: columnClassName } = column$1;
		const { key, fixedInfo, appendCellNode, additionalCellProps } = getCellProps(rowInfo, column$1, colIndex, indent, index$1, rowKeys, expandedRowInfo?.offset);
		return /* @__PURE__ */ import_react.createElement(Cell_default, _extends$17({
			className: clsx(columnClassName, classNames.cell),
			style: styles.cell,
			ellipsis: column$1.ellipsis,
			align: column$1.align,
			scope: column$1.rowScope,
			component: column$1.rowScope ? scopeCellComponent : cellComponent,
			prefixCls,
			key,
			record,
			index: index$1,
			renderIndex,
			dataIndex,
			render: render$1,
			shouldCellUpdate: column$1.shouldCellUpdate
		}, fixedInfo, {
			appendNode: appendCellNode,
			additionalProps: additionalCellProps
		}));
	}));
	let expandRowNode;
	if (rowSupportExpand && (expandedRef.current || expanded)) {
		const expandContent = expandedRowRender(record, index$1, indent + 1, expanded);
		expandRowNode = /* @__PURE__ */ import_react.createElement(ExpandedRow_default, {
			expanded,
			className: clsx(`${prefixCls}-expanded-row`, `${prefixCls}-expanded-row-level-${indent + 1}`, expandedClsName),
			prefixCls,
			component: RowComponent,
			cellComponent,
			colSpan: expandedRowInfo ? expandedRowInfo.colSpan : flattenColumns.length,
			isEmpty: false,
			stickyOffset: expandedRowInfo?.sticky
		}, expandContent);
	}
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, baseRowNode, expandRowNode);
};
BodyRow.displayName = "BodyRow";
var BodyRow_default = responseImmutable(BodyRow);

//#endregion
//#region node_modules/@rc-component/table/es/Body/MeasureCell.js
var MeasureCell = (props) => {
	const { columnKey, onColumnResize, title } = props;
	const cellRef = import_react.useRef(null);
	useLayoutEffect_default(() => {
		if (cellRef.current) onColumnResize(columnKey, cellRef.current.offsetWidth);
	}, []);
	return /* @__PURE__ */ import_react.createElement(es_default$2, { data: columnKey }, /* @__PURE__ */ import_react.createElement("td", {
		ref: cellRef,
		style: {
			paddingTop: 0,
			paddingBottom: 0,
			borderTop: 0,
			borderBottom: 0,
			height: 0
		}
	}, /* @__PURE__ */ import_react.createElement("div", { style: {
		height: 0,
		overflow: "hidden",
		fontWeight: "bold"
	} }, title || "\xA0")));
};
var MeasureCell_default = MeasureCell;

//#endregion
//#region node_modules/@rc-component/table/es/Body/MeasureRow.js
var MeasureRow = ({ prefixCls, columnsKey, onColumnResize, columns }) => {
	const ref = import_react.useRef(null);
	const { measureRowRender } = useContext$1(TableContext_default, ["measureRowRender"]);
	const measureRow = /* @__PURE__ */ import_react.createElement("tr", {
		"aria-hidden": "true",
		className: `${prefixCls}-measure-row`,
		style: { height: 0 },
		ref
	}, /* @__PURE__ */ import_react.createElement(es_default$2.Collection, { onBatchResize: (infoList) => {
		if (isVisible_default(ref.current)) infoList.forEach(({ data: columnKey, size }) => {
			onColumnResize(columnKey, size.offsetWidth);
		});
	} }, columnsKey.map((columnKey) => {
		const rawTitle = columns.find((col) => col.key === columnKey)?.title;
		const titleForMeasure = /* @__PURE__ */ import_react.isValidElement(rawTitle) ? /* @__PURE__ */ import_react.cloneElement(rawTitle, { ref: null }) : rawTitle;
		return /* @__PURE__ */ import_react.createElement(MeasureCell_default, {
			key: columnKey,
			columnKey,
			onColumnResize,
			title: titleForMeasure
		});
	})));
	return typeof measureRowRender === "function" ? measureRowRender(measureRow) : measureRow;
};
var MeasureRow_default = MeasureRow;

//#endregion
//#region node_modules/@rc-component/table/es/Body/index.js
var Body = (props) => {
	useRenderTimes_default(props);
	const { data, measureColumnWidth } = props;
	const { prefixCls, getComponent, onColumnResize, flattenColumns, getRowKey, expandedKeys, childrenColumnName, emptyNode, classNames, styles, expandedRowOffset = 0, colWidths } = useContext$1(TableContext_default, [
		"prefixCls",
		"getComponent",
		"onColumnResize",
		"flattenColumns",
		"getRowKey",
		"expandedKeys",
		"childrenColumnName",
		"emptyNode",
		"classNames",
		"styles",
		"expandedRowOffset",
		"fixedInfoList",
		"colWidths"
	]);
	const { body: bodyCls = {} } = classNames || {};
	const { body: bodyStyles = {} } = styles || {};
	const flattenData$1 = useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey);
	const rowKeys = import_react.useMemo(() => flattenData$1.map((item) => item.rowKey), [flattenData$1]);
	const perfRef = import_react.useRef({ renderWithProps: false });
	const expandedRowInfo = import_react.useMemo(() => {
		const expandedColSpan = flattenColumns.length - expandedRowOffset;
		let expandedStickyStart = 0;
		for (let i = 0; i < expandedRowOffset; i += 1) expandedStickyStart += colWidths[i] || 0;
		return {
			offset: expandedRowOffset,
			colSpan: expandedColSpan,
			sticky: expandedStickyStart
		};
	}, [
		flattenColumns.length,
		expandedRowOffset,
		colWidths
	]);
	const WrapperComponent = getComponent(["body", "wrapper"], "tbody");
	const trComponent = getComponent(["body", "row"], "tr");
	const tdComponent = getComponent(["body", "cell"], "td");
	const thComponent = getComponent(["body", "cell"], "th");
	let rows;
	if (data.length) rows = flattenData$1.map((item, idx) => {
		const { record, indent, index: renderIndex, rowKey } = item;
		return /* @__PURE__ */ import_react.createElement(BodyRow_default, {
			classNames: bodyCls,
			styles: bodyStyles,
			key: rowKey,
			rowKey,
			rowKeys,
			record,
			index: idx,
			renderIndex,
			rowComponent: trComponent,
			cellComponent: tdComponent,
			scopeCellComponent: thComponent,
			indent,
			expandedRowInfo
		});
	});
	else rows = /* @__PURE__ */ import_react.createElement(ExpandedRow_default, {
		expanded: true,
		className: `${prefixCls}-placeholder`,
		prefixCls,
		component: trComponent,
		cellComponent: tdComponent,
		colSpan: flattenColumns.length,
		isEmpty: true
	}, emptyNode);
	const columnsKey = getColumnsKey(flattenColumns);
	return /* @__PURE__ */ import_react.createElement(PerfContext_default.Provider, { value: perfRef.current }, /* @__PURE__ */ import_react.createElement(WrapperComponent, {
		style: bodyStyles.wrapper,
		className: clsx(`${prefixCls}-tbody`, bodyCls.wrapper)
	}, measureColumnWidth && /* @__PURE__ */ import_react.createElement(MeasureRow_default, {
		prefixCls,
		columnsKey,
		onColumnResize,
		columns: flattenColumns
	}), rows));
};
Body.displayName = "Body";
var Body_default = responseImmutable(Body);

//#endregion
//#region node_modules/@rc-component/table/es/utils/legacyUtil.js
const INTERNAL_COL_DEFINE = "RC_TABLE_INTERNAL_COL_DEFINE";
function getExpandableProps(props) {
	const { expandable, ...legacyExpandableConfig } = props;
	let config;
	if ("expandable" in props) config = {
		...legacyExpandableConfig,
		...expandable
	};
	else {
		if ([
			"indentSize",
			"expandedRowKeys",
			"defaultExpandedRowKeys",
			"defaultExpandAllRows",
			"expandedRowRender",
			"expandRowByClick",
			"expandIcon",
			"onExpand",
			"onExpandedRowsChange",
			"expandedRowClassName",
			"expandIconColumnIndex",
			"showExpandColumn",
			"title"
		].some((prop) => prop in props)) warning_default$1(false, "expanded related props have been moved into `expandable`.");
		config = legacyExpandableConfig;
	}
	if (config.showExpandColumn === false) config.expandIconColumnIndex = -1;
	return config;
}

//#endregion
//#region node_modules/@rc-component/table/es/ColGroup.js
function _extends$16() {
	_extends$16 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$16.apply(this, arguments);
}
var ColGroup = (props) => {
	const { colWidths, columns, columCount } = props;
	const { tableLayout } = useContext$1(TableContext_default, ["tableLayout"]);
	const cols = [];
	const len = columCount || columns.length;
	let mustInsert = false;
	for (let i = len - 1; i >= 0; i -= 1) {
		const width = colWidths[i];
		const column$1 = columns && columns[i];
		let additionalProps;
		let minWidth;
		if (column$1) {
			additionalProps = column$1[INTERNAL_COL_DEFINE];
			if (tableLayout === "auto") minWidth = column$1.minWidth;
		}
		if (width || minWidth || additionalProps || mustInsert) {
			const { columnType, ...restAdditionalProps } = additionalProps || {};
			cols.unshift(/* @__PURE__ */ import_react.createElement("col", _extends$16({
				key: i,
				style: {
					width,
					minWidth
				}
			}, restAdditionalProps)));
			mustInsert = true;
		}
	}
	return cols.length > 0 ? /* @__PURE__ */ import_react.createElement("colgroup", null, cols) : null;
};
var ColGroup_default = ColGroup;

//#endregion
//#region node_modules/@rc-component/table/es/FixedHolder/index.js
function useColumnWidth(colWidths, columCount) {
	return (0, import_react.useMemo)(() => {
		const cloneColumns = [];
		for (let i = 0; i < columCount; i += 1) {
			const val = colWidths[i];
			if (val !== void 0) cloneColumns[i] = val;
			else return null;
		}
		return cloneColumns;
	}, [colWidths.join("_"), columCount]);
}
var FixedHolder = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	useRenderTimes_default(props);
	const { className, style: style$1, noData, columns, flattenColumns, colWidths, colGroup, columCount, stickyOffsets, direction, fixHeader, stickyTopOffset, stickyBottomOffset, stickyClassName, scrollX, tableLayout = "fixed", onScroll, maxContentScroll, children, ...restProps } = props;
	const { prefixCls, scrollbarSize, isSticky, getComponent } = useContext$1(TableContext_default, [
		"prefixCls",
		"scrollbarSize",
		"isSticky",
		"getComponent"
	]);
	const TableComponent = getComponent(["header", "table"], "table");
	const combinationScrollBarSize = isSticky && !fixHeader ? 0 : scrollbarSize;
	const scrollRef = import_react.useRef(null);
	const setScrollRef = import_react.useCallback((element) => {
		fillRef(ref, element);
		fillRef(scrollRef, element);
	}, []);
	import_react.useEffect(() => {
		function onWheel(e$2) {
			const { currentTarget, deltaX } = e$2;
			if (deltaX) {
				const { scrollLeft, scrollWidth, clientWidth } = currentTarget;
				const maxScrollWidth = scrollWidth - clientWidth;
				let nextScroll = scrollLeft + deltaX;
				if (direction === "rtl") {
					nextScroll = Math.max(-maxScrollWidth, nextScroll);
					nextScroll = Math.min(0, nextScroll);
				} else {
					nextScroll = Math.min(maxScrollWidth, nextScroll);
					nextScroll = Math.max(0, nextScroll);
				}
				onScroll({
					currentTarget,
					scrollLeft: nextScroll
				});
				e$2.preventDefault();
			}
		}
		const scrollEle = scrollRef.current;
		scrollEle?.addEventListener("wheel", onWheel, { passive: false });
		return () => {
			scrollEle?.removeEventListener("wheel", onWheel);
		};
	}, []);
	const lastColumn = flattenColumns[flattenColumns.length - 1];
	const ScrollBarColumn = {
		fixed: lastColumn ? lastColumn.fixed : null,
		scrollbar: true,
		onHeaderCell: () => ({ className: `${prefixCls}-cell-scrollbar` })
	};
	const columnsWithScrollbar = (0, import_react.useMemo)(() => combinationScrollBarSize ? [...columns, ScrollBarColumn] : columns, [combinationScrollBarSize, columns]);
	const flattenColumnsWithScrollbar = (0, import_react.useMemo)(() => combinationScrollBarSize ? [...flattenColumns, ScrollBarColumn] : flattenColumns, [combinationScrollBarSize, flattenColumns]);
	const headerStickyOffsets = (0, import_react.useMemo)(() => {
		const { start, end } = stickyOffsets;
		return {
			...stickyOffsets,
			start,
			end: [...end.map((width) => width + combinationScrollBarSize), 0],
			isSticky
		};
	}, [
		combinationScrollBarSize,
		stickyOffsets,
		isSticky
	]);
	const mergedColumnWidth = useColumnWidth(colWidths, columCount);
	const isColGroupEmpty = (0, import_react.useMemo)(() => {
		const noWidth = !mergedColumnWidth || !mergedColumnWidth.length || mergedColumnWidth.every((w) => !w);
		return noData || noWidth;
	}, [noData, mergedColumnWidth]);
	return /* @__PURE__ */ import_react.createElement("div", {
		style: {
			overflow: "hidden",
			...isSticky ? {
				top: stickyTopOffset,
				bottom: stickyBottomOffset
			} : {},
			...style$1
		},
		ref: setScrollRef,
		className: clsx(className, { [stickyClassName]: !!stickyClassName })
	}, /* @__PURE__ */ import_react.createElement(TableComponent, { style: {
		tableLayout,
		minWidth: "100%",
		width: scrollX
	} }, isColGroupEmpty ? colGroup : /* @__PURE__ */ import_react.createElement(ColGroup_default, {
		colWidths: [...mergedColumnWidth, combinationScrollBarSize],
		columCount: columCount + 1,
		columns: flattenColumnsWithScrollbar
	}), children({
		...restProps,
		stickyOffsets: headerStickyOffsets,
		columns: columnsWithScrollbar,
		flattenColumns: flattenColumnsWithScrollbar
	})));
});
FixedHolder.displayName = "FixedHolder";
/** Return a table in div as fixed element which contains sticky info */
var FixedHolder_default = /* @__PURE__ */ import_react.memo(FixedHolder);

//#endregion
//#region node_modules/@rc-component/table/es/Header/HeaderRow.js
function _extends$15() {
	_extends$15 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$15.apply(this, arguments);
}
var HeaderRow = (props) => {
	const { cells, stickyOffsets, flattenColumns, rowComponent: RowComponent, cellComponent: CellComponent, onHeaderRow, index: index$1, classNames, styles } = props;
	const { prefixCls } = useContext$1(TableContext_default, ["prefixCls"]);
	let rowProps;
	if (onHeaderRow) rowProps = onHeaderRow(cells.map((cell) => cell.column), index$1);
	const columnsKey = getColumnsKey(cells.map((cell) => cell.column));
	return /* @__PURE__ */ import_react.createElement(RowComponent, _extends$15({}, rowProps, {
		className: classNames.row,
		style: styles.row
	}), cells.map((cell, cellIndex) => {
		const { column: column$1, colStart, colEnd, colSpan } = cell;
		const fixedInfo = getCellFixedInfo(colStart, colEnd, flattenColumns, stickyOffsets);
		const additionalProps = column$1?.onHeaderCell?.(column$1) || {};
		return /* @__PURE__ */ import_react.createElement(Cell_default, _extends$15({}, cell, {
			scope: column$1.title ? colSpan > 1 ? "colgroup" : "col" : null,
			ellipsis: column$1.ellipsis,
			align: column$1.align,
			component: CellComponent,
			prefixCls,
			key: columnsKey[cellIndex]
		}, fixedInfo, {
			additionalProps,
			rowType: "header"
		}));
	}));
};
HeaderRow.displayName = "HeaderRow";
var HeaderRow_default = HeaderRow;

//#endregion
//#region node_modules/@rc-component/table/es/Header/Header.js
function parseHeaderRows(rootColumns, classNames, styles) {
	const rows = [];
	function fillRowCells(columns, colIndex, rowIndex = 0) {
		rows[rowIndex] = rows[rowIndex] || [];
		let currentColIndex = colIndex;
		return columns.filter(Boolean).map((column$1) => {
			const cell = {
				key: column$1.key,
				className: clsx(column$1.className, classNames.cell) || "",
				style: styles.cell,
				children: column$1.title,
				column: column$1,
				colStart: currentColIndex
			};
			let colSpan = 1;
			const subColumns = column$1.children;
			if (subColumns && subColumns.length > 0) {
				colSpan = fillRowCells(subColumns, currentColIndex, rowIndex + 1).reduce((total, count) => total + count, 0);
				cell.hasSubColumns = true;
			}
			if ("colSpan" in column$1) ({colSpan} = column$1);
			if ("rowSpan" in column$1) cell.rowSpan = column$1.rowSpan;
			cell.colSpan = colSpan;
			cell.colEnd = cell.colStart + colSpan - 1;
			rows[rowIndex].push(cell);
			currentColIndex += colSpan;
			return colSpan;
		});
	}
	fillRowCells(rootColumns, 0);
	const rowCount = rows.length;
	for (let rowIndex = 0; rowIndex < rowCount; rowIndex += 1) rows[rowIndex].forEach((cell) => {
		if (!("rowSpan" in cell) && !cell.hasSubColumns) cell.rowSpan = rowCount - rowIndex;
	});
	return rows;
}
var Header = (props) => {
	useRenderTimes_default(props);
	const { stickyOffsets, columns, flattenColumns, onHeaderRow } = props;
	const { prefixCls, getComponent, classNames, styles } = useContext$1(TableContext_default, [
		"prefixCls",
		"getComponent",
		"classNames",
		"styles"
	]);
	const { header: headerCls = {} } = classNames || {};
	const { header: headerStyles = {} } = styles || {};
	const rows = import_react.useMemo(() => parseHeaderRows(columns, headerCls, headerStyles), [
		columns,
		headerCls,
		headerStyles
	]);
	const WrapperComponent = getComponent(["header", "wrapper"], "thead");
	const trComponent = getComponent(["header", "row"], "tr");
	const thComponent = getComponent(["header", "cell"], "th");
	return /* @__PURE__ */ import_react.createElement(WrapperComponent, {
		className: clsx(`${prefixCls}-thead`, headerCls.wrapper),
		style: headerStyles.wrapper
	}, rows.map((row, rowIndex) => {
		return /* @__PURE__ */ import_react.createElement(HeaderRow_default, {
			classNames: headerCls,
			styles: headerStyles,
			key: rowIndex,
			flattenColumns,
			cells: row,
			stickyOffsets,
			rowComponent: trComponent,
			cellComponent: thComponent,
			onHeaderRow,
			index: rowIndex
		});
	}));
};
var Header_default = responseImmutable(Header);

//#endregion
//#region node_modules/@rc-component/table/es/hooks/useColumns/useWidthColumns.js
function parseColWidth(totalWidth, width = "") {
	if (typeof width === "number") return width;
	if (width.endsWith("%")) return totalWidth * parseFloat(width) / 100;
	return null;
}
/**
* Fill all column with width
*/
function useWidthColumns(flattenColumns, scrollWidth, clientWidth) {
	return import_react.useMemo(() => {
		if (scrollWidth && scrollWidth > 0) {
			let totalWidth = 0;
			let missWidthCount = 0;
			flattenColumns.forEach((col) => {
				const colWidth = parseColWidth(scrollWidth, col.width);
				if (colWidth) totalWidth += colWidth;
				else missWidthCount += 1;
			});
			const maxFitWidth = Math.max(scrollWidth, clientWidth);
			let restWidth = Math.max(maxFitWidth - totalWidth, missWidthCount);
			let restCount = missWidthCount;
			const avgWidth = restWidth / missWidthCount;
			let realTotal = 0;
			const filledColumns = flattenColumns.map((col) => {
				const clone = { ...col };
				const colWidth = parseColWidth(scrollWidth, clone.width);
				if (colWidth) clone.width = colWidth;
				else {
					const colAvgWidth = Math.floor(avgWidth);
					clone.width = restCount === 1 ? restWidth : colAvgWidth;
					restWidth -= colAvgWidth;
					restCount -= 1;
				}
				realTotal += clone.width;
				return clone;
			});
			if (realTotal < maxFitWidth) {
				const scale = maxFitWidth / realTotal;
				restWidth = maxFitWidth;
				filledColumns.forEach((col, index$1) => {
					const colWidth = Math.floor(col.width * scale);
					col.width = index$1 === filledColumns.length - 1 ? restWidth : colWidth;
					restWidth -= colWidth;
				});
			}
			return [filledColumns, Math.max(realTotal, maxFitWidth)];
		}
		return [flattenColumns, scrollWidth];
	}, [
		flattenColumns,
		scrollWidth,
		clientWidth
	]);
}

//#endregion
//#region node_modules/@rc-component/table/es/hooks/useColumns/index.js
function convertChildrenToColumns(children) {
	return toArray(children).filter((node$1) => /* @__PURE__ */ import_react.isValidElement(node$1)).map((node$1) => {
		const { key, props } = node$1;
		const { children: nodeChildren, ...restProps } = props;
		const column$1 = {
			key,
			...restProps
		};
		if (nodeChildren) column$1.children = convertChildrenToColumns(nodeChildren);
		return column$1;
	});
}
function filterHiddenColumns(columns) {
	return columns.filter((column$1) => column$1 && typeof column$1 === "object" && !column$1.hidden).map((column$1) => {
		const subColumns = column$1.children;
		if (subColumns && subColumns.length > 0) return {
			...column$1,
			children: filterHiddenColumns(subColumns)
		};
		return column$1;
	});
}
function flatColumns(columns, parentKey = "key") {
	return columns.filter((column$1) => column$1 && typeof column$1 === "object").reduce((list, column$1, index$1) => {
		const { fixed } = column$1;
		const parsedFixed = fixed === true || fixed === "left" ? "start" : fixed === "right" ? "end" : fixed;
		const mergedKey = `${parentKey}-${index$1}`;
		const subColumns = column$1.children;
		if (subColumns && subColumns.length > 0) return [...list, ...flatColumns(subColumns, mergedKey).map((subColum) => ({
			...subColum,
			fixed: subColum.fixed ?? parsedFixed
		}))];
		return [...list, {
			key: mergedKey,
			...column$1,
			fixed: parsedFixed
		}];
	}, []);
}
/**
* Parse `columns` & `children` into `columns`.
*/
function useColumns({ prefixCls, columns, children, expandable, expandedKeys, columnTitle, getRowKey, onTriggerExpand, expandIcon, rowExpandable, expandIconColumnIndex, expandedRowOffset = 0, direction, expandRowByClick, columnWidth, fixed, scrollWidth, clientWidth }, transformColumns) {
	const baseColumns = import_react.useMemo(() => {
		return filterHiddenColumns((columns || convertChildrenToColumns(children) || []).slice());
	}, [columns, children]);
	const withExpandColumns = import_react.useMemo(() => {
		if (expandable) {
			let cloneColumns = baseColumns.slice();
			if (expandIconColumnIndex >= 0) warning_default$1(false, "`expandIconColumnIndex` is deprecated. Please use `Table.EXPAND_COLUMN` in `columns` instead.");
			if (!cloneColumns.includes(EXPAND_COLUMN)) {
				const expandColIndex = expandIconColumnIndex || 0;
				const insertIndex = expandColIndex === 0 && (fixed === "right" || fixed === "end") ? baseColumns.length : expandColIndex;
				if (insertIndex >= 0) cloneColumns.splice(insertIndex, 0, EXPAND_COLUMN);
			}
			if (cloneColumns.filter((c) => c === EXPAND_COLUMN).length > 1) warning_default$1(false, "There exist more than one `EXPAND_COLUMN` in `columns`.");
			const expandColumnIndex = cloneColumns.indexOf(EXPAND_COLUMN);
			cloneColumns = cloneColumns.filter((column$1, index$1) => column$1 !== EXPAND_COLUMN || index$1 === expandColumnIndex);
			const prevColumn = baseColumns[expandColumnIndex];
			let fixedColumn;
			if (fixed) fixedColumn = fixed;
			else fixedColumn = prevColumn ? prevColumn.fixed : null;
			const expandColumn = {
				[INTERNAL_COL_DEFINE]: {
					className: `${prefixCls}-expand-icon-col`,
					columnType: "EXPAND_COLUMN"
				},
				title: columnTitle,
				fixed: fixedColumn,
				className: `${prefixCls}-row-expand-icon-cell`,
				width: columnWidth,
				render: (_, record, index$1) => {
					const rowKey = getRowKey(record, index$1);
					const icon = expandIcon({
						prefixCls,
						expanded: expandedKeys.has(rowKey),
						expandable: rowExpandable ? rowExpandable(record) : true,
						record,
						onExpand: onTriggerExpand
					});
					if (expandRowByClick) return /* @__PURE__ */ import_react.createElement("span", { onClick: (e$2) => e$2.stopPropagation() }, icon);
					return icon;
				}
			};
			return cloneColumns.map((col, index$1) => {
				const column$1 = col === EXPAND_COLUMN ? expandColumn : col;
				if (index$1 < expandedRowOffset) return {
					...column$1,
					fixed: column$1.fixed || "start"
				};
				return column$1;
			});
		}
		if (baseColumns.includes(EXPAND_COLUMN)) warning_default$1(false, "`expandable` is not config but there exist `EXPAND_COLUMN` in `columns`.");
		return baseColumns.filter((col) => col !== EXPAND_COLUMN);
	}, [
		expandable,
		baseColumns,
		getRowKey,
		expandedKeys,
		expandIcon,
		direction,
		expandedRowOffset
	]);
	const mergedColumns = import_react.useMemo(() => {
		let finalColumns = withExpandColumns;
		if (transformColumns) finalColumns = transformColumns(finalColumns);
		if (!finalColumns.length) finalColumns = [{ render: () => null }];
		return finalColumns;
	}, [
		transformColumns,
		withExpandColumns,
		direction
	]);
	const [filledColumns, realScrollWidth] = useWidthColumns(import_react.useMemo(() => flatColumns(mergedColumns), [
		mergedColumns,
		direction,
		scrollWidth
	]), scrollWidth, clientWidth);
	return [
		mergedColumns,
		filledColumns,
		realScrollWidth
	];
}
var useColumns_default = useColumns;

//#endregion
//#region node_modules/@rc-component/table/es/hooks/useExpand.js
function useExpand(props, mergedData, getRowKey) {
	const expandableConfig = getExpandableProps(props);
	const { expandIcon, expandedRowKeys, defaultExpandedRowKeys, defaultExpandAllRows, expandedRowRender, onExpand, onExpandedRowsChange, childrenColumnName } = expandableConfig;
	const mergedExpandIcon = expandIcon || renderExpandIcon$1;
	const mergedChildrenColumnName = childrenColumnName || "children";
	const expandableType = import_react.useMemo(() => {
		if (expandedRowRender) return "row";
		/**
		* Fix https://github.com/ant-design/ant-design/issues/21154
		* This is a workaround to not to break current behavior.
		* We can remove follow code after final release.
		*
		* To other developer:
		*  Do not use `__PARENT_RENDER_ICON__` in prod since we will remove this when refactor
		*/
		if (props.expandable && props.internalHooks === INTERNAL_HOOKS && props.expandable.__PARENT_RENDER_ICON__ || mergedData.some((record) => record && typeof record === "object" && record[mergedChildrenColumnName])) return "nest";
		return false;
	}, [!!expandedRowRender, mergedData]);
	const [innerExpandedKeys, setInnerExpandedKeys] = import_react.useState(() => {
		if (defaultExpandedRowKeys) return defaultExpandedRowKeys;
		if (defaultExpandAllRows) return findAllChildrenKeys(mergedData, getRowKey, mergedChildrenColumnName);
		return [];
	});
	const mergedExpandedKeys = import_react.useMemo(() => new Set(expandedRowKeys || innerExpandedKeys || []), [expandedRowKeys, innerExpandedKeys]);
	const onTriggerExpand = import_react.useCallback((record) => {
		const key = getRowKey(record, mergedData.indexOf(record));
		let newExpandedKeys;
		const hasKey = mergedExpandedKeys.has(key);
		if (hasKey) {
			mergedExpandedKeys.delete(key);
			newExpandedKeys = [...mergedExpandedKeys];
		} else newExpandedKeys = [...mergedExpandedKeys, key];
		setInnerExpandedKeys(newExpandedKeys);
		if (onExpand) onExpand(!hasKey, record);
		if (onExpandedRowsChange) onExpandedRowsChange(newExpandedKeys);
	}, [
		getRowKey,
		mergedExpandedKeys,
		mergedData,
		onExpand,
		onExpandedRowsChange
	]);
	if (expandedRowRender && mergedData.some((record) => {
		return Array.isArray(record?.[mergedChildrenColumnName]);
	})) warning_default$1(false, "`expandedRowRender` should not use with nested Table");
	return [
		expandableConfig,
		expandableType,
		mergedExpandedKeys,
		mergedExpandIcon,
		mergedChildrenColumnName,
		onTriggerExpand
	];
}

//#endregion
//#region node_modules/@rc-component/table/es/hooks/useFixedInfo.js
function useFixedInfo(flattenColumns, stickyOffsets) {
	const fixedInfoList = import_react.useMemo(() => flattenColumns.map((_, colIndex) => getCellFixedInfo(colIndex, colIndex, flattenColumns, stickyOffsets)), [flattenColumns, stickyOffsets]);
	return useMemo$1(() => fixedInfoList, [fixedInfoList], (prev$1, next$1) => !isEqual_default(prev$1, next$1));
}

//#endregion
//#region node_modules/@rc-component/table/es/hooks/useFrame.js
/**
* Execute code before next frame but async
*/
function useLayoutState(defaultState) {
	const stateRef = (0, import_react.useRef)(defaultState);
	const [, forceUpdate] = (0, import_react.useState)({});
	const lastPromiseRef = (0, import_react.useRef)(null);
	const updateBatchRef = (0, import_react.useRef)([]);
	function setFrameState(updater) {
		updateBatchRef.current.push(updater);
		const promise = Promise.resolve();
		lastPromiseRef.current = promise;
		promise.then(() => {
			if (lastPromiseRef.current === promise) {
				const prevBatch = updateBatchRef.current;
				const prevState = stateRef.current;
				updateBatchRef.current = [];
				prevBatch.forEach((batchUpdater) => {
					stateRef.current = batchUpdater(stateRef.current);
				});
				lastPromiseRef.current = null;
				if (prevState !== stateRef.current) forceUpdate({});
			}
		});
	}
	(0, import_react.useEffect)(() => () => {
		lastPromiseRef.current = null;
	}, []);
	return [stateRef.current, setFrameState];
}
/** Lock frame, when frame pass reset the lock. */
function useTimeoutLock(defaultState) {
	const frameRef = (0, import_react.useRef)(defaultState || null);
	const timeoutRef = (0, import_react.useRef)(null);
	function cleanUp() {
		clearTimeout(timeoutRef.current);
	}
	function setState(newState) {
		frameRef.current = newState;
		cleanUp();
		timeoutRef.current = setTimeout(() => {
			frameRef.current = null;
			timeoutRef.current = void 0;
		}, 100);
	}
	function getState() {
		return frameRef.current;
	}
	(0, import_react.useEffect)(() => cleanUp, []);
	return [setState, getState];
}

//#endregion
//#region node_modules/@rc-component/table/es/hooks/useHover.js
function useHover() {
	const [startRow, setStartRow] = import_react.useState(-1);
	const [endRow, setEndRow] = import_react.useState(-1);
	return [
		startRow,
		endRow,
		import_react.useCallback((start, end) => {
			setStartRow(start);
			setEndRow(end);
		}, [])
	];
}

//#endregion
//#region node_modules/@rc-component/table/es/hooks/useSticky.js
var defaultContainer = canUseDom() ? window : null;
/** Sticky header hooks */
function useSticky(sticky, prefixCls) {
	const { offsetHeader = 0, offsetSummary = 0, offsetScroll = 0, getContainer = () => defaultContainer } = typeof sticky === "object" ? sticky : {};
	const container = getContainer() || defaultContainer;
	const isSticky = !!sticky;
	return import_react.useMemo(() => {
		return {
			isSticky,
			stickyClassName: isSticky ? `${prefixCls}-sticky-holder` : "",
			offsetHeader,
			offsetSummary,
			offsetScroll,
			container
		};
	}, [
		isSticky,
		offsetScroll,
		offsetHeader,
		offsetSummary,
		prefixCls,
		container
	]);
}

//#endregion
//#region node_modules/@rc-component/table/es/hooks/useStickyOffsets.js
/**
* Get sticky column offset width
*/
function useStickyOffsets(colWidths, flattenColumns) {
	return (0, import_react.useMemo)(() => {
		const columnCount = flattenColumns.length;
		const getOffsets = (startIndex, endIndex, offset$2) => {
			const offsets = [];
			let total = 0;
			for (let i = startIndex; i !== endIndex; i += offset$2) {
				offsets.push(total);
				if (flattenColumns[i].fixed) total += colWidths[i] || 0;
			}
			return offsets;
		};
		return {
			start: getOffsets(0, columnCount, 1),
			end: getOffsets(columnCount - 1, -1, -1).reverse(),
			widths: colWidths
		};
	}, [colWidths, flattenColumns]);
}
var useStickyOffsets_default = useStickyOffsets;

//#endregion
//#region node_modules/@rc-component/table/es/Panel/index.js
var Panel = (props) => {
	const { children, className, style: style$1 } = props;
	return /* @__PURE__ */ import_react.createElement("div", {
		className,
		style: style$1
	}, children);
};
var Panel_default = Panel;

//#endregion
//#region node_modules/@rc-component/table/es/utils/offsetUtil.js
function getOffset(node$1) {
	const box$1 = getDOM(node$1).getBoundingClientRect();
	const docElem = document.documentElement;
	return {
		left: box$1.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || document.body.clientLeft || 0),
		top: box$1.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || document.body.clientTop || 0)
	};
}

//#endregion
//#region node_modules/@rc-component/table/es/stickyScrollBar.js
var MOUSEUP_EVENT = "mouseup";
var MOUSEMOVE_EVENT = "mousemove";
var SCROLL_EVENT = "scroll";
var RESIZE_EVENT = "resize";
var StickyScrollBar = (props, ref) => {
	const { scrollBodyRef, onScroll, offsetScroll, container, direction } = props;
	const prefixCls = useContext$1(TableContext_default, "prefixCls");
	const bodyScrollWidth = scrollBodyRef.current?.scrollWidth || 0;
	const bodyWidth = scrollBodyRef.current?.clientWidth || 0;
	const scrollBarWidth = bodyScrollWidth && bodyWidth * (bodyWidth / bodyScrollWidth);
	const scrollBarRef = import_react.useRef(null);
	const [scrollState, setScrollState] = useLayoutState({
		scrollLeft: 0,
		isHiddenScrollBar: true
	});
	const refState = import_react.useRef({
		delta: 0,
		x: 0
	});
	const [isActive$1, setActive] = import_react.useState(false);
	const rafRef = import_react.useRef(null);
	import_react.useEffect(() => () => {
		raf_default.cancel(rafRef.current);
	}, []);
	const onMouseUp = () => {
		setActive(false);
	};
	const onMouseDown = (event) => {
		event.persist();
		refState.current.delta = event.pageX - scrollState.scrollLeft;
		refState.current.x = 0;
		setActive(true);
		event.preventDefault();
	};
	const onMouseMove = (event) => {
		const { buttons } = event || window?.event;
		if (!isActive$1 || buttons === 0) {
			if (isActive$1) setActive(false);
			return;
		}
		let left = refState.current.x + event.pageX - refState.current.x - refState.current.delta;
		const isRTL = direction === "rtl";
		left = Math.max(isRTL ? scrollBarWidth - bodyWidth : 0, Math.min(isRTL ? 0 : bodyWidth - scrollBarWidth, left));
		if (!isRTL || Math.abs(left) + Math.abs(scrollBarWidth) < bodyWidth) {
			onScroll({ scrollLeft: left / bodyWidth * (bodyScrollWidth + 2) });
			refState.current.x = event.pageX;
		}
	};
	const checkScrollBarVisible = () => {
		raf_default.cancel(rafRef.current);
		rafRef.current = raf_default(() => {
			if (!scrollBodyRef.current) return;
			const tableOffsetTop = getOffset(scrollBodyRef.current).top;
			const tableBottomOffset = tableOffsetTop + scrollBodyRef.current.offsetHeight;
			const currentClientOffset = container === window ? document.documentElement.scrollTop + window.innerHeight : getOffset(container).top + container.clientHeight;
			if (tableBottomOffset - getScrollBarSize() <= currentClientOffset || tableOffsetTop >= currentClientOffset - offsetScroll) setScrollState((state) => ({
				...state,
				isHiddenScrollBar: true
			}));
			else setScrollState((state) => ({
				...state,
				isHiddenScrollBar: false
			}));
		});
	};
	const setScrollLeft = (left) => {
		setScrollState((state) => {
			return {
				...state,
				scrollLeft: left / bodyScrollWidth * bodyWidth || 0
			};
		});
	};
	import_react.useImperativeHandle(ref, () => ({
		setScrollLeft,
		checkScrollBarVisible
	}));
	import_react.useEffect(() => {
		document.body.addEventListener(MOUSEUP_EVENT, onMouseUp, false);
		document.body.addEventListener(MOUSEMOVE_EVENT, onMouseMove, false);
		checkScrollBarVisible();
		return () => {
			document.body.removeEventListener(MOUSEUP_EVENT, onMouseUp);
			document.body.removeEventListener(MOUSEMOVE_EVENT, onMouseMove);
		};
	}, [scrollBarWidth, isActive$1]);
	import_react.useEffect(() => {
		if (scrollBodyRef.current) {
			const scrollParents = [];
			let parent = getDOM(scrollBodyRef.current);
			while (parent) {
				scrollParents.push(parent);
				parent = parent.parentElement;
			}
			scrollParents.forEach((p) => {
				p.addEventListener(SCROLL_EVENT, checkScrollBarVisible, false);
			});
			window.addEventListener(RESIZE_EVENT, checkScrollBarVisible, false);
			window.addEventListener(SCROLL_EVENT, checkScrollBarVisible, false);
			container.addEventListener(SCROLL_EVENT, checkScrollBarVisible, false);
			return () => {
				scrollParents.forEach((p) => {
					p.removeEventListener(SCROLL_EVENT, checkScrollBarVisible);
				});
				window.removeEventListener(RESIZE_EVENT, checkScrollBarVisible);
				window.removeEventListener(SCROLL_EVENT, checkScrollBarVisible);
				container.removeEventListener(SCROLL_EVENT, checkScrollBarVisible);
			};
		}
	}, [container]);
	import_react.useEffect(() => {
		if (!scrollState.isHiddenScrollBar) setScrollState((state) => {
			const bodyNode = scrollBodyRef.current;
			if (!bodyNode) return state;
			return {
				...state,
				scrollLeft: bodyNode.scrollLeft / bodyNode.scrollWidth * bodyNode.clientWidth
			};
		});
	}, [scrollState.isHiddenScrollBar]);
	if (bodyScrollWidth <= bodyWidth || !scrollBarWidth || scrollState.isHiddenScrollBar) return null;
	return /* @__PURE__ */ import_react.createElement("div", {
		style: {
			height: getScrollBarSize(),
			width: bodyWidth,
			bottom: offsetScroll
		},
		className: `${prefixCls}-sticky-scroll`
	}, /* @__PURE__ */ import_react.createElement("div", {
		onMouseDown,
		ref: scrollBarRef,
		className: clsx(`${prefixCls}-sticky-scroll-bar`, { [`${prefixCls}-sticky-scroll-bar-active`]: isActive$1 }),
		style: {
			width: `${scrollBarWidth}px`,
			transform: `translate3d(${scrollState.scrollLeft}px, 0, 0)`
		}
	}));
};
var stickyScrollBar_default = /* @__PURE__ */ import_react.forwardRef(StickyScrollBar);

//#endregion
//#region node_modules/@rc-component/table/es/Table.js
/**
* Feature:
*  - fixed not need to set width
*  - support `rowExpandable` to config row expand logic
*  - add `summary` to support `() => ReactNode`
*
* Update:
*  - `dataIndex` is `array[]` now
*  - `expandable` wrap all the expand related props
*
* Removed:
*  - expandIconAsCell
*  - useFixedHeader
*  - rowRef
*  - columns[number].onCellClick
*  - onRowClick
*  - onRowDoubleClick
*  - onRowMouseEnter
*  - onRowMouseLeave
*  - getBodyWrapper
*  - bodyStyle
*
* Deprecated:
*  - All expanded props, move into expandable
*/
function _extends$14() {
	_extends$14 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$14.apply(this, arguments);
}
const DEFAULT_PREFIX = "rc-table";
var EMPTY_DATA = [];
var EMPTY_SCROLL_TARGET = {};
function defaultEmpty() {
	return "No Data";
}
var Table$1 = (tableProps, ref) => {
	const props = {
		rowKey: "key",
		prefixCls: DEFAULT_PREFIX,
		emptyText: defaultEmpty,
		...tableProps
	};
	const { prefixCls, className, rowClassName, style: style$1, classNames, styles, data, rowKey, scroll, tableLayout, direction, title, footer, summary, caption, id, showHeader, components: components$1, emptyText, onRow, onHeaderRow, measureRowRender, onScroll, internalHooks, transformColumns, internalRefs, tailor, getContainerWidth, sticky, rowHoverable = true } = props;
	const mergedData = data || EMPTY_DATA;
	const hasData = !!mergedData.length;
	const useInternalHooks = internalHooks === INTERNAL_HOOKS;
	[
		"onRowClick",
		"onRowDoubleClick",
		"onRowContextMenu",
		"onRowMouseEnter",
		"onRowMouseLeave"
	].forEach((name) => {
		warning_default$1(props[name] === void 0, `\`${name}\` is removed, please use \`onRow\` instead.`);
	});
	warning_default$1(!("getBodyWrapper" in props), "`getBodyWrapper` is deprecated, please use custom `components` instead.");
	const getComponent = import_react.useCallback((path$1, defaultComponent) => get(components$1, path$1) || defaultComponent, [components$1]);
	const getRowKey = import_react.useMemo(() => {
		if (typeof rowKey === "function") return rowKey;
		return (record) => {
			const key = record && record[rowKey];
			warning_default$1(key !== void 0, "Each record in table should have a unique `key` prop, or set `rowKey` to an unique primary key.");
			return key;
		};
	}, [rowKey]);
	const customizeScrollBody = getComponent(["body"]);
	const [startRow, endRow, onHover] = useHover();
	const [expandableConfig, expandableType, mergedExpandedKeys, mergedExpandIcon, mergedChildrenColumnName, onTriggerExpand] = useExpand(props, mergedData, getRowKey);
	const scrollX = scroll?.x;
	const [componentWidth, setComponentWidth] = import_react.useState(0);
	const [columns, flattenColumns, flattenScrollX] = useColumns_default({
		...props,
		...expandableConfig,
		expandable: !!expandableConfig.expandedRowRender,
		columnTitle: expandableConfig.columnTitle,
		expandedKeys: mergedExpandedKeys,
		getRowKey,
		onTriggerExpand,
		expandIcon: mergedExpandIcon,
		expandIconColumnIndex: expandableConfig.expandIconColumnIndex,
		direction,
		scrollWidth: useInternalHooks && tailor && typeof scrollX === "number" ? scrollX : null,
		clientWidth: componentWidth
	}, useInternalHooks ? transformColumns : null);
	const mergedScrollX = flattenScrollX ?? scrollX;
	const columnContext = import_react.useMemo(() => ({
		columns,
		flattenColumns
	}), [columns, flattenColumns]);
	const fullTableRef = import_react.useRef(null);
	const scrollHeaderRef = import_react.useRef(null);
	const scrollBodyRef = import_react.useRef(null);
	const scrollBodyContainerRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => {
		return {
			nativeElement: fullTableRef.current,
			scrollTo: (config) => {
				if (scrollBodyRef.current instanceof HTMLElement) {
					const { index: index$1, top, key, offset: offset$2 } = config;
					if (validNumberValue(top)) scrollBodyRef.current?.scrollTo({ top });
					else {
						const mergedKey = key ?? getRowKey(mergedData[index$1]);
						const targetElement = scrollBodyRef.current.querySelector(`[data-row-key="${mergedKey}"]`);
						if (targetElement) if (!offset$2) targetElement.scrollIntoView();
						else {
							const elementTop = targetElement.offsetTop;
							scrollBodyRef.current.scrollTo({ top: elementTop + offset$2 });
						}
					}
				} else if (scrollBodyRef.current?.scrollTo) scrollBodyRef.current.scrollTo(config);
			}
		};
	});
	const scrollSummaryRef = import_react.useRef(null);
	const [shadowStart, setShadowStart] = import_react.useState(false);
	const [shadowEnd, setShadowEnd] = import_react.useState(false);
	const [colsWidths, updateColsWidths] = import_react.useState(/* @__PURE__ */ new Map());
	const pureColWidths = getColumnsKey(flattenColumns).map((columnKey) => colsWidths.get(columnKey));
	const colWidths = import_react.useMemo(() => pureColWidths, [pureColWidths.join("_")]);
	const stickyOffsets = useStickyOffsets_default(colWidths, flattenColumns);
	const fixHeader = scroll && validateValue(scroll.y);
	const horizonScroll = scroll && validateValue(mergedScrollX) || Boolean(expandableConfig.fixed);
	const fixColumn = horizonScroll && flattenColumns.some(({ fixed }) => fixed);
	const stickyRef = import_react.useRef(null);
	const { isSticky, offsetHeader, offsetSummary, offsetScroll, stickyClassName, container } = useSticky(sticky, prefixCls);
	const summaryNode = import_react.useMemo(() => summary?.(mergedData), [summary, mergedData]);
	const fixFooter = (fixHeader || isSticky) && /* @__PURE__ */ import_react.isValidElement(summaryNode) && summaryNode.type === Summary_default && summaryNode.props.fixed;
	let scrollXStyle;
	let scrollYStyle;
	let scrollTableStyle;
	if (fixHeader) scrollYStyle = {
		overflowY: hasData ? "scroll" : "auto",
		maxHeight: scroll.y
	};
	if (horizonScroll) {
		scrollXStyle = { overflowX: "auto" };
		if (!fixHeader) scrollYStyle = { overflowY: "hidden" };
		scrollTableStyle = {
			width: mergedScrollX === true ? "auto" : mergedScrollX,
			minWidth: "100%"
		};
	}
	const onColumnResize = import_react.useCallback((columnKey, width) => {
		updateColsWidths((widths) => {
			if (widths.get(columnKey) !== width) {
				const newWidths = new Map(widths);
				newWidths.set(columnKey, width);
				return newWidths;
			}
			return widths;
		});
	}, []);
	const [setScrollTarget, getScrollTarget] = useTimeoutLock(null);
	function forceScroll(scrollLeft, target) {
		if (!target) return;
		if (typeof target === "function") target(scrollLeft);
		else if (target.scrollLeft !== scrollLeft) {
			target.scrollLeft = scrollLeft;
			if (target.scrollLeft !== scrollLeft) setTimeout(() => {
				target.scrollLeft = scrollLeft;
			}, 0);
		}
	}
	const [scrollInfo, setScrollInfo] = import_react.useState([0, 0]);
	const onInternalScroll = useEvent_default(({ currentTarget, scrollLeft }) => {
		const mergedScrollLeft = typeof scrollLeft === "number" ? scrollLeft : currentTarget.scrollLeft;
		const compareTarget = currentTarget || EMPTY_SCROLL_TARGET;
		if (!getScrollTarget() || getScrollTarget() === compareTarget) {
			setScrollTarget(compareTarget);
			forceScroll(mergedScrollLeft, scrollHeaderRef.current);
			forceScroll(mergedScrollLeft, scrollBodyRef.current);
			forceScroll(mergedScrollLeft, scrollSummaryRef.current);
			forceScroll(mergedScrollLeft, stickyRef.current?.setScrollLeft);
		}
		const measureTarget = currentTarget || scrollHeaderRef.current;
		if (measureTarget) {
			const scrollWidth = useInternalHooks && tailor && typeof mergedScrollX === "number" ? mergedScrollX : measureTarget.scrollWidth;
			const clientWidth = measureTarget.clientWidth;
			const absScrollStart = Math.abs(mergedScrollLeft);
			setScrollInfo((ori) => {
				const nextScrollInfo = [absScrollStart, scrollWidth - clientWidth];
				return isEqual_default(ori, nextScrollInfo) ? ori : nextScrollInfo;
			});
			if (scrollWidth === clientWidth) {
				setShadowStart(false);
				setShadowEnd(false);
				return;
			}
			setShadowStart(absScrollStart > 0);
			setShadowEnd(absScrollStart < scrollWidth - clientWidth - 1);
		}
	});
	const onBodyScroll = useEvent_default((e$2) => {
		onInternalScroll(e$2);
		onScroll?.(e$2);
	});
	const triggerOnScroll = () => {
		if (horizonScroll && scrollBodyRef.current) onInternalScroll({
			currentTarget: getDOM(scrollBodyRef.current),
			scrollLeft: scrollBodyRef.current?.scrollLeft
		});
		else {
			setShadowStart(false);
			setShadowEnd(false);
		}
	};
	const onFullTableResize = (offsetWidth) => {
		stickyRef.current?.checkScrollBarVisible();
		let mergedWidth = offsetWidth ?? fullTableRef.current?.offsetWidth ?? 0;
		if (useInternalHooks && getContainerWidth && fullTableRef.current) mergedWidth = getContainerWidth(fullTableRef.current, mergedWidth) || mergedWidth;
		if (mergedWidth !== componentWidth) {
			triggerOnScroll();
			setComponentWidth(mergedWidth);
		}
	};
	useLayoutEffect_default(() => {
		if (horizonScroll) onFullTableResize();
	}, [horizonScroll]);
	const mounted = import_react.useRef(false);
	import_react.useEffect(() => {
		if (mounted.current) triggerOnScroll();
	}, [
		horizonScroll,
		data,
		columns.length
	]);
	import_react.useEffect(() => {
		mounted.current = true;
	}, []);
	const [scrollbarSize, setScrollbarSize] = import_react.useState(0);
	useLayoutEffect_default(() => {
		if (!tailor || !useInternalHooks) if (scrollBodyRef.current instanceof Element) setScrollbarSize(getTargetScrollBarSize(scrollBodyRef.current).width);
		else setScrollbarSize(getTargetScrollBarSize(scrollBodyContainerRef.current).width);
	}, []);
	import_react.useEffect(() => {
		if (useInternalHooks && internalRefs) internalRefs.body.current = scrollBodyRef.current;
	});
	const renderFixedHeaderTable = import_react.useCallback((fixedHolderPassProps) => /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(Header_default, fixedHolderPassProps), fixFooter === "top" && /* @__PURE__ */ import_react.createElement(Footer_default, fixedHolderPassProps, summaryNode)), [fixFooter, summaryNode]);
	const renderFixedFooterTable = import_react.useCallback((fixedHolderPassProps) => /* @__PURE__ */ import_react.createElement(Footer_default, fixedHolderPassProps, summaryNode), [summaryNode]);
	const TableComponent = getComponent(["table"], "table");
	const mergedTableLayout = import_react.useMemo(() => {
		if (tableLayout) return tableLayout;
		if (fixColumn) return mergedScrollX === "max-content" ? "auto" : "fixed";
		if (fixHeader || isSticky || flattenColumns.some(({ ellipsis }) => ellipsis)) return "fixed";
		return "auto";
	}, [
		fixHeader,
		fixColumn,
		flattenColumns,
		tableLayout,
		isSticky
	]);
	let groupTableNode;
	const headerProps = {
		colWidths,
		columCount: flattenColumns.length,
		stickyOffsets,
		onHeaderRow,
		fixHeader,
		scroll
	};
	const emptyNode = import_react.useMemo(() => {
		if (hasData) return null;
		if (typeof emptyText === "function") return emptyText();
		return emptyText;
	}, [hasData, emptyText]);
	const bodyTable = /* @__PURE__ */ import_react.createElement(Body_default, {
		data: mergedData,
		measureColumnWidth: fixHeader || horizonScroll || isSticky
	});
	const bodyColGroup = /* @__PURE__ */ import_react.createElement(ColGroup_default, {
		colWidths: flattenColumns.map(({ width }) => width),
		columns: flattenColumns
	});
	const captionElement = caption !== null && caption !== void 0 ? /* @__PURE__ */ import_react.createElement("caption", { className: `${prefixCls}-caption` }, caption) : void 0;
	const dataProps = pickAttrs(props, { data: true });
	const ariaProps = pickAttrs(props, { aria: true });
	if (fixHeader || isSticky) {
		let bodyContent;
		if (typeof customizeScrollBody === "function") {
			bodyContent = customizeScrollBody(mergedData, {
				scrollbarSize,
				ref: scrollBodyRef,
				onScroll: onInternalScroll
			});
			headerProps.colWidths = flattenColumns.map(({ width }, index$1) => {
				const colWidth = index$1 === flattenColumns.length - 1 ? width - scrollbarSize : width;
				if (typeof colWidth === "number" && !Number.isNaN(colWidth)) return colWidth;
				warning_default$1(props.columns.length === 0, "When use `components.body` with render props. Each column should have a fixed `width` value.");
				return 0;
			});
		} else bodyContent = /* @__PURE__ */ import_react.createElement("div", {
			style: {
				...scrollXStyle,
				...scrollYStyle
			},
			onScroll: onBodyScroll,
			ref: scrollBodyRef,
			className: `${prefixCls}-body`
		}, /* @__PURE__ */ import_react.createElement(TableComponent, _extends$14({ style: {
			...scrollTableStyle,
			tableLayout: mergedTableLayout
		} }, ariaProps), captionElement, bodyColGroup, bodyTable, !fixFooter && summaryNode && /* @__PURE__ */ import_react.createElement(Footer_default, {
			stickyOffsets,
			flattenColumns
		}, summaryNode)));
		const fixedHolderProps = {
			noData: !mergedData.length,
			maxContentScroll: horizonScroll && mergedScrollX === "max-content",
			...headerProps,
			...columnContext,
			direction,
			stickyClassName,
			scrollX: mergedScrollX,
			tableLayout: mergedTableLayout,
			onScroll: onInternalScroll
		};
		groupTableNode = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, showHeader !== false && /* @__PURE__ */ import_react.createElement(FixedHolder_default, _extends$14({}, fixedHolderProps, {
			stickyTopOffset: offsetHeader,
			className: `${prefixCls}-header`,
			ref: scrollHeaderRef,
			colGroup: bodyColGroup
		}), renderFixedHeaderTable), bodyContent, fixFooter && fixFooter !== "top" && /* @__PURE__ */ import_react.createElement(FixedHolder_default, _extends$14({}, fixedHolderProps, {
			stickyBottomOffset: offsetSummary,
			className: `${prefixCls}-summary`,
			ref: scrollSummaryRef,
			colGroup: bodyColGroup
		}), renderFixedFooterTable), isSticky && scrollBodyRef.current && scrollBodyRef.current instanceof Element && /* @__PURE__ */ import_react.createElement(stickyScrollBar_default, {
			ref: stickyRef,
			offsetScroll,
			scrollBodyRef,
			onScroll: onInternalScroll,
			container,
			direction
		}));
	} else groupTableNode = /* @__PURE__ */ import_react.createElement("div", {
		style: {
			...scrollXStyle,
			...scrollYStyle,
			...styles?.content
		},
		className: clsx(`${prefixCls}-content`, classNames?.content),
		onScroll: onInternalScroll,
		ref: scrollBodyRef
	}, /* @__PURE__ */ import_react.createElement(TableComponent, _extends$14({ style: {
		...scrollTableStyle,
		tableLayout: mergedTableLayout
	} }, ariaProps), captionElement, bodyColGroup, showHeader !== false && /* @__PURE__ */ import_react.createElement(Header_default, _extends$14({}, headerProps, columnContext)), bodyTable, summaryNode && /* @__PURE__ */ import_react.createElement(Footer_default, {
		stickyOffsets,
		flattenColumns
	}, summaryNode)));
	const tableStyle = { ...style$1 };
	if (isSticky) tableStyle["--columns-count"] = flattenColumns.length;
	let fullTable = /* @__PURE__ */ import_react.createElement("div", _extends$14({
		className: clsx(prefixCls, className, {
			[`${prefixCls}-rtl`]: direction === "rtl",
			[`${prefixCls}-fix-start-shadow`]: horizonScroll,
			[`${prefixCls}-fix-end-shadow`]: horizonScroll,
			[`${prefixCls}-fix-start-shadow-show`]: horizonScroll && shadowStart,
			[`${prefixCls}-fix-end-shadow-show`]: horizonScroll && shadowEnd,
			[`${prefixCls}-layout-fixed`]: tableLayout === "fixed",
			[`${prefixCls}-fixed-header`]: fixHeader,
			[`${prefixCls}-fixed-column`]: fixColumn,
			[`${prefixCls}-scroll-horizontal`]: horizonScroll,
			[`${prefixCls}-has-fix-start`]: flattenColumns[0]?.fixed,
			[`${prefixCls}-has-fix-end`]: flattenColumns[flattenColumns.length - 1]?.fixed === "end"
		}),
		style: tableStyle,
		id,
		ref: fullTableRef
	}, dataProps), title && /* @__PURE__ */ import_react.createElement(Panel_default, {
		className: clsx(`${prefixCls}-title`, classNames?.title),
		style: styles?.title
	}, title(mergedData)), /* @__PURE__ */ import_react.createElement("div", {
		ref: scrollBodyContainerRef,
		className: clsx(`${prefixCls}-container`, classNames?.section),
		style: styles?.section
	}, groupTableNode), footer && /* @__PURE__ */ import_react.createElement(Panel_default, {
		className: clsx(`${prefixCls}-footer`, classNames?.footer),
		style: styles?.footer
	}, footer(mergedData)));
	if (horizonScroll) fullTable = /* @__PURE__ */ import_react.createElement(es_default$2, { onResize: ({ offsetWidth }) => onFullTableResize(offsetWidth) }, fullTable);
	const fixedInfoList = useFixedInfo(flattenColumns, stickyOffsets);
	const TableContextValue = import_react.useMemo(() => ({
		scrollX: mergedScrollX,
		scrollInfo,
		classNames,
		styles,
		prefixCls,
		getComponent,
		scrollbarSize,
		direction,
		fixedInfoList,
		isSticky,
		componentWidth,
		fixHeader,
		fixColumn,
		horizonScroll,
		tableLayout: mergedTableLayout,
		rowClassName,
		expandedRowClassName: expandableConfig.expandedRowClassName,
		expandIcon: mergedExpandIcon,
		expandableType,
		expandRowByClick: expandableConfig.expandRowByClick,
		expandedRowRender: expandableConfig.expandedRowRender,
		expandedRowOffset: expandableConfig.expandedRowOffset,
		onTriggerExpand,
		expandIconColumnIndex: expandableConfig.expandIconColumnIndex,
		indentSize: expandableConfig.indentSize,
		allColumnsFixedLeft: flattenColumns.every((col) => col.fixed === "start"),
		emptyNode,
		columns,
		flattenColumns,
		onColumnResize,
		colWidths,
		hoverStartRow: startRow,
		hoverEndRow: endRow,
		onHover,
		rowExpandable: expandableConfig.rowExpandable,
		onRow,
		getRowKey,
		expandedKeys: mergedExpandedKeys,
		childrenColumnName: mergedChildrenColumnName,
		rowHoverable,
		measureRowRender
	}), [
		mergedScrollX,
		scrollInfo,
		classNames,
		styles,
		prefixCls,
		getComponent,
		scrollbarSize,
		direction,
		fixedInfoList,
		isSticky,
		componentWidth,
		fixHeader,
		fixColumn,
		horizonScroll,
		mergedTableLayout,
		rowClassName,
		expandableConfig.expandedRowClassName,
		mergedExpandIcon,
		expandableType,
		expandableConfig.expandRowByClick,
		expandableConfig.expandedRowRender,
		expandableConfig.expandedRowOffset,
		onTriggerExpand,
		expandableConfig.expandIconColumnIndex,
		expandableConfig.indentSize,
		emptyNode,
		columns,
		flattenColumns,
		onColumnResize,
		colWidths,
		startRow,
		endRow,
		onHover,
		expandableConfig.rowExpandable,
		onRow,
		getRowKey,
		mergedExpandedKeys,
		mergedChildrenColumnName,
		rowHoverable,
		measureRowRender
	]);
	return /* @__PURE__ */ import_react.createElement(TableContext_default.Provider, { value: TableContextValue }, fullTable);
};
var RefTable = /* @__PURE__ */ import_react.forwardRef(Table$1);
RefTable.displayName = "Table";
const genTable = (shouldTriggerRender) => {
	return makeImmutable(RefTable, shouldTriggerRender);
};
var ImmutableTable = genTable();
ImmutableTable.EXPAND_COLUMN = EXPAND_COLUMN;
ImmutableTable.INTERNAL_HOOKS = INTERNAL_HOOKS;
ImmutableTable.Column = Column_default$1;
ImmutableTable.ColumnGroup = ColumnGroup_default$1;
ImmutableTable.Summary = FooterComponents;
var Table_default$1 = ImmutableTable;

//#endregion
//#region node_modules/@rc-component/table/es/VirtualTable/context.js
const StaticContext = createContext(null);
const GridContext = createContext(null);

//#endregion
//#region node_modules/@rc-component/table/es/VirtualTable/VirtualCell.js
function _extends$13() {
	_extends$13 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$13.apply(this, arguments);
}
/**
* Return the width of the column by `colSpan`.
* When `colSpan` is `0` will be trade as `1`.
*/
function getColumnWidth(colIndex, colSpan, columnsOffset) {
	return columnsOffset[colIndex + (colSpan || 1)] - (columnsOffset[colIndex] || 0);
}
var VirtualCell = (props) => {
	const { rowInfo, column: column$1, colIndex, indent, index: index$1, component, renderIndex, record, style: style$1, className, inverse, getHeight: getHeight$1 } = props;
	const { render: render$1, dataIndex, className: columnClassName, width: colWidth } = column$1;
	const { columnsOffset } = useContext$1(GridContext, ["columnsOffset"]);
	const { key, fixedInfo, appendCellNode, additionalCellProps } = getCellProps(rowInfo, column$1, colIndex, indent, index$1);
	const { style: cellStyle, colSpan = 1, rowSpan = 1 } = additionalCellProps;
	const concatColWidth = getColumnWidth(colIndex - 1, colSpan, columnsOffset);
	const marginOffset = colSpan > 1 ? colWidth - concatColWidth : 0;
	const mergedStyle = {
		...cellStyle,
		...style$1,
		flex: `0 0 ${concatColWidth}px`,
		width: `${concatColWidth}px`,
		marginRight: marginOffset,
		pointerEvents: "auto"
	};
	const needHide = import_react.useMemo(() => {
		if (inverse) return rowSpan <= 1;
		else return colSpan === 0 || rowSpan === 0 || rowSpan > 1;
	}, [
		rowSpan,
		colSpan,
		inverse
	]);
	if (needHide) mergedStyle.visibility = "hidden";
	else if (inverse) mergedStyle.height = getHeight$1?.(rowSpan);
	const mergedRender = needHide ? () => null : render$1;
	const cellSpan = {};
	if (rowSpan === 0 || colSpan === 0) {
		cellSpan.rowSpan = 1;
		cellSpan.colSpan = 1;
	}
	return /* @__PURE__ */ import_react.createElement(Cell_default, _extends$13({
		className: clsx(columnClassName, className),
		ellipsis: column$1.ellipsis,
		align: column$1.align,
		scope: column$1.rowScope,
		component,
		prefixCls: rowInfo.prefixCls,
		key,
		record,
		index: index$1,
		renderIndex,
		dataIndex,
		render: mergedRender,
		shouldCellUpdate: column$1.shouldCellUpdate
	}, fixedInfo, {
		appendNode: appendCellNode,
		additionalProps: {
			...additionalCellProps,
			style: mergedStyle,
			...cellSpan
		}
	}));
};
var VirtualCell_default = VirtualCell;

//#endregion
//#region node_modules/@rc-component/table/es/VirtualTable/BodyLine.js
function _extends$12() {
	_extends$12 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$12.apply(this, arguments);
}
var ResponseBodyLine = responseImmutable(/* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { data, index: index$1, className, rowKey, style: style$1, extra, getHeight: getHeight$1, ...restProps } = props;
	const { record, indent, index: renderIndex } = data;
	const { scrollX, flattenColumns, prefixCls, fixColumn, componentWidth } = useContext$1(TableContext_default, [
		"prefixCls",
		"flattenColumns",
		"fixColumn",
		"componentWidth",
		"scrollX"
	]);
	const { getComponent } = useContext$1(StaticContext, ["getComponent"]);
	const rowInfo = useRowInfo(record, rowKey, index$1, indent);
	const RowComponent = getComponent(["body", "row"], "div");
	const cellComponent = getComponent(["body", "cell"], "div");
	const { rowSupportExpand, expanded, rowProps, expandedRowRender, expandedRowClassName } = rowInfo;
	let expandRowNode;
	if (rowSupportExpand && expanded) {
		const expandContent = expandedRowRender(record, index$1, indent + 1, expanded);
		const expandedClsName = computedExpandedClassName(expandedRowClassName, record, index$1, indent);
		let additionalProps = {};
		if (fixColumn) additionalProps = { style: { ["--virtual-width"]: `${componentWidth}px` } };
		const rowCellCls = `${prefixCls}-expanded-row-cell`;
		expandRowNode = /* @__PURE__ */ import_react.createElement(RowComponent, { className: clsx(`${prefixCls}-expanded-row`, `${prefixCls}-expanded-row-level-${indent + 1}`, expandedClsName) }, /* @__PURE__ */ import_react.createElement(Cell_default, {
			component: cellComponent,
			prefixCls,
			className: clsx(rowCellCls, { [`${rowCellCls}-fixed`]: fixColumn }),
			additionalProps
		}, expandContent));
	}
	const rowStyle = {
		...style$1,
		width: scrollX
	};
	if (extra) {
		rowStyle.position = "absolute";
		rowStyle.pointerEvents = "none";
	}
	const rowNode = /* @__PURE__ */ import_react.createElement(RowComponent, _extends$12({}, rowProps, restProps, {
		"data-row-key": rowKey,
		ref: rowSupportExpand ? null : ref,
		className: clsx(className, `${prefixCls}-row`, rowProps?.className, { [`${prefixCls}-row-extra`]: extra }),
		style: {
			...rowStyle,
			...rowProps?.style
		}
	}), flattenColumns.map((column$1, colIndex) => {
		return /* @__PURE__ */ import_react.createElement(VirtualCell_default, {
			key: colIndex,
			component: cellComponent,
			rowInfo,
			column: column$1,
			colIndex,
			indent,
			index: index$1,
			renderIndex,
			record,
			inverse: extra,
			getHeight: getHeight$1
		});
	}));
	if (rowSupportExpand) return /* @__PURE__ */ import_react.createElement("div", { ref }, rowNode, expandRowNode);
	return rowNode;
}));
ResponseBodyLine.displayName = "BodyLine";
var BodyLine_default = ResponseBodyLine;

//#endregion
//#region node_modules/@rc-component/table/es/VirtualTable/BodyGrid.js
var ResponseGrid = responseImmutable(/* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { data, onScroll } = props;
	const { flattenColumns, onColumnResize, getRowKey, expandedKeys, prefixCls, childrenColumnName, scrollX, direction } = useContext$1(TableContext_default, [
		"flattenColumns",
		"onColumnResize",
		"getRowKey",
		"prefixCls",
		"expandedKeys",
		"childrenColumnName",
		"scrollX",
		"direction"
	]);
	const { sticky, scrollY, listItemHeight, getComponent, onScroll: onTablePropScroll } = useContext$1(StaticContext);
	const listRef = import_react.useRef(null);
	const flattenData$1 = useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey);
	const columnsWidth = import_react.useMemo(() => {
		let total = 0;
		return flattenColumns.map(({ width, minWidth, key }) => {
			const finalWidth = Math.max(width || 0, minWidth || 0);
			total += finalWidth;
			return [
				key,
				finalWidth,
				total
			];
		});
	}, [flattenColumns]);
	const columnsOffset = import_react.useMemo(() => columnsWidth.map((colWidth) => colWidth[2]), [columnsWidth]);
	import_react.useEffect(() => {
		columnsWidth.forEach(([key, width]) => {
			onColumnResize(key, width);
		});
	}, [columnsWidth]);
	import_react.useImperativeHandle(ref, () => {
		const obj = {
			scrollTo: (config) => {
				const { offset: offset$2, ...restConfig } = config;
				if (offset$2) listRef.current?.scrollTo({
					...restConfig,
					offset: offset$2,
					align: "top"
				});
				else listRef.current?.scrollTo(config);
			},
			nativeElement: listRef.current?.nativeElement
		};
		Object.defineProperty(obj, "scrollLeft", {
			get: () => listRef.current?.getScrollInfo().x || 0,
			set: (value) => {
				listRef.current?.scrollTo({ left: value });
			}
		});
		Object.defineProperty(obj, "scrollTop", {
			get: () => listRef.current?.getScrollInfo().y || 0,
			set: (value) => {
				listRef.current?.scrollTo({ top: value });
			}
		});
		return obj;
	});
	const getRowSpan = (column$1, index$1) => {
		const record = flattenData$1[index$1]?.record;
		const { onCell } = column$1;
		if (onCell) return onCell(record, index$1)?.rowSpan ?? 1;
		return 1;
	};
	const extraRender = (info) => {
		const { start, end, getSize: getSize$2, offsetY } = info;
		if (end < 0) return null;
		let firstRowSpanColumns = flattenColumns.filter((column$1) => getRowSpan(column$1, start) === 0);
		let startIndex = start;
		for (let i = start; i >= 0; i -= 1) {
			firstRowSpanColumns = firstRowSpanColumns.filter((column$1) => getRowSpan(column$1, i) === 0);
			if (!firstRowSpanColumns.length) {
				startIndex = i;
				break;
			}
		}
		let lastRowSpanColumns = flattenColumns.filter((column$1) => getRowSpan(column$1, end) !== 1);
		let endIndex = end;
		for (let i = end; i < flattenData$1.length; i += 1) {
			lastRowSpanColumns = lastRowSpanColumns.filter((column$1) => getRowSpan(column$1, i) !== 1);
			if (!lastRowSpanColumns.length) {
				endIndex = Math.max(i - 1, end);
				break;
			}
		}
		const spanLines = [];
		for (let i = startIndex; i <= endIndex; i += 1) {
			if (!flattenData$1[i]) continue;
			if (flattenColumns.some((column$1) => getRowSpan(column$1, i) > 1)) spanLines.push(i);
		}
		return spanLines.map((index$1) => {
			const item = flattenData$1[index$1];
			const rowKey = getRowKey(item.record, index$1);
			const getHeight$1 = (rowSpan) => {
				const endItemIndex = index$1 + rowSpan - 1;
				const endItem = flattenData$1[endItemIndex];
				if (!endItem || !endItem.record) {
					const safeEndIndex = Math.min(endItemIndex, flattenData$1.length - 1);
					const safeEndItem = flattenData$1[safeEndIndex];
					const sizeInfo$2 = getSize$2(rowKey, getRowKey(safeEndItem.record, safeEndIndex));
					return sizeInfo$2.bottom - sizeInfo$2.top;
				}
				const sizeInfo$1 = getSize$2(rowKey, getRowKey(endItem.record, endItemIndex));
				return sizeInfo$1.bottom - sizeInfo$1.top;
			};
			const sizeInfo = getSize$2(rowKey);
			return /* @__PURE__ */ import_react.createElement(BodyLine_default, {
				key: index$1,
				data: item,
				rowKey,
				index: index$1,
				style: { top: -offsetY + sizeInfo.top },
				extra: true,
				getHeight: getHeight$1
			});
		});
	};
	const gridContext = import_react.useMemo(() => ({ columnsOffset }), [columnsOffset]);
	const tblPrefixCls = `${prefixCls}-tbody`;
	const wrapperComponent = getComponent(["body", "wrapper"]);
	const horizontalScrollBarStyle = {};
	if (sticky) {
		horizontalScrollBarStyle.position = "sticky";
		horizontalScrollBarStyle.bottom = 0;
		if (typeof sticky === "object" && sticky.offsetScroll) horizontalScrollBarStyle.bottom = sticky.offsetScroll;
	}
	return /* @__PURE__ */ import_react.createElement(GridContext.Provider, { value: gridContext }, /* @__PURE__ */ import_react.createElement(es_default$8, {
		fullHeight: false,
		ref: listRef,
		prefixCls: `${tblPrefixCls}-virtual`,
		styles: { horizontalScrollBar: horizontalScrollBarStyle },
		className: tblPrefixCls,
		height: scrollY,
		itemHeight: listItemHeight || 24,
		data: flattenData$1,
		itemKey: (item) => getRowKey(item.record),
		component: wrapperComponent,
		scrollWidth: scrollX,
		direction,
		onVirtualScroll: ({ x }) => {
			onScroll({
				currentTarget: listRef.current?.nativeElement,
				scrollLeft: x
			});
		},
		onScroll: onTablePropScroll,
		extraRender
	}, (item, index$1, itemProps) => {
		const rowKey = getRowKey(item.record, index$1);
		return /* @__PURE__ */ import_react.createElement(BodyLine_default, {
			data: item,
			rowKey,
			index: index$1,
			style: itemProps.style
		});
	}));
}));
ResponseGrid.displayName = "ResponseGrid";
var BodyGrid_default = ResponseGrid;

//#endregion
//#region node_modules/@rc-component/table/es/VirtualTable/index.js
function _extends$11() {
	_extends$11 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$11.apply(this, arguments);
}
var renderBody = (rawData, props) => {
	const { ref, onScroll } = props;
	return /* @__PURE__ */ import_react.createElement(BodyGrid_default, {
		ref,
		data: rawData,
		onScroll
	});
};
var VirtualTable = (props, ref) => {
	const { data, columns, scroll, sticky, prefixCls = DEFAULT_PREFIX, className, listItemHeight, components: components$1, onScroll } = props;
	let { x: scrollX, y: scrollY } = scroll || {};
	if (typeof scrollX !== "number") {
		warning_default$1(!scrollX, "`scroll.x` in virtual table must be number.");
		scrollX = 1;
	}
	if (typeof scrollY !== "number") {
		scrollY = 500;
		warning_default$1(false, "`scroll.y` in virtual table must be number.");
	}
	const getComponent = useEvent_default((path$1, defaultComponent) => get(components$1, path$1) || defaultComponent);
	const onInternalScroll = useEvent_default(onScroll);
	const context = import_react.useMemo(() => ({
		sticky,
		scrollY,
		listItemHeight,
		getComponent,
		onScroll: onInternalScroll
	}), [
		sticky,
		scrollY,
		listItemHeight,
		getComponent,
		onInternalScroll
	]);
	return /* @__PURE__ */ import_react.createElement(StaticContext.Provider, { value: context }, /* @__PURE__ */ import_react.createElement(Table_default$1, _extends$11({}, props, {
		className: clsx(className, `${prefixCls}-virtual`),
		scroll: {
			...scroll,
			x: scrollX
		},
		components: {
			...components$1,
			body: data?.length ? renderBody : void 0
		},
		columns,
		internalHooks: INTERNAL_HOOKS,
		tailor: true,
		ref
	})));
};
var RefVirtualTable = /* @__PURE__ */ import_react.forwardRef(VirtualTable);
RefVirtualTable.displayName = "VirtualTable";
const genVirtualTable = (shouldTriggerRender) => {
	return makeImmutable(RefVirtualTable, shouldTriggerRender);
};
var VirtualTable_default$1 = genVirtualTable();

//#endregion
//#region node_modules/antd/es/table/Column.js
/* istanbul ignore next */
/** This is a syntactic sugar for `columns` prop. So HOC will not work on this. */
var Column = (_) => null;
var Column_default = Column;

//#endregion
//#region node_modules/antd/es/table/ColumnGroup.js
/* istanbul ignore next */
/** This is a syntactic sugar for `columns` prop. So HOC will not work on this. */
var ColumnGroup = (_) => null;
var ColumnGroup_default = ColumnGroup;

//#endregion
//#region node_modules/@rc-component/tree/es/contextTypes.js
/**
* Webpack has bug for import loop, which is not the same behavior as ES module.
* When util.js imports the TreeNode for tree generate will cause treeContextTypes be empty.
*/
const TreeContext = /* @__PURE__ */ import_react.createContext(null);
/** Internal usage, safe to remove. Do not use in prod */
const UnstableContext = /* @__PURE__ */ import_react.createContext({});

//#endregion
//#region node_modules/@rc-component/tree/es/Indent.js
var Indent = ({ prefixCls, level, isStart, isEnd }) => {
	const baseClassName = `${prefixCls}-indent-unit`;
	const list = [];
	for (let i = 0; i < level; i += 1) list.push(/* @__PURE__ */ import_react.createElement("span", {
		key: i,
		className: clsx(baseClassName, {
			[`${baseClassName}-start`]: isStart[i],
			[`${baseClassName}-end`]: isEnd[i]
		})
	}));
	return /* @__PURE__ */ import_react.createElement("span", {
		"aria-hidden": "true",
		className: `${prefixCls}-indent`
	}, list);
};
var Indent_default = /* @__PURE__ */ import_react.memo(Indent);

//#endregion
//#region node_modules/@rc-component/tree/es/TreeNode.js
function _extends$10() {
	_extends$10 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$10.apply(this, arguments);
}
var ICON_OPEN = "open";
var ICON_CLOSE = "close";
var defaultTitle = "---";
var TreeNode$1 = (props) => {
	const { eventKey, className, style: style$1, dragOver, dragOverGapTop, dragOverGapBottom, isLeaf: isLeaf$1, isStart, isEnd, expanded, selected, checked, halfChecked, loading, domRef, active, data, onMouseMove, selectable, ...otherProps } = props;
	const context = import_react.useContext(TreeContext);
	const { classNames: treeClassNames, styles } = context || {};
	const unstableContext = import_react.useContext(UnstableContext);
	const selectHandleRef = import_react.useRef(null);
	const [dragNodeHighlight, setDragNodeHighlight] = import_react.useState(false);
	const isDisabled = !!(context.disabled || props.disabled || unstableContext.nodeDisabled?.(data));
	const isCheckable = import_react.useMemo(() => {
		if (!context.checkable || props.checkable === false) return false;
		return context.checkable;
	}, [context.checkable, props.checkable]);
	const onSelect = (e$2) => {
		if (isDisabled) return;
		context.onNodeSelect(e$2, convertNodePropsToEventData(props));
	};
	const onCheck = (e$2) => {
		if (isDisabled) return;
		if (!isCheckable || props.disableCheckbox) return;
		context.onNodeCheck(e$2, convertNodePropsToEventData(props), !checked);
	};
	const isSelectable = import_react.useMemo(() => {
		if (typeof selectable === "boolean") return selectable;
		return context.selectable;
	}, [selectable, context.selectable]);
	const onSelectorClick = (e$2) => {
		context.onNodeClick(e$2, convertNodePropsToEventData(props));
		if (isSelectable) onSelect(e$2);
		else onCheck(e$2);
	};
	const onSelectorDoubleClick = (e$2) => {
		context.onNodeDoubleClick(e$2, convertNodePropsToEventData(props));
	};
	const onMouseEnter = (e$2) => {
		context.onNodeMouseEnter(e$2, convertNodePropsToEventData(props));
	};
	const onMouseLeave = (e$2) => {
		context.onNodeMouseLeave(e$2, convertNodePropsToEventData(props));
	};
	const onContextMenu = (e$2) => {
		context.onNodeContextMenu(e$2, convertNodePropsToEventData(props));
	};
	const isDraggable = import_react.useMemo(() => {
		return !!(context.draggable && (!context.draggable.nodeDraggable || context.draggable.nodeDraggable(data)));
	}, [context.draggable, data]);
	const onDragStart = (e$2) => {
		e$2.stopPropagation();
		setDragNodeHighlight(true);
		context.onNodeDragStart(e$2, props);
		try {
			e$2.dataTransfer.setData("text/plain", "");
		} catch {}
	};
	const onDragEnter = (e$2) => {
		e$2.preventDefault();
		e$2.stopPropagation();
		context.onNodeDragEnter(e$2, props);
	};
	const onDragOver = (e$2) => {
		e$2.preventDefault();
		e$2.stopPropagation();
		context.onNodeDragOver(e$2, props);
	};
	const onDragLeave = (e$2) => {
		e$2.stopPropagation();
		context.onNodeDragLeave(e$2, props);
	};
	const onDragEnd = (e$2) => {
		e$2.stopPropagation();
		setDragNodeHighlight(false);
		context.onNodeDragEnd(e$2, props);
	};
	const onDrop = (e$2) => {
		e$2.preventDefault();
		e$2.stopPropagation();
		setDragNodeHighlight(false);
		context.onNodeDrop(e$2, props);
	};
	const onExpand = (e$2) => {
		if (loading) return;
		context.onNodeExpand(e$2, convertNodePropsToEventData(props));
	};
	const hasChildren = import_react.useMemo(() => {
		const { children } = getEntity(context.keyEntities, eventKey) || {};
		return Boolean((children || []).length);
	}, [context.keyEntities, eventKey]);
	const memoizedIsLeaf = import_react.useMemo(() => {
		if (isLeaf$1 === false) return false;
		return isLeaf$1 || !context.loadData && !hasChildren || context.loadData && props.loaded && !hasChildren;
	}, [
		isLeaf$1,
		context.loadData,
		hasChildren,
		props.loaded
	]);
	import_react.useEffect(() => {
		if (loading) return;
		if (typeof context.loadData === "function" && expanded && !memoizedIsLeaf && !props.loaded) context.onNodeLoad(convertNodePropsToEventData(props));
	}, [
		loading,
		context.loadData,
		context.onNodeLoad,
		expanded,
		memoizedIsLeaf,
		props
	]);
	const dragHandlerNode = import_react.useMemo(() => {
		if (!context.draggable?.icon) return null;
		return /* @__PURE__ */ import_react.createElement("span", { className: `${context.prefixCls}-draggable-icon` }, context.draggable.icon);
	}, [context.draggable]);
	const renderSwitcherIconDom = (isInternalLeaf) => {
		const switcherIcon = props.switcherIcon || context.switcherIcon;
		if (typeof switcherIcon === "function") return switcherIcon({
			...props,
			isLeaf: isInternalLeaf
		});
		return switcherIcon;
	};
	const renderSwitcher = () => {
		if (memoizedIsLeaf) {
			const switcherIconDom$1 = renderSwitcherIconDom(true);
			return switcherIconDom$1 !== false ? /* @__PURE__ */ import_react.createElement("span", { className: clsx(`${context.prefixCls}-switcher`, `${context.prefixCls}-switcher-noop`) }, switcherIconDom$1) : null;
		}
		const switcherIconDom = renderSwitcherIconDom(false);
		return switcherIconDom !== false ? /* @__PURE__ */ import_react.createElement("span", {
			onClick: onExpand,
			className: clsx(`${context.prefixCls}-switcher`, `${context.prefixCls}-switcher_${expanded ? ICON_OPEN : ICON_CLOSE}`)
		}, switcherIconDom) : null;
	};
	const checkboxNode = import_react.useMemo(() => {
		if (!isCheckable) return null;
		const $custom = typeof isCheckable !== "boolean" ? isCheckable : null;
		return /* @__PURE__ */ import_react.createElement("span", {
			className: clsx(`${context.prefixCls}-checkbox`, {
				[`${context.prefixCls}-checkbox-checked`]: checked,
				[`${context.prefixCls}-checkbox-indeterminate`]: !checked && halfChecked,
				[`${context.prefixCls}-checkbox-disabled`]: isDisabled || props.disableCheckbox
			}),
			onClick: onCheck,
			role: "checkbox",
			"aria-checked": halfChecked ? "mixed" : checked,
			"aria-disabled": isDisabled || props.disableCheckbox,
			"aria-label": `Select ${typeof props.title === "string" ? props.title : "tree node"}`
		}, $custom);
	}, [
		isCheckable,
		checked,
		halfChecked,
		isDisabled,
		props.disableCheckbox,
		props.title
	]);
	const nodeState = import_react.useMemo(() => {
		if (memoizedIsLeaf) return null;
		return expanded ? ICON_OPEN : ICON_CLOSE;
	}, [memoizedIsLeaf, expanded]);
	const iconNode = import_react.useMemo(() => {
		return /* @__PURE__ */ import_react.createElement("span", {
			className: clsx(treeClassNames?.itemIcon, `${context.prefixCls}-iconEle`, `${context.prefixCls}-icon__${nodeState || "docu"}`, { [`${context.prefixCls}-icon_loading`]: loading }),
			style: styles?.itemIcon
		});
	}, [
		context.prefixCls,
		nodeState,
		loading
	]);
	const dropIndicatorNode = import_react.useMemo(() => {
		const rootDraggable = Boolean(context.draggable);
		if (!(!props.disabled && rootDraggable && context.dragOverNodeKey === eventKey)) return null;
		return context.dropIndicatorRender({
			dropPosition: context.dropPosition,
			dropLevelOffset: context.dropLevelOffset,
			indent: context.indent,
			prefixCls: context.prefixCls,
			direction: context.direction
		});
	}, [
		context.dropPosition,
		context.dropLevelOffset,
		context.indent,
		context.prefixCls,
		context.direction,
		context.draggable,
		context.dragOverNodeKey,
		context.dropIndicatorRender
	]);
	const selectorNode = import_react.useMemo(() => {
		const { title = defaultTitle } = props;
		const wrapClass = `${context.prefixCls}-node-content-wrapper`;
		let $icon;
		if (context.showIcon) {
			const currentIcon = props.icon || context.icon;
			$icon = currentIcon ? /* @__PURE__ */ import_react.createElement("span", {
				className: clsx(treeClassNames?.itemIcon, `${context.prefixCls}-iconEle`, `${context.prefixCls}-icon__customize`),
				style: styles?.itemIcon
			}, typeof currentIcon === "function" ? currentIcon(props) : currentIcon) : iconNode;
		} else if (context.loadData && loading) $icon = iconNode;
		let titleNode;
		if (typeof title === "function") titleNode = title(data);
		else if (context.titleRender) titleNode = context.titleRender(data);
		else titleNode = title;
		return /* @__PURE__ */ import_react.createElement("span", {
			ref: selectHandleRef,
			title: typeof title === "string" ? title : "",
			className: clsx(wrapClass, `${wrapClass}-${nodeState || "normal"}`, { [`${context.prefixCls}-node-selected`]: !isDisabled && (selected || dragNodeHighlight) }),
			onMouseEnter,
			onMouseLeave,
			onContextMenu,
			onClick: onSelectorClick,
			onDoubleClick: onSelectorDoubleClick
		}, $icon, /* @__PURE__ */ import_react.createElement("span", {
			className: clsx(`${context.prefixCls}-title`, treeClassNames?.itemTitle),
			style: styles?.itemTitle
		}, titleNode), dropIndicatorNode);
	}, [
		context.prefixCls,
		context.showIcon,
		props,
		context.icon,
		iconNode,
		context.titleRender,
		data,
		nodeState,
		onMouseEnter,
		onMouseLeave,
		onContextMenu,
		onSelectorClick,
		onSelectorDoubleClick
	]);
	const dataOrAriaAttributeProps = pickAttrs(otherProps, {
		aria: true,
		data: true
	});
	const { level } = getEntity(context.keyEntities, eventKey) || {};
	const isEndNode = isEnd[isEnd.length - 1];
	const draggableWithoutDisabled = !isDisabled && isDraggable;
	const dragging = context.draggingNodeKey === eventKey;
	const ariaSelected = selectable !== void 0 ? { "aria-selected": !!selectable } : void 0;
	return /* @__PURE__ */ import_react.createElement("div", _extends$10({
		ref: domRef,
		role: "treeitem",
		"aria-expanded": isLeaf$1 ? void 0 : expanded,
		className: clsx(className, `${context.prefixCls}-treenode`, treeClassNames?.item, {
			[`${context.prefixCls}-treenode-disabled`]: isDisabled,
			[`${context.prefixCls}-treenode-switcher-${expanded ? "open" : "close"}`]: !isLeaf$1,
			[`${context.prefixCls}-treenode-checkbox-checked`]: checked,
			[`${context.prefixCls}-treenode-checkbox-indeterminate`]: halfChecked,
			[`${context.prefixCls}-treenode-selected`]: selected,
			[`${context.prefixCls}-treenode-loading`]: loading,
			[`${context.prefixCls}-treenode-active`]: active,
			[`${context.prefixCls}-treenode-leaf-last`]: isEndNode,
			[`${context.prefixCls}-treenode-draggable`]: isDraggable,
			dragging,
			"drop-target": context.dropTargetKey === eventKey,
			"drop-container": context.dropContainerKey === eventKey,
			"drag-over": !isDisabled && dragOver,
			"drag-over-gap-top": !isDisabled && dragOverGapTop,
			"drag-over-gap-bottom": !isDisabled && dragOverGapBottom,
			"filter-node": context.filterTreeNode?.(convertNodePropsToEventData(props)),
			[`${context.prefixCls}-treenode-leaf`]: memoizedIsLeaf
		}),
		style: {
			...style$1,
			...styles?.item
		},
		draggable: draggableWithoutDisabled,
		onDragStart: draggableWithoutDisabled ? onDragStart : void 0,
		onDragEnter: isDraggable ? onDragEnter : void 0,
		onDragOver: isDraggable ? onDragOver : void 0,
		onDragLeave: isDraggable ? onDragLeave : void 0,
		onDrop: isDraggable ? onDrop : void 0,
		onDragEnd: isDraggable ? onDragEnd : void 0,
		onMouseMove
	}, ariaSelected, dataOrAriaAttributeProps), /* @__PURE__ */ import_react.createElement(Indent_default, {
		prefixCls: context.prefixCls,
		level,
		isStart,
		isEnd
	}), dragHandlerNode, renderSwitcher(), checkboxNode, selectorNode);
};
TreeNode$1.isTreeNode = 1;
TreeNode$1.displayName = "TreeNode";
var TreeNode_default$1 = TreeNode$1;

//#endregion
//#region node_modules/@rc-component/tree/es/util.js
/**
* Legacy code. Should avoid to use if you are new to import these code.
*/
function arrDel(list, value) {
	if (!list) return [];
	const clone = list.slice();
	const index$1 = clone.indexOf(value);
	if (index$1 >= 0) clone.splice(index$1, 1);
	return clone;
}
function arrAdd(list, value) {
	const clone = (list || []).slice();
	if (clone.indexOf(value) === -1) clone.push(value);
	return clone;
}
function posToArr(pos) {
	return pos.split("-");
}
function getDragChildrenKeys(dragNodeKey, keyEntities) {
	const dragChildrenKeys = [];
	const entity = getEntity(keyEntities, dragNodeKey);
	function dig(list = []) {
		list.forEach(({ key, children }) => {
			dragChildrenKeys.push(key);
			dig(children);
		});
	}
	dig(entity.children);
	return dragChildrenKeys;
}
function isLastChild(treeNodeEntity) {
	if (treeNodeEntity.parent) {
		const posArr = posToArr(treeNodeEntity.pos);
		return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;
	}
	return false;
}
function isFirstChild(treeNodeEntity) {
	const posArr = posToArr(treeNodeEntity.pos);
	return Number(posArr[posArr.length - 1]) === 0;
}
function calcDropPosition(event, dragNodeProps, targetNodeProps, indent, startMousePosition, allowDrop, flattenedNodes, keyEntities, expandKeys, direction) {
	const { clientX, clientY } = event;
	const { top, height } = event.target.getBoundingClientRect();
	const rawDropLevelOffset = ((direction === "rtl" ? -1 : 1) * ((startMousePosition?.x || 0) - clientX) - 12) / indent;
	const filteredExpandKeys = expandKeys.filter((key) => keyEntities[key]?.children?.length);
	let abstractDropNodeEntity = getEntity(keyEntities, targetNodeProps.eventKey);
	if (clientY < top + height / 2) {
		const nodeIndex = flattenedNodes.findIndex((flattenedNode) => flattenedNode.key === abstractDropNodeEntity.key);
		const prevNodeKey = flattenedNodes[nodeIndex <= 0 ? 0 : nodeIndex - 1].key;
		abstractDropNodeEntity = getEntity(keyEntities, prevNodeKey);
	}
	const initialAbstractDropNodeKey = abstractDropNodeEntity.key;
	const abstractDragOverEntity = abstractDropNodeEntity;
	const dragOverNodeKey = abstractDropNodeEntity.key;
	let dropPosition = 0;
	let dropLevelOffset = 0;
	if (!filteredExpandKeys.includes(initialAbstractDropNodeKey)) for (let i = 0; i < rawDropLevelOffset; i += 1) if (isLastChild(abstractDropNodeEntity)) {
		abstractDropNodeEntity = abstractDropNodeEntity.parent;
		dropLevelOffset += 1;
	} else break;
	const abstractDragDataNode = dragNodeProps.data;
	const abstractDropDataNode = abstractDropNodeEntity.node;
	let dropAllowed = true;
	if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop({
		dragNode: abstractDragDataNode,
		dropNode: abstractDropDataNode,
		dropPosition: -1
	}) && abstractDropNodeEntity.key === targetNodeProps.eventKey) dropPosition = -1;
	else if ((abstractDragOverEntity.children || []).length && filteredExpandKeys.includes(dragOverNodeKey)) if (allowDrop({
		dragNode: abstractDragDataNode,
		dropNode: abstractDropDataNode,
		dropPosition: 0
	})) dropPosition = 0;
	else dropAllowed = false;
	else if (dropLevelOffset === 0) if (rawDropLevelOffset > -1.5) if (allowDrop({
		dragNode: abstractDragDataNode,
		dropNode: abstractDropDataNode,
		dropPosition: 1
	})) dropPosition = 1;
	else dropAllowed = false;
	else if (allowDrop({
		dragNode: abstractDragDataNode,
		dropNode: abstractDropDataNode,
		dropPosition: 0
	})) dropPosition = 0;
	else if (allowDrop({
		dragNode: abstractDragDataNode,
		dropNode: abstractDropDataNode,
		dropPosition: 1
	})) dropPosition = 1;
	else dropAllowed = false;
	else if (allowDrop({
		dragNode: abstractDragDataNode,
		dropNode: abstractDropDataNode,
		dropPosition: 1
	})) dropPosition = 1;
	else dropAllowed = false;
	return {
		dropPosition,
		dropLevelOffset,
		dropTargetKey: abstractDropNodeEntity.key,
		dropTargetPos: abstractDropNodeEntity.pos,
		dragOverNodeKey,
		dropContainerKey: dropPosition === 0 ? null : abstractDropNodeEntity.parent?.key || null,
		dropAllowed
	};
}
/**
* Return selectedKeys according with multiple prop
* @param selectedKeys
* @param props
* @returns [string]
*/
function calcSelectedKeys(selectedKeys, props) {
	if (!selectedKeys) return void 0;
	const { multiple } = props;
	if (multiple) return selectedKeys.slice();
	if (selectedKeys.length) return [selectedKeys[0]];
	return selectedKeys;
}
/**
* Parse `checkedKeys` to { checkedKeys, halfCheckedKeys } style
*/
function parseCheckedKeys(keys$1) {
	if (!keys$1) return null;
	let keyProps;
	if (Array.isArray(keys$1)) keyProps = {
		checkedKeys: keys$1,
		halfCheckedKeys: void 0
	};
	else if (typeof keys$1 === "object") keyProps = {
		checkedKeys: keys$1.checked || void 0,
		halfCheckedKeys: keys$1.halfChecked || void 0
	};
	else {
		warning_default$1(false, "`checkedKeys` is not an array or an object");
		return null;
	}
	return keyProps;
}
/**
* If user use `autoExpandParent` we should get the list of parent node
* @param keyList
* @param keyEntities
*/
function conductExpandParent(keyList, keyEntities) {
	const expandedKeys = /* @__PURE__ */ new Set();
	function conductUp(key) {
		if (expandedKeys.has(key)) return;
		const entity = getEntity(keyEntities, key);
		if (!entity) return;
		expandedKeys.add(key);
		const { parent, node: node$1 } = entity;
		if (node$1.disabled) return;
		if (parent) conductUp(parent.key);
	}
	(keyList || []).forEach((key) => {
		conductUp(key);
	});
	return [...expandedKeys];
}

//#endregion
//#region node_modules/antd/es/table/hooks/useSelection.js
const SELECTION_COLUMN = {};
const SELECTION_ALL = "SELECT_ALL";
const SELECTION_INVERT = "SELECT_INVERT";
const SELECTION_NONE = "SELECT_NONE";
var EMPTY_LIST$1 = [];
var flattenData = (childrenColumnName, data, list = []) => {
	(data || []).forEach((record) => {
		list.push(record);
		if (record && typeof record === "object" && childrenColumnName in record) flattenData(childrenColumnName, record[childrenColumnName], list);
	});
	return list;
};
var useSelection$1 = (config, rowSelection) => {
	const { preserveSelectedRowKeys, selectedRowKeys, defaultSelectedRowKeys, getCheckboxProps, getTitleCheckboxProps, onChange: onSelectionChange, onSelect, onSelectAll, onSelectInvert, onSelectNone, onSelectMultiple, columnWidth: selectionColWidth, type: selectionType, selections, fixed, renderCell: customizeRenderCell, hideSelectAll, checkStrictly = true } = rowSelection || {};
	const { prefixCls, data, pageData, getRecordByKey, getRowKey, expandType, childrenColumnName, locale: tableLocale, getPopupContainer } = config;
	const warning$3 = devUseWarning("Table");
	const [multipleSelect, updatePrevSelectedIndex] = useMultipleSelect((item) => item);
	const [mergedSelectedKeys, setMergedSelectedKeys] = useControlledState(defaultSelectedRowKeys || EMPTY_LIST$1, selectedRowKeys);
	const preserveRecordsRef = import_react.useRef(/* @__PURE__ */ new Map());
	const updatePreserveRecordsCache = (0, import_react.useCallback)((keys$1) => {
		if (preserveSelectedRowKeys) {
			const newCache = /* @__PURE__ */ new Map();
			keys$1.forEach((key) => {
				let record = getRecordByKey(key);
				if (!record && preserveRecordsRef.current.has(key)) record = preserveRecordsRef.current.get(key);
				newCache.set(key, record);
			});
			preserveRecordsRef.current = newCache;
		}
	}, [getRecordByKey, preserveSelectedRowKeys]);
	import_react.useEffect(() => {
		updatePreserveRecordsCache(mergedSelectedKeys);
	}, [mergedSelectedKeys]);
	const flattedData = (0, import_react.useMemo)(() => flattenData(childrenColumnName, pageData), [childrenColumnName, pageData]);
	const { keyEntities } = (0, import_react.useMemo)(() => {
		if (checkStrictly) return { keyEntities: null };
		let convertData = data;
		if (preserveSelectedRowKeys) {
			const keysSet = new Set(flattedData.map(getRowKey));
			const preserveRecords = Array.from(preserveRecordsRef.current).reduce((total, [key, value]) => keysSet.has(key) ? total : total.concat(value), []);
			convertData = [].concat(_toConsumableArray(convertData), _toConsumableArray(preserveRecords));
		}
		return convertDataToEntities(convertData, {
			externalGetKey: getRowKey,
			childrenPropName: childrenColumnName
		});
	}, [
		data,
		getRowKey,
		checkStrictly,
		childrenColumnName,
		preserveSelectedRowKeys,
		flattedData
	]);
	const checkboxPropsMap = (0, import_react.useMemo)(() => {
		const map = /* @__PURE__ */ new Map();
		flattedData.forEach((record, index$1) => {
			const key = getRowKey(record, index$1);
			const checkboxProps = (getCheckboxProps ? getCheckboxProps(record) : null) || {};
			map.set(key, checkboxProps);
			warning$3(!("checked" in checkboxProps || "defaultChecked" in checkboxProps), "usage", "Do not set `checked` or `defaultChecked` in `getCheckboxProps`. Please use `selectedRowKeys` instead.");
		});
		return map;
	}, [
		flattedData,
		getRowKey,
		getCheckboxProps
	]);
	const isCheckboxDisabled = (0, import_react.useCallback)((r$1) => {
		const rowKey = getRowKey(r$1);
		let checkboxProps;
		if (checkboxPropsMap.has(rowKey)) checkboxProps = checkboxPropsMap.get(getRowKey(r$1));
		else checkboxProps = getCheckboxProps ? getCheckboxProps(r$1) : void 0;
		return !!checkboxProps?.disabled;
	}, [checkboxPropsMap, getRowKey]);
	const [derivedSelectedKeys, derivedHalfSelectedKeys] = (0, import_react.useMemo)(() => {
		if (checkStrictly) return [mergedSelectedKeys || [], []];
		const { checkedKeys, halfCheckedKeys } = conductCheck(mergedSelectedKeys, true, keyEntities, isCheckboxDisabled);
		return [checkedKeys || [], halfCheckedKeys];
	}, [
		mergedSelectedKeys,
		checkStrictly,
		keyEntities,
		isCheckboxDisabled
	]);
	const derivedSelectedKeySet = (0, import_react.useMemo)(() => {
		const keys$1 = selectionType === "radio" ? derivedSelectedKeys.slice(0, 1) : derivedSelectedKeys;
		return new Set(keys$1);
	}, [derivedSelectedKeys, selectionType]);
	const derivedHalfSelectedKeySet = (0, import_react.useMemo)(() => selectionType === "radio" ? /* @__PURE__ */ new Set() : new Set(derivedHalfSelectedKeys), [derivedHalfSelectedKeys, selectionType]);
	import_react.useEffect(() => {
		if (!rowSelection) setMergedSelectedKeys(EMPTY_LIST$1);
	}, [!!rowSelection]);
	const setSelectedKeys = (0, import_react.useCallback)((keys$1, method$1) => {
		let availableKeys;
		let records;
		updatePreserveRecordsCache(keys$1);
		if (preserveSelectedRowKeys) {
			availableKeys = keys$1;
			records = keys$1.map((key) => preserveRecordsRef.current.get(key));
		} else {
			availableKeys = [];
			records = [];
			keys$1.forEach((key) => {
				const record = getRecordByKey(key);
				if (record !== void 0) {
					availableKeys.push(key);
					records.push(record);
				}
			});
		}
		setMergedSelectedKeys(availableKeys);
		onSelectionChange?.(availableKeys, records, { type: method$1 });
	}, [
		setMergedSelectedKeys,
		getRecordByKey,
		onSelectionChange,
		preserveSelectedRowKeys
	]);
	const triggerSingleSelection = (0, import_react.useCallback)((key, selected, keys$1, event) => {
		if (onSelect) {
			const rows = keys$1.map((k) => getRecordByKey(k));
			onSelect(getRecordByKey(key), selected, rows, event);
		}
		setSelectedKeys(keys$1, "single");
	}, [
		onSelect,
		getRecordByKey,
		setSelectedKeys
	]);
	const mergedSelections = (0, import_react.useMemo)(() => {
		if (!selections || hideSelectAll) return null;
		return (selections === true ? [
			SELECTION_ALL,
			SELECTION_INVERT,
			SELECTION_NONE
		] : selections).map((selection) => {
			if (selection === SELECTION_ALL) return {
				key: "all",
				text: tableLocale.selectionAll,
				onSelect() {
					setSelectedKeys(data.map((record, index$1) => getRowKey(record, index$1)).filter((key) => {
						return !checkboxPropsMap.get(key)?.disabled || derivedSelectedKeySet.has(key);
					}), "all");
				}
			};
			if (selection === SELECTION_INVERT) return {
				key: "invert",
				text: tableLocale.selectInvert,
				onSelect() {
					const keySet = new Set(derivedSelectedKeySet);
					pageData.forEach((record, index$1) => {
						const key = getRowKey(record, index$1);
						if (!checkboxPropsMap.get(key)?.disabled) if (keySet.has(key)) keySet.delete(key);
						else keySet.add(key);
					});
					const keys$1 = Array.from(keySet);
					if (onSelectInvert) {
						warning$3.deprecated(false, "onSelectInvert", "onChange");
						onSelectInvert(keys$1);
					}
					setSelectedKeys(keys$1, "invert");
				}
			};
			if (selection === SELECTION_NONE) return {
				key: "none",
				text: tableLocale.selectNone,
				onSelect() {
					onSelectNone?.();
					setSelectedKeys(Array.from(derivedSelectedKeySet).filter((key) => {
						return checkboxPropsMap.get(key)?.disabled;
					}), "none");
				}
			};
			return selection;
		}).map((selection) => ({
			...selection,
			onSelect: (...rest) => {
				selection.onSelect?.(...rest);
				updatePrevSelectedIndex(null);
			}
		}));
	}, [
		selections,
		hideSelectAll,
		tableLocale.selectionAll,
		tableLocale.selectInvert,
		tableLocale.selectNone,
		checkboxPropsMap,
		derivedSelectedKeySet,
		data,
		pageData,
		getRowKey,
		onSelectInvert,
		setSelectedKeys
	]);
	return [(0, import_react.useCallback)((columns) => {
		if (!rowSelection) {
			warning$3(!columns.includes(SELECTION_COLUMN), "usage", "`rowSelection` is not config but `SELECTION_COLUMN` exists in the `columns`.");
			return columns.filter((col) => col !== SELECTION_COLUMN);
		}
		let cloneColumns = _toConsumableArray(columns);
		const keySet = new Set(derivedSelectedKeySet);
		const recordKeys = flattedData.map(getRowKey).filter((key) => !checkboxPropsMap.get(key).disabled);
		const checkedCurrentAll = recordKeys.every((key) => keySet.has(key));
		const checkedCurrentSome = recordKeys.some((key) => keySet.has(key));
		const onSelectAllChange = () => {
			const changeKeys = [];
			if (checkedCurrentAll) recordKeys.forEach((key) => {
				keySet.delete(key);
				changeKeys.push(key);
			});
			else recordKeys.forEach((key) => {
				if (!keySet.has(key)) {
					keySet.add(key);
					changeKeys.push(key);
				}
			});
			const keys$1 = Array.from(keySet);
			onSelectAll?.(!checkedCurrentAll, keys$1.map((k) => getRecordByKey(k)), changeKeys.map((k) => getRecordByKey(k)));
			setSelectedKeys(keys$1, "all");
			updatePrevSelectedIndex(null);
		};
		let title;
		let columnTitleCheckbox;
		if (selectionType !== "radio") {
			let customizeSelections;
			if (mergedSelections) {
				const menu = {
					getPopupContainer,
					items: mergedSelections.map((selection, index$1) => {
						const { key, text, onSelect: onSelectionClick } = selection;
						return {
							key: key ?? index$1,
							onClick: () => {
								onSelectionClick?.(recordKeys);
							},
							label: text
						};
					})
				};
				customizeSelections = /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-selection-extra` }, /* @__PURE__ */ import_react.createElement(dropdown_default, {
					menu,
					getPopupContainer
				}, /* @__PURE__ */ import_react.createElement("span", null, /* @__PURE__ */ import_react.createElement(DownOutlined_default, null))));
			}
			const allDisabledData = flattedData.map((record, index$1) => {
				const key = getRowKey(record, index$1);
				const checkboxProps = checkboxPropsMap.get(key) || {};
				return {
					checked: keySet.has(key),
					...checkboxProps
				};
			}).filter(({ disabled: disabled$1 }) => disabled$1);
			const allDisabled = !!allDisabledData.length && allDisabledData.length === flattedData.length;
			const allDisabledAndChecked = allDisabled && allDisabledData.every(({ checked }) => checked);
			const allDisabledSomeChecked = allDisabled && allDisabledData.some(({ checked }) => checked);
			const customCheckboxProps = getTitleCheckboxProps?.() || {};
			const { onChange, disabled } = customCheckboxProps;
			columnTitleCheckbox = /* @__PURE__ */ import_react.createElement(checkbox_default, {
				"aria-label": customizeSelections ? "Custom selection" : "Select all",
				...customCheckboxProps,
				checked: !allDisabled ? !!flattedData.length && checkedCurrentAll : allDisabledAndChecked,
				indeterminate: !allDisabled ? !checkedCurrentAll && checkedCurrentSome : !allDisabledAndChecked && allDisabledSomeChecked,
				onChange: (e$2) => {
					onSelectAllChange();
					onChange?.(e$2);
				},
				disabled: disabled ?? (flattedData.length === 0 || allDisabled),
				skipGroup: true
			});
			title = !hideSelectAll && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-selection` }, columnTitleCheckbox, customizeSelections);
		}
		let renderCell;
		if (selectionType === "radio") renderCell = (_, record, index$1) => {
			const key = getRowKey(record, index$1);
			const checked = keySet.has(key);
			const checkboxProps = checkboxPropsMap.get(key);
			return {
				node: /* @__PURE__ */ import_react.createElement(radio_default, {
					...checkboxProps,
					checked,
					onClick: (e$2) => {
						e$2.stopPropagation();
						checkboxProps?.onClick?.(e$2);
					},
					onChange: (event) => {
						if (!keySet.has(key)) triggerSingleSelection(key, true, [key], event.nativeEvent);
						checkboxProps?.onChange?.(event);
					}
				}),
				checked
			};
		};
		else renderCell = (_, record, index$1) => {
			const key = getRowKey(record, index$1);
			const checked = keySet.has(key);
			const indeterminate = derivedHalfSelectedKeySet.has(key);
			const checkboxProps = checkboxPropsMap.get(key);
			let mergedIndeterminate;
			if (expandType === "nest") {
				mergedIndeterminate = indeterminate;
				warning$3(typeof checkboxProps?.indeterminate !== "boolean", "usage", "set `indeterminate` using `rowSelection.getCheckboxProps` is not allowed with tree structured dataSource.");
			} else mergedIndeterminate = checkboxProps?.indeterminate ?? indeterminate;
			return {
				node: /* @__PURE__ */ import_react.createElement(checkbox_default, {
					...checkboxProps,
					indeterminate: mergedIndeterminate,
					checked,
					skipGroup: true,
					onClick: (e$2) => {
						e$2.stopPropagation();
						checkboxProps?.onClick?.(e$2);
					},
					onChange: (event) => {
						const { nativeEvent } = event;
						const { shiftKey } = nativeEvent;
						const currentSelectedIndex = recordKeys.indexOf(key);
						const isMultiple$1 = derivedSelectedKeys.some((item) => recordKeys.includes(item));
						if (shiftKey && checkStrictly && isMultiple$1) {
							const changedKeys = multipleSelect(currentSelectedIndex, recordKeys, keySet);
							const keys$1 = Array.from(keySet);
							onSelectMultiple?.(!checked, keys$1.map((recordKey) => getRecordByKey(recordKey)), changedKeys.map((recordKey) => getRecordByKey(recordKey)));
							setSelectedKeys(keys$1, "multiple");
						} else {
							const originCheckedKeys = derivedSelectedKeys;
							if (checkStrictly) {
								const checkedKeys = checked ? arrDel(originCheckedKeys, key) : arrAdd(originCheckedKeys, key);
								triggerSingleSelection(key, !checked, checkedKeys, nativeEvent);
							} else {
								const { checkedKeys, halfCheckedKeys } = conductCheck([].concat(_toConsumableArray(originCheckedKeys), [key]), true, keyEntities, isCheckboxDisabled);
								let nextCheckedKeys = checkedKeys;
								if (checked) {
									const tempKeySet = new Set(checkedKeys);
									tempKeySet.delete(key);
									nextCheckedKeys = conductCheck(Array.from(tempKeySet), {
										checked: false,
										halfCheckedKeys
									}, keyEntities, isCheckboxDisabled).checkedKeys;
								}
								triggerSingleSelection(key, !checked, nextCheckedKeys, nativeEvent);
							}
						}
						if (checked) updatePrevSelectedIndex(null);
						else updatePrevSelectedIndex(currentSelectedIndex);
						checkboxProps?.onChange?.(event);
					}
				}),
				checked
			};
		};
		const renderSelectionCell = (_, record, index$1) => {
			const { node: node$1, checked } = renderCell(_, record, index$1);
			if (customizeRenderCell) return customizeRenderCell(checked, record, index$1, node$1);
			return node$1;
		};
		if (!cloneColumns.includes(SELECTION_COLUMN)) if (cloneColumns.findIndex((col) => col[INTERNAL_COL_DEFINE]?.columnType === "EXPAND_COLUMN") === 0) {
			const [expandColumn, ...restColumns] = cloneColumns;
			cloneColumns = [expandColumn, SELECTION_COLUMN].concat(_toConsumableArray(restColumns));
		} else cloneColumns = [SELECTION_COLUMN].concat(_toConsumableArray(cloneColumns));
		const selectionColumnIndex = cloneColumns.indexOf(SELECTION_COLUMN);
		warning$3(cloneColumns.filter((col) => col === SELECTION_COLUMN).length <= 1, "usage", "Multiple `SELECTION_COLUMN` exist in `columns`.");
		cloneColumns = cloneColumns.filter((column$1, index$1) => column$1 !== SELECTION_COLUMN || index$1 === selectionColumnIndex);
		const prevCol = cloneColumns[selectionColumnIndex - 1];
		const nextCol = cloneColumns[selectionColumnIndex + 1];
		let mergedFixed = fixed;
		if (mergedFixed === void 0) {
			if (nextCol?.fixed !== void 0) mergedFixed = nextCol.fixed;
			else if (prevCol?.fixed !== void 0) mergedFixed = prevCol.fixed;
		}
		if (mergedFixed && prevCol && prevCol[INTERNAL_COL_DEFINE]?.columnType === "EXPAND_COLUMN" && prevCol.fixed === void 0) prevCol.fixed = mergedFixed;
		const columnCls = clsx(`${prefixCls}-selection-col`, { [`${prefixCls}-selection-col-with-dropdown`]: selections && selectionType === "checkbox" });
		const renderColumnTitle$1 = () => {
			if (!rowSelection?.columnTitle) return title;
			if (typeof rowSelection.columnTitle === "function") return rowSelection.columnTitle(columnTitleCheckbox);
			return rowSelection.columnTitle;
		};
		const selectionColumn = {
			fixed: mergedFixed,
			width: selectionColWidth,
			className: `${prefixCls}-selection-column`,
			title: renderColumnTitle$1(),
			render: renderSelectionCell,
			onCell: rowSelection.onCell,
			align: rowSelection.align,
			[INTERNAL_COL_DEFINE]: { className: columnCls }
		};
		return cloneColumns.map((col) => col === SELECTION_COLUMN ? selectionColumn : col);
	}, [
		getRowKey,
		flattedData,
		rowSelection,
		derivedSelectedKeys,
		derivedSelectedKeySet,
		derivedHalfSelectedKeySet,
		selectionColWidth,
		mergedSelections,
		expandType,
		checkboxPropsMap,
		onSelectMultiple,
		triggerSingleSelection,
		isCheckboxDisabled
	]), derivedSelectedKeySet];
};
var useSelection_default$1 = useSelection$1;

//#endregion
//#region node_modules/antd/es/table/ExpandIcon.js
function renderExpandIcon(locale$5) {
	return (props) => {
		const { prefixCls, onExpand, record, expanded, expandable } = props;
		const iconPrefix = `${prefixCls}-row-expand-icon`;
		return /* @__PURE__ */ import_react.createElement("button", {
			type: "button",
			onClick: (e$2) => {
				onExpand(record, e$2);
				e$2.stopPropagation();
			},
			className: clsx(iconPrefix, {
				[`${iconPrefix}-spaced`]: !expandable,
				[`${iconPrefix}-expanded`]: expandable && expanded,
				[`${iconPrefix}-collapsed`]: expandable && !expanded
			}),
			"aria-label": expanded ? locale$5.collapse : locale$5.expand,
			"aria-expanded": expanded
		});
	};
}
var ExpandIcon_default = renderExpandIcon;

//#endregion
//#region node_modules/antd/es/table/hooks/useContainerWidth.js
function useContainerWidth(prefixCls) {
	const getContainerWidth = (ele, width) => {
		const container = ele.querySelector(`.${prefixCls}-container`);
		let returnWidth = width;
		if (container) {
			const style$1 = getComputedStyle(container);
			const borderLeft = Number.parseInt(style$1.borderLeftWidth, 10);
			const borderRight = Number.parseInt(style$1.borderRightWidth, 10);
			returnWidth = width - borderLeft - borderRight;
		}
		return returnWidth;
	};
	return getContainerWidth;
}

//#endregion
//#region node_modules/antd/es/table/util.js
const getColumnKey = (column$1, defaultKey) => {
	if ("key" in column$1 && column$1.key !== void 0 && column$1.key !== null) return column$1.key;
	if (column$1.dataIndex) return Array.isArray(column$1.dataIndex) ? column$1.dataIndex.join(".") : column$1.dataIndex;
	return defaultKey;
};
function getColumnPos(index$1, pos) {
	return pos ? `${pos}-${index$1}` : `${index$1}`;
}
const renderColumnTitle = (title, props) => {
	if (typeof title === "function") return title(props);
	return title;
};
/**
* Safe get column title
*
* Should filter [object Object]
*
* @param title
*/
const safeColumnTitle = (title, props) => {
	const res = renderColumnTitle(title, props);
	if (Object.prototype.toString.call(res) === "[object Object]") return "";
	return res;
};

//#endregion
//#region node_modules/@rc-component/tree/es/DropIndicator.js
var DropIndicator = (props) => {
	const { dropPosition, dropLevelOffset, indent } = props;
	const style$1 = {
		pointerEvents: "none",
		position: "absolute",
		right: 0,
		backgroundColor: "red",
		height: 2
	};
	switch (dropPosition) {
		case -1:
			style$1.top = 0;
			style$1.left = -dropLevelOffset * indent;
			break;
		case 1:
			style$1.bottom = 0;
			style$1.left = -dropLevelOffset * indent;
			break;
		case 0:
			style$1.bottom = 0;
			style$1.left = indent;
			break;
	}
	return /* @__PURE__ */ import_react.createElement("div", { style: style$1 });
};
DropIndicator.displayName = "DropIndicator";
var DropIndicator_default = DropIndicator;

//#endregion
//#region node_modules/@rc-component/tree/es/useUnmount.js
/**
* Trigger only when component unmount
*/
function useUnmount(triggerStart, triggerEnd) {
	const [firstMount, setFirstMount] = import_react.useState(false);
	useLayoutEffect_default(() => {
		if (firstMount) {
			triggerStart();
			return () => {
				triggerEnd();
			};
		}
	}, [firstMount]);
	useLayoutEffect_default(() => {
		setFirstMount(true);
		return () => {
			setFirstMount(false);
		};
	}, []);
}
var useUnmount_default = useUnmount;

//#endregion
//#region node_modules/@rc-component/tree/es/MotionTreeNode.js
function _extends$9() {
	_extends$9 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$9.apply(this, arguments);
}
var MotionTreeNode = /* @__PURE__ */ import_react.forwardRef((oriProps, ref) => {
	const { className, style: style$1, motion: motion$1, motionNodes, motionType, onMotionStart: onOriginMotionStart, onMotionEnd: onOriginMotionEnd, active, treeNodeRequiredProps, ...props } = oriProps;
	const [visible, setVisible] = import_react.useState(true);
	const { prefixCls } = import_react.useContext(TreeContext);
	const targetVisible = motionNodes && motionType !== "hide";
	useLayoutEffect_default(() => {
		if (motionNodes) {
			if (targetVisible !== visible) setVisible(targetVisible);
		}
	}, [motionNodes]);
	const triggerMotionStart = () => {
		if (motionNodes) onOriginMotionStart();
	};
	const triggerMotionEndRef = import_react.useRef(false);
	const triggerMotionEnd = () => {
		if (motionNodes && !triggerMotionEndRef.current) {
			triggerMotionEndRef.current = true;
			onOriginMotionEnd();
		}
	};
	useUnmount_default(triggerMotionStart, triggerMotionEnd);
	const onVisibleChanged = (nextVisible) => {
		if (targetVisible === nextVisible) triggerMotionEnd();
	};
	if (motionNodes) return /* @__PURE__ */ import_react.createElement(es_default$1, _extends$9({
		ref,
		visible
	}, motion$1, {
		motionAppear: motionType === "show",
		onVisibleChanged
	}), ({ className: motionClassName, style: motionStyle }, motionRef) => /* @__PURE__ */ import_react.createElement("div", {
		ref: motionRef,
		className: clsx(`${prefixCls}-treenode-motion`, motionClassName),
		style: motionStyle
	}, motionNodes.map((treeNode) => {
		const { data: { ...restProps }, title, key, isStart, isEnd } = treeNode;
		delete restProps.children;
		const treeNodeProps = getTreeNodeProps(key, treeNodeRequiredProps);
		return /* @__PURE__ */ import_react.createElement(TreeNode_default$1, _extends$9({}, restProps, treeNodeProps, {
			title,
			active,
			data: treeNode.data,
			key,
			isStart,
			isEnd
		}));
	})));
	return /* @__PURE__ */ import_react.createElement(TreeNode_default$1, _extends$9({
		domRef: ref,
		className,
		style: style$1
	}, props, { active }));
});
MotionTreeNode.displayName = "MotionTreeNode";
var MotionTreeNode_default = MotionTreeNode;

//#endregion
//#region node_modules/@rc-component/tree/es/utils/diffUtil.js
function findExpandedKeys(prev$1 = [], next$1 = []) {
	const prevLen = prev$1.length;
	const nextLen = next$1.length;
	if (Math.abs(prevLen - nextLen) !== 1) return {
		add: false,
		key: null
	};
	function find(shorter, longer) {
		const cache = /* @__PURE__ */ new Map();
		shorter.forEach((key) => {
			cache.set(key, true);
		});
		const keys$1 = longer.filter((key) => !cache.has(key));
		return keys$1.length === 1 ? keys$1[0] : null;
	}
	if (prevLen < nextLen) return {
		add: true,
		key: find(prev$1, next$1)
	};
	return {
		add: false,
		key: find(next$1, prev$1)
	};
}
function getExpandRange(shorter, longer, key) {
	const shorterEndNode = shorter[shorter.findIndex((data) => data.key === key) + 1];
	const longerStartIndex = longer.findIndex((data) => data.key === key);
	if (shorterEndNode) {
		const longerEndIndex = longer.findIndex((data) => data.key === shorterEndNode.key);
		return longer.slice(longerStartIndex + 1, longerEndIndex);
	}
	return longer.slice(longerStartIndex + 1);
}

//#endregion
//#region node_modules/@rc-component/tree/es/NodeList.js
/**
* Handle virtual list of the TreeNodes.
*/
function _extends$8() {
	_extends$8 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$8.apply(this, arguments);
}
var HIDDEN_STYLE$1 = {
	width: 0,
	height: 0,
	display: "flex",
	overflow: "hidden",
	opacity: 0,
	border: 0,
	padding: 0,
	margin: 0
};
var noop = () => {};
const MOTION_KEY = `RC_TREE_MOTION_${Math.random()}`;
var MotionNode = { key: MOTION_KEY };
const MotionEntity = {
	key: MOTION_KEY,
	level: 0,
	index: 0,
	pos: "0",
	node: MotionNode,
	nodes: [MotionNode]
};
var MotionFlattenData = {
	parent: null,
	children: [],
	pos: MotionEntity.pos,
	data: MotionNode,
	title: null,
	key: MOTION_KEY,
	isStart: [],
	isEnd: []
};
/**
* We only need get visible content items to play the animation.
*/
function getMinimumRangeTransitionRange(list, virtual, height, itemHeight) {
	if (virtual === false || !height) return list;
	return list.slice(0, Math.ceil(height / itemHeight) + 1);
}
function itemKey(item) {
	const { key, pos } = item;
	return getKey(key, pos);
}
function getAccessibilityPath(item) {
	let path$1 = String(item.data.key);
	let current = item;
	while (current.parent) {
		current = current.parent;
		path$1 = `${current.data.key} > ${path$1}`;
	}
	return path$1;
}
var NodeList = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls, data, selectable, checkable, expandedKeys, selectedKeys, checkedKeys, loadedKeys, loadingKeys, halfCheckedKeys, keyEntities, disabled, dragging, dragOverNodeKey, dropPosition, motion: motion$1, height, itemHeight, virtual, scrollWidth, focusable: focusable$1, activeItem, focused, tabIndex, onKeyDown: onKeyDown$1, onFocus, onBlur, onActiveChange, onListChangeStart, onListChangeEnd, ...domProps } = props;
	const listRef = import_react.useRef(null);
	const indentMeasurerRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => ({
		scrollTo: (scroll) => {
			listRef.current.scrollTo(scroll);
		},
		getIndentWidth: () => indentMeasurerRef.current.offsetWidth
	}));
	const [prevExpandedKeys, setPrevExpandedKeys] = import_react.useState(expandedKeys);
	const [prevData, setPrevData] = import_react.useState(data);
	const [transitionData, setTransitionData] = import_react.useState(data);
	const [transitionRange, setTransitionRange] = import_react.useState([]);
	const [motionType, setMotionType] = import_react.useState(null);
	const dataRef = import_react.useRef(data);
	dataRef.current = data;
	function onMotionEnd() {
		const latestData = dataRef.current;
		setPrevData(latestData);
		setTransitionData(latestData);
		setTransitionRange([]);
		setMotionType(null);
		onListChangeEnd();
	}
	useLayoutEffect_default(() => {
		setPrevExpandedKeys(expandedKeys);
		const diffExpanded = findExpandedKeys(prevExpandedKeys, expandedKeys);
		if (diffExpanded.key !== null) if (diffExpanded.add) {
			const keyIndex$1 = prevData.findIndex(({ key }) => key === diffExpanded.key);
			const rangeNodes = getMinimumRangeTransitionRange(getExpandRange(prevData, data, diffExpanded.key), virtual, height, itemHeight);
			const newTransitionData = prevData.slice();
			newTransitionData.splice(keyIndex$1 + 1, 0, MotionFlattenData);
			setTransitionData(newTransitionData);
			setTransitionRange(rangeNodes);
			setMotionType("show");
		} else {
			const keyIndex$1 = data.findIndex(({ key }) => key === diffExpanded.key);
			const rangeNodes = getMinimumRangeTransitionRange(getExpandRange(data, prevData, diffExpanded.key), virtual, height, itemHeight);
			const newTransitionData = data.slice();
			newTransitionData.splice(keyIndex$1 + 1, 0, MotionFlattenData);
			setTransitionData(newTransitionData);
			setTransitionRange(rangeNodes);
			setMotionType("hide");
		}
		else if (prevData !== data) {
			setPrevData(data);
			setTransitionData(data);
		}
	}, [expandedKeys, data]);
	import_react.useEffect(() => {
		if (!dragging) onMotionEnd();
	}, [dragging]);
	const mergedData = motion$1 ? transitionData : data;
	const treeNodeRequiredProps = {
		expandedKeys,
		selectedKeys,
		loadedKeys,
		loadingKeys,
		checkedKeys,
		halfCheckedKeys,
		dragOverNodeKey,
		dropPosition,
		keyEntities
	};
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, focused && activeItem && /* @__PURE__ */ import_react.createElement("span", {
		style: HIDDEN_STYLE$1,
		"aria-live": "assertive"
	}, getAccessibilityPath(activeItem)), /* @__PURE__ */ import_react.createElement("div", null, /* @__PURE__ */ import_react.createElement("input", {
		style: HIDDEN_STYLE$1,
		disabled: focusable$1 === false || disabled,
		tabIndex: focusable$1 !== false ? tabIndex : null,
		onKeyDown: onKeyDown$1,
		onFocus,
		onBlur,
		value: "",
		onChange: noop,
		"aria-label": "for screen reader"
	})), /* @__PURE__ */ import_react.createElement("div", {
		className: `${prefixCls}-treenode`,
		"aria-hidden": true,
		style: {
			position: "absolute",
			pointerEvents: "none",
			visibility: "hidden",
			height: 0,
			overflow: "hidden",
			border: 0,
			padding: 0
		}
	}, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-indent` }, /* @__PURE__ */ import_react.createElement("div", {
		ref: indentMeasurerRef,
		className: `${prefixCls}-indent-unit`
	}))), /* @__PURE__ */ import_react.createElement(es_default$8, _extends$8({}, domProps, {
		data: mergedData,
		itemKey,
		height,
		fullHeight: false,
		virtual,
		itemHeight,
		scrollWidth,
		prefixCls: `${prefixCls}-list`,
		ref: listRef,
		role: "tree",
		onVisibleChange: (originList) => {
			if (originList.every((item) => itemKey(item) !== MOTION_KEY)) onMotionEnd();
		}
	}), (treeNode) => {
		const { pos, data: { ...restProps }, title, key, isStart, isEnd } = treeNode;
		const mergedKey = getKey(key, pos);
		delete restProps.key;
		delete restProps.children;
		const treeNodeProps = getTreeNodeProps(mergedKey, treeNodeRequiredProps);
		return /* @__PURE__ */ import_react.createElement(MotionTreeNode_default, _extends$8({}, restProps, treeNodeProps, {
			title,
			active: !!activeItem && key === activeItem.key,
			pos,
			data: treeNode.data,
			isStart,
			isEnd,
			motion: motion$1,
			motionNodes: key === MOTION_KEY ? transitionRange : null,
			motionType,
			onMotionStart: onListChangeStart,
			onMotionEnd,
			treeNodeRequiredProps,
			onMouseMove: () => {
				onActiveChange(null);
			}
		}));
	}));
});
NodeList.displayName = "NodeList";
var NodeList_default = NodeList;

//#endregion
//#region node_modules/@rc-component/tree/es/Tree.js
function _extends$7() {
	_extends$7 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$7.apply(this, arguments);
}
var MAX_RETRY_TIMES = 10;
var Tree$2 = class extends import_react.Component {
	static defaultProps = {
		prefixCls: "rc-tree",
		showLine: false,
		showIcon: true,
		selectable: true,
		multiple: false,
		checkable: false,
		disabled: false,
		checkStrictly: false,
		draggable: false,
		defaultExpandParent: true,
		autoExpandParent: false,
		defaultExpandAll: false,
		defaultExpandedKeys: [],
		defaultCheckedKeys: [],
		defaultSelectedKeys: [],
		dropIndicatorRender: DropIndicator_default,
		allowDrop: () => true,
		expandAction: false
	};
	static TreeNode = TreeNode_default$1;
	destroyed = false;
	delayedDragEnterLogic;
	loadingRetryTimes = {};
	state = {
		keyEntities: {},
		indent: null,
		selectedKeys: [],
		checkedKeys: [],
		halfCheckedKeys: [],
		loadedKeys: [],
		loadingKeys: [],
		expandedKeys: [],
		draggingNodeKey: null,
		dragChildrenKeys: [],
		dropTargetKey: null,
		dropPosition: null,
		dropContainerKey: null,
		dropLevelOffset: null,
		dropTargetPos: null,
		dropAllowed: true,
		dragOverNodeKey: null,
		treeData: [],
		flattenNodes: [],
		focused: false,
		activeKey: null,
		listChanging: false,
		prevProps: null,
		fieldNames: fillFieldNames$1()
	};
	dragStartMousePosition = null;
	dragNodeProps = null;
	currentMouseOverDroppableNodeKey = null;
	listRef = /* @__PURE__ */ import_react.createRef();
	componentDidMount() {
		this.destroyed = false;
		this.onUpdated();
	}
	componentDidUpdate() {
		this.onUpdated();
	}
	onUpdated() {
		const { activeKey, itemScrollOffset = 0 } = this.props;
		if (activeKey !== void 0 && activeKey !== this.state.activeKey) {
			this.setState({ activeKey });
			if (activeKey !== null) this.scrollTo({
				key: activeKey,
				offset: itemScrollOffset
			});
		}
	}
	componentWillUnmount() {
		window.removeEventListener("dragend", this.onWindowDragEnd);
		this.destroyed = true;
	}
	static getDerivedStateFromProps(props, prevState) {
		const { prevProps } = prevState;
		const newState = { prevProps: props };
		function needSync(name) {
			return !prevProps && props.hasOwnProperty(name) || prevProps && prevProps[name] !== props[name];
		}
		let treeData;
		let { fieldNames } = prevState;
		if (needSync("fieldNames")) {
			fieldNames = fillFieldNames$1(props.fieldNames);
			newState.fieldNames = fieldNames;
		}
		if (needSync("treeData")) ({treeData} = props);
		else if (needSync("children")) {
			warning_default$1(false, "`children` of Tree is deprecated. Please use `treeData` instead.");
			treeData = convertTreeToData(props.children);
		}
		if (treeData) {
			newState.treeData = treeData;
			const entitiesMap = convertDataToEntities(treeData, { fieldNames });
			newState.keyEntities = {
				[MOTION_KEY]: MotionEntity,
				...entitiesMap.keyEntities
			};
			warningWithoutKey(treeData, fieldNames);
		}
		const keyEntities = newState.keyEntities || prevState.keyEntities;
		if (needSync("expandedKeys") || prevProps && needSync("autoExpandParent")) newState.expandedKeys = props.autoExpandParent || !prevProps && props.defaultExpandParent ? conductExpandParent(props.expandedKeys, keyEntities) : props.expandedKeys;
		else if (!prevProps && props.defaultExpandAll) {
			const cloneKeyEntities = { ...keyEntities };
			delete cloneKeyEntities[MOTION_KEY];
			const nextExpandedKeys = [];
			Object.keys(cloneKeyEntities).forEach((key) => {
				const entity = cloneKeyEntities[key];
				if (entity.children && entity.children.length) nextExpandedKeys.push(entity.key);
			});
			newState.expandedKeys = nextExpandedKeys;
		} else if (!prevProps && props.defaultExpandedKeys) newState.expandedKeys = props.autoExpandParent || props.defaultExpandParent ? conductExpandParent(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys;
		if (!newState.expandedKeys) delete newState.expandedKeys;
		if (treeData || newState.expandedKeys) newState.flattenNodes = flattenTreeData(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys, fieldNames);
		if (props.selectable) {
			if (needSync("selectedKeys")) newState.selectedKeys = calcSelectedKeys(props.selectedKeys, props);
			else if (!prevProps && props.defaultSelectedKeys) newState.selectedKeys = calcSelectedKeys(props.defaultSelectedKeys, props);
		}
		if (props.checkable) {
			let checkedKeyEntity;
			if (needSync("checkedKeys")) checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {};
			else if (!prevProps && props.defaultCheckedKeys) checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {};
			else if (treeData) checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {
				checkedKeys: prevState.checkedKeys,
				halfCheckedKeys: prevState.halfCheckedKeys
			};
			if (checkedKeyEntity) {
				let { checkedKeys = [], halfCheckedKeys = [] } = checkedKeyEntity;
				if (!props.checkStrictly) {
					const conductKeys = conductCheck(checkedKeys, true, keyEntities);
					({checkedKeys, halfCheckedKeys} = conductKeys);
				}
				newState.checkedKeys = checkedKeys;
				newState.halfCheckedKeys = halfCheckedKeys;
			}
		}
		if (needSync("loadedKeys")) newState.loadedKeys = props.loadedKeys;
		return newState;
	}
	onNodeDragStart = (event, nodeProps) => {
		const { expandedKeys, keyEntities } = this.state;
		const { onDragStart } = this.props;
		const { eventKey } = nodeProps;
		this.dragNodeProps = nodeProps;
		this.dragStartMousePosition = {
			x: event.clientX,
			y: event.clientY
		};
		const newExpandedKeys = arrDel(expandedKeys, eventKey);
		this.setState({
			draggingNodeKey: eventKey,
			dragChildrenKeys: getDragChildrenKeys(eventKey, keyEntities),
			indent: this.listRef.current.getIndentWidth()
		});
		this.setExpandedKeys(newExpandedKeys);
		window.addEventListener("dragend", this.onWindowDragEnd);
		onDragStart?.({
			event,
			node: convertNodePropsToEventData(nodeProps)
		});
	};
	/**
	* [Legacy] Select handler is smaller than node,
	* so that this will trigger when drag enter node or select handler.
	* This is a little tricky if customize css without padding.
	* Better for use mouse move event to refresh drag state.
	* But let's just keep it to avoid event trigger logic change.
	*/
	onNodeDragEnter = (event, nodeProps) => {
		const { expandedKeys, keyEntities, dragChildrenKeys, flattenNodes, indent } = this.state;
		const { onDragEnter, onExpand, allowDrop, direction } = this.props;
		const { pos, eventKey } = nodeProps;
		if (this.currentMouseOverDroppableNodeKey !== eventKey) this.currentMouseOverDroppableNodeKey = eventKey;
		if (!this.dragNodeProps) {
			this.resetDragState();
			return;
		}
		const { dropPosition, dropLevelOffset, dropTargetKey, dropContainerKey, dropTargetPos, dropAllowed, dragOverNodeKey } = calcDropPosition(event, this.dragNodeProps, nodeProps, indent, this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction);
		if (dragChildrenKeys.includes(dropTargetKey) || !dropAllowed) {
			this.resetDragState();
			return;
		}
		if (!this.delayedDragEnterLogic) this.delayedDragEnterLogic = {};
		Object.keys(this.delayedDragEnterLogic).forEach((key) => {
			clearTimeout(this.delayedDragEnterLogic[key]);
		});
		if (this.dragNodeProps.eventKey !== nodeProps.eventKey) {
			event.persist();
			this.delayedDragEnterLogic[pos] = window.setTimeout(() => {
				if (this.state.draggingNodeKey === null) return;
				let newExpandedKeys = [...expandedKeys];
				const entity = getEntity(keyEntities, nodeProps.eventKey);
				if (entity && (entity.children || []).length) newExpandedKeys = arrAdd(expandedKeys, nodeProps.eventKey);
				if (!this.props.hasOwnProperty("expandedKeys")) this.setExpandedKeys(newExpandedKeys);
				onExpand?.(newExpandedKeys, {
					node: convertNodePropsToEventData(nodeProps),
					expanded: true,
					nativeEvent: event.nativeEvent
				});
			}, 800);
		}
		if (this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {
			this.resetDragState();
			return;
		}
		this.setState({
			dragOverNodeKey,
			dropPosition,
			dropLevelOffset,
			dropTargetKey,
			dropContainerKey,
			dropTargetPos,
			dropAllowed
		});
		onDragEnter?.({
			event,
			node: convertNodePropsToEventData(nodeProps),
			expandedKeys
		});
	};
	onNodeDragOver = (event, nodeProps) => {
		const { dragChildrenKeys, flattenNodes, keyEntities, expandedKeys, indent } = this.state;
		const { onDragOver, allowDrop, direction } = this.props;
		if (!this.dragNodeProps) return;
		const { dropPosition, dropLevelOffset, dropTargetKey, dropContainerKey, dropTargetPos, dropAllowed, dragOverNodeKey } = calcDropPosition(event, this.dragNodeProps, nodeProps, indent, this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction);
		if (dragChildrenKeys.includes(dropTargetKey) || !dropAllowed) return;
		if (this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {
			if (!(this.state.dropPosition === null && this.state.dropLevelOffset === null && this.state.dropTargetKey === null && this.state.dropContainerKey === null && this.state.dropTargetPos === null && this.state.dropAllowed === false && this.state.dragOverNodeKey === null)) this.resetDragState();
		} else if (!(dropPosition === this.state.dropPosition && dropLevelOffset === this.state.dropLevelOffset && dropTargetKey === this.state.dropTargetKey && dropContainerKey === this.state.dropContainerKey && dropTargetPos === this.state.dropTargetPos && dropAllowed === this.state.dropAllowed && dragOverNodeKey === this.state.dragOverNodeKey)) this.setState({
			dropPosition,
			dropLevelOffset,
			dropTargetKey,
			dropContainerKey,
			dropTargetPos,
			dropAllowed,
			dragOverNodeKey
		});
		onDragOver?.({
			event,
			node: convertNodePropsToEventData(nodeProps)
		});
	};
	onNodeDragLeave = (event, nodeProps) => {
		if (this.currentMouseOverDroppableNodeKey === nodeProps.eventKey && !event.currentTarget.contains(event.relatedTarget)) {
			this.resetDragState();
			this.currentMouseOverDroppableNodeKey = null;
		}
		const { onDragLeave } = this.props;
		onDragLeave?.({
			event,
			node: convertNodePropsToEventData(nodeProps)
		});
	};
	onWindowDragEnd = (event) => {
		this.onNodeDragEnd(event, null, true);
		window.removeEventListener("dragend", this.onWindowDragEnd);
	};
	onNodeDragEnd = (event, nodeProps) => {
		const { onDragEnd } = this.props;
		this.setState({ dragOverNodeKey: null });
		this.cleanDragState();
		onDragEnd?.({
			event,
			node: convertNodePropsToEventData(nodeProps)
		});
		this.dragNodeProps = null;
		window.removeEventListener("dragend", this.onWindowDragEnd);
	};
	onNodeDrop = (event, _, outsideTree = false) => {
		const { dragChildrenKeys, dropPosition, dropTargetKey, dropTargetPos, dropAllowed } = this.state;
		if (!dropAllowed) return;
		const { onDrop } = this.props;
		this.setState({ dragOverNodeKey: null });
		this.cleanDragState();
		if (dropTargetKey === null) return;
		const abstractDropNodeProps = {
			...getTreeNodeProps(dropTargetKey, this.getTreeNodeRequiredProps()),
			active: this.getActiveItem()?.key === dropTargetKey,
			data: getEntity(this.state.keyEntities, dropTargetKey).node
		};
		warning_default$1(!dragChildrenKeys.includes(dropTargetKey), "Can not drop to dragNode's children node. This is a bug of rc-tree. Please report an issue.");
		const posArr = posToArr(dropTargetPos);
		const dropResult = {
			event,
			node: convertNodePropsToEventData(abstractDropNodeProps),
			dragNode: this.dragNodeProps ? convertNodePropsToEventData(this.dragNodeProps) : null,
			dragNodesKeys: [this.dragNodeProps.eventKey].concat(dragChildrenKeys),
			dropToGap: dropPosition !== 0,
			dropPosition: dropPosition + Number(posArr[posArr.length - 1])
		};
		if (!outsideTree) onDrop?.(dropResult);
		this.dragNodeProps = null;
	};
	resetDragState() {
		this.setState({
			dragOverNodeKey: null,
			dropPosition: null,
			dropLevelOffset: null,
			dropTargetKey: null,
			dropContainerKey: null,
			dropTargetPos: null,
			dropAllowed: false
		});
	}
	cleanDragState = () => {
		const { draggingNodeKey } = this.state;
		if (draggingNodeKey !== null) this.setState({
			draggingNodeKey: null,
			dropPosition: null,
			dropContainerKey: null,
			dropTargetKey: null,
			dropLevelOffset: null,
			dropAllowed: true,
			dragOverNodeKey: null
		});
		this.dragStartMousePosition = null;
		this.currentMouseOverDroppableNodeKey = null;
	};
	triggerExpandActionExpand = (e$2, treeNode) => {
		const { expandedKeys, flattenNodes } = this.state;
		const { expanded, key, isLeaf: isLeaf$1 } = treeNode;
		if (isLeaf$1 || e$2.shiftKey || e$2.metaKey || e$2.ctrlKey) return;
		const node$1 = flattenNodes.filter((nodeItem) => nodeItem.key === key)[0];
		const eventNode = convertNodePropsToEventData({
			...getTreeNodeProps(key, this.getTreeNodeRequiredProps()),
			data: node$1.data
		});
		this.setExpandedKeys(expanded ? arrDel(expandedKeys, key) : arrAdd(expandedKeys, key));
		this.onNodeExpand(e$2, eventNode);
	};
	onNodeClick = (e$2, treeNode) => {
		const { onClick, expandAction } = this.props;
		if (expandAction === "click") this.triggerExpandActionExpand(e$2, treeNode);
		onClick?.(e$2, treeNode);
	};
	onNodeDoubleClick = (e$2, treeNode) => {
		const { onDoubleClick, expandAction } = this.props;
		if (expandAction === "doubleClick") this.triggerExpandActionExpand(e$2, treeNode);
		onDoubleClick?.(e$2, treeNode);
	};
	onNodeSelect = (e$2, treeNode) => {
		let { selectedKeys } = this.state;
		const { keyEntities, fieldNames } = this.state;
		const { onSelect, multiple } = this.props;
		const { selected } = treeNode;
		const key = treeNode[fieldNames.key];
		const targetSelected = !selected;
		if (!targetSelected) selectedKeys = arrDel(selectedKeys, key);
		else if (!multiple) selectedKeys = [key];
		else selectedKeys = arrAdd(selectedKeys, key);
		const selectedNodes = selectedKeys.map((selectedKey) => {
			const entity = getEntity(keyEntities, selectedKey);
			return entity ? entity.node : null;
		}).filter(Boolean);
		this.setUncontrolledState({ selectedKeys });
		onSelect?.(selectedKeys, {
			event: "select",
			selected: targetSelected,
			node: treeNode,
			selectedNodes,
			nativeEvent: e$2.nativeEvent
		});
	};
	onNodeCheck = (e$2, treeNode, checked) => {
		const { keyEntities, checkedKeys: oriCheckedKeys, halfCheckedKeys: oriHalfCheckedKeys } = this.state;
		const { checkStrictly, onCheck } = this.props;
		const { key } = treeNode;
		let checkedObj;
		const eventObj = {
			event: "check",
			node: treeNode,
			checked,
			nativeEvent: e$2.nativeEvent
		};
		if (checkStrictly) {
			const checkedKeys = checked ? arrAdd(oriCheckedKeys, key) : arrDel(oriCheckedKeys, key);
			checkedObj = {
				checked: checkedKeys,
				halfChecked: arrDel(oriHalfCheckedKeys, key)
			};
			eventObj.checkedNodes = checkedKeys.map((checkedKey) => getEntity(keyEntities, checkedKey)).filter(Boolean).map((entity) => entity.node);
			this.setUncontrolledState({ checkedKeys });
		} else {
			let { checkedKeys, halfCheckedKeys } = conductCheck([...oriCheckedKeys, key], true, keyEntities);
			if (!checked) {
				const keySet = new Set(checkedKeys);
				keySet.delete(key);
				({checkedKeys, halfCheckedKeys} = conductCheck(Array.from(keySet), {
					checked: false,
					halfCheckedKeys
				}, keyEntities));
			}
			checkedObj = checkedKeys;
			eventObj.checkedNodes = [];
			eventObj.checkedNodesPositions = [];
			eventObj.halfCheckedKeys = halfCheckedKeys;
			checkedKeys.forEach((checkedKey) => {
				const entity = getEntity(keyEntities, checkedKey);
				if (!entity) return;
				const { node: node$1, pos } = entity;
				eventObj.checkedNodes.push(node$1);
				eventObj.checkedNodesPositions.push({
					node: node$1,
					pos
				});
			});
			this.setUncontrolledState({ checkedKeys }, false, { halfCheckedKeys });
		}
		onCheck?.(checkedObj, eventObj);
	};
	onNodeLoad = (treeNode) => {
		const { key } = treeNode;
		const { keyEntities } = this.state;
		if (getEntity(keyEntities, key)?.children?.length) return;
		const loadPromise = new Promise((resolve, reject) => {
			this.setState(({ loadedKeys = [], loadingKeys = [] }) => {
				const { loadData, onLoad } = this.props;
				if (!loadData || loadedKeys.includes(key) || loadingKeys.includes(key)) return null;
				loadData(treeNode).then(() => {
					const { loadedKeys: currentLoadedKeys } = this.state;
					const newLoadedKeys = arrAdd(currentLoadedKeys, key);
					onLoad?.(newLoadedKeys, {
						event: "load",
						node: treeNode
					});
					this.setUncontrolledState({ loadedKeys: newLoadedKeys });
					this.setState((prevState) => ({ loadingKeys: arrDel(prevState.loadingKeys, key) }));
					resolve();
				}).catch((e$2) => {
					this.setState((prevState) => ({ loadingKeys: arrDel(prevState.loadingKeys, key) }));
					this.loadingRetryTimes[key] = (this.loadingRetryTimes[key] || 0) + 1;
					if (this.loadingRetryTimes[key] >= MAX_RETRY_TIMES) {
						const { loadedKeys: currentLoadedKeys } = this.state;
						warning_default$1(false, "Retry for `loadData` many times but still failed. No more retry.");
						this.setUncontrolledState({ loadedKeys: arrAdd(currentLoadedKeys, key) });
						resolve();
					}
					reject(e$2);
				});
				return { loadingKeys: arrAdd(loadingKeys, key) };
			});
		});
		loadPromise.catch(() => {});
		return loadPromise;
	};
	onNodeMouseEnter = (event, node$1) => {
		const { onMouseEnter } = this.props;
		onMouseEnter?.({
			event,
			node: node$1
		});
	};
	onNodeMouseLeave = (event, node$1) => {
		const { onMouseLeave } = this.props;
		onMouseLeave?.({
			event,
			node: node$1
		});
	};
	onNodeContextMenu = (event, node$1) => {
		const { onRightClick } = this.props;
		if (onRightClick) {
			event.preventDefault();
			onRightClick({
				event,
				node: node$1
			});
		}
	};
	onFocus = (...args) => {
		const { onFocus } = this.props;
		this.setState({ focused: true });
		onFocus?.(...args);
	};
	onBlur = (...args) => {
		const { onBlur } = this.props;
		this.setState({ focused: false });
		this.onActiveChange(null);
		onBlur?.(...args);
	};
	getTreeNodeRequiredProps = () => {
		const { expandedKeys, selectedKeys, loadedKeys, loadingKeys, checkedKeys, halfCheckedKeys, dragOverNodeKey, dropPosition, keyEntities } = this.state;
		return {
			expandedKeys: expandedKeys || [],
			selectedKeys: selectedKeys || [],
			loadedKeys: loadedKeys || [],
			loadingKeys: loadingKeys || [],
			checkedKeys: checkedKeys || [],
			halfCheckedKeys: halfCheckedKeys || [],
			dragOverNodeKey,
			dropPosition,
			keyEntities
		};
	};
	/** Set uncontrolled `expandedKeys`. This will also auto update `flattenNodes`. */
	setExpandedKeys = (expandedKeys) => {
		const { treeData, fieldNames } = this.state;
		const flattenNodes = flattenTreeData(treeData, expandedKeys, fieldNames);
		this.setUncontrolledState({
			expandedKeys,
			flattenNodes
		}, true);
	};
	onNodeExpand = (e$2, treeNode) => {
		let { expandedKeys } = this.state;
		const { listChanging, fieldNames } = this.state;
		const { onExpand, loadData } = this.props;
		const { expanded } = treeNode;
		const key = treeNode[fieldNames.key];
		if (listChanging) return;
		const certain = expandedKeys.includes(key);
		const targetExpanded = !expanded;
		warning_default$1(expanded && certain || !expanded && !certain, "Expand state not sync with index check");
		expandedKeys = targetExpanded ? arrAdd(expandedKeys, key) : arrDel(expandedKeys, key);
		this.setExpandedKeys(expandedKeys);
		onExpand?.(expandedKeys, {
			node: treeNode,
			expanded: targetExpanded,
			nativeEvent: e$2.nativeEvent
		});
		if (targetExpanded && loadData) {
			const loadPromise = this.onNodeLoad(treeNode);
			if (loadPromise) loadPromise.then(() => {
				const newFlattenTreeData = flattenTreeData(this.state.treeData, expandedKeys, fieldNames);
				this.setUncontrolledState({ flattenNodes: newFlattenTreeData });
			}).catch(() => {
				const { expandedKeys: currentExpandedKeys } = this.state;
				const expandedKeysToRestore = arrDel(currentExpandedKeys, key);
				this.setExpandedKeys(expandedKeysToRestore);
			});
		}
	};
	onListChangeStart = () => {
		this.setUncontrolledState({ listChanging: true });
	};
	onListChangeEnd = () => {
		setTimeout(() => {
			this.setUncontrolledState({ listChanging: false });
		});
	};
	onActiveChange = (newActiveKey) => {
		const { activeKey } = this.state;
		const { onActiveChange, itemScrollOffset = 0 } = this.props;
		if (activeKey === newActiveKey) return;
		this.setState({ activeKey: newActiveKey });
		if (newActiveKey !== null) this.scrollTo({
			key: newActiveKey,
			offset: itemScrollOffset
		});
		onActiveChange?.(newActiveKey);
	};
	getActiveItem = () => {
		const { activeKey, flattenNodes } = this.state;
		if (activeKey === null) return null;
		return flattenNodes.find(({ key }) => key === activeKey) || null;
	};
	offsetActiveKey = (offset$2) => {
		const { flattenNodes, activeKey } = this.state;
		let index$1 = flattenNodes.findIndex(({ key }) => key === activeKey);
		if (index$1 === -1 && offset$2 < 0) index$1 = flattenNodes.length;
		index$1 = (index$1 + offset$2 + flattenNodes.length) % flattenNodes.length;
		const item = flattenNodes[index$1];
		if (item) {
			const { key } = item;
			this.onActiveChange(key);
		} else this.onActiveChange(null);
	};
	onKeyDown = (event) => {
		const { activeKey, expandedKeys, checkedKeys, fieldNames } = this.state;
		const { onKeyDown: onKeyDown$1, checkable, selectable } = this.props;
		switch (event.which) {
			case KeyCode_default.UP:
				this.offsetActiveKey(-1);
				event.preventDefault();
				break;
			case KeyCode_default.DOWN:
				this.offsetActiveKey(1);
				event.preventDefault();
				break;
		}
		const activeItem = this.getActiveItem();
		if (activeItem && activeItem.data) {
			const treeNodeRequiredProps = this.getTreeNodeRequiredProps();
			const expandable = activeItem.data.isLeaf === false || !!(activeItem.data[fieldNames.children] || []).length;
			const eventNode = convertNodePropsToEventData({
				...getTreeNodeProps(activeKey, treeNodeRequiredProps),
				data: activeItem.data,
				active: true
			});
			switch (event.which) {
				case KeyCode_default.LEFT:
					if (expandable && expandedKeys.includes(activeKey)) this.onNodeExpand({}, eventNode);
					else if (activeItem.parent) this.onActiveChange(activeItem.parent.key);
					event.preventDefault();
					break;
				case KeyCode_default.RIGHT:
					if (expandable && !expandedKeys.includes(activeKey)) this.onNodeExpand({}, eventNode);
					else if (activeItem.children && activeItem.children.length) this.onActiveChange(activeItem.children[0].key);
					event.preventDefault();
					break;
				case KeyCode_default.ENTER:
				case KeyCode_default.SPACE:
					if (checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox) this.onNodeCheck({}, eventNode, !checkedKeys.includes(activeKey));
					else if (!checkable && selectable && !eventNode.disabled && eventNode.selectable !== false) this.onNodeSelect({}, eventNode);
					break;
			}
		}
		onKeyDown$1?.(event);
	};
	/**
	* Only update the value which is not in props
	*/
	setUncontrolledState = (state, atomic = false, forceState = null) => {
		if (!this.destroyed) {
			let needSync = false;
			let allPassed = true;
			const newState = {};
			Object.keys(state).forEach((name) => {
				if (this.props.hasOwnProperty(name)) {
					allPassed = false;
					return;
				}
				needSync = true;
				newState[name] = state[name];
			});
			if (needSync && (!atomic || allPassed)) this.setState({
				...newState,
				...forceState
			});
		}
	};
	scrollTo = (scroll) => {
		this.listRef.current.scrollTo(scroll);
	};
	render() {
		const { focused, flattenNodes, keyEntities, draggingNodeKey, activeKey, dropLevelOffset, dropContainerKey, dropTargetKey, dropPosition, dragOverNodeKey, indent } = this.state;
		const { prefixCls, className, style: style$1, styles, classNames: treeClassNames, showLine, focusable: focusable$1, tabIndex = 0, selectable, showIcon, icon, switcherIcon, draggable, checkable, checkStrictly, disabled, motion: motion$1, loadData, filterTreeNode, height, itemHeight, scrollWidth, virtual, titleRender, dropIndicatorRender: dropIndicatorRender$1, onContextMenu, onScroll, direction, rootClassName, rootStyle } = this.props;
		const domProps = pickAttrs(this.props, {
			aria: true,
			data: true
		});
		let draggableConfig;
		if (draggable) if (typeof draggable === "object") draggableConfig = draggable;
		else if (typeof draggable === "function") draggableConfig = { nodeDraggable: draggable };
		else draggableConfig = {};
		const contextValue = {
			styles,
			classNames: treeClassNames,
			prefixCls,
			selectable,
			showIcon,
			icon,
			switcherIcon,
			draggable: draggableConfig,
			draggingNodeKey,
			checkable,
			checkStrictly,
			disabled,
			keyEntities,
			dropLevelOffset,
			dropContainerKey,
			dropTargetKey,
			dropPosition,
			dragOverNodeKey,
			indent,
			direction,
			dropIndicatorRender: dropIndicatorRender$1,
			loadData,
			filterTreeNode,
			titleRender,
			onNodeClick: this.onNodeClick,
			onNodeDoubleClick: this.onNodeDoubleClick,
			onNodeExpand: this.onNodeExpand,
			onNodeSelect: this.onNodeSelect,
			onNodeCheck: this.onNodeCheck,
			onNodeLoad: this.onNodeLoad,
			onNodeMouseEnter: this.onNodeMouseEnter,
			onNodeMouseLeave: this.onNodeMouseLeave,
			onNodeContextMenu: this.onNodeContextMenu,
			onNodeDragStart: this.onNodeDragStart,
			onNodeDragEnter: this.onNodeDragEnter,
			onNodeDragOver: this.onNodeDragOver,
			onNodeDragLeave: this.onNodeDragLeave,
			onNodeDragEnd: this.onNodeDragEnd,
			onNodeDrop: this.onNodeDrop
		};
		return /* @__PURE__ */ import_react.createElement(TreeContext.Provider, { value: contextValue }, /* @__PURE__ */ import_react.createElement("div", {
			className: clsx(prefixCls, className, rootClassName, {
				[`${prefixCls}-show-line`]: showLine,
				[`${prefixCls}-focused`]: focused,
				[`${prefixCls}-active-focused`]: activeKey !== null
			}),
			style: rootStyle
		}, /* @__PURE__ */ import_react.createElement(NodeList_default, _extends$7({
			ref: this.listRef,
			prefixCls,
			style: style$1,
			data: flattenNodes,
			disabled,
			selectable,
			checkable: !!checkable,
			motion: motion$1,
			dragging: draggingNodeKey !== null,
			height,
			itemHeight,
			virtual,
			focusable: focusable$1,
			focused,
			tabIndex,
			activeItem: this.getActiveItem(),
			onFocus: this.onFocus,
			onBlur: this.onBlur,
			onKeyDown: this.onKeyDown,
			onActiveChange: this.onActiveChange,
			onListChangeStart: this.onListChangeStart,
			onListChangeEnd: this.onListChangeEnd,
			onContextMenu,
			onScroll,
			scrollWidth
		}, this.getTreeNodeRequiredProps(), domProps))));
	}
};
var Tree_default$1 = Tree$2;

//#endregion
//#region node_modules/@rc-component/tree/es/index.js
var es_default$4 = Tree_default$1;

//#endregion
//#region node_modules/antd/es/tree/style/directory.js
const genDirectoryStyle = ({ treeCls, treeNodeCls, directoryNodeSelectedBg, directoryNodeSelectedColor, motionDurationMid, borderRadius, controlItemBgHover }) => ({ [`${treeCls}${treeCls}-directory ${treeNodeCls}`]: {
	[`${treeCls}-node-content-wrapper`]: {
		position: "static",
		[`&:has(${treeCls}-drop-indicator)`]: { position: "relative" },
		[`> *:not(${treeCls}-drop-indicator)`]: { position: "relative" },
		"&:hover": { background: "transparent" },
		"&:before": {
			position: "absolute",
			inset: 0,
			transition: `background-color ${motionDurationMid}`,
			content: "\"\"",
			borderRadius
		},
		"&:hover:before": { background: controlItemBgHover }
	},
	[`${treeCls}-switcher, ${treeCls}-checkbox, ${treeCls}-draggable-icon`]: { zIndex: 1 },
	"&-selected": {
		background: directoryNodeSelectedBg,
		borderRadius,
		[`${treeCls}-switcher, ${treeCls}-draggable-icon`]: { color: directoryNodeSelectedColor },
		[`${treeCls}-node-content-wrapper`]: {
			color: directoryNodeSelectedColor,
			background: "transparent",
			"&, &:hover": { color: directoryNodeSelectedColor },
			"&:before, &:hover:before": { background: directoryNodeSelectedBg }
		}
	}
} });

//#endregion
//#region node_modules/antd/es/tree/style/index.js
var treeNodeFX = new Keyframes_default("ant-tree-node-fx-do-not-use", {
	"0%": { opacity: 0 },
	"100%": { opacity: 1 }
});
var getSwitchStyle = (prefixCls, token$1) => ({ [`.${prefixCls}-switcher-icon`]: {
	display: "inline-block",
	fontSize: 10,
	verticalAlign: "baseline",
	svg: { transition: `transform ${token$1.motionDurationSlow}` }
} });
var getDropIndicatorStyle = (prefixCls, token$1) => ({ [`.${prefixCls}-drop-indicator`]: {
	position: "absolute",
	zIndex: 1,
	height: 2,
	backgroundColor: token$1.colorPrimary,
	borderRadius: 1,
	pointerEvents: "none",
	"&:after": {
		position: "absolute",
		top: -3,
		insetInlineStart: -6,
		width: 8,
		height: 8,
		backgroundColor: "transparent",
		border: `${unit(token$1.lineWidthBold)} solid ${token$1.colorPrimary}`,
		borderRadius: "50%",
		content: "\"\""
	}
} });
const genBaseStyle$4 = (prefixCls, token$1) => {
	const { treeCls, treeNodeCls, treeNodePadding, titleHeight, indentSize, nodeSelectedBg, nodeHoverBg, colorTextQuaternary, controlItemBgActiveDisabled } = token$1;
	return { [treeCls]: {
		...resetComponent(token$1),
		["--rc-virtual-list-scrollbar-bg"]: token$1.colorSplit,
		background: token$1.colorBgContainer,
		borderRadius: token$1.borderRadius,
		transition: `background-color ${token$1.motionDurationSlow}`,
		"&-rtl": { direction: "rtl" },
		[`&${treeCls}-rtl ${treeCls}-switcher_close ${treeCls}-switcher-icon svg`]: { transform: "rotate(90deg)" },
		[`&-focused:not(:hover):not(${treeCls}-active-focused)`]: genFocusOutline(token$1),
		[`${treeCls}-list-holder-inner`]: { alignItems: "flex-start" },
		[`&${treeCls}-block-node`]: { [`${treeCls}-list-holder-inner`]: {
			alignItems: "stretch",
			[`${treeCls}-node-content-wrapper`]: { flex: "auto" },
			[`${treeNodeCls}.dragging:after`]: {
				position: "absolute",
				inset: 0,
				border: `1px solid ${token$1.colorPrimary}`,
				opacity: 0,
				animationName: treeNodeFX,
				animationDuration: token$1.motionDurationSlow,
				animationPlayState: "running",
				animationFillMode: "forwards",
				content: "\"\"",
				pointerEvents: "none",
				borderRadius: token$1.borderRadius
			}
		} },
		[treeNodeCls]: {
			display: "flex",
			alignItems: "flex-start",
			marginBottom: treeNodePadding,
			lineHeight: unit(titleHeight),
			position: "relative",
			"&:before": {
				content: "\"\"",
				position: "absolute",
				zIndex: 1,
				insetInlineStart: 0,
				width: "100%",
				top: "100%",
				height: treeNodePadding
			},
			[`&-disabled ${treeCls}-node-content-wrapper`]: {
				color: token$1.colorTextDisabled,
				cursor: "not-allowed",
				"&:hover": { background: "transparent" }
			},
			[`${treeCls}-checkbox-disabled + ${treeCls}-node-selected,&${treeNodeCls}-disabled${treeNodeCls}-selected ${treeCls}-node-content-wrapper`]: { backgroundColor: controlItemBgActiveDisabled },
			[`${treeCls}-checkbox-disabled`]: { pointerEvents: "unset" },
			[`&:not(${treeNodeCls}-disabled)`]: { [`${treeCls}-node-content-wrapper`]: { "&:hover": { color: token$1.nodeHoverColor } } },
			[`&-active ${treeCls}-node-content-wrapper`]: { background: token$1.controlItemBgHover },
			[`&:not(${treeNodeCls}-disabled).filter-node ${treeCls}-title`]: {
				color: token$1.colorPrimary,
				fontWeight: token$1.fontWeightStrong
			},
			"&-draggable": {
				cursor: "grab",
				[`${treeCls}-draggable-icon`]: {
					flexShrink: 0,
					width: titleHeight,
					textAlign: "center",
					visibility: "visible",
					color: colorTextQuaternary
				},
				[`&${treeNodeCls}-disabled ${treeCls}-draggable-icon`]: { visibility: "hidden" }
			}
		},
		[`${treeCls}-indent`]: {
			alignSelf: "stretch",
			whiteSpace: "nowrap",
			userSelect: "none",
			"&-unit": {
				display: "inline-block",
				width: indentSize
			}
		},
		[`${treeCls}-draggable-icon`]: { visibility: "hidden" },
		[`${treeCls}-switcher, ${treeCls}-checkbox`]: { marginInlineEnd: token$1.calc(token$1.calc(titleHeight).sub(token$1.controlInteractiveSize)).div(2).equal() },
		[`${treeCls}-switcher`]: {
			...getSwitchStyle(prefixCls, token$1),
			position: "relative",
			flex: "none",
			alignSelf: "stretch",
			width: titleHeight,
			textAlign: "center",
			cursor: "pointer",
			userSelect: "none",
			transition: `all ${token$1.motionDurationSlow}`,
			"&-noop": { cursor: "unset" },
			"&:before": {
				pointerEvents: "none",
				content: "\"\"",
				width: titleHeight,
				height: titleHeight,
				position: "absolute",
				left: {
					_skip_check_: true,
					value: 0
				},
				top: 0,
				borderRadius: token$1.borderRadius,
				transition: `all ${token$1.motionDurationSlow}`
			},
			[`&:not(${treeCls}-switcher-noop):hover:before`]: { backgroundColor: token$1.colorBgTextHover },
			[`&_close ${treeCls}-switcher-icon svg`]: { transform: "rotate(-90deg)" },
			"&-loading-icon": { color: token$1.colorPrimary },
			"&-leaf-line": {
				position: "relative",
				zIndex: 1,
				display: "inline-block",
				width: "100%",
				height: "100%",
				"&:before": {
					position: "absolute",
					top: 0,
					insetInlineEnd: token$1.calc(titleHeight).div(2).equal(),
					bottom: token$1.calc(treeNodePadding).mul(-1).equal(),
					marginInlineStart: -1,
					borderInlineEnd: `1px solid ${token$1.colorBorder}`,
					content: "\"\""
				},
				"&:after": {
					position: "absolute",
					width: token$1.calc(token$1.calc(titleHeight).div(2).equal()).mul(.8).equal(),
					height: token$1.calc(titleHeight).div(2).equal(),
					borderBottom: `1px solid ${token$1.colorBorder}`,
					content: "\"\""
				}
			}
		},
		[`${treeCls}-node-content-wrapper`]: {
			position: "relative",
			minHeight: titleHeight,
			paddingBlock: 0,
			paddingInline: token$1.paddingXS,
			background: "transparent",
			borderRadius: token$1.borderRadius,
			cursor: "pointer",
			transition: `all ${token$1.motionDurationMid}, border 0s, line-height 0s, box-shadow 0s`,
			...getDropIndicatorStyle(prefixCls, token$1),
			"&:hover": { backgroundColor: nodeHoverBg },
			[`&${treeCls}-node-selected`]: {
				color: token$1.nodeSelectedColor,
				backgroundColor: nodeSelectedBg
			},
			[`${treeCls}-iconEle`]: {
				display: "inline-block",
				width: titleHeight,
				height: titleHeight,
				textAlign: "center",
				verticalAlign: "top",
				"&:empty": { display: "none" }
			}
		},
		[`${treeCls}-unselectable ${treeCls}-node-content-wrapper:hover`]: { backgroundColor: "transparent" },
		[`${treeNodeCls}.drop-container > [draggable]`]: { boxShadow: `0 0 0 2px ${token$1.colorPrimary}` },
		"&-show-line": {
			[`${treeCls}-indent-unit`]: {
				position: "relative",
				height: "100%",
				"&:before": {
					position: "absolute",
					top: 0,
					insetInlineEnd: token$1.calc(titleHeight).div(2).equal(),
					bottom: token$1.calc(treeNodePadding).mul(-1).equal(),
					borderInlineEnd: `1px solid ${token$1.colorBorder}`,
					content: "\"\""
				},
				"&-end:before": { display: "none" }
			},
			[`${treeCls}-switcher`]: {
				background: "transparent",
				"&-line-icon": { verticalAlign: "-0.15em" }
			}
		},
		[`${treeNodeCls}-leaf-last ${treeCls}-switcher-leaf-line:before`]: {
			top: "auto !important",
			bottom: "auto !important",
			height: `${unit(token$1.calc(titleHeight).div(2).equal())} !important`
		}
	} };
};
const genTreeStyle = (prefixCls, token$1, enableDirectory = true) => {
	const treeCls = `.${prefixCls}`;
	const treeToken = merge(token$1, {
		treeCls,
		treeNodeCls: `${treeCls}-treenode`,
		treeNodePadding: token$1.calc(token$1.paddingXS).div(2).equal()
	});
	return [genBaseStyle$4(prefixCls, treeToken), enableDirectory && genDirectoryStyle(treeToken)].filter(Boolean);
};
const initComponentToken = (token$1) => {
	const { controlHeightSM, controlItemBgHover, controlItemBgActive } = token$1;
	const titleHeight = controlHeightSM;
	return {
		titleHeight,
		indentSize: titleHeight,
		nodeHoverBg: controlItemBgHover,
		nodeHoverColor: token$1.colorText,
		nodeSelectedBg: controlItemBgActive,
		nodeSelectedColor: token$1.colorText
	};
};
const prepareComponentToken$7 = (token$1) => {
	const { colorTextLightSolid, colorPrimary } = token$1;
	return {
		...initComponentToken(token$1),
		directoryNodeSelectedColor: colorTextLightSolid,
		directoryNodeSelectedBg: colorPrimary
	};
};
var style_default$8 = genStyleHooks("Tree", (token$1, { prefixCls }) => [
	{ [token$1.componentCls]: getStyle(`${prefixCls}-checkbox`, token$1) },
	genTreeStyle(prefixCls, token$1),
	collapse_default$1(token$1)
], prepareComponentToken$7);

//#endregion
//#region node_modules/antd/es/tree/utils/dropIndicator.js
const offset = 4;
function dropIndicatorRender(props) {
	const { dropPosition, dropLevelOffset, prefixCls, indent, direction = "ltr" } = props;
	const startPosition = direction === "ltr" ? "left" : "right";
	const endPosition = direction === "ltr" ? "right" : "left";
	const style$1 = {
		[startPosition]: -dropLevelOffset * indent + offset,
		[endPosition]: 0
	};
	switch (dropPosition) {
		case -1:
			style$1.top = -3;
			break;
		case 1:
			style$1.bottom = -3;
			break;
		default:
			style$1.bottom = -3;
			style$1[startPosition] = indent + offset;
			break;
	}
	return /* @__PURE__ */ import_react.createElement("div", {
		style: style$1,
		className: `${prefixCls}-drop-indicator`
	});
}
var dropIndicator_default = dropIndicatorRender;

//#endregion
//#region node_modules/antd/es/tree/utils/iconUtil.js
var SwitcherIconCom = (props) => {
	const { prefixCls, switcherIcon, treeNodeProps, showLine, switcherLoadingIcon } = props;
	const { isLeaf: isLeaf$1, expanded, loading } = treeNodeProps;
	if (loading) {
		if (/* @__PURE__ */ import_react.isValidElement(switcherLoadingIcon)) return switcherLoadingIcon;
		return /* @__PURE__ */ import_react.createElement(LoadingOutlined_default, { className: `${prefixCls}-switcher-loading-icon` });
	}
	let showLeafIcon;
	if (showLine && typeof showLine === "object") showLeafIcon = showLine.showLeafIcon;
	if (isLeaf$1) {
		if (!showLine) return null;
		if (typeof showLeafIcon !== "boolean" && !!showLeafIcon) {
			const leafIcon = typeof showLeafIcon === "function" ? showLeafIcon(treeNodeProps) : showLeafIcon;
			const leafCls = `${prefixCls}-switcher-line-custom-icon`;
			if (/* @__PURE__ */ import_react.isValidElement(leafIcon)) return cloneElement(leafIcon, { className: clsx(leafIcon.props?.className, leafCls) });
			return leafIcon;
		}
		return showLeafIcon ? /* @__PURE__ */ import_react.createElement(FileOutlined_default, { className: `${prefixCls}-switcher-line-icon` }) : /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-switcher-leaf-line` });
	}
	const switcherCls = `${prefixCls}-switcher-icon`;
	const switcher = typeof switcherIcon === "function" ? switcherIcon(treeNodeProps) : switcherIcon;
	if (/* @__PURE__ */ import_react.isValidElement(switcher)) return cloneElement(switcher, { className: clsx(switcher.props?.className, switcherCls) });
	if (switcher !== void 0) return switcher;
	if (showLine) return expanded ? /* @__PURE__ */ import_react.createElement(MinusSquareOutlined_default, { className: `${prefixCls}-switcher-line-icon` }) : /* @__PURE__ */ import_react.createElement(PlusSquareOutlined_default, { className: `${prefixCls}-switcher-line-icon` });
	return /* @__PURE__ */ import_react.createElement(CaretDownFilled_default, { className: switcherCls });
};
var iconUtil_default = SwitcherIconCom;

//#endregion
//#region node_modules/antd/es/tree/Tree.js
var Tree$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("tree");
	const { virtual } = import_react.useContext(ConfigContext);
	const { prefixCls: customizePrefixCls, className, showIcon = false, showLine, switcherIcon, switcherLoadingIcon, blockNode = false, children, checkable = false, selectable = true, draggable, disabled, motion: customMotion, style: style$1, rootClassName, classNames, styles } = props;
	const contextDisabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = disabled ?? contextDisabled;
	const prefixCls = getPrefixCls("tree", customizePrefixCls);
	const rootPrefixCls = getPrefixCls();
	const motion$1 = customMotion ?? {
		...motion_default(rootPrefixCls),
		motionAppear: false
	};
	const mergedProps = {
		...props,
		showIcon,
		blockNode,
		checkable,
		selectable,
		disabled: mergedDisabled,
		motion: motion$1
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const newProps = {
		...props,
		checkable,
		selectable,
		showIcon,
		motion: motion$1,
		blockNode,
		disabled: mergedDisabled,
		showLine: Boolean(showLine),
		dropIndicatorRender: dropIndicator_default
	};
	const [hashId, cssVarCls] = style_default$8(prefixCls);
	const [, token$1] = useToken();
	const itemHeight = token$1.paddingXS / 2 + (token$1.Tree?.titleHeight || token$1.controlHeightSM);
	const draggableConfig = import_react.useMemo(() => {
		if (!draggable) return false;
		let mergedDraggable = {};
		switch (typeof draggable) {
			case "function":
				mergedDraggable.nodeDraggable = draggable;
				break;
			case "object":
				mergedDraggable = { ...draggable };
				break;
			default: break;
		}
		if (mergedDraggable.icon !== false) mergedDraggable.icon = mergedDraggable.icon || /* @__PURE__ */ import_react.createElement(HolderOutlined_default, null);
		return mergedDraggable;
	}, [draggable]);
	const renderSwitcherIcon = (nodeProps) => /* @__PURE__ */ import_react.createElement(iconUtil_default, {
		prefixCls,
		switcherIcon,
		switcherLoadingIcon,
		treeNodeProps: nodeProps,
		showLine
	});
	return /* @__PURE__ */ import_react.createElement(es_default$4, {
		itemHeight,
		ref,
		virtual,
		...newProps,
		prefixCls,
		className: clsx({
			[`${prefixCls}-icon-hide`]: !showIcon,
			[`${prefixCls}-block-node`]: blockNode,
			[`${prefixCls}-unselectable`]: !selectable,
			[`${prefixCls}-rtl`]: direction === "rtl",
			[`${prefixCls}-disabled`]: mergedDisabled
		}, contextClassName, className, hashId, cssVarCls),
		style: {
			...contextStyle,
			...style$1
		},
		rootClassName: clsx(mergedClassNames?.root, rootClassName),
		rootStyle: mergedStyles?.root,
		classNames: mergedClassNames,
		styles: mergedStyles,
		direction,
		checkable: checkable ? /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-checkbox-inner` }) : checkable,
		selectable,
		switcherIcon: renderSwitcherIcon,
		draggable: draggableConfig
	}, children);
});
Tree$1.displayName = "Tree";
var Tree_default = Tree$1;

//#endregion
//#region node_modules/antd/es/tree/utils/dictUtil.js
var RECORD_NONE = 0;
var RECORD_START = 1;
var RECORD_END = 2;
function traverseNodesKey(treeData, callback, fieldNames) {
	const { key: fieldKey, children: fieldChildren } = fieldNames;
	function processNode(dataNode) {
		const key = dataNode[fieldKey];
		const children = dataNode[fieldChildren];
		if (callback(key, dataNode) !== false) traverseNodesKey(children || [], callback, fieldNames);
	}
	treeData.forEach(processNode);
}
/** expanded */
function calcRangeKeys({ treeData, expandedKeys, startKey, endKey, fieldNames }) {
	const keys$1 = [];
	let record = RECORD_NONE;
	if (startKey && startKey === endKey) return [startKey];
	if (!startKey || !endKey) return [];
	function matchKey(key) {
		return key === startKey || key === endKey;
	}
	traverseNodesKey(treeData, (key) => {
		if (record === RECORD_END) return false;
		if (matchKey(key)) {
			keys$1.push(key);
			if (record === RECORD_NONE) record = RECORD_START;
			else if (record === RECORD_START) {
				record = RECORD_END;
				return false;
			}
		} else if (record === RECORD_START) keys$1.push(key);
		return expandedKeys.includes(key);
	}, fillFieldNames$1(fieldNames));
	return keys$1;
}
function convertDirectoryKeysToNodes(treeData, keys$1, fieldNames) {
	const restKeys = _toConsumableArray(keys$1);
	const nodes = [];
	traverseNodesKey(treeData, (key, node$1) => {
		const index$1 = restKeys.indexOf(key);
		if (index$1 !== -1) {
			nodes.push(node$1);
			restKeys.splice(index$1, 1);
		}
		return !!restKeys.length;
	}, fillFieldNames$1(fieldNames));
	return nodes;
}

//#endregion
//#region node_modules/antd/es/tree/DirectoryTree.js
function getIcon(props) {
	const { isLeaf: isLeaf$1, expanded } = props;
	if (isLeaf$1) return /* @__PURE__ */ import_react.createElement(FileOutlined_default, null);
	return expanded ? /* @__PURE__ */ import_react.createElement(FolderOpenOutlined_default, null) : /* @__PURE__ */ import_react.createElement(FolderOutlined_default, null);
}
function getTreeData({ treeData, children }) {
	return treeData || convertTreeToData(children);
}
var DirectoryTree = ({ defaultExpandAll, defaultExpandParent, defaultExpandedKeys, ...props }, ref) => {
	const lastSelectedKey = import_react.useRef(null);
	const cachedSelectedKeys = import_react.useRef(null);
	const getInitExpandedKeys = () => {
		const { keyEntities } = convertDataToEntities(getTreeData(props), { fieldNames: props.fieldNames });
		let initExpandedKeys;
		if (defaultExpandAll) initExpandedKeys = Object.keys(keyEntities);
		else if (defaultExpandParent) initExpandedKeys = conductExpandParent(props.expandedKeys || defaultExpandedKeys || [], keyEntities);
		else initExpandedKeys = props.expandedKeys || defaultExpandedKeys || [];
		return initExpandedKeys;
	};
	const [selectedKeys, setSelectedKeys] = import_react.useState(props.selectedKeys || props.defaultSelectedKeys || []);
	const [expandedKeys, setExpandedKeys] = import_react.useState(() => getInitExpandedKeys());
	import_react.useEffect(() => {
		if ("selectedKeys" in props) setSelectedKeys(props.selectedKeys);
	}, [props.selectedKeys]);
	import_react.useEffect(() => {
		if ("expandedKeys" in props) setExpandedKeys(props.expandedKeys);
	}, [props.expandedKeys]);
	const onExpand = (keys$1, info) => {
		if (!("expandedKeys" in props)) setExpandedKeys(keys$1);
		return props.onExpand?.(keys$1, info);
	};
	const onSelect = (keys$1, event) => {
		const { multiple, fieldNames } = props;
		const { node: node$1, nativeEvent } = event;
		const { key = "" } = node$1;
		const treeData = getTreeData(props);
		const newEvent = {
			...event,
			selected: true
		};
		const ctrlPick = nativeEvent?.ctrlKey || nativeEvent?.metaKey;
		const shiftPick = nativeEvent?.shiftKey;
		let newSelectedKeys;
		if (multiple && ctrlPick) {
			newSelectedKeys = keys$1;
			lastSelectedKey.current = key;
			cachedSelectedKeys.current = newSelectedKeys;
			newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys, fieldNames);
		} else if (multiple && shiftPick) {
			newSelectedKeys = Array.from(new Set([].concat(_toConsumableArray(cachedSelectedKeys.current || []), _toConsumableArray(calcRangeKeys({
				treeData,
				expandedKeys,
				startKey: key,
				endKey: lastSelectedKey.current,
				fieldNames
			})))));
			newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys, fieldNames);
		} else {
			newSelectedKeys = [key];
			lastSelectedKey.current = key;
			cachedSelectedKeys.current = newSelectedKeys;
			newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys, fieldNames);
		}
		props.onSelect?.(newSelectedKeys, newEvent);
		if (!("selectedKeys" in props)) setSelectedKeys(newSelectedKeys);
	};
	const { getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const { prefixCls: customizePrefixCls, className, showIcon = true, expandAction = "click", ...otherProps } = props;
	const prefixCls = getPrefixCls("tree", customizePrefixCls);
	const connectClassName = clsx(`${prefixCls}-directory`, { [`${prefixCls}-directory-rtl`]: direction === "rtl" }, className);
	return /* @__PURE__ */ import_react.createElement(Tree_default, {
		icon: getIcon,
		ref,
		blockNode: true,
		...otherProps,
		showIcon,
		expandAction,
		prefixCls,
		className: connectClassName,
		expandedKeys,
		selectedKeys,
		onSelect,
		onExpand
	});
};
var ForwardDirectoryTree = /* @__PURE__ */ import_react.forwardRef(DirectoryTree);
ForwardDirectoryTree.displayName = "DirectoryTree";
var DirectoryTree_default = ForwardDirectoryTree;

//#endregion
//#region node_modules/antd/es/tree/index.js
var Tree = Tree_default;
Tree.DirectoryTree = DirectoryTree_default;
Tree.TreeNode = TreeNode_default$1;
var tree_default = Tree;

//#endregion
//#region node_modules/antd/es/table/TableMeasureRowContext.js
var TableMeasureRowContext = /* @__PURE__ */ import_react.createContext(false);
var TableMeasureRowContext_default = TableMeasureRowContext;

//#endregion
//#region node_modules/antd/es/table/hooks/useFilter/FilterSearch.js
var FilterSearch = (props) => {
	const { value, filterSearch, tablePrefixCls, locale: locale$5, onChange } = props;
	if (!filterSearch) return null;
	return /* @__PURE__ */ import_react.createElement("div", { className: `${tablePrefixCls}-filter-dropdown-search` }, /* @__PURE__ */ import_react.createElement(Input_default, {
		prefix: /* @__PURE__ */ import_react.createElement(SearchOutlined_default, null),
		placeholder: locale$5.filterSearchPlaceholder,
		onChange,
		value,
		htmlSize: 1,
		className: `${tablePrefixCls}-filter-dropdown-search-input`
	}));
};
var FilterSearch_default = FilterSearch;

//#endregion
//#region node_modules/antd/es/table/hooks/useFilter/FilterWrapper.js
var onKeyDown = (event) => {
	const { keyCode } = event;
	if (keyCode === KeyCode_default.ENTER) event.stopPropagation();
};
var FilterDropdownMenuWrapper = /* @__PURE__ */ import_react.forwardRef((props, ref) => /* @__PURE__ */ import_react.createElement("div", {
	className: props.className,
	onClick: (e$2) => e$2.stopPropagation(),
	onKeyDown,
	ref
}, props.children));
FilterDropdownMenuWrapper.displayName = "FilterDropdownMenuWrapper";
var FilterWrapper_default = FilterDropdownMenuWrapper;

//#endregion
//#region node_modules/antd/es/table/hooks/useFilter/FilterDropdown.js
function flattenKeys$1(filters) {
	let keys$1 = [];
	(filters || []).forEach(({ value, children }) => {
		keys$1.push(value);
		if (children) keys$1 = [].concat(_toConsumableArray(keys$1), _toConsumableArray(flattenKeys$1(children)));
	});
	return keys$1;
}
function hasSubMenu(filters) {
	return filters.some(({ children }) => children);
}
function searchValueMatched(searchValue, text) {
	if (typeof text === "string" || typeof text === "number") return text?.toString().toLowerCase().includes(searchValue.trim().toLowerCase());
	return false;
}
function renderFilterItems({ filters, prefixCls, filteredKeys, filterMultiple, searchValue, filterSearch }) {
	return filters.map((filter$2, index$1) => {
		const key = String(filter$2.value);
		if (filter$2.children) return {
			key: key || index$1,
			label: filter$2.text,
			popupClassName: `${prefixCls}-dropdown-submenu`,
			children: renderFilterItems({
				filters: filter$2.children,
				prefixCls,
				filteredKeys,
				filterMultiple,
				searchValue,
				filterSearch
			})
		};
		const Component$2 = filterMultiple ? checkbox_default : radio_default;
		const item = {
			key: filter$2.value !== void 0 ? key : index$1,
			label: /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(Component$2, { checked: filteredKeys.includes(key) }), /* @__PURE__ */ import_react.createElement("span", null, filter$2.text))
		};
		if (searchValue.trim()) {
			if (typeof filterSearch === "function") return filterSearch(searchValue, filter$2) ? item : null;
			return searchValueMatched(searchValue, filter$2.text) ? item : null;
		}
		return item;
	});
}
function wrapStringListType(keys$1) {
	return keys$1 || [];
}
var FilterDropdown = (props) => {
	const { tablePrefixCls, prefixCls, column: column$1, dropdownPrefixCls, columnKey, filterOnClose, filterMultiple, filterMode = "menu", filterSearch = false, filterState, triggerFilter, locale: locale$5, children, getPopupContainer, rootClassName } = props;
	const { filterResetToDefaultFilteredValue, defaultFilteredValue, filterDropdownProps = {}, filterDropdownOpen, onFilterDropdownOpenChange } = column$1;
	const [visible, setVisible] = import_react.useState(false);
	const inMeasureRow = import_react.useContext(TableMeasureRowContext_default);
	const filtered = !!(filterState && (filterState.filteredKeys?.length || filterState.forceFiltered));
	const triggerVisible = (newVisible) => {
		setVisible(newVisible);
		filterDropdownProps.onOpenChange?.(newVisible);
		onFilterDropdownOpenChange?.(newVisible);
	};
	{
		const warning$3 = devUseWarning("Table");
		[["filterDropdownOpen", "filterDropdownProps.open"], ["onFilterDropdownOpenChange", "filterDropdownProps.onOpenChange"]].forEach(([deprecatedName, newName]) => {
			warning$3.deprecated(!(deprecatedName in column$1), deprecatedName, newName);
		});
		warning$3.deprecated(!("filterCheckall" in locale$5), "filterCheckall", "locale.filterCheckAll");
	}
	const mergedVisible = filterDropdownProps.open ?? filterDropdownOpen ?? visible;
	const propFilteredKeys = filterState?.filteredKeys;
	const [getFilteredKeysSync, setFilteredKeysSync] = useSyncState(wrapStringListType(propFilteredKeys));
	const onSelectKeys = ({ selectedKeys }) => {
		setFilteredKeysSync(selectedKeys);
	};
	const onCheck = (keys$1, { node: node$1, checked }) => {
		if (!filterMultiple) onSelectKeys({ selectedKeys: checked && node$1.key ? [node$1.key] : [] });
		else onSelectKeys({ selectedKeys: keys$1 });
	};
	import_react.useEffect(() => {
		if (!visible) return;
		onSelectKeys({ selectedKeys: wrapStringListType(propFilteredKeys) });
	}, [propFilteredKeys]);
	const [openKeys, setOpenKeys] = import_react.useState([]);
	const onOpenChange = (keys$1) => {
		setOpenKeys(keys$1);
	};
	const [searchValue, setSearchValue] = import_react.useState("");
	const onSearch = (e$2) => {
		const { value } = e$2.target;
		setSearchValue(value);
	};
	import_react.useEffect(() => {
		if (!visible) setSearchValue("");
	}, [visible]);
	const internalTriggerFilter = (keys$1) => {
		const mergedKeys = keys$1?.length ? keys$1 : null;
		if (mergedKeys === null && (!filterState || !filterState.filteredKeys)) return null;
		if (isEqual_default(mergedKeys, filterState?.filteredKeys, true)) return null;
		triggerFilter({
			column: column$1,
			key: columnKey,
			filteredKeys: mergedKeys
		});
	};
	const onConfirm = () => {
		triggerVisible(false);
		internalTriggerFilter(getFilteredKeysSync());
	};
	const onReset = ({ confirm: confirm$1, closeDropdown } = {
		confirm: false,
		closeDropdown: false
	}) => {
		if (confirm$1) internalTriggerFilter([]);
		if (closeDropdown) triggerVisible(false);
		setSearchValue("");
		if (filterResetToDefaultFilteredValue) setFilteredKeysSync((defaultFilteredValue || []).map((key) => String(key)));
		else setFilteredKeysSync([]);
	};
	const doFilter = ({ closeDropdown } = { closeDropdown: true }) => {
		if (closeDropdown) triggerVisible(false);
		internalTriggerFilter(getFilteredKeysSync());
	};
	const onVisibleChange = (newVisible, info) => {
		if (info.source === "trigger") {
			if (newVisible && propFilteredKeys !== void 0) setFilteredKeysSync(wrapStringListType(propFilteredKeys));
			triggerVisible(newVisible);
			if (!newVisible && !column$1.filterDropdown && filterOnClose) onConfirm();
		}
	};
	const dropdownMenuClass = clsx({ [`${dropdownPrefixCls}-menu-without-submenu`]: !hasSubMenu(column$1.filters || []) });
	const onCheckAll = (e$2) => {
		if (e$2.target.checked) setFilteredKeysSync(flattenKeys$1(column$1?.filters).map((key) => String(key)));
		else setFilteredKeysSync([]);
	};
	const getTreeData$1 = ({ filters }) => (filters || []).map((filter$2, index$1) => {
		const key = String(filter$2.value);
		const item = {
			title: filter$2.text,
			key: filter$2.value !== void 0 ? key : String(index$1)
		};
		if (filter$2.children) item.children = getTreeData$1({ filters: filter$2.children });
		return item;
	});
	const getFilterData$1 = (node$1) => ({
		...node$1,
		text: node$1.title,
		value: node$1.key,
		children: node$1.children?.map((item) => getFilterData$1(item)) || []
	});
	let dropdownContent;
	const { direction, renderEmpty } = import_react.useContext(ConfigContext);
	if (typeof column$1.filterDropdown === "function") dropdownContent = column$1.filterDropdown({
		prefixCls: `${dropdownPrefixCls}-custom`,
		setSelectedKeys: (selectedKeys) => onSelectKeys({ selectedKeys }),
		selectedKeys: getFilteredKeysSync(),
		confirm: doFilter,
		clearFilters: onReset,
		filters: column$1.filters,
		visible: mergedVisible,
		close: () => {
			triggerVisible(false);
		}
	});
	else if (column$1.filterDropdown) dropdownContent = column$1.filterDropdown;
	else {
		const selectedKeys = getFilteredKeysSync() || [];
		const getFilterComponent = () => {
			const empty$1 = renderEmpty?.("Table.filter") ?? /* @__PURE__ */ import_react.createElement(empty_default, {
				image: empty_default.PRESENTED_IMAGE_SIMPLE,
				description: locale$5.filterEmptyText,
				styles: { image: { height: 24 } },
				style: {
					margin: 0,
					padding: "16px 0"
				}
			});
			if ((column$1.filters || []).length === 0) return empty$1;
			if (filterMode === "tree") return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(FilterSearch_default, {
				filterSearch,
				value: searchValue,
				onChange: onSearch,
				tablePrefixCls,
				locale: locale$5
			}), /* @__PURE__ */ import_react.createElement("div", { className: `${tablePrefixCls}-filter-dropdown-tree` }, filterMultiple ? /* @__PURE__ */ import_react.createElement(checkbox_default, {
				checked: selectedKeys.length === flattenKeys$1(column$1.filters).length,
				indeterminate: selectedKeys.length > 0 && selectedKeys.length < flattenKeys$1(column$1.filters).length,
				className: `${tablePrefixCls}-filter-dropdown-checkall`,
				onChange: onCheckAll
			}, locale$5?.filterCheckall ?? locale$5?.filterCheckAll) : null, /* @__PURE__ */ import_react.createElement(tree_default, {
				checkable: true,
				selectable: false,
				blockNode: true,
				multiple: filterMultiple,
				checkStrictly: !filterMultiple,
				className: `${dropdownPrefixCls}-menu`,
				onCheck,
				checkedKeys: selectedKeys,
				selectedKeys,
				showIcon: false,
				treeData: getTreeData$1({ filters: column$1.filters }),
				autoExpandParent: true,
				defaultExpandAll: true,
				filterTreeNode: searchValue.trim() ? (node$1) => {
					if (typeof filterSearch === "function") return filterSearch(searchValue, getFilterData$1(node$1));
					return searchValueMatched(searchValue, node$1.title);
				} : void 0
			})));
			const items = renderFilterItems({
				filters: column$1.filters || [],
				filterSearch,
				prefixCls,
				filteredKeys: getFilteredKeysSync(),
				filterMultiple,
				searchValue
			});
			const isEmpty$1 = items.every((item) => item === null);
			return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(FilterSearch_default, {
				filterSearch,
				value: searchValue,
				onChange: onSearch,
				tablePrefixCls,
				locale: locale$5
			}), isEmpty$1 ? empty$1 : /* @__PURE__ */ import_react.createElement(menu_default, {
				selectable: true,
				multiple: filterMultiple,
				prefixCls: `${dropdownPrefixCls}-menu`,
				className: dropdownMenuClass,
				onSelect: onSelectKeys,
				onDeselect: onSelectKeys,
				selectedKeys,
				getPopupContainer,
				openKeys,
				onOpenChange,
				items
			}));
		};
		const getResetDisabled = () => {
			if (filterResetToDefaultFilteredValue) return isEqual_default((defaultFilteredValue || []).map((key) => String(key)), selectedKeys, true);
			return selectedKeys.length === 0;
		};
		dropdownContent = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, getFilterComponent(), /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-dropdown-btns` }, /* @__PURE__ */ import_react.createElement(Button_default, {
			type: "link",
			size: "small",
			disabled: getResetDisabled(),
			onClick: () => onReset()
		}, locale$5.filterReset), /* @__PURE__ */ import_react.createElement(Button_default, {
			type: "primary",
			size: "small",
			onClick: onConfirm
		}, locale$5.filterConfirm)));
	}
	if (column$1.filterDropdown) dropdownContent = /* @__PURE__ */ import_react.createElement(OverrideProvider, { selectable: void 0 }, dropdownContent);
	dropdownContent = /* @__PURE__ */ import_react.createElement(FilterWrapper_default, { className: `${prefixCls}-dropdown` }, dropdownContent);
	const getDropdownTrigger = () => {
		let filterIcon;
		if (typeof column$1.filterIcon === "function") filterIcon = column$1.filterIcon(filtered);
		else if (column$1.filterIcon) filterIcon = column$1.filterIcon;
		else filterIcon = /* @__PURE__ */ import_react.createElement(FilterFilled_default, null);
		return /* @__PURE__ */ import_react.createElement("span", {
			role: "button",
			tabIndex: -1,
			className: clsx(`${prefixCls}-trigger`, { active: filtered }),
			onClick: (e$2) => {
				e$2.stopPropagation();
			}
		}, filterIcon);
	};
	const triggerNode = getDropdownTrigger();
	if (inMeasureRow) return /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-column` }, /* @__PURE__ */ import_react.createElement("span", { className: `${tablePrefixCls}-column-title` }, children), triggerNode);
	const mergedDropdownProps = extendsObject_default({
		trigger: ["click"],
		placement: direction === "rtl" ? "bottomLeft" : "bottomRight",
		children: triggerNode,
		getPopupContainer
	}, {
		...filterDropdownProps,
		rootClassName: clsx(rootClassName, filterDropdownProps.rootClassName),
		open: mergedVisible,
		onOpenChange: onVisibleChange,
		popupRender: () => {
			if (typeof filterDropdownProps?.dropdownRender === "function") return filterDropdownProps.dropdownRender(dropdownContent);
			return dropdownContent;
		}
	});
	return /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-column` }, /* @__PURE__ */ import_react.createElement("span", { className: `${tablePrefixCls}-column-title` }, children), /* @__PURE__ */ import_react.createElement(dropdown_default, { ...mergedDropdownProps }));
};
var FilterDropdown_default = FilterDropdown;

//#endregion
//#region node_modules/antd/es/table/hooks/useFilter/index.js
var collectFilterStates = (columns, init, pos) => {
	let filterStates = [];
	(columns || []).forEach((column$1, index$1) => {
		const columnPos = getColumnPos(index$1, pos);
		const filterDropdownIsDefined = column$1.filterDropdown !== void 0;
		if (column$1.filters || filterDropdownIsDefined || "onFilter" in column$1) if ("filteredValue" in column$1) {
			let filteredValues = column$1.filteredValue;
			if (!filterDropdownIsDefined) filteredValues = filteredValues?.map(String) ?? filteredValues;
			filterStates.push({
				column: column$1,
				key: getColumnKey(column$1, columnPos),
				filteredKeys: filteredValues,
				forceFiltered: column$1.filtered
			});
		} else filterStates.push({
			column: column$1,
			key: getColumnKey(column$1, columnPos),
			filteredKeys: init && column$1.defaultFilteredValue ? column$1.defaultFilteredValue : void 0,
			forceFiltered: column$1.filtered
		});
		if ("children" in column$1) filterStates = [].concat(_toConsumableArray(filterStates), _toConsumableArray(collectFilterStates(column$1.children, init, columnPos)));
	});
	return filterStates;
};
function injectFilter(prefixCls, dropdownPrefixCls, columns, filterStates, locale$5, triggerFilter, getPopupContainer, pos, rootClassName) {
	return columns.map((column$1, index$1) => {
		const columnPos = getColumnPos(index$1, pos);
		const { filterOnClose = true, filterMultiple = true, filterMode, filterSearch } = column$1;
		let newColumn = column$1;
		if (newColumn.filters || newColumn.filterDropdown) {
			const columnKey = getColumnKey(newColumn, columnPos);
			const filterState = filterStates.find(({ key }) => columnKey === key);
			newColumn = {
				...newColumn,
				title: (renderProps) => /* @__PURE__ */ import_react.createElement(FilterDropdown_default, {
					tablePrefixCls: prefixCls,
					prefixCls: `${prefixCls}-filter`,
					dropdownPrefixCls,
					column: newColumn,
					columnKey,
					filterState,
					filterOnClose,
					filterMultiple,
					filterMode,
					filterSearch,
					triggerFilter,
					locale: locale$5,
					getPopupContainer,
					rootClassName
				}, renderColumnTitle(column$1.title, renderProps))
			};
		}
		if ("children" in newColumn) newColumn = {
			...newColumn,
			children: injectFilter(prefixCls, dropdownPrefixCls, newColumn.children, filterStates, locale$5, triggerFilter, getPopupContainer, columnPos, rootClassName)
		};
		return newColumn;
	});
}
var generateFilterInfo = (filterStates) => {
	const currentFilters = {};
	filterStates.forEach(({ key, filteredKeys, column: column$1 }) => {
		const keyAsString = key;
		const { filters, filterDropdown } = column$1;
		if (filterDropdown) currentFilters[keyAsString] = filteredKeys || null;
		else if (Array.isArray(filteredKeys)) currentFilters[keyAsString] = flattenKeys$1(filters).filter((originKey) => filteredKeys.includes(String(originKey)));
		else currentFilters[keyAsString] = null;
	});
	return currentFilters;
};
const getFilterData = (data, filterStates, childrenColumnName) => {
	return filterStates.reduce((currentData, filterState) => {
		const { column: { onFilter, filters }, filteredKeys } = filterState;
		if (onFilter && filteredKeys && filteredKeys.length) return currentData.map((record) => ({ ...record })).filter((record) => filteredKeys.some((key) => {
			const keys$1 = flattenKeys$1(filters);
			const keyIndex$1 = keys$1.findIndex((k) => String(k) === String(key));
			const realKey = keyIndex$1 !== -1 ? keys$1[keyIndex$1] : key;
			if (record[childrenColumnName]) record[childrenColumnName] = getFilterData(record[childrenColumnName], filterStates, childrenColumnName);
			return onFilter(realKey, record);
		}));
		return currentData;
	}, data);
};
var getMergedColumns = (rawMergedColumns) => rawMergedColumns.flatMap((column$1) => {
	if ("children" in column$1) return [column$1].concat(_toConsumableArray(getMergedColumns(column$1.children || [])));
	return [column$1];
});
var useFilter = (props) => {
	const { prefixCls, dropdownPrefixCls, mergedColumns: rawMergedColumns, onFilterChange, getPopupContainer, locale: tableLocale, rootClassName } = props;
	const warning$3 = devUseWarning("Table");
	const mergedColumns = import_react.useMemo(() => getMergedColumns(rawMergedColumns || []), [rawMergedColumns]);
	const [filterStates, setFilterStates] = import_react.useState(() => collectFilterStates(mergedColumns, true));
	const mergedFilterStates = import_react.useMemo(() => {
		const collectedStates = collectFilterStates(mergedColumns, false);
		if (collectedStates.length === 0) return collectedStates;
		let filteredKeysIsAllNotControlled = true;
		let filteredKeysIsAllControlled = true;
		collectedStates.forEach(({ filteredKeys }) => {
			if (filteredKeys !== void 0) filteredKeysIsAllNotControlled = false;
			else filteredKeysIsAllControlled = false;
		});
		if (filteredKeysIsAllNotControlled) {
			const keyList = (mergedColumns || []).map((column$1, index$1) => getColumnKey(column$1, getColumnPos(index$1)));
			return filterStates.filter(({ key }) => keyList.includes(key)).map((item) => {
				const col = mergedColumns[keyList.indexOf(item.key)];
				return {
					...item,
					column: {
						...item.column,
						...col
					},
					forceFiltered: col.filtered
				};
			});
		}
		warning$3(filteredKeysIsAllControlled, "usage", "Columns should all contain `filteredValue` or not contain `filteredValue`.");
		return collectedStates;
	}, [mergedColumns, filterStates]);
	const filters = import_react.useMemo(() => generateFilterInfo(mergedFilterStates), [mergedFilterStates]);
	const triggerFilter = (filterState) => {
		const newFilterStates = mergedFilterStates.filter(({ key }) => key !== filterState.key);
		newFilterStates.push(filterState);
		setFilterStates(newFilterStates);
		onFilterChange(generateFilterInfo(newFilterStates), newFilterStates);
	};
	const transformColumns = (innerColumns) => injectFilter(prefixCls, dropdownPrefixCls, innerColumns, mergedFilterStates, tableLocale, triggerFilter, getPopupContainer, void 0, rootClassName);
	return [
		transformColumns,
		mergedFilterStates,
		filters
	];
};
var useFilter_default = useFilter;

//#endregion
//#region node_modules/antd/es/table/hooks/useLazyKVMap.js
var useLazyKVMap = (data, childrenColumnName, getRowKey) => {
	const mapCacheRef = import_react.useRef({});
	function getRecordByKey(key) {
		if (!mapCacheRef.current || mapCacheRef.current.data !== data || mapCacheRef.current.childrenColumnName !== childrenColumnName || mapCacheRef.current.getRowKey !== getRowKey) {
			const kvMap = /* @__PURE__ */ new Map();
			function dig(records) {
				records.forEach((record, index$1) => {
					const rowKey = getRowKey(record, index$1);
					kvMap.set(rowKey, record);
					if (record && typeof record === "object" && childrenColumnName in record) dig(record[childrenColumnName] || []);
				});
			}
			dig(data);
			mapCacheRef.current = {
				data,
				childrenColumnName,
				kvMap,
				getRowKey
			};
		}
		return mapCacheRef.current.kvMap?.get(key);
	}
	return [getRecordByKey];
};
var useLazyKVMap_default = useLazyKVMap;

//#endregion
//#region node_modules/antd/es/table/hooks/usePagination.js
const DEFAULT_PAGE_SIZE = 10;
function getPaginationParam(mergedPagination, pagination) {
	const param = {
		current: mergedPagination.current,
		pageSize: mergedPagination.pageSize
	};
	const paginationObj = pagination && typeof pagination === "object" ? pagination : {};
	Object.keys(paginationObj).forEach((pageProp) => {
		const value = mergedPagination[pageProp];
		if (typeof value !== "function") param[pageProp] = value;
	});
	return param;
}
function usePagination(total, onChange, pagination) {
	const { total: paginationTotal = 0, ...paginationObj } = pagination && typeof pagination === "object" ? pagination : {};
	const [innerPagination, setInnerPagination] = (0, import_react.useState)(() => ({
		current: "defaultCurrent" in paginationObj ? paginationObj.defaultCurrent : 1,
		pageSize: "defaultPageSize" in paginationObj ? paginationObj.defaultPageSize : DEFAULT_PAGE_SIZE
	}));
	const mergedPagination = extendsObject_default(innerPagination, paginationObj, { total: paginationTotal > 0 ? paginationTotal : total });
	const maxPage = Math.ceil((paginationTotal || total) / mergedPagination.pageSize);
	if (mergedPagination.current > maxPage) mergedPagination.current = maxPage || 1;
	const refreshPagination = (current, pageSize) => {
		setInnerPagination({
			current: current ?? 1,
			pageSize: pageSize || mergedPagination.pageSize
		});
	};
	const onInternalChange = (current, pageSize) => {
		if (pagination) pagination.onChange?.(current, pageSize);
		refreshPagination(current, pageSize);
		onChange(current, pageSize || mergedPagination?.pageSize);
	};
	if (pagination === false) return [{}, () => {}];
	return [{
		...mergedPagination,
		onChange: onInternalChange
	}, refreshPagination];
}
var usePagination_default = usePagination;

//#endregion
//#region node_modules/antd/es/table/hooks/useSorter.js
var ASCEND = "ascend";
var DESCEND = "descend";
var getMultiplePriority = (column$1) => {
	if (typeof column$1.sorter === "object" && typeof column$1.sorter.multiple === "number") return column$1.sorter.multiple;
	return false;
};
var getSortFunction = (sorter) => {
	if (typeof sorter === "function") return sorter;
	if (sorter && typeof sorter === "object" && sorter.compare) return sorter.compare;
	return false;
};
var nextSortDirection = (sortDirections, current) => {
	if (!current) return sortDirections[0];
	return sortDirections[sortDirections.indexOf(current) + 1];
};
var collectSortStates = (columns, init, pos) => {
	let sortStates = [];
	const pushState = (column$1, columnPos) => {
		sortStates.push({
			column: column$1,
			key: getColumnKey(column$1, columnPos),
			multiplePriority: getMultiplePriority(column$1),
			sortOrder: column$1.sortOrder
		});
	};
	(columns || []).forEach((column$1, index$1) => {
		const columnPos = getColumnPos(index$1, pos);
		if (column$1.children) {
			if ("sortOrder" in column$1) pushState(column$1, columnPos);
			sortStates = [].concat(_toConsumableArray(sortStates), _toConsumableArray(collectSortStates(column$1.children, init, columnPos)));
		} else if (column$1.sorter) {
			if ("sortOrder" in column$1) pushState(column$1, columnPos);
			else if (init && column$1.defaultSortOrder) sortStates.push({
				column: column$1,
				key: getColumnKey(column$1, columnPos),
				multiplePriority: getMultiplePriority(column$1),
				sortOrder: column$1.defaultSortOrder
			});
		}
	});
	return sortStates;
};
var injectSorter = (prefixCls, columns, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, pos, a11yLocale) => {
	return (columns || []).map((column$1, index$1) => {
		const columnPos = getColumnPos(index$1, pos);
		let newColumn = column$1;
		if (newColumn.sorter) {
			const sortDirections = newColumn.sortDirections || defaultSortDirections;
			const showSorterTooltip = newColumn.showSorterTooltip === void 0 ? tableShowSorterTooltip : newColumn.showSorterTooltip;
			const columnKey = getColumnKey(newColumn, columnPos);
			const sorterState = sorterStates.find(({ key }) => key === columnKey);
			const sortOrder = sorterState ? sorterState.sortOrder : null;
			const nextSortOrder = nextSortDirection(sortDirections, sortOrder);
			let sorter;
			if (column$1.sortIcon) sorter = column$1.sortIcon({ sortOrder });
			else {
				const upNode = sortDirections.includes(ASCEND) && /* @__PURE__ */ import_react.createElement(CaretUpOutlined_default, { className: clsx(`${prefixCls}-column-sorter-up`, { active: sortOrder === ASCEND }) });
				const downNode = sortDirections.includes(DESCEND) && /* @__PURE__ */ import_react.createElement(CaretDownOutlined_default, { className: clsx(`${prefixCls}-column-sorter-down`, { active: sortOrder === DESCEND }) });
				sorter = /* @__PURE__ */ import_react.createElement("span", { className: clsx(`${prefixCls}-column-sorter`, { [`${prefixCls}-column-sorter-full`]: !!(upNode && downNode) }) }, /* @__PURE__ */ import_react.createElement("span", {
					className: `${prefixCls}-column-sorter-inner`,
					"aria-hidden": "true"
				}, upNode, downNode));
			}
			const { cancelSort, triggerAsc, triggerDesc } = tableLocale || {};
			let sortTip = cancelSort;
			if (nextSortOrder === DESCEND) sortTip = triggerDesc;
			else if (nextSortOrder === ASCEND) sortTip = triggerAsc;
			const tooltipProps = typeof showSorterTooltip === "object" ? {
				title: sortTip,
				...showSorterTooltip
			} : { title: sortTip };
			newColumn = {
				...newColumn,
				className: clsx(newColumn.className, { [`${prefixCls}-column-sort`]: sortOrder }),
				title: (renderProps) => {
					const columnSortersClass = `${prefixCls}-column-sorters`;
					const renderColumnTitleWrapper = /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-column-title` }, renderColumnTitle(column$1.title, renderProps));
					const renderSortTitle = /* @__PURE__ */ import_react.createElement("div", { className: columnSortersClass }, renderColumnTitleWrapper, sorter);
					if (showSorterTooltip) {
						if (typeof showSorterTooltip !== "boolean" && showSorterTooltip?.target === "sorter-icon") return /* @__PURE__ */ import_react.createElement("div", { className: clsx(columnSortersClass, `${columnSortersClass}-tooltip-target-sorter`) }, renderColumnTitleWrapper, /* @__PURE__ */ import_react.createElement(tooltip_default, { ...tooltipProps }, sorter));
						return /* @__PURE__ */ import_react.createElement(tooltip_default, { ...tooltipProps }, renderSortTitle);
					}
					return renderSortTitle;
				},
				onHeaderCell: (col) => {
					const cell = column$1.onHeaderCell?.(col) || {};
					const originOnClick = cell.onClick;
					const originOKeyDown = cell.onKeyDown;
					cell.onClick = (event) => {
						triggerSorter({
							column: column$1,
							key: columnKey,
							sortOrder: nextSortOrder,
							multiplePriority: getMultiplePriority(column$1)
						});
						originOnClick?.(event);
					};
					cell.onKeyDown = (event) => {
						if (event.keyCode === KeyCode_default.ENTER) {
							triggerSorter({
								column: column$1,
								key: columnKey,
								sortOrder: nextSortOrder,
								multiplePriority: getMultiplePriority(column$1)
							});
							originOKeyDown?.(event);
						}
					};
					const renderTitle = safeColumnTitle(column$1.title, {});
					const displayTitle = renderTitle?.toString();
					if (sortOrder) cell["aria-sort"] = sortOrder === "ascend" ? "ascending" : "descending";
					cell["aria-description"] = a11yLocale?.sortable;
					cell["aria-label"] = displayTitle || "";
					cell.className = clsx(cell.className, `${prefixCls}-column-has-sorters`);
					cell.tabIndex = 0;
					if (column$1.ellipsis) cell.title = (renderTitle ?? "").toString();
					return cell;
				}
			};
		}
		if ("children" in newColumn) newColumn = {
			...newColumn,
			children: injectSorter(prefixCls, newColumn.children, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, columnPos, a11yLocale)
		};
		return newColumn;
	});
};
var stateToInfo = (sorterState) => {
	const { column: column$1, sortOrder } = sorterState;
	return {
		column: column$1,
		order: sortOrder,
		field: column$1.dataIndex,
		columnKey: column$1.key
	};
};
var generateSorterInfo = (sorterStates) => {
	const activeSorters = sorterStates.filter(({ sortOrder }) => sortOrder).map(stateToInfo);
	if (activeSorters.length === 0 && sorterStates.length) return {
		...stateToInfo(sorterStates[sorterStates.length - 1]),
		column: void 0,
		order: void 0,
		field: void 0,
		columnKey: void 0
	};
	if (activeSorters.length <= 1) return activeSorters[0] || {};
	return activeSorters;
};
const getSortData = (data, sortStates, childrenColumnName) => {
	const innerSorterStates = sortStates.slice().sort((a, b) => b.multiplePriority - a.multiplePriority);
	const cloneData = data.slice();
	const runningSorters = innerSorterStates.filter(({ column: { sorter }, sortOrder }) => getSortFunction(sorter) && sortOrder);
	if (!runningSorters.length) return cloneData;
	return cloneData.sort((record1, record2) => {
		for (let i = 0; i < runningSorters.length; i += 1) {
			const { column: { sorter }, sortOrder } = runningSorters[i];
			const compareFn = getSortFunction(sorter);
			if (compareFn && sortOrder) {
				const compareResult = compareFn(record1, record2, sortOrder);
				if (compareResult !== 0) return sortOrder === ASCEND ? compareResult : -compareResult;
			}
		}
		return 0;
	}).map((record) => {
		const subRecords = record[childrenColumnName];
		if (subRecords) return {
			...record,
			[childrenColumnName]: getSortData(subRecords, sortStates, childrenColumnName)
		};
		return record;
	});
};
var useFilterSorter = (props) => {
	const { prefixCls, mergedColumns, sortDirections, tableLocale, showSorterTooltip, onSorterChange, globalLocale } = props;
	const [sortStates, setSortStates] = import_react.useState(() => collectSortStates(mergedColumns, true));
	const getColumnKeys = (columns, pos) => {
		const newKeys = [];
		columns.forEach((item, index$1) => {
			const columnPos = getColumnPos(index$1, pos);
			newKeys.push(getColumnKey(item, columnPos));
			if (Array.isArray(item.children)) {
				const childKeys = getColumnKeys(item.children, columnPos);
				newKeys.push.apply(newKeys, _toConsumableArray(childKeys));
			}
		});
		return newKeys;
	};
	const mergedSorterStates = import_react.useMemo(() => {
		let validate = true;
		const collectedStates = collectSortStates(mergedColumns, false);
		if (!collectedStates.length) {
			const mergedColumnsKeys = getColumnKeys(mergedColumns);
			return sortStates.filter(({ key }) => mergedColumnsKeys.includes(key));
		}
		const validateStates = [];
		function patchStates(state) {
			if (validate) validateStates.push(state);
			else validateStates.push({
				...state,
				sortOrder: null
			});
		}
		let multipleMode = null;
		collectedStates.forEach((state) => {
			if (multipleMode === null) {
				patchStates(state);
				if (state.sortOrder) if (state.multiplePriority === false) validate = false;
				else multipleMode = true;
			} else if (multipleMode && state.multiplePriority !== false) patchStates(state);
			else {
				validate = false;
				patchStates(state);
			}
		});
		return validateStates;
	}, [mergedColumns, sortStates]);
	const columnTitleSorterProps = import_react.useMemo(() => {
		const sortColumns = mergedSorterStates.map(({ column: column$1, sortOrder }) => ({
			column: column$1,
			order: sortOrder
		}));
		return {
			sortColumns,
			sortColumn: sortColumns[0]?.column,
			sortOrder: sortColumns[0]?.order
		};
	}, [mergedSorterStates]);
	const triggerSorter = (sortState) => {
		let newSorterStates;
		if (sortState.multiplePriority === false || !mergedSorterStates.length || mergedSorterStates[0].multiplePriority === false) newSorterStates = [sortState];
		else newSorterStates = [].concat(_toConsumableArray(mergedSorterStates.filter(({ key }) => key !== sortState.key)), [sortState]);
		setSortStates(newSorterStates);
		onSorterChange(generateSorterInfo(newSorterStates), newSorterStates);
	};
	const transformColumns = (innerColumns) => injectSorter(prefixCls, innerColumns, mergedSorterStates, triggerSorter, sortDirections, tableLocale, showSorterTooltip, void 0, globalLocale);
	const getSorters = () => generateSorterInfo(mergedSorterStates);
	return [
		transformColumns,
		mergedSorterStates,
		columnTitleSorterProps,
		getSorters
	];
};
var useSorter_default = useFilterSorter;

//#endregion
//#region node_modules/antd/es/table/hooks/useTitleColumns.js
var fillTitle = (columns, columnTitleProps) => {
	return columns.map((column$1) => {
		const cloneColumn = { ...column$1 };
		cloneColumn.title = renderColumnTitle(column$1.title, columnTitleProps);
		if ("children" in cloneColumn) cloneColumn.children = fillTitle(cloneColumn.children, columnTitleProps);
		return cloneColumn;
	});
};
var useTitleColumns = (columnTitleProps) => {
	return [import_react.useCallback((columns) => fillTitle(columns, columnTitleProps), [columnTitleProps])];
};
var useTitleColumns_default = useTitleColumns;

//#endregion
//#region node_modules/antd/es/table/RcTable/index.js
/**
* Same as `rc-component/table` but we modify trigger children update logic instead.
*/
var RcTable = genTable((prev$1, next$1) => {
	const { _renderTimes: prevRenderTimes } = prev$1;
	const { _renderTimes: nextRenderTimes } = next$1;
	return prevRenderTimes !== nextRenderTimes;
});
var RcTable_default = RcTable;

//#endregion
//#region node_modules/antd/es/table/RcTable/VirtualTable.js
/**
* Same as `rc-component/table` but we modify trigger children update logic instead.
*/
var RcVirtualTable = genVirtualTable((prev$1, next$1) => {
	const { _renderTimes: prevRenderTimes } = prev$1;
	const { _renderTimes: nextRenderTimes } = next$1;
	return prevRenderTimes !== nextRenderTimes;
});
var VirtualTable_default = RcVirtualTable;

//#endregion
//#region node_modules/antd/es/table/style/bordered.js
var genBorderedStyle = (token$1) => {
	const { componentCls, lineWidth, lineType, tableBorderColor, tableHeaderBg, tablePaddingVertical, tablePaddingHorizontal, calc } = token$1;
	const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
	const getSizeBorderStyle = (size, paddingVertical, paddingHorizontal) => ({ [`&${componentCls}-${size}`]: { [`> ${componentCls}-container`]: { [`> ${componentCls}-content, > ${componentCls}-body`]: { [`
            > table > tbody > tr > th,
            > table > tbody > tr > td
          `]: { [`> ${componentCls}-expanded-row-fixed`]: { margin: `${unit(calc(paddingVertical).mul(-1).equal())}
              ${unit(calc(calc(paddingHorizontal).add(lineWidth)).mul(-1).equal())}` } } } } } });
	return { [`${componentCls}-wrapper`]: {
		[`${componentCls}${componentCls}-bordered`]: {
			[`> ${componentCls}-title`]: {
				border: tableBorder,
				borderBottom: 0
			},
			[`> ${componentCls}-container`]: {
				borderInlineStart: tableBorder,
				borderTop: tableBorder,
				[`
            > ${componentCls}-content,
            > ${componentCls}-header,
            > ${componentCls}-body,
            > ${componentCls}-summary
          `]: { "> table": {
					[`
                > thead > tr > th,
                > thead > tr > td,
                > tbody > tr > th,
                > tbody > tr > td,
                > tfoot > tr > th,
                > tfoot > tr > td
              `]: { borderInlineEnd: tableBorder },
					"> thead": {
						"> tr:not(:last-child) > th": { borderBottom: tableBorder },
						"> tr > th::before": { backgroundColor: "transparent !important" }
					},
					[`
                > thead > tr,
                > tbody > tr,
                > tfoot > tr
              `]: { [`> ${componentCls}-cell-fix-right-first::after`]: { borderInlineEnd: tableBorder } },
					[`
                > tbody > tr > th,
                > tbody > tr > td
              `]: { [`> ${componentCls}-expanded-row-fixed`]: {
						margin: `${unit(calc(tablePaddingVertical).mul(-1).equal())} ${unit(calc(calc(tablePaddingHorizontal).add(lineWidth)).mul(-1).equal())}`,
						"&::after": {
							position: "absolute",
							top: 0,
							insetInlineEnd: lineWidth,
							bottom: 0,
							borderInlineEnd: tableBorder,
							content: "\"\""
						}
					} }
				} }
			},
			[`&${componentCls}-scroll-horizontal`]: { [`> ${componentCls}-container > ${componentCls}-body`]: { "> table > tbody": { [`
                > tr${componentCls}-expanded-row,
                > tr${componentCls}-placeholder
              `]: { "> th, > td": { borderInlineEnd: 0 } } } } },
			...getSizeBorderStyle("middle", token$1.tablePaddingVerticalMiddle, token$1.tablePaddingHorizontalMiddle),
			...getSizeBorderStyle("small", token$1.tablePaddingVerticalSmall, token$1.tablePaddingHorizontalSmall),
			[`> ${componentCls}-footer`]: {
				border: tableBorder,
				borderTop: 0
			}
		},
		[`${componentCls}-cell`]: {
			[`${componentCls}-container:first-child`]: { borderTop: 0 },
			"&-scrollbar:not([rowspan])": { boxShadow: `0 ${unit(lineWidth)} 0 ${unit(lineWidth)} ${tableHeaderBg}` }
		},
		[`${componentCls}-bordered ${componentCls}-cell-scrollbar`]: { borderInlineEnd: tableBorder }
	} };
};
var bordered_default = genBorderedStyle;

//#endregion
//#region node_modules/antd/es/table/style/ellipsis.js
var genEllipsisStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-wrapper`]: { [`${componentCls}-cell-ellipsis`]: {
		...textEllipsis,
		wordBreak: "keep-all",
		[`
          &${componentCls}-cell-fix-start-shadow,
          &${componentCls}-cell-fix-end-shadow
        `]: {
			overflow: "visible",
			[`${componentCls}-cell-content`]: {
				...textEllipsis,
				display: "block"
			}
		},
		[`${componentCls}-column-title`]: {
			...textEllipsis,
			wordBreak: "keep-all"
		}
	} } };
};
var ellipsis_default = genEllipsisStyle;

//#endregion
//#region node_modules/antd/es/table/style/empty.js
var genEmptyStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-wrapper`]: { [`${componentCls}-tbody > tr${componentCls}-placeholder`]: {
		textAlign: "center",
		color: token$1.colorTextDisabled,
		[`
          &:hover > th,
          &:hover > td,
        `]: { background: token$1.colorBgContainer }
	} } };
};
var empty_default$1 = genEmptyStyle;

//#endregion
//#region node_modules/antd/es/table/style/expand.js
var genExpandStyle = (token$1) => {
	const { componentCls, antCls, motionDurationSlow, lineWidth, paddingXS, lineType, tableBorderColor, tableExpandIconBg, tableExpandColumnWidth, borderRadius, tablePaddingVertical, tablePaddingHorizontal, tableExpandedRowBg, paddingXXS, expandIconMarginTop, expandIconSize, expandIconHalfInner, expandIconScale, calc } = token$1;
	const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
	const expandIconLineOffset = calc(paddingXXS).sub(lineWidth).equal();
	return { [`${componentCls}-wrapper`]: {
		[`${componentCls}-expand-icon-col`]: { width: tableExpandColumnWidth },
		[`${componentCls}-row-expand-icon-cell`]: {
			textAlign: "center",
			[`${componentCls}-row-expand-icon`]: {
				display: "inline-flex",
				float: "none",
				verticalAlign: "sub"
			}
		},
		[`${componentCls}-row-indent`]: {
			height: 1,
			float: "left"
		},
		[`${componentCls}-row-expand-icon`]: {
			...operationUnit(token$1),
			position: "relative",
			float: "left",
			width: expandIconSize,
			height: expandIconSize,
			color: "inherit",
			lineHeight: unit(expandIconSize),
			background: tableExpandIconBg,
			border: tableBorder,
			borderRadius,
			transform: `scale(${expandIconScale})`,
			"&:focus, &:hover, &:active": { borderColor: "currentcolor" },
			"&::before, &::after": {
				position: "absolute",
				background: "currentcolor",
				transition: `transform ${motionDurationSlow} ease-out`,
				content: "\"\""
			},
			"&::before": {
				top: expandIconHalfInner,
				insetInlineEnd: expandIconLineOffset,
				insetInlineStart: expandIconLineOffset,
				height: lineWidth
			},
			"&::after": {
				top: expandIconLineOffset,
				bottom: expandIconLineOffset,
				insetInlineStart: expandIconHalfInner,
				width: lineWidth,
				transform: "rotate(90deg)"
			},
			"&-collapsed::before": { transform: "rotate(-180deg)" },
			"&-collapsed::after": { transform: "rotate(0deg)" },
			"&-spaced": {
				"&::before, &::after": {
					display: "none",
					content: "none"
				},
				background: "transparent",
				border: 0,
				visibility: "hidden"
			}
		},
		[`${componentCls}-row-indent + ${componentCls}-row-expand-icon`]: {
			marginTop: expandIconMarginTop,
			marginInlineEnd: paddingXS
		},
		[`tr${componentCls}-expanded-row`]: {
			"&, &:hover": { "> th, > td": { background: tableExpandedRowBg } },
			[`${antCls}-descriptions-view`]: {
				display: "flex",
				table: {
					flex: "auto",
					width: "100%"
				}
			}
		},
		[`${componentCls}-expanded-row-fixed`]: {
			position: "relative",
			margin: `${unit(calc(tablePaddingVertical).mul(-1).equal())} ${unit(calc(tablePaddingHorizontal).mul(-1).equal())}`,
			padding: `${unit(tablePaddingVertical)} ${unit(tablePaddingHorizontal)}`
		}
	} };
};
var expand_default = genExpandStyle;

//#endregion
//#region node_modules/antd/es/table/style/filter.js
var genFilterStyle = (token$1) => {
	const { componentCls, antCls, iconCls, tableFilterDropdownWidth, tableFilterDropdownSearchWidth, paddingXXS, paddingXS, colorText, lineWidth, lineType, tableBorderColor, headerIconColor, fontSizeSM, tablePaddingHorizontal, borderRadius, motionDurationSlow, colorIcon, colorPrimary, tableHeaderFilterActiveBg, colorTextDisabled, tableFilterDropdownBg, tableFilterDropdownHeight, controlItemBgHover, controlItemBgActive, boxShadowSecondary, filterDropdownMenuBg, calc } = token$1;
	const dropdownPrefixCls = `${antCls}-dropdown`;
	const tableFilterDropdownPrefixCls = `${componentCls}-filter-dropdown`;
	const treePrefixCls = `${antCls}-tree`;
	const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
	return [
		{ [`${componentCls}-wrapper`]: {
			[`${componentCls}-filter-column`]: {
				display: "flex",
				justifyContent: "space-between"
			},
			[`${componentCls}-filter-trigger`]: {
				position: "relative",
				display: "flex",
				alignItems: "center",
				marginBlock: calc(paddingXXS).mul(-1).equal(),
				marginInline: `${unit(paddingXXS)} ${unit(calc(tablePaddingHorizontal).div(2).mul(-1).equal())}`,
				padding: `0 ${unit(paddingXXS)}`,
				color: headerIconColor,
				fontSize: fontSizeSM,
				borderRadius,
				cursor: "pointer",
				transition: `all ${motionDurationSlow}`,
				"&:hover": {
					color: colorIcon,
					background: tableHeaderFilterActiveBg
				},
				"&.active": { color: colorPrimary }
			}
		} },
		{ [`${antCls}-dropdown`]: { [tableFilterDropdownPrefixCls]: {
			...resetComponent(token$1),
			minWidth: tableFilterDropdownWidth,
			backgroundColor: tableFilterDropdownBg,
			borderRadius,
			boxShadow: boxShadowSecondary,
			overflow: "hidden",
			[`${dropdownPrefixCls}-menu`]: {
				maxHeight: tableFilterDropdownHeight,
				overflowX: "hidden",
				border: 0,
				boxShadow: "none",
				borderRadius: "unset",
				backgroundColor: filterDropdownMenuBg,
				"&:empty::after": {
					display: "block",
					padding: `${unit(paddingXS)} 0`,
					color: colorTextDisabled,
					fontSize: fontSizeSM,
					textAlign: "center",
					content: "\"Not Found\""
				}
			},
			[`${tableFilterDropdownPrefixCls}-tree`]: {
				paddingBlock: `${unit(paddingXS)} 0`,
				paddingInline: paddingXS,
				[treePrefixCls]: { padding: 0 },
				[`${treePrefixCls}-treenode ${treePrefixCls}-node-content-wrapper:hover`]: { backgroundColor: controlItemBgHover },
				[`${treePrefixCls}-treenode-checkbox-checked ${treePrefixCls}-node-content-wrapper`]: { "&, &:hover": { backgroundColor: controlItemBgActive } }
			},
			[`${tableFilterDropdownPrefixCls}-search`]: {
				padding: paddingXS,
				borderBottom: tableBorder,
				"&-input": {
					input: { minWidth: tableFilterDropdownSearchWidth },
					[iconCls]: { color: colorTextDisabled }
				}
			},
			[`${tableFilterDropdownPrefixCls}-checkall`]: {
				width: "100%",
				marginBottom: paddingXXS,
				marginInlineStart: paddingXXS
			},
			[`${tableFilterDropdownPrefixCls}-btns`]: {
				display: "flex",
				justifyContent: "space-between",
				padding: `${unit(calc(paddingXS).sub(lineWidth).equal())} ${unit(paddingXS)}`,
				overflow: "hidden",
				borderTop: tableBorder
			}
		} } },
		{ [`${antCls}-dropdown ${tableFilterDropdownPrefixCls}, ${tableFilterDropdownPrefixCls}-submenu`]: {
			[`${antCls}-checkbox-wrapper + span`]: {
				paddingInlineStart: paddingXS,
				color: colorText
			},
			"> ul": {
				maxHeight: "calc(100vh - 130px)",
				overflowX: "hidden",
				overflowY: "auto"
			}
		} }
	];
};
var filter_default = genFilterStyle;

//#endregion
//#region node_modules/antd/es/table/style/fixed.js
function getShadowStyle({ colorSplit: shadowColor }) {
	return [{ boxShadow: `inset 10px 0 8px -8px ${shadowColor}` }, { boxShadow: `inset -10px 0 8px -8px ${shadowColor}` }];
}
var genFixedStyle = (token$1) => {
	const { componentCls, lineWidth, motionDurationSlow, zIndexTableFixed: zIndexTableFixed$1, tableBg, calc } = token$1;
	const cellCls = `${componentCls}-cell`;
	const fixCellCls = `${cellCls}-fix`;
	const sharedShadowStyle = {
		position: "absolute",
		top: 0,
		bottom: calc(lineWidth).mul(-1).equal(),
		width: 30,
		transition: `box-shadow ${motionDurationSlow}`,
		content: "\"\"",
		pointerEvents: "none"
	};
	const [leftShadowStyle, rightShadowStyle] = getShadowStyle(token$1);
	return { [`${componentCls}-wrapper`]: {
		[`${cellCls}${fixCellCls}`]: { position: "sticky" },
		[fixCellCls]: {
			zIndex: `calc(var(--z-offset-reverse) + ${zIndexTableFixed$1})`,
			background: tableBg,
			"&:after": sharedShadowStyle,
			"&-start:after": { insetInlineStart: "100%" },
			"&-end:after": { insetInlineEnd: "100%" },
			"&-start-shadow-show:after": leftShadowStyle,
			"&-end-shadow-show:after": rightShadowStyle
		},
		[`${componentCls}-container`]: {
			position: "relative",
			"&:before, &:after": {
				...sharedShadowStyle,
				zIndex: `calc(var(--columns-count) * 2 + ${zIndexTableFixed$1} + 1)`
			},
			"&:before": { insetInlineStart: 0 },
			"&:after": { insetInlineEnd: 0 }
		},
		[`${componentCls}-has-fix-start ${componentCls}-container:before`]: { display: "none" },
		[`${componentCls}-has-fix-end ${componentCls}-container:after`]: { display: "none" },
		[`${componentCls}-fix-start-shadow-show ${componentCls}-container:before`]: leftShadowStyle,
		[`${componentCls}-fix-end-shadow-show ${componentCls}-container:after`]: rightShadowStyle
	} };
};
var fixed_default = genFixedStyle;

//#endregion
//#region node_modules/antd/es/table/style/pagination.js
var genPaginationStyle = (token$1) => {
	const { componentCls, antCls, margin } = token$1;
	return { [`${componentCls}-wrapper`]: {
		[`${componentCls}-pagination${antCls}-pagination`]: { margin: `${unit(margin)} 0` },
		[`${componentCls}-pagination`]: {
			display: "flex",
			flexWrap: "wrap",
			rowGap: token$1.paddingXS,
			"> *": { flex: "none" },
			"&-start": { justifyContent: "flex-start" },
			"&-center": { justifyContent: "center" },
			"&-end": { justifyContent: "flex-end" }
		}
	} };
};
var pagination_default$1 = genPaginationStyle;

//#endregion
//#region node_modules/antd/es/table/style/radius.js
var genRadiusStyle = (token$1) => {
	const { componentCls, tableRadius } = token$1;
	return { [`${componentCls}-wrapper`]: { [componentCls]: {
		[`${componentCls}-title, ${componentCls}-header`]: { borderRadius: `${unit(tableRadius)} ${unit(tableRadius)} 0 0` },
		[`${componentCls}-title + ${componentCls}-container`]: {
			borderStartStartRadius: 0,
			borderStartEndRadius: 0,
			[`${componentCls}-header, table`]: { borderRadius: 0 },
			"table > thead > tr:first-child": { "th:first-child, th:last-child, td:first-child, td:last-child": { borderRadius: 0 } }
		},
		"&-container": {
			borderStartStartRadius: tableRadius,
			borderStartEndRadius: tableRadius,
			"table > thead > tr:first-child": {
				"> *:first-child": { borderStartStartRadius: tableRadius },
				"> *:last-child": { borderStartEndRadius: tableRadius }
			}
		},
		"&-footer": { borderRadius: `0 0 ${unit(tableRadius)} ${unit(tableRadius)}` }
	} } };
};
var radius_default = genRadiusStyle;

//#endregion
//#region node_modules/antd/es/table/style/rtl.js
var genStyle = (token$1) => {
	const { componentCls } = token$1;
	const [leftShadowStyle, rightShadowStyle] = getShadowStyle(token$1);
	return { [`${componentCls}-wrapper-rtl`]: {
		direction: "rtl",
		table: { direction: "rtl" },
		[`${componentCls}-row-expand-icon`]: {
			float: "right",
			"&::after": { transform: "rotate(-90deg)" },
			"&-collapsed::before": { transform: "rotate(180deg)" },
			"&-collapsed::after": { transform: "rotate(0deg)" }
		},
		[`${componentCls}-cell-fix`]: {
			"&-start-shadow-show:after": rightShadowStyle,
			"&-end-shadow-show:after": leftShadowStyle
		},
		[`${componentCls}-container`]: { [`${componentCls}-row-indent`]: { float: "right" } },
		[`${componentCls}-fix-start-shadow-show ${componentCls}-container:before`]: rightShadowStyle,
		[`${componentCls}-fix-end-shadow-show ${componentCls}-container:after`]: leftShadowStyle
	} };
};
var rtl_default$1 = genStyle;

//#endregion
//#region node_modules/antd/es/table/style/selection.js
var genSelectionStyle = (token$1) => {
	const { componentCls, antCls, iconCls, fontSizeIcon, padding, paddingXS, headerIconColor, headerIconHoverColor, tableSelectionColumnWidth, tableSelectedRowBg, tableSelectedRowHoverBg, tableRowHoverBg, tablePaddingHorizontal, calc } = token$1;
	return { [`${componentCls}-wrapper`]: {
		[`${componentCls}-selection-col`]: {
			width: tableSelectionColumnWidth,
			[`&${componentCls}-selection-col-with-dropdown`]: { width: calc(tableSelectionColumnWidth).add(fontSizeIcon).add(calc(padding).div(4)).equal() }
		},
		[`${componentCls}-bordered ${componentCls}-selection-col`]: {
			width: calc(tableSelectionColumnWidth).add(calc(paddingXS).mul(2)).equal(),
			[`&${componentCls}-selection-col-with-dropdown`]: { width: calc(tableSelectionColumnWidth).add(fontSizeIcon).add(calc(padding).div(4)).add(calc(paddingXS).mul(2)).equal() }
		},
		[`
        table tr th${componentCls}-selection-column,
        table tr td${componentCls}-selection-column,
        ${componentCls}-selection-column
      `]: {
			paddingInlineEnd: token$1.paddingXS,
			paddingInlineStart: token$1.paddingXS,
			textAlign: "center",
			[`${antCls}-radio-wrapper`]: { marginInlineEnd: 0 }
		},
		[`table tr th${componentCls}-selection-column${componentCls}-cell-fix-left`]: { zIndex: calc(token$1.zIndexTableFixed).add(1).equal({ unit: false }) },
		[`table tr th${componentCls}-selection-column::after`]: { backgroundColor: "transparent !important" },
		[`${componentCls}-selection`]: {
			position: "relative",
			display: "inline-flex",
			flexDirection: "column"
		},
		[`${componentCls}-selection-extra`]: {
			position: "absolute",
			top: 0,
			zIndex: 1,
			cursor: "pointer",
			transition: `all ${token$1.motionDurationSlow}`,
			marginInlineStart: "100%",
			paddingInlineStart: unit(calc(tablePaddingHorizontal).div(4).equal()),
			[iconCls]: {
				color: headerIconColor,
				fontSize: fontSizeIcon,
				verticalAlign: "baseline",
				"&:hover": { color: headerIconHoverColor }
			}
		},
		[`${componentCls}-tbody`]: { [`${componentCls}-row`]: {
			[`&${componentCls}-row-selected`]: { [`> ${componentCls}-cell`]: {
				background: tableSelectedRowBg,
				"&-row-hover": { background: tableSelectedRowHoverBg }
			} },
			[`> ${componentCls}-cell-row-hover`]: { background: tableRowHoverBg }
		} }
	} };
};
var selection_default = genSelectionStyle;

//#endregion
//#region node_modules/antd/es/table/style/size.js
var genSizeStyle = (token$1) => {
	const { componentCls, tableExpandColumnWidth, calc } = token$1;
	const getSizeStyle = (size, paddingVertical, paddingHorizontal, fontSize) => ({ [`${componentCls}${componentCls}-${size}`]: {
		fontSize,
		[`
        ${componentCls}-title,
        ${componentCls}-footer,
        ${componentCls}-cell,
        ${componentCls}-thead > tr > th,
        ${componentCls}-tbody > tr > th,
        ${componentCls}-tbody > tr > td,
        tfoot > tr > th,
        tfoot > tr > td
      `]: { padding: `${unit(paddingVertical)} ${unit(paddingHorizontal)}` },
		[`${componentCls}-filter-trigger`]: { marginInlineEnd: unit(calc(paddingHorizontal).div(2).mul(-1).equal()) },
		[`${componentCls}-expanded-row-fixed`]: { margin: `${unit(calc(paddingVertical).mul(-1).equal())} ${unit(calc(paddingHorizontal).mul(-1).equal())}` },
		[`${componentCls}-tbody`]: { [`${componentCls}-wrapper:only-child ${componentCls}`]: {
			marginBlock: unit(calc(paddingVertical).mul(-1).equal()),
			marginInline: `${unit(calc(tableExpandColumnWidth).sub(paddingHorizontal).equal())} ${unit(calc(paddingHorizontal).mul(-1).equal())}`
		} },
		[`${componentCls}-selection-extra`]: { paddingInlineStart: unit(calc(paddingHorizontal).div(4).equal()) }
	} });
	return { [`${componentCls}-wrapper`]: {
		...getSizeStyle("middle", token$1.tablePaddingVerticalMiddle, token$1.tablePaddingHorizontalMiddle, token$1.tableFontSizeMiddle),
		...getSizeStyle("small", token$1.tablePaddingVerticalSmall, token$1.tablePaddingHorizontalSmall, token$1.tableFontSizeSmall)
	} };
};
var size_default = genSizeStyle;

//#endregion
//#region node_modules/antd/es/table/style/sorter.js
var genSorterStyle = (token$1) => {
	const { componentCls, marginXXS, fontSizeIcon, headerIconColor, headerIconHoverColor } = token$1;
	return { [`${componentCls}-wrapper`]: {
		[`${componentCls}-thead th${componentCls}-column-has-sorters`]: {
			outline: "none",
			cursor: "pointer",
			transition: `all ${token$1.motionDurationSlow}, left 0s`,
			"&:hover": {
				background: token$1.tableHeaderSortHoverBg,
				"&::before": { backgroundColor: "transparent !important" }
			},
			"&:focus-visible": { color: token$1.colorPrimary },
			[`
          &${componentCls}-cell-fix-left:hover,
          &${componentCls}-cell-fix-right:hover
        `]: { background: token$1.tableFixedHeaderSortActiveBg }
		},
		[`${componentCls}-thead th${componentCls}-column-sort`]: {
			background: token$1.tableHeaderSortBg,
			"&::before": { backgroundColor: "transparent !important" }
		},
		[`td${componentCls}-column-sort`]: { background: token$1.tableBodySortBg },
		[`${componentCls}-column-title`]: {
			position: "relative",
			zIndex: 1,
			flex: 1,
			minWidth: 0
		},
		[`${componentCls}-column-sorters`]: {
			display: "flex",
			flex: "auto",
			alignItems: "center",
			justifyContent: "space-between",
			"&::after": {
				position: "absolute",
				inset: 0,
				width: "100%",
				height: "100%",
				content: "\"\""
			}
		},
		[`${componentCls}-column-sorters-tooltip-target-sorter`]: { "&::after": { content: "none" } },
		[`${componentCls}-column-sorter`]: {
			marginInlineStart: marginXXS,
			color: headerIconColor,
			fontSize: 0,
			transition: `color ${token$1.motionDurationSlow}`,
			"&-inner": {
				display: "inline-flex",
				flexDirection: "column",
				alignItems: "center"
			},
			"&-up, &-down": {
				fontSize: fontSizeIcon,
				"&.active": { color: token$1.colorPrimary }
			},
			[`${componentCls}-column-sorter-up + ${componentCls}-column-sorter-down`]: { marginTop: "-0.3em" }
		},
		[`${componentCls}-column-sorters:hover ${componentCls}-column-sorter`]: { color: headerIconHoverColor }
	} };
};
var sorter_default = genSorterStyle;

//#endregion
//#region node_modules/antd/es/table/style/sticky.js
var genStickyStyle = (token$1) => {
	const { componentCls, opacityLoading, tableScrollThumbBg, tableScrollThumbBgHover, tableScrollThumbSize, tableScrollBg, stickyScrollBarBorderRadius, lineWidth, lineType, tableBorderColor, zIndexTableFixed: zIndexTableFixed$1 } = token$1;
	const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
	return { [`${componentCls}-wrapper`]: { [`${componentCls}-sticky`]: {
		"&-holder": {
			position: "sticky",
			zIndex: `calc(var(--columns-count) * 2 + ${zIndexTableFixed$1} + 1)`,
			background: token$1.colorBgContainer
		},
		"&-scroll": {
			position: "sticky",
			bottom: 0,
			height: `${unit(tableScrollThumbSize)} !important`,
			zIndex: `calc(var(--columns-count) * 2 + ${zIndexTableFixed$1} + 1)`,
			display: "flex",
			alignItems: "center",
			background: tableScrollBg,
			borderTop: tableBorder,
			opacity: opacityLoading,
			"&:hover": { transformOrigin: "center bottom" },
			"&-bar": {
				height: tableScrollThumbSize,
				backgroundColor: tableScrollThumbBg,
				borderRadius: stickyScrollBarBorderRadius,
				transition: `all ${token$1.motionDurationSlow}, transform 0s`,
				position: "absolute",
				bottom: 0,
				"&:hover, &-active": { backgroundColor: tableScrollThumbBgHover }
			}
		}
	} } };
};
var sticky_default = genStickyStyle;

//#endregion
//#region node_modules/antd/es/table/style/summary.js
var genSummaryStyle = (token$1) => {
	const { componentCls, lineWidth, tableBorderColor, calc } = token$1;
	const tableBorder = `${unit(lineWidth)} ${token$1.lineType} ${tableBorderColor}`;
	return { [`${componentCls}-wrapper`]: {
		[`${componentCls}-summary`]: {
			position: "relative",
			zIndex: token$1.zIndexTableFixed,
			background: token$1.tableBg,
			"> tr": { "> th, > td": { borderBottom: tableBorder } }
		},
		[`div${componentCls}-summary`]: { boxShadow: `0 ${unit(calc(lineWidth).mul(-1).equal())} 0 ${tableBorderColor}` }
	} };
};
var summary_default = genSummaryStyle;

//#endregion
//#region node_modules/antd/es/table/style/virtual.js
var genVirtualStyle = (token$1) => {
	const { componentCls, motionDurationMid, lineWidth, lineType, tableBorderColor, calc } = token$1;
	const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
	const rowCellCls = `${componentCls}-expanded-row-cell`;
	return { [`${componentCls}-wrapper`]: {
		[`${componentCls}-tbody-virtual`]: {
			[`${componentCls}-tbody-virtual-holder-inner`]: { [`
            & > ${componentCls}-row, 
            & > div:not(${componentCls}-row) > ${componentCls}-row
          `]: {
				display: "flex",
				boxSizing: "border-box",
				width: "100%"
			} },
			[`${componentCls}-cell`]: {
				borderBottom: tableBorder,
				transition: `background ${motionDurationMid}`
			},
			[`${componentCls}-expanded-row`]: { [`${rowCellCls}${rowCellCls}-fixed`]: {
				position: "sticky",
				insetInlineStart: 0,
				overflow: "hidden",
				width: `calc(var(--virtual-width) - ${unit(lineWidth)})`,
				borderInlineEnd: "none"
			} }
		},
		[`${componentCls}-bordered`]: {
			[`${componentCls}-tbody-virtual`]: {
				"&:after": {
					content: "\"\"",
					insetInline: 0,
					bottom: 0,
					borderBottom: tableBorder,
					position: "absolute"
				},
				[`${componentCls}-cell`]: {
					borderInlineEnd: tableBorder,
					[`&${componentCls}-cell-fix-right-first:before`]: {
						content: "\"\"",
						position: "absolute",
						insetBlock: 0,
						insetInlineStart: calc(lineWidth).mul(-1).equal(),
						borderInlineStart: tableBorder
					}
				}
			},
			[`&${componentCls}-virtual`]: { [`${componentCls}-placeholder ${componentCls}-cell`]: {
				borderInlineEnd: tableBorder,
				borderBottom: tableBorder
			} }
		}
	} };
};
var virtual_default = genVirtualStyle;

//#endregion
//#region node_modules/antd/es/table/style/index.js
var genTableStyle = (token$1) => {
	const { componentCls, fontWeightStrong, tablePaddingVertical, tablePaddingHorizontal, tableExpandColumnWidth, lineWidth, lineType, tableBorderColor, tableFontSize, tableBg, tableRadius, tableHeaderTextColor, motionDurationMid, tableHeaderBg, tableHeaderCellSplitColor, tableFooterTextColor, tableFooterBg, calc } = token$1;
	const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
	return { [`${componentCls}-wrapper`]: {
		clear: "both",
		maxWidth: "100%",
		["--rc-virtual-list-scrollbar-bg"]: token$1.tableScrollBg,
		...clearFix(),
		[componentCls]: {
			...resetComponent(token$1),
			fontSize: tableFontSize,
			background: tableBg,
			borderRadius: `${unit(tableRadius)} ${unit(tableRadius)} 0 0`,
			scrollbarColor: `${token$1.tableScrollThumbBg} ${token$1.tableScrollBg}`
		},
		table: {
			width: "100%",
			textAlign: "start",
			borderRadius: `${unit(tableRadius)} ${unit(tableRadius)} 0 0`,
			borderCollapse: "separate",
			borderSpacing: 0
		},
		[`
          ${componentCls}-cell,
          ${componentCls}-thead > tr > th,
          ${componentCls}-tbody > tr > th,
          ${componentCls}-tbody > tr > td,
          tfoot > tr > th,
          tfoot > tr > td
        `]: {
			position: "relative",
			padding: `${unit(tablePaddingVertical)} ${unit(tablePaddingHorizontal)}`,
			overflowWrap: "break-word"
		},
		[`${componentCls}-title`]: { padding: `${unit(tablePaddingVertical)} ${unit(tablePaddingHorizontal)}` },
		[`${componentCls}-thead`]: {
			[`
          > tr > th,
          > tr > td
        `]: {
				position: "relative",
				color: tableHeaderTextColor,
				fontWeight: fontWeightStrong,
				textAlign: "start",
				background: tableHeaderBg,
				borderBottom: tableBorder,
				transition: `background ${motionDurationMid} ease`,
				"&[colspan]:not([colspan='1'])": { textAlign: "center" },
				[`&:not(:last-child):not(${componentCls}-selection-column):not(${componentCls}-row-expand-icon-cell):not([colspan])::before`]: {
					position: "absolute",
					top: "50%",
					insetInlineEnd: 0,
					width: 1,
					height: "1.6em",
					backgroundColor: tableHeaderCellSplitColor,
					transform: "translateY(-50%)",
					transition: `background-color ${motionDurationMid}`,
					content: "\"\""
				}
			},
			"> tr:not(:last-child) > th[colspan]": { borderBottom: 0 }
		},
		[`${componentCls}-tbody`]: { "> tr": {
			"> th, > td": {
				transition: `background ${motionDurationMid}, border-color ${motionDurationMid}`,
				borderBottom: tableBorder,
				[`
              > ${componentCls}-wrapper:only-child,
              > ${componentCls}-expanded-row-fixed > ${componentCls}-wrapper:only-child
            `]: { [componentCls]: {
					marginBlock: unit(calc(tablePaddingVertical).mul(-1).equal()),
					marginInline: `${unit(calc(tableExpandColumnWidth).sub(tablePaddingHorizontal).equal())}
                ${unit(calc(tablePaddingHorizontal).mul(-1).equal())}`,
					[`${componentCls}-tbody > tr:last-child > td`]: {
						borderBottomWidth: 0,
						"&:first-child, &:last-child": { borderRadius: 0 }
					}
				} }
			},
			"> th": {
				position: "relative",
				color: tableHeaderTextColor,
				fontWeight: fontWeightStrong,
				textAlign: "start",
				background: tableHeaderBg,
				borderBottom: tableBorder,
				transition: `background ${motionDurationMid} ease`
			},
			[`& > ${componentCls}-measure-cell`]: {
				paddingBlock: `0 !important`,
				borderBlock: `0 !important`,
				[`${componentCls}-measure-cell-content`]: {
					height: 0,
					overflow: "hidden",
					pointerEvents: "none"
				}
			}
		} },
		[`${componentCls}-footer`]: {
			padding: `${unit(tablePaddingVertical)} ${unit(tablePaddingHorizontal)}`,
			color: tableFooterTextColor,
			background: tableFooterBg
		}
	} };
};
const prepareComponentToken$6 = (token$1) => {
	const { colorFillAlter, colorBgContainer, colorTextHeading, colorFillSecondary, colorFillContent, controlItemBgActive, controlItemBgActiveHover, padding, paddingSM, paddingXS, colorBorderSecondary, borderRadiusLG, controlHeight, colorTextPlaceholder, fontSize, fontSizeSM, lineHeight, lineWidth, colorIcon, colorIconHover, opacityLoading, controlInteractiveSize } = token$1;
	const colorFillSecondarySolid = new FastColor(colorFillSecondary).onBackground(colorBgContainer).toHexString();
	const colorFillContentSolid = new FastColor(colorFillContent).onBackground(colorBgContainer).toHexString();
	const colorFillAlterSolid = new FastColor(colorFillAlter).onBackground(colorBgContainer).toHexString();
	const baseColorAction = new FastColor(colorIcon);
	const baseColorActionHover = new FastColor(colorIconHover);
	const expandIconHalfInner = controlInteractiveSize / 2 - lineWidth;
	const expandIconSize = expandIconHalfInner * 2 + lineWidth * 3;
	return {
		headerBg: colorFillAlterSolid,
		headerColor: colorTextHeading,
		headerSortActiveBg: colorFillSecondarySolid,
		headerSortHoverBg: colorFillContentSolid,
		bodySortBg: colorFillAlterSolid,
		rowHoverBg: colorFillAlterSolid,
		rowSelectedBg: controlItemBgActive,
		rowSelectedHoverBg: controlItemBgActiveHover,
		rowExpandedBg: colorFillAlter,
		cellPaddingBlock: padding,
		cellPaddingInline: padding,
		cellPaddingBlockMD: paddingSM,
		cellPaddingInlineMD: paddingXS,
		cellPaddingBlockSM: paddingXS,
		cellPaddingInlineSM: paddingXS,
		borderColor: colorBorderSecondary,
		headerBorderRadius: borderRadiusLG,
		footerBg: colorFillAlterSolid,
		footerColor: colorTextHeading,
		cellFontSize: fontSize,
		cellFontSizeMD: fontSize,
		cellFontSizeSM: fontSize,
		headerSplitColor: colorBorderSecondary,
		fixedHeaderSortActiveBg: colorFillSecondarySolid,
		headerFilterHoverBg: colorFillContent,
		filterDropdownMenuBg: colorBgContainer,
		filterDropdownBg: colorBgContainer,
		expandIconBg: colorBgContainer,
		selectionColumnWidth: controlHeight,
		stickyScrollBarBg: colorTextPlaceholder,
		stickyScrollBarBorderRadius: 100,
		expandIconMarginTop: (fontSize * lineHeight - lineWidth * 3) / 2 - Math.ceil((fontSizeSM * 1.4 - lineWidth * 3) / 2),
		headerIconColor: baseColorAction.clone().setA(baseColorAction.a * opacityLoading).toRgbString(),
		headerIconHoverColor: baseColorActionHover.clone().setA(baseColorActionHover.a * opacityLoading).toRgbString(),
		expandIconHalfInner,
		expandIconSize,
		expandIconScale: controlInteractiveSize / expandIconSize
	};
};
var zIndexTableFixed = 2;
var style_default$7 = genStyleHooks("Table", (token$1) => {
	const { colorTextHeading, colorSplit, colorBgContainer, controlInteractiveSize: checkboxSize, headerBg, headerColor, headerSortActiveBg, headerSortHoverBg, bodySortBg, rowHoverBg, rowSelectedBg, rowSelectedHoverBg, rowExpandedBg, cellPaddingBlock, cellPaddingInline, cellPaddingBlockMD, cellPaddingInlineMD, cellPaddingBlockSM, cellPaddingInlineSM, borderColor, footerBg, footerColor, headerBorderRadius, cellFontSize, cellFontSizeMD, cellFontSizeSM, headerSplitColor, fixedHeaderSortActiveBg, headerFilterHoverBg, filterDropdownBg, expandIconBg, selectionColumnWidth, stickyScrollBarBg, calc } = token$1;
	const tableToken = merge(token$1, {
		tableFontSize: cellFontSize,
		tableBg: colorBgContainer,
		tableRadius: headerBorderRadius,
		tablePaddingVertical: cellPaddingBlock,
		tablePaddingHorizontal: cellPaddingInline,
		tablePaddingVerticalMiddle: cellPaddingBlockMD,
		tablePaddingHorizontalMiddle: cellPaddingInlineMD,
		tablePaddingVerticalSmall: cellPaddingBlockSM,
		tablePaddingHorizontalSmall: cellPaddingInlineSM,
		tableBorderColor: borderColor,
		tableHeaderTextColor: headerColor,
		tableHeaderBg: headerBg,
		tableFooterTextColor: footerColor,
		tableFooterBg: footerBg,
		tableHeaderCellSplitColor: headerSplitColor,
		tableHeaderSortBg: headerSortActiveBg,
		tableHeaderSortHoverBg: headerSortHoverBg,
		tableBodySortBg: bodySortBg,
		tableFixedHeaderSortActiveBg: fixedHeaderSortActiveBg,
		tableHeaderFilterActiveBg: headerFilterHoverBg,
		tableFilterDropdownBg: filterDropdownBg,
		tableRowHoverBg: rowHoverBg,
		tableSelectedRowBg: rowSelectedBg,
		tableSelectedRowHoverBg: rowSelectedHoverBg,
		zIndexTableFixed,
		tableFontSizeMiddle: cellFontSizeMD,
		tableFontSizeSmall: cellFontSizeSM,
		tableSelectionColumnWidth: selectionColumnWidth,
		tableExpandIconBg: expandIconBg,
		tableExpandColumnWidth: calc(checkboxSize).add(calc(token$1.padding).mul(2)).equal(),
		tableExpandedRowBg: rowExpandedBg,
		tableFilterDropdownWidth: 120,
		tableFilterDropdownHeight: 264,
		tableFilterDropdownSearchWidth: 140,
		tableScrollThumbSize: 8,
		tableScrollThumbBg: stickyScrollBarBg,
		tableScrollThumbBgHover: colorTextHeading,
		tableScrollBg: colorSplit
	});
	return [
		genTableStyle(tableToken),
		pagination_default$1(tableToken),
		summary_default(tableToken),
		sorter_default(tableToken),
		filter_default(tableToken),
		bordered_default(tableToken),
		radius_default(tableToken),
		expand_default(tableToken),
		summary_default(tableToken),
		empty_default$1(tableToken),
		selection_default(tableToken),
		fixed_default(tableToken),
		sticky_default(tableToken),
		ellipsis_default(tableToken),
		size_default(tableToken),
		rtl_default$1(tableToken),
		virtual_default(tableToken)
	];
}, prepareComponentToken$6, {
	resetFont: false,
	unitless: { expandIconScale: true }
});

//#endregion
//#region node_modules/antd/es/table/InternalTable.js
var EMPTY_LIST = [];
var InternalTable = (props, ref) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, style: style$1, classNames, styles, size: customizeSize, bordered, dropdownPrefixCls: customizeDropdownPrefixCls, dataSource, pagination, rowSelection, rowKey: customizeRowKey, rowClassName, columns, children, childrenColumnName: legacyChildrenColumnName, onChange, getPopupContainer, loading, expandIcon, expandable, expandedRowRender, expandIconColumnIndex, indentSize, scroll, sortDirections, locale: locale$5, showSorterTooltip = { target: "full-header" }, virtual } = props;
	const warning$3 = devUseWarning("Table");
	const baseColumns = import_react.useMemo(() => columns || convertChildrenToColumns(children), [columns, children]);
	const screens = useBreakpoint_default(import_react.useMemo(() => baseColumns.some((col) => col.responsive), [baseColumns]));
	const mergedColumns = import_react.useMemo(() => {
		const matched = new Set(Object.keys(screens).filter((m) => screens[m]));
		return baseColumns.filter((c) => !c.responsive || c.responsive.some((r$1) => matched.has(r$1)));
	}, [baseColumns, screens]);
	const tableProps = omit(props, [
		"className",
		"style",
		"columns"
	]);
	const { locale: contextLocale = en_US_default, table } = import_react.useContext(ConfigContext);
	const { getPrefixCls, direction, renderEmpty, getPopupContainer: getContextPopupContainer, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("table");
	const mergedSize = useSize_default(customizeSize);
	const mergedProps = {
		...props,
		size: mergedSize,
		bordered
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps }, {
		pagination: { _default: "root" },
		header: { _default: "wrapper" },
		body: { _default: "wrapper" }
	});
	const tableLocale = {
		...contextLocale.Table,
		...locale$5
	};
	const [globalLocale] = useLocale_default("global", en_US_default.global);
	const rawData = dataSource || EMPTY_LIST;
	const prefixCls = getPrefixCls("table", customizePrefixCls);
	const dropdownPrefixCls = getPrefixCls("dropdown", customizeDropdownPrefixCls);
	const [, token$1] = useToken();
	const rootCls = useCSSVarCls_default(prefixCls);
	const [hashId, cssVarCls] = style_default$7(prefixCls, rootCls);
	const mergedExpandable = {
		childrenColumnName: legacyChildrenColumnName,
		expandIconColumnIndex,
		...expandable,
		expandIcon: expandable?.expandIcon ?? table?.expandable?.expandIcon
	};
	const { childrenColumnName = "children" } = mergedExpandable;
	const expandType = import_react.useMemo(() => {
		if (rawData.some((item) => item?.[childrenColumnName])) return "nest";
		if (expandedRowRender || expandable?.expandedRowRender) return "row";
		return null;
	}, [childrenColumnName, rawData]);
	const internalRefs = { body: import_react.useRef(null) };
	const getContainerWidth = useContainerWidth(prefixCls);
	const rootRef = import_react.useRef(null);
	const tblRef = import_react.useRef(null);
	useProxyImperativeHandle(ref, () => ({
		...tblRef.current,
		nativeElement: rootRef.current
	}));
	const rowKey = customizeRowKey || table?.rowKey || "key";
	warning$3(!(typeof rowKey === "function" && rowKey.length > 1), "usage", "`index` parameter of `rowKey` function is deprecated. There is no guarantee that it will work as expected.");
	const getRowKey = import_react.useMemo(() => {
		if (typeof rowKey === "function") return rowKey;
		return (record) => record?.[rowKey];
	}, [rowKey]);
	const [getRecordByKey] = useLazyKVMap_default(rawData, childrenColumnName, getRowKey);
	const changeEventInfo = {};
	const triggerOnChange = (info, action, reset = false) => {
		const changeInfo = {
			...changeEventInfo,
			...info
		};
		if (reset) {
			changeEventInfo.resetPagination?.();
			if (changeInfo.pagination?.current) changeInfo.pagination.current = 1;
			if (pagination) pagination.onChange?.(1, changeInfo.pagination?.pageSize);
		}
		if (scroll && scroll.scrollToFirstRowOnChange !== false && internalRefs.body.current) scrollTo(0, { getContainer: () => internalRefs.body.current });
		onChange?.(changeInfo.pagination, changeInfo.filters, changeInfo.sorter, {
			currentDataSource: getFilterData(getSortData(rawData, changeInfo.sorterStates, childrenColumnName), changeInfo.filterStates, childrenColumnName),
			action
		});
	};
	/**
	* Controlled state in `columns` is not a good idea that makes too many code (1000+ line?) to read
	* state out and then put it back to title render. Move these code into `hooks` but still too
	* complex. We should provides Table props like `sorter` & `filter` to handle control in next big
	* version.
	*/
	const onSorterChange = (sorter, sorterStates) => {
		triggerOnChange({
			sorter,
			sorterStates
		}, "sort", false);
	};
	const [transformSorterColumns, sortStates, sorterTitleProps, getSorters] = useSorter_default({
		prefixCls,
		mergedColumns,
		onSorterChange,
		sortDirections: sortDirections || ["ascend", "descend"],
		tableLocale,
		showSorterTooltip,
		globalLocale
	});
	const sortedData = import_react.useMemo(() => getSortData(rawData, sortStates, childrenColumnName), [
		childrenColumnName,
		rawData,
		sortStates
	]);
	changeEventInfo.sorter = getSorters();
	changeEventInfo.sorterStates = sortStates;
	const onFilterChange = (filters$1, filterStates$1) => {
		triggerOnChange({
			filters: filters$1,
			filterStates: filterStates$1
		}, "filter", true);
	};
	const [transformFilterColumns, filterStates, filters] = useFilter_default({
		prefixCls,
		locale: tableLocale,
		dropdownPrefixCls,
		mergedColumns,
		onFilterChange,
		getPopupContainer: getPopupContainer || getContextPopupContainer,
		rootClassName: clsx(rootClassName, rootCls)
	});
	const mergedData = getFilterData(sortedData, filterStates, childrenColumnName);
	changeEventInfo.filters = filters;
	changeEventInfo.filterStates = filterStates;
	const [transformTitleColumns] = useTitleColumns_default(import_react.useMemo(() => {
		const mergedFilters = {};
		Object.keys(filters).forEach((filterKey) => {
			if (filters[filterKey] !== null) mergedFilters[filterKey] = filters[filterKey];
		});
		return {
			...sorterTitleProps,
			filters: mergedFilters
		};
	}, [sorterTitleProps, filters]));
	const onPaginationChange = (current, pageSize) => {
		triggerOnChange({ pagination: {
			...changeEventInfo.pagination,
			current,
			pageSize
		} }, "paginate");
	};
	const [mergedPagination, resetPagination] = usePagination_default(mergedData.length, onPaginationChange, pagination);
	changeEventInfo.pagination = pagination === false ? {} : getPaginationParam(mergedPagination, pagination);
	changeEventInfo.resetPagination = resetPagination;
	const pageData = import_react.useMemo(() => {
		if (pagination === false || !mergedPagination.pageSize) return mergedData;
		const { current = 1, total, pageSize = DEFAULT_PAGE_SIZE } = mergedPagination;
		warning$3(current > 0, "usage", "`current` should be positive number.");
		if (mergedData.length < total) {
			if (mergedData.length > pageSize) {
				warning$3(false, "usage", "`dataSource` length is less than `pagination.total` but large than `pagination.pageSize`. Please make sure your config correct data with async mode.");
				return mergedData.slice((current - 1) * pageSize, current * pageSize);
			}
			return mergedData;
		}
		return mergedData.slice((current - 1) * pageSize, current * pageSize);
	}, [
		!!pagination,
		mergedData,
		mergedPagination?.current,
		mergedPagination?.pageSize,
		mergedPagination?.total
	]);
	const [transformSelectionColumns, selectedKeySet] = useSelection_default$1({
		prefixCls,
		data: mergedData,
		pageData,
		getRowKey,
		getRecordByKey,
		expandType,
		childrenColumnName,
		locale: tableLocale,
		getPopupContainer: getPopupContainer || getContextPopupContainer
	}, rowSelection);
	const internalRowClassName = (record, index$1, indent) => {
		const resolvedRowClassName = typeof rowClassName === "function" ? rowClassName(record, index$1, indent) : rowClassName;
		return clsx({ [`${prefixCls}-row-selected`]: selectedKeySet.has(getRowKey(record, index$1)) }, resolvedRowClassName);
	};
	mergedExpandable.__PARENT_RENDER_ICON__ = mergedExpandable.expandIcon;
	mergedExpandable.expandIcon = mergedExpandable.expandIcon || expandIcon || ExpandIcon_default(tableLocale);
	if (expandType === "nest" && mergedExpandable.expandIconColumnIndex === void 0) mergedExpandable.expandIconColumnIndex = rowSelection ? 1 : 0;
	else if (mergedExpandable.expandIconColumnIndex > 0 && rowSelection) mergedExpandable.expandIconColumnIndex -= 1;
	if (typeof mergedExpandable.indentSize !== "number") mergedExpandable.indentSize = typeof indentSize === "number" ? indentSize : 15;
	const transformColumns = import_react.useCallback((innerColumns) => transformTitleColumns(transformSelectionColumns(transformFilterColumns(transformSorterColumns(innerColumns)))), [
		transformSorterColumns,
		transformFilterColumns,
		transformSelectionColumns
	]);
	let topPaginationNode;
	let bottomPaginationNode;
	if (pagination !== false && mergedPagination?.total) {
		let paginationSize;
		if (mergedPagination.size) paginationSize = mergedPagination.size;
		else paginationSize = mergedSize === "small" || mergedSize === "middle" ? "small" : void 0;
		const renderPagination = (placement$1 = "end") => /* @__PURE__ */ import_react.createElement(pagination_default, {
			...mergedPagination,
			classNames: mergedClassNames.pagination,
			styles: mergedStyles.pagination,
			className: clsx(`${prefixCls}-pagination ${prefixCls}-pagination-${placement$1}`, mergedPagination.className),
			size: paginationSize
		});
		const { placement, position: position$2 } = mergedPagination;
		const mergedPlacement = placement ?? position$2;
		const normalizePlacement = (pos) => {
			const lowerPos = pos.toLowerCase();
			if (lowerPos.includes("center")) return "center";
			return lowerPos.includes("left") || lowerPos.includes("start") ? "start" : "end";
		};
		if (Array.isArray(mergedPlacement)) {
			const [topPos, bottomPos] = ["top", "bottom"].map((dir) => mergedPlacement.find((p) => p.includes(dir)));
			const isDisable = mergedPlacement.every((p) => `${p}` === "none");
			if (!topPos && !bottomPos && !isDisable) bottomPaginationNode = renderPagination();
			if (topPos) topPaginationNode = renderPagination(normalizePlacement(topPos));
			if (bottomPos) bottomPaginationNode = renderPagination(normalizePlacement(bottomPos));
		} else bottomPaginationNode = renderPagination();
		warning$3.deprecated(!position$2, "pagination.position", "pagination.placement");
	}
	const spinProps = import_react.useMemo(() => {
		if (typeof loading === "boolean") return { spinning: loading };
		else if (typeof loading === "object" && loading !== null) return {
			spinning: true,
			...loading
		};
		else return;
	}, [loading]);
	const wrappercls = clsx(cssVarCls, rootCls, `${prefixCls}-wrapper`, contextClassName, { [`${prefixCls}-wrapper-rtl`]: direction === "rtl" }, className, rootClassName, mergedClassNames.root, hashId);
	const mergedStyle = {
		...mergedStyles.root,
		...contextStyle,
		...style$1
	};
	const mergedEmptyNode = import_react.useMemo(() => {
		if (spinProps?.spinning && rawData === EMPTY_LIST) return null;
		if (typeof locale$5?.emptyText !== "undefined") return locale$5.emptyText;
		return renderEmpty?.("Table") || /* @__PURE__ */ import_react.createElement(defaultRenderEmpty_default, { componentName: "Table" });
	}, [
		spinProps?.spinning,
		rawData,
		locale$5?.emptyText,
		renderEmpty
	]);
	const TableComponent = virtual ? VirtualTable_default : RcTable_default;
	const virtualProps = {};
	const listItemHeight = import_react.useMemo(() => {
		const { fontSize, lineHeight, lineWidth, padding, paddingXS, paddingSM } = token$1;
		const fontHeight = Math.floor(fontSize * lineHeight);
		switch (mergedSize) {
			case "middle": return paddingSM * 2 + fontHeight + lineWidth;
			case "small": return paddingXS * 2 + fontHeight + lineWidth;
			default: return padding * 2 + fontHeight + lineWidth;
		}
	}, [token$1, mergedSize]);
	if (virtual) virtualProps.listItemHeight = listItemHeight;
	return /* @__PURE__ */ import_react.createElement("div", {
		ref: rootRef,
		className: wrappercls,
		style: mergedStyle
	}, /* @__PURE__ */ import_react.createElement(spin_default, {
		spinning: false,
		...spinProps
	}, topPaginationNode, /* @__PURE__ */ import_react.createElement(TableComponent, {
		...virtualProps,
		...tableProps,
		classNames: mergedClassNames,
		styles: mergedStyles,
		ref: tblRef,
		columns: mergedColumns,
		direction,
		expandable: mergedExpandable,
		prefixCls,
		className: clsx({
			[`${prefixCls}-middle`]: mergedSize === "middle",
			[`${prefixCls}-small`]: mergedSize === "small",
			[`${prefixCls}-bordered`]: bordered,
			[`${prefixCls}-empty`]: rawData.length === 0
		}, cssVarCls, rootCls, hashId),
		data: pageData,
		rowKey: getRowKey,
		rowClassName: internalRowClassName,
		emptyText: mergedEmptyNode,
		internalHooks: INTERNAL_HOOKS,
		internalRefs,
		transformColumns,
		getContainerWidth,
		measureRowRender: (measureRow) => /* @__PURE__ */ import_react.createElement(TableMeasureRowContext_default.Provider, { value: true }, /* @__PURE__ */ import_react.createElement(config_provider_default, { getPopupContainer: (node$1) => node$1 }, measureRow))
	}), bottomPaginationNode));
};
var InternalTable_default = /* @__PURE__ */ import_react.forwardRef(InternalTable);

//#endregion
//#region node_modules/antd/es/table/Table.js
var Table = (props, ref) => {
	const renderTimesRef = import_react.useRef(0);
	renderTimesRef.current += 1;
	return /* @__PURE__ */ import_react.createElement(InternalTable_default, {
		...props,
		ref,
		_renderTimes: renderTimesRef.current
	});
};
var ForwardTable = /* @__PURE__ */ import_react.forwardRef(Table);
ForwardTable.SELECTION_COLUMN = SELECTION_COLUMN;
ForwardTable.EXPAND_COLUMN = EXPAND_COLUMN;
ForwardTable.SELECTION_ALL = SELECTION_ALL;
ForwardTable.SELECTION_INVERT = SELECTION_INVERT;
ForwardTable.SELECTION_NONE = SELECTION_NONE;
ForwardTable.Column = Column_default;
ForwardTable.ColumnGroup = ColumnGroup_default;
ForwardTable.Summary = FooterComponents;
ForwardTable.displayName = "Table";
var Table_default = ForwardTable;

//#endregion
//#region node_modules/antd/es/table/index.js
var table_default = Table_default;

//#endregion
//#region node_modules/antd/es/tag/style/index.js
var genBaseStyle$3 = (token$1) => {
	const { paddingXXS, lineWidth, tagPaddingHorizontal, componentCls, calc } = token$1;
	const paddingInline = calc(tagPaddingHorizontal).sub(lineWidth).equal();
	const iconMarginInline = calc(paddingXXS).sub(lineWidth).equal();
	return {
		[componentCls]: {
			...resetComponent(token$1),
			display: "inline-block",
			height: "auto",
			paddingInline,
			fontSize: token$1.tagFontSize,
			lineHeight: token$1.tagLineHeight,
			whiteSpace: "nowrap",
			backgroundColor: token$1.defaultBg,
			border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`,
			borderRadius: token$1.borderRadiusSM,
			opacity: 1,
			transition: `all ${token$1.motionDurationMid}`,
			textAlign: "start",
			position: "relative",
			[`&${componentCls}-rtl`]: { direction: "rtl" },
			"&, a, a:hover": { color: token$1.defaultColor },
			[`${componentCls}-close-icon`]: {
				marginInlineStart: iconMarginInline,
				fontSize: token$1.tagIconSize,
				color: token$1.colorIcon,
				cursor: "pointer",
				transition: `all ${token$1.motionDurationMid}`,
				"&:hover": { color: token$1.colorTextHeading }
			},
			"&-checkable": {
				backgroundColor: "transparent",
				borderColor: "transparent",
				cursor: "pointer",
				[`&:not(${componentCls}-checkable-checked):hover`]: {
					color: token$1.colorPrimary,
					backgroundColor: token$1.colorFillSecondary
				},
				"&:active, &-checked": { color: token$1.colorTextLightSolid },
				"&-checked": {
					backgroundColor: token$1.colorPrimary,
					"&:hover": { backgroundColor: token$1.colorPrimaryHover }
				},
				"&:active": { backgroundColor: token$1.colorPrimaryActive },
				"&-disabled": {
					cursor: "not-allowed",
					[`&:not(${componentCls}-checkable-checked)`]: {
						color: token$1.colorTextDisabled,
						"&:hover": { backgroundColor: "transparent" }
					},
					[`&${componentCls}-checkable-checked`]: {
						color: token$1.colorTextDisabled,
						backgroundColor: token$1.colorBgContainerDisabled
					},
					"&:hover, &:active": {
						backgroundColor: token$1.colorBgContainerDisabled,
						color: token$1.colorTextDisabled
					},
					[`&:not(${componentCls}-checkable-checked):hover`]: { color: token$1.colorTextDisabled }
				},
				"&-group": {
					display: "flex",
					flexWrap: "wrap",
					gap: token$1.paddingXS
				}
			},
			"&-hidden": { display: "none" },
			[`> ${token$1.iconCls} + span, > span + ${token$1.iconCls}`]: { marginInlineStart: paddingInline }
		},
		[`&${token$1.componentCls}-solid`]: {
			borderColor: "transparent",
			color: token$1.colorTextLightSolid,
			backgroundColor: token$1.colorBgSolid,
			[`&${componentCls}-default`]: { color: token$1.solidTextColor }
		},
		[`${componentCls}-filled`]: {
			borderColor: "transparent",
			backgroundColor: token$1.tagBorderlessBg
		},
		[`&${componentCls}-disabled`]: {
			color: token$1.colorTextDisabled,
			cursor: "not-allowed",
			backgroundColor: token$1.colorBgContainerDisabled,
			a: {
				cursor: "not-allowed",
				pointerEvents: "none",
				color: token$1.colorTextDisabled,
				"&:hover": { color: token$1.colorTextDisabled }
			},
			"a&": { "&:hover, &:active": { color: token$1.colorTextDisabled } },
			[`&${componentCls}-outlined`]: { borderColor: token$1.colorBorderDisabled },
			[`&${componentCls}-solid, &${componentCls}-filled`]: {
				color: token$1.colorTextDisabled,
				[`${componentCls}-close-icon`]: { color: token$1.colorTextDisabled }
			},
			[`${componentCls}-close-icon`]: {
				cursor: "not-allowed",
				color: token$1.colorTextDisabled,
				"&:hover": { color: token$1.colorTextDisabled }
			}
		}
	};
};
const prepareToken = (token$1) => {
	const { lineWidth, fontSizeIcon, calc } = token$1;
	const tagFontSize = token$1.fontSizeSM;
	return merge(token$1, {
		tagFontSize,
		tagLineHeight: unit(calc(token$1.lineHeightSM).mul(tagFontSize).equal()),
		tagIconSize: calc(fontSizeIcon).sub(calc(lineWidth).mul(2)).equal(),
		tagPaddingHorizontal: 8,
		tagBorderlessBg: token$1.defaultBg
	});
};
const prepareComponentToken$5 = (token$1) => {
	const solidTextColor = isBright(new AggregationColor(token$1.colorBgSolid), "#fff") ? "#000" : "#fff";
	return {
		defaultBg: new FastColor(token$1.colorFillTertiary).onBackground(token$1.colorBgContainer).toHexString(),
		defaultColor: token$1.colorText,
		solidTextColor
	};
};
var style_default$6 = genStyleHooks("Tag", (token$1) => {
	return genBaseStyle$3(prepareToken(token$1));
}, prepareComponentToken$5);

//#endregion
//#region node_modules/antd/es/tag/CheckableTag.js
var CheckableTag = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, style: style$1, className, checked, children, icon, onChange, onClick, disabled: customDisabled, ...restProps } = props;
	const { getPrefixCls, tag } = import_react.useContext(ConfigContext);
	const disabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = customDisabled ?? disabled;
	const handleClick = (e$2) => {
		if (mergedDisabled) return;
		onChange?.(!checked);
		onClick?.(e$2);
	};
	const prefixCls = getPrefixCls("tag", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$6(prefixCls);
	const cls = clsx(prefixCls, `${prefixCls}-checkable`, {
		[`${prefixCls}-checkable-checked`]: checked,
		[`${prefixCls}-checkable-disabled`]: mergedDisabled
	}, tag?.className, className, hashId, cssVarCls);
	return /* @__PURE__ */ import_react.createElement("span", {
		...restProps,
		ref,
		style: {
			...style$1,
			...tag?.style
		},
		className: cls,
		onClick: handleClick
	}, icon, /* @__PURE__ */ import_react.createElement("span", null, children));
});
var CheckableTag_default = CheckableTag;

//#endregion
//#region node_modules/antd/es/tag/CheckableTagGroup.js
function CheckableTagGroup(props, ref) {
	const { id, prefixCls: customizePrefixCls, rootClassName, className, style: style$1, classNames, styles, disabled, options, value, defaultValue, onChange, multiple, ...restProps } = props;
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("tag");
	const prefixCls = getPrefixCls("tag", customizePrefixCls);
	const groupPrefixCls = `${prefixCls}-checkable-group`;
	const [hashId, cssVarCls] = style_default$6(prefixCls, useCSSVarCls_default(prefixCls));
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props });
	const parsedOptions = (0, import_react.useMemo)(() => (options || []).map((option) => {
		if (option && typeof option === "object") return option;
		return {
			value: option,
			label: option
		};
	}), [options]);
	const [mergedValue, setMergedValue] = useControlledState(defaultValue, value);
	const handleChange = (checked, option) => {
		let newValue = null;
		if (multiple) {
			const valueList = mergedValue || [];
			newValue = checked ? [].concat(_toConsumableArray(valueList), [option.value]) : valueList.filter((item) => item !== option.value);
		} else newValue = checked ? option.value : null;
		setMergedValue(newValue);
		onChange?.(newValue);
	};
	const divRef = import_react.useRef(null);
	(0, import_react.useImperativeHandle)(ref, () => ({ nativeElement: divRef.current }));
	const ariaProps = pickAttrs(restProps, {
		aria: true,
		data: true
	});
	return /* @__PURE__ */ import_react.createElement("div", {
		...ariaProps,
		className: clsx(groupPrefixCls, contextClassName, rootClassName, {
			[`${groupPrefixCls}-disabled`]: disabled,
			[`${groupPrefixCls}-rtl`]: direction === "rtl"
		}, hashId, cssVarCls, className, mergedClassNames.root),
		style: {
			...contextStyle,
			...mergedStyles.root,
			...style$1
		},
		id,
		ref: divRef
	}, parsedOptions.map((option) => /* @__PURE__ */ import_react.createElement(CheckableTag_default, {
		key: option.value,
		className: clsx(`${groupPrefixCls}-item`, mergedClassNames.item),
		style: mergedStyles.item,
		checked: multiple ? (mergedValue || []).includes(option.value) : mergedValue === option.value,
		onChange: (checked) => handleChange(checked, option),
		disabled
	}, option.label)));
}
var ForwardCheckableTagGroup = /* @__PURE__ */ import_react.forwardRef(CheckableTagGroup);
ForwardCheckableTagGroup.displayName = "CheckableTagGroup";
var CheckableTagGroup_default = ForwardCheckableTagGroup;

//#endregion
//#region node_modules/antd/es/tag/hooks/useColor.js
/**
* Convert color related props to a unified object,
* which is used to flatten the compatibility requirements.
*/
function useColor(props, contextVariant) {
	const { color, variant, bordered } = props;
	return import_react.useMemo(() => {
		const isInverseColor = color?.endsWith("-inverse");
		let nextVariant;
		if (variant) nextVariant = variant;
		else if (isInverseColor) nextVariant = "solid";
		else if (bordered === false) nextVariant = "filled";
		else nextVariant = contextVariant || "filled";
		const nextColor = isInverseColor ? color?.replace("-inverse", "") : color;
		const nextIsPreset = isPresetColor(color);
		const nextIsStatus = isPresetStatusColor(color);
		const tagStyle = {};
		if (!nextIsPreset && !nextIsStatus && nextColor) if (nextVariant === "solid") tagStyle.backgroundColor = color;
		else {
			const hsl = new FastColor(nextColor).toHsl();
			hsl.l = .95;
			tagStyle.backgroundColor = new FastColor(hsl).toHexString();
			tagStyle.color = color;
			if (nextVariant === "outlined") tagStyle.borderColor = color;
		}
		return [
			nextVariant,
			nextColor,
			nextIsPreset,
			nextIsStatus,
			tagStyle
		];
	}, [
		color,
		variant,
		bordered,
		contextVariant
	]);
}

//#endregion
//#region node_modules/antd/es/tag/style/presetCmp.js
var genPresetStyle = (token$1) => genPresetColor(token$1, (colorKey, { textColor, lightBorderColor, lightColor, darkColor }) => ({ [`${token$1.componentCls}${token$1.componentCls}-${colorKey}:not(${token$1.componentCls}-disabled)`]: {
	[`&${token$1.componentCls}-outlined`]: {
		backgroundColor: lightColor,
		borderColor: lightBorderColor,
		color: textColor
	},
	[`&${token$1.componentCls}-solid`]: {
		backgroundColor: darkColor,
		borderColor: darkColor,
		color: token$1.colorTextLightSolid
	},
	[`&${token$1.componentCls}-filled`]: {
		backgroundColor: lightColor,
		color: textColor
	}
} }));
var presetCmp_default = genSubStyleComponent(["Tag", "preset"], (token$1) => {
	return genPresetStyle(prepareToken(token$1));
}, prepareComponentToken$5);

//#endregion
//#region node_modules/antd/es/_util/capitalize.js
function capitalize(str) {
	if (typeof str !== "string") return str;
	return str.charAt(0).toUpperCase() + str.slice(1);
}

//#endregion
//#region node_modules/antd/es/tag/style/statusCmp.js
var genTagStatusStyle = (token$1, status, cssVariableType) => {
	const capitalizedCssVariableType = capitalize(cssVariableType);
	return { [`${token$1.componentCls}${token$1.componentCls}-${status}:not(${token$1.componentCls}-disabled)`]: {
		[`&${token$1.componentCls}-outlined`]: {
			backgroundColor: token$1[`color${capitalizedCssVariableType}Bg`],
			borderColor: token$1[`color${capitalizedCssVariableType}Border`],
			color: token$1[`color${cssVariableType}`]
		},
		[`&${token$1.componentCls}-solid`]: {
			backgroundColor: token$1[`color${cssVariableType}`],
			borderColor: token$1[`color${cssVariableType}`]
		},
		[`&${token$1.componentCls}-filled`]: {
			backgroundColor: token$1[`color${capitalizedCssVariableType}Bg`],
			color: token$1[`color${cssVariableType}`]
		}
	} };
};
var statusCmp_default = genSubStyleComponent(["Tag", "status"], (token$1) => {
	const tagToken = prepareToken(token$1);
	return [
		genTagStatusStyle(tagToken, "success", "Success"),
		genTagStatusStyle(tagToken, "processing", "Info"),
		genTagStatusStyle(tagToken, "error", "Error"),
		genTagStatusStyle(tagToken, "warning", "Warning")
	];
}, prepareComponentToken$5);

//#endregion
//#region node_modules/antd/es/tag/index.js
var Tag = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, style: style$1, children, icon, color, variant: _variant, onClose, bordered, disabled: customDisabled, href, target, styles, classNames, ...restProps } = props;
	const { getPrefixCls, direction, className: contextClassName, variant: contextVariant, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("tag");
	{
		const warning$3 = devUseWarning("Tag");
		warning$3.deprecated(bordered !== false, "bordered={false}", "variant=\"filled\"");
		warning$3.deprecated(!color?.endsWith("-inverse"), "color=\"xxx-inverse\"", "variant=\"solid\"");
	}
	const [mergedVariant, mergedColor, isPreset, isStatus, customTagStyle] = useColor(props, contextVariant);
	const isInternalColor = isPreset || isStatus;
	const disabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = customDisabled ?? disabled;
	const { tag: tagContext } = import_react.useContext(ConfigContext);
	const [visible, setVisible] = import_react.useState(true);
	const domProps = omit(restProps, ["closeIcon", "closable"]);
	const mergedProps = {
		...props,
		color: mergedColor,
		variant: mergedVariant,
		disabled: mergedDisabled,
		href,
		target,
		icon
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const tagStyle = import_react.useMemo(() => {
		let nextTagStyle = {
			...mergedStyles.root,
			...contextStyle,
			...style$1
		};
		if (!mergedDisabled) nextTagStyle = {
			...customTagStyle,
			...nextTagStyle
		};
		return nextTagStyle;
	}, [
		mergedStyles.root,
		contextStyle,
		style$1,
		customTagStyle,
		mergedDisabled
	]);
	const prefixCls = getPrefixCls("tag", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$6(prefixCls);
	const tagClassName = clsx(prefixCls, contextClassName, mergedClassNames.root, `${prefixCls}-${mergedVariant}`, {
		[`${prefixCls}-${mergedColor}`]: isInternalColor,
		[`${prefixCls}-hidden`]: !visible,
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-disabled`]: mergedDisabled
	}, className, rootClassName, hashId, cssVarCls);
	const handleCloseClick = (e$2) => {
		if (mergedDisabled) return;
		e$2.stopPropagation();
		onClose?.(e$2);
		if (e$2.defaultPrevented) return;
		setVisible(false);
	};
	const [, mergedCloseIcon] = useClosable(pickClosable(props), pickClosable(tagContext), {
		closable: false,
		closeIconRender: (iconNode$1) => {
			return replaceElement(iconNode$1, /* @__PURE__ */ import_react.createElement("span", {
				className: `${prefixCls}-close-icon`,
				onClick: handleCloseClick
			}, iconNode$1), (originProps) => ({
				onClick: (e$2) => {
					originProps?.onClick?.(e$2);
					handleCloseClick(e$2);
				},
				className: clsx(originProps?.className, `${prefixCls}-close-icon`)
			}));
		}
	});
	const isNeedWave = typeof restProps.onClick === "function" || children && children.type === "a";
	const iconNode = cloneElement(icon, {
		className: clsx(/* @__PURE__ */ import_react.isValidElement(icon) ? icon.props?.className : "", mergedClassNames.icon),
		style: mergedStyles.icon
	});
	const child = iconNode ? /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, iconNode, children && /* @__PURE__ */ import_react.createElement("span", {
		className: mergedClassNames.content,
		style: mergedStyles.content
	}, children)) : children;
	const TagWrapper = href ? "a" : "span";
	const tagNode = /* @__PURE__ */ import_react.createElement(TagWrapper, {
		...domProps,
		ref,
		className: tagClassName,
		style: tagStyle,
		href: mergedDisabled ? void 0 : href,
		target,
		onClick: mergedDisabled ? void 0 : domProps.onClick,
		...href && mergedDisabled ? { "aria-disabled": true } : {}
	}, child, mergedCloseIcon, isPreset && /* @__PURE__ */ import_react.createElement(presetCmp_default, {
		key: "preset",
		prefixCls
	}), isStatus && /* @__PURE__ */ import_react.createElement(statusCmp_default, {
		key: "status",
		prefixCls
	}));
	return isNeedWave ? /* @__PURE__ */ import_react.createElement(wave_default, { component: "Tag" }, tagNode) : tagNode;
});
Tag.displayName = "Tag";
Tag.CheckableTag = CheckableTag_default;
Tag.CheckableTagGroup = CheckableTagGroup_default;
var tag_default = Tag;

//#endregion
//#region node_modules/antd/es/theme/getDesignToken.js
var getDesignToken = (config) => {
	const theme = config?.algorithm ? createTheme(config.algorithm) : theme_default$1;
	return getComputedToken({
		...seed_default,
		...config?.token
	}, { override: config?.token }, theme, formatToken);
};
var getDesignToken_default = getDesignToken;

//#endregion
//#region node_modules/antd/es/theme/themes/compact/genCompactSizeMapToken.js
function genSizeMapToken(token$1) {
	const { sizeUnit, sizeStep } = token$1;
	const compactSizeStep = sizeStep - 2;
	return {
		sizeXXL: sizeUnit * (compactSizeStep + 10),
		sizeXL: sizeUnit * (compactSizeStep + 6),
		sizeLG: sizeUnit * (compactSizeStep + 2),
		sizeMD: sizeUnit * (compactSizeStep + 2),
		sizeMS: sizeUnit * (compactSizeStep + 1),
		size: sizeUnit * compactSizeStep,
		sizeSM: sizeUnit * compactSizeStep,
		sizeXS: sizeUnit * (compactSizeStep - 1),
		sizeXXS: sizeUnit * (compactSizeStep - 1)
	};
}

//#endregion
//#region node_modules/antd/es/theme/themes/compact/index.js
var derivative$2 = (token$1, mapToken) => {
	const mergedMapToken = mapToken ?? derivative(token$1);
	const fontSize = mergedMapToken.fontSizeSM;
	const controlHeight = mergedMapToken.controlHeight - 4;
	return {
		...mergedMapToken,
		...genSizeMapToken(mapToken ?? token$1),
		...genFontMapToken_default(fontSize),
		controlHeight,
		...genControlHeight_default({
			...mergedMapToken,
			controlHeight
		})
	};
};
var compact_default = derivative$2;

//#endregion
//#region node_modules/antd/es/theme/themes/dark/colorAlgorithm.js
const getAlphaColor = (baseColor, alpha) => new FastColor(baseColor).setA(alpha).toRgbString();
const getSolidColor = (baseColor, brightness) => {
	return new FastColor(baseColor).lighten(brightness).toHexString();
};

//#endregion
//#region node_modules/antd/es/theme/themes/dark/colors.js
const generateColorPalettes = (baseColor) => {
	const colors = generate(baseColor, { theme: "dark" });
	return {
		1: colors[0],
		2: colors[1],
		3: colors[2],
		4: colors[3],
		5: colors[6],
		6: colors[5],
		7: colors[4],
		8: colors[6],
		9: colors[5],
		10: colors[4]
	};
};
const generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
	const colorBgBase = bgBaseColor || "#000";
	const colorTextBase = textBaseColor || "#fff";
	return {
		colorBgBase,
		colorTextBase,
		colorText: getAlphaColor(colorTextBase, .85),
		colorTextSecondary: getAlphaColor(colorTextBase, .65),
		colorTextTertiary: getAlphaColor(colorTextBase, .45),
		colorTextQuaternary: getAlphaColor(colorTextBase, .25),
		colorFill: getAlphaColor(colorTextBase, .18),
		colorFillSecondary: getAlphaColor(colorTextBase, .12),
		colorFillTertiary: getAlphaColor(colorTextBase, .08),
		colorFillQuaternary: getAlphaColor(colorTextBase, .04),
		colorBgSolid: getAlphaColor(colorTextBase, .95),
		colorBgSolidHover: getAlphaColor(colorTextBase, 1),
		colorBgSolidActive: getAlphaColor(colorTextBase, .9),
		colorBgElevated: getSolidColor(colorBgBase, 12),
		colorBgContainer: getSolidColor(colorBgBase, 8),
		colorBgLayout: getSolidColor(colorBgBase, 0),
		colorBgSpotlight: getSolidColor(colorBgBase, 26),
		colorBgBlur: getAlphaColor(colorTextBase, .04),
		colorBorder: getSolidColor(colorBgBase, 26),
		colorBorderDisabled: getSolidColor(colorBgBase, 26),
		colorBorderSecondary: getSolidColor(colorBgBase, 19)
	};
};

//#endregion
//#region node_modules/antd/es/theme/themes/dark/index.js
var derivative$1 = (token$1, mapToken) => {
	const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
		const colors = generate(token$1[colorKey], { theme: "dark" });
		return Array.from({ length: 10 }, () => 1).reduce((prev$1, _, i) => {
			prev$1[`${colorKey}-${i + 1}`] = colors[i];
			prev$1[`${colorKey}${i + 1}`] = colors[i];
			return prev$1;
		}, {});
	}).reduce((prev$1, cur) => {
		prev$1 = {
			...prev$1,
			...cur
		};
		return prev$1;
	}, {});
	const mergedMapToken = mapToken ?? derivative(token$1);
	const colorMapToken = genColorMapToken(token$1, {
		generateColorPalettes,
		generateNeutralColorPalettes
	});
	return {
		...mergedMapToken,
		...colorPalettes,
		...colorMapToken,
		colorPrimaryBg: colorMapToken.colorPrimaryBorder,
		colorPrimaryBgHover: colorMapToken.colorPrimaryBorderHover
	};
};
var dark_default = derivative$1;

//#endregion
//#region node_modules/antd/es/theme/index.js
/** Get current context Design Token. Will be different if you are using nest theme config. */
function useToken$1() {
	const [theme, token$1, hashId, cssVar] = useToken();
	return {
		theme,
		token: token$1,
		hashId,
		cssVar
	};
}
var theme_default = {
	defaultSeed: defaultConfig.token,
	useToken: useToken$1,
	defaultAlgorithm: derivative,
	darkAlgorithm: dark_default,
	compactAlgorithm: compact_default,
	getDesignToken: getDesignToken_default,
	defaultConfig,
	_internalContext: DesignTokenContext
};

//#endregion
//#region node_modules/antd/es/time-picker/index.js
var { TimePicker: InternalTimePicker, RangePicker: InternalRangePicker } = date_picker_default;
var RangePicker = /* @__PURE__ */ import_react.forwardRef((props, ref) => /* @__PURE__ */ import_react.createElement(InternalRangePicker, {
	...props,
	picker: "time",
	mode: void 0,
	ref
}));
var TimePicker = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { addon, renderExtraFooter, variant, bordered, classNames, styles, popupClassName, popupStyle, ...restProps } = props;
	devUseWarning("TimePicker").deprecated(!addon, "addon", "renderExtraFooter");
	const [mergedVariant] = useVariants_default("timePicker", variant, bordered);
	const internalRenderExtraFooter = import_react.useMemo(() => {
		if (renderExtraFooter) return renderExtraFooter;
		if (addon) return addon;
	}, [addon, renderExtraFooter]);
	const [mergedClassNames, mergedStyles] = useMergedPickerSemantic_default("timePicker", classNames, styles, popupClassName, popupStyle, {
		...props,
		variant: mergedVariant
	});
	return /* @__PURE__ */ import_react.createElement(InternalTimePicker, {
		...restProps,
		mode: void 0,
		ref,
		renderExtraFooter: internalRenderExtraFooter,
		variant: mergedVariant,
		classNames: mergedClassNames,
		styles: mergedStyles
	});
});
TimePicker.displayName = "TimePicker";
/* istanbul ignore next */
var PurePanel$2 = PurePanel_default(TimePicker, "popupAlign", void 0, "picker");
TimePicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$2;
TimePicker.RangePicker = RangePicker;
TimePicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$2;
var time_picker_default = TimePicker;

//#endregion
//#region node_modules/antd/es/timeline/style/horizontal.js
var genHorizontalStyle = (token$1) => {
	const { componentCls, fontHeight } = token$1;
	const itemCls = `${componentCls}-item`;
	return { [`${componentCls}-horizontal`]: {
		"--steps-title-vertical-row-gap": token$1.paddingXS,
		"--timeline-content-height": `${unit(fontHeight)}`,
		alignItems: "stretch",
		[`&${componentCls}-layout-alternate`]: { [itemCls]: {
			[`${itemCls}-wrapper`]: {
				"--timeline-alternate-content-offset": `calc(var(--timeline-content-height) + var(--steps-title-vertical-row-gap) * 2 + var(--steps-icon-size-max))`,
				height: `calc(var(--timeline-content-height) * 2 + var(--steps-title-vertical-row-gap) * 2 + var(--steps-icon-size-max))`
			},
			[`${itemCls}-icon`]: { position: "absolute" },
			[`${itemCls}-icon, ${itemCls}-rail`]: {
				position: "absolute",
				top: "50%",
				transform: "translateY(-50%)",
				margin: 0
			},
			[`${itemCls}-title, ${itemCls}-subtitle, ${itemCls}-content`]: {
				whiteSpace: "nowrap",
				maxWidth: "unset"
			},
			[`${itemCls}-title`]: {
				position: "absolute",
				left: {
					_skip_check_: true,
					value: "50%"
				},
				transform: "translateX(-50%)"
			},
			[`${itemCls}-content`]: {
				position: "absolute",
				left: {
					_skip_check_: true,
					value: "50%"
				},
				transform: "translateX(-50%)"
			},
			"&-placement-start": {
				[`${itemCls}-title`]: { bottom: "var(--timeline-alternate-content-offset)" },
				[`${itemCls}-content`]: { top: "var(--timeline-alternate-content-offset)" }
			},
			"&-placement-end": {
				[`${itemCls}-title`]: { top: "var(--timeline-alternate-content-offset)" },
				[`${itemCls}-content`]: { bottom: "var(--timeline-alternate-content-offset)" }
			}
		} },
		[`&:not(${componentCls}-layout-alternate)`]: { [`${itemCls}-placement-end`]: {
			display: "flex",
			alignItems: "flex-end",
			[`${itemCls}-wrapper`]: {
				flex: "auto",
				flexDirection: "column-reverse"
			},
			[`${itemCls}-rail`]: {
				top: "auto",
				bottom: "var(--steps-horizontal-rail-margin)",
				transform: "translateY(50%)"
			}
		} }
	} };
};
var horizontal_default = genHorizontalStyle;

//#endregion
//#region node_modules/antd/es/timeline/style/index.js
var genTimelineStyle = (token$1) => {
	const { componentCls, tailColor } = token$1;
	const itemCls = `${componentCls}-item`;
	return { [componentCls]: [{
		...resetComponent(token$1),
		[itemCls]: {
			"--steps-title-horizontal-title-height": token$1.fontHeight,
			"--steps-vertical-rail-margin": "0px",
			"--steps-title-horizontal-rail-gap": "0px",
			"--steps-icon-dot-size-origin": "var(--steps-icon-size-active)",
			"--steps-icon-dot-size-custom": token$1.dotSize,
			"--steps-item-icon-dot-bg-color-origin": "var(--steps-item-icon-dot-bg-color)",
			"--steps-item-icon-dot-bg-color-custom": token$1.dotBg,
			"--steps-icon-size": "var(--steps-icon-dot-size-custom, var(--steps-icon-dot-size-origin))",
			[`${itemCls}-icon`]: {
				"--steps-dot-icon-border-width": token$1.dotBorderWidth,
				"--steps-dot-icon-size": "var(--steps-icon-size)",
				"--steps-item-icon-dot-bg-color": "var(--steps-item-icon-dot-bg-color-custom, var(--steps-item-icon-dot-bg-color-origin))"
			},
			[`${itemCls}-title`]: {
				fontSize: token$1.fontSize,
				lineHeight: token$1.lineHeight
			},
			[`${itemCls}-content`]: { color: token$1.colorText },
			[`${itemCls}-rail`]: {
				"--steps-item-solid-line-color": tailColor,
				"--steps-rail-size": token$1.tailWidth
			}
		}
	}, {
		[itemCls]: { "--steps-item-process-rail-line-style": "dotted" },
		[`${itemCls}${itemCls}${itemCls}-color`]: {
			"&-blue": { "--steps-item-icon-dot-color": token$1.colorPrimary },
			"&-red": { "--steps-item-icon-dot-color": token$1.colorError },
			"&-green": { "--steps-item-icon-dot-color": token$1.colorSuccess },
			"&-gray": { "--steps-item-icon-dot-color": token$1.colorTextDisabled }
		}
	}] };
};
var genVerticalStyle = (token$1) => {
	const { calc, componentCls, itemPaddingBottom } = token$1;
	const itemCls = `${componentCls}-item`;
	return { [`${componentCls}:not(${componentCls}-horizontal)`]: {
		"--timeline-head-span": "12",
		"--timeline-head-span-ptg": "calc(var(--timeline-head-span) / 24 * 100%)",
		[`&${componentCls}-layout-alternate`]: { [itemCls]: {
			"--timeline-alternate-gap": calc(token$1.margin).mul(2).add("var(--steps-dot-icon-size)").equal(),
			minHeight: "auto",
			paddingBottom: itemPaddingBottom,
			[`${itemCls}-icon, ${itemCls}-rail`]: {
				position: "absolute",
				insetInlineStart: "var(--timeline-head-span-ptg)"
			},
			[`${itemCls}-icon`]: { marginInlineStart: `calc(var(--steps-icon-size) / -2)` },
			[`${itemCls}-section`]: {
				display: "flex",
				flexWrap: "nowrap",
				gap: "var(--timeline-alternate-gap)"
			},
			[`${itemCls}-header`]: {
				textAlign: "end",
				flexDirection: "column",
				alignItems: "stretch",
				flex: "1 1 calc(var(--timeline-head-span-ptg) - var(--timeline-alternate-gap) / 2)"
			},
			[`${itemCls}-content`]: {
				textAlign: "start",
				flex: "1 1 calc(100% - var(--timeline-head-span-ptg) - var(--timeline-alternate-gap) / 2)"
			},
			"&-placement-end": {
				[`${itemCls}-header`]: {
					textAlign: "start",
					order: 1
				},
				[`${itemCls}-content`]: { textAlign: "end" },
				[`${itemCls}-icon, ${itemCls}-rail`]: { insetInlineStart: "calc(100% - var(--timeline-head-span-ptg))" }
			}
		} },
		[`&:not(${componentCls}-layout-alternate)`]: { [`${itemCls}-placement-end`]: {
			textAlign: "end",
			[`${itemCls}-icon`]: { order: 1 },
			[`${itemCls}-rail`]: {
				insetInlineStart: "auto",
				insetInlineEnd: "calc(var(--steps-icon-size) / 2)",
				marginInlineEnd: `calc(var(--steps-rail-size) / -2)`
			}
		} }
	} };
};
const prepareComponentToken$4 = (token$1) => ({
	tailColor: token$1.colorSplit,
	tailWidth: token$1.lineWidthBold,
	dotBorderWidth: token$1.lineWidthBold,
	dotBg: void 0,
	dotSize: void 0,
	itemPaddingBottom: token$1.padding * 1.25
});
var style_default$5 = genStyleHooks("Timeline", (token$1) => {
	const timeLineToken = merge(token$1, {
		itemHeadSize: 10,
		customHeadPaddingVertical: token$1.paddingXXS,
		paddingInlineEnd: 2
	});
	return [
		genTimelineStyle(timeLineToken),
		genVerticalStyle(timeLineToken),
		horizontal_default(timeLineToken)
	];
}, prepareComponentToken$4);

//#endregion
//#region node_modules/antd/es/timeline/useItems.js
function useItems(prefixCls, mode, items, children, pending, pendingDot) {
	const itemCls = `${prefixCls}-item`;
	const parseItems$1 = import_react.useMemo(() => {
		return Array.isArray(items) ? items : toArray(children).map((ele) => ({ ...ele.props }));
	}, [items, children]);
	return import_react.useMemo(() => {
		const mergedItems = parseItems$1.map((item, index$1) => {
			const { label, children: children$1, title, content, color, className, style: style$1, icon, dot, placement, position: position$2, loading, ...restProps } = item;
			let mergedStyle = style$1;
			let mergedClassName = className;
			if (color) if ([
				"blue",
				"red",
				"green",
				"gray"
			].includes(color)) mergedClassName = clsx(className, `${itemCls}-color-${color}`);
			else mergedStyle = {
				"--steps-item-icon-dot-color": color,
				...style$1
			};
			const mergedPlacement = placement ?? position$2 ?? (mode === "alternate" ? index$1 % 2 === 0 ? "start" : "end" : mode);
			mergedClassName = clsx(mergedClassName, `${itemCls}-placement-${mergedPlacement}`);
			let mergedIcon = icon ?? dot;
			if (!mergedIcon && loading) mergedIcon = /* @__PURE__ */ import_react.createElement(LoadingOutlined_default, null);
			return {
				...restProps,
				title: title ?? label,
				content: content ?? children$1,
				style: mergedStyle,
				className: mergedClassName,
				icon: mergedIcon,
				status: loading ? "process" : "finish"
			};
		});
		if (pending) mergedItems.push({
			icon: pendingDot ?? /* @__PURE__ */ import_react.createElement(LoadingOutlined_default, null),
			content: pending,
			status: "process"
		});
		return mergedItems;
	}, [
		parseItems$1,
		pending,
		pendingDot,
		itemCls,
		mode
	]);
}

//#endregion
//#region node_modules/antd/es/timeline/Timeline.js
var stepInternalContext = {
	rootComponent: "ol",
	itemComponent: "li"
};
var Timeline = (props) => {
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("timeline");
	const { prefixCls: customizePrefixCls, className, style: style$1, classNames, styles, variant = "outlined", mode, orientation = "vertical", titleSpan, items, children, reverse, pending, pendingDot, ...restProps } = props;
	const prefixCls = getPrefixCls("timeline", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$5(prefixCls);
	const stepsClassNames = import_react.useMemo(() => ({
		item: `${prefixCls}-item`,
		itemTitle: `${prefixCls}-item-title`,
		itemIcon: `${prefixCls}-item-icon`,
		itemContent: `${prefixCls}-item-content`,
		itemRail: `${prefixCls}-item-rail`,
		itemWrapper: `${prefixCls}-item-wrapper`,
		itemSection: `${prefixCls}-item-section`,
		itemHeader: `${prefixCls}-item-header`
	}), [prefixCls]);
	const mergedMode = import_react.useMemo(() => {
		if (mode === "left") return "start";
		if (mode === "right") return "end";
		return [
			"alternate",
			"start",
			"end"
		].includes(mode) ? mode : "start";
	}, [mode]);
	const rawItems = useItems(prefixCls, mergedMode, items, children, pending, pendingDot);
	const mergedItems = import_react.useMemo(() => reverse ? _toConsumableArray(rawItems).reverse() : rawItems, [reverse, rawItems]);
	const mergedProps = {
		...props,
		variant,
		mode: mergedMode,
		orientation,
		items: mergedItems
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([
		stepsClassNames,
		contextClassNames,
		classNames
	], [contextStyles, styles], { props: mergedProps });
	const stepContext = import_react.useMemo(() => ({ railFollowPrevStatus: reverse }), [reverse]);
	const layoutAlternate = import_react.useMemo(() => mergedMode === "alternate" || orientation === "vertical" && mergedItems.some((item) => item.title), [
		mergedItems,
		mergedMode,
		orientation
	]);
	{
		const warning$3 = devUseWarning("Timeline");
		warning$3.deprecated(!children, "Timeline.Item", "items");
		const pendingWarning = "You can create a `item` as pending node directly.";
		warning$3.deprecated(!pending, "pending", "items", pendingWarning);
		warning$3.deprecated(!pendingDot, "pendingDot", "items", pendingWarning);
		warning$3.deprecated(mode !== "left" && mode !== "right", "mode=left|right", "mode=start|end");
		const warnItems = items || [];
		[
			["label", "title"],
			["children", "content"],
			["dot", "icon"],
			["position", "placement"]
		].forEach(([oldProp, newProp]) => {
			warning$3.deprecated(warnItems.every((item) => !item[oldProp]), `items.${oldProp}`, `items.${newProp}`);
		});
	}
	const stepStyle = {
		...contextStyle,
		...style$1
	};
	if (titleSpan && mergedMode !== "alternate") if (typeof titleSpan === "number") stepStyle["--timeline-head-span"] = titleSpan;
	else stepStyle["--timeline-head-span-ptg"] = titleSpan;
	return /* @__PURE__ */ import_react.createElement(InternalContext.Provider, { value: stepInternalContext }, /* @__PURE__ */ import_react.createElement(UnstableContext$1.Provider, { value: stepContext }, /* @__PURE__ */ import_react.createElement(steps_default, {
		...restProps,
		className: clsx(prefixCls, contextClassName, className, hashId, cssVarCls, {
			[`${prefixCls}-${orientation}`]: orientation === "horizontal",
			[`${prefixCls}-layout-alternate`]: layoutAlternate,
			[`${prefixCls}-rtl`]: direction === "rtl"
		}),
		style: stepStyle,
		classNames: mergedClassNames,
		styles: mergedStyles,
		variant,
		orientation,
		type: "dot",
		items: mergedItems,
		current: mergedItems.length - 1
	})));
};
Timeline.Item = () => {};
Timeline.displayName = "Timeline";
var Timeline_default = Timeline;

//#endregion
//#region node_modules/antd/es/timeline/index.js
var timeline_default = Timeline_default;

//#endregion
//#region node_modules/@rc-component/tour/es/hooks/useClosable.js
function isConfigObj(closable) {
	return closable !== null && typeof closable === "object";
}
/**
* Convert `closable` to ClosableConfig.
* When `preset` is true, will auto fill ClosableConfig with default value.
*/
function getClosableConfig(closable, closeIcon, preset) {
	if (closable === false || closeIcon === false && (!isConfigObj(closable) || !closable.closeIcon)) return null;
	const mergedCloseIcon = typeof closeIcon !== "boolean" ? closeIcon : void 0;
	if (isConfigObj(closable)) return {
		...closable,
		closeIcon: closable.closeIcon ?? mergedCloseIcon
	};
	return preset || closable || closeIcon ? { closeIcon: mergedCloseIcon } : "empty";
}
function useClosable$1(stepClosable, stepCloseIcon, closable, closeIcon) {
	return import_react.useMemo(() => {
		const stepClosableConfig = getClosableConfig(stepClosable, stepCloseIcon, false);
		const rootClosableConfig = getClosableConfig(closable, closeIcon, true);
		if (stepClosableConfig !== "empty") return stepClosableConfig;
		return rootClosableConfig;
	}, [
		closable,
		closeIcon,
		stepClosable,
		stepCloseIcon
	]);
}

//#endregion
//#region node_modules/@rc-component/tour/es/util.js
function isInViewPort(element) {
	const viewWidth = window.innerWidth || document.documentElement.clientWidth;
	const viewHeight = window.innerHeight || document.documentElement.clientHeight;
	const { top, right, bottom, left } = element.getBoundingClientRect();
	return top >= 0 && left >= 0 && right <= viewWidth && bottom <= viewHeight;
}
function getPlacement(targetElement, placement, stepPlacement) {
	return stepPlacement ?? placement ?? (targetElement === null ? "center" : "bottom");
}

//#endregion
//#region node_modules/@rc-component/tour/es/hooks/useTarget.js
function isValidNumber(val) {
	return typeof val === "number" && !Number.isNaN(val);
}
function useTarget(target, open$2, gap, scrollIntoViewOptions, inlineMode, placeholderRef) {
	const [targetElement, setTargetElement] = (0, import_react.useState)(void 0);
	useLayoutEffect_default(() => {
		setTargetElement((typeof target === "function" ? target() : target) || null);
	});
	const [posInfo, setPosInfo] = (0, import_react.useState)(null);
	const updatePos = useEvent_default(() => {
		if (targetElement) {
			if (!inlineMode && !isInViewPort(targetElement) && open$2) targetElement.scrollIntoView(scrollIntoViewOptions);
			const { left, top, width, height } = targetElement.getBoundingClientRect();
			const nextPosInfo = {
				left,
				top,
				width,
				height,
				radius: 0
			};
			if (inlineMode) {
				const parentRect = placeholderRef.current?.parentElement?.getBoundingClientRect();
				if (parentRect) {
					nextPosInfo.left -= parentRect.left;
					nextPosInfo.top -= parentRect.top;
				}
			}
			setPosInfo((origin) => {
				if (JSON.stringify(origin) !== JSON.stringify(nextPosInfo)) return nextPosInfo;
				return origin;
			});
		} else setPosInfo(null);
	});
	const getGapOffset = (index$1) => (Array.isArray(gap?.offset) ? gap?.offset[index$1] : gap?.offset) ?? 6;
	useLayoutEffect_default(() => {
		updatePos();
		window.addEventListener("resize", updatePos);
		window.addEventListener("scroll", updatePos);
		return () => {
			window.removeEventListener("resize", updatePos);
			window.removeEventListener("scroll", updatePos);
		};
	}, [
		targetElement,
		open$2,
		updatePos
	]);
	return [(0, import_react.useMemo)(() => {
		if (!posInfo) return posInfo;
		const gapOffsetX = getGapOffset(0);
		const gapOffsetY = getGapOffset(1);
		const gapRadius = isValidNumber(gap?.radius) ? gap?.radius : 2;
		return {
			left: posInfo.left - gapOffsetX,
			top: posInfo.top - gapOffsetY,
			width: posInfo.width + gapOffsetX * 2,
			height: posInfo.height + gapOffsetY * 2,
			radius: gapRadius
		};
	}, [posInfo, gap]), targetElement];
}

//#endregion
//#region node_modules/@rc-component/tour/es/Mask.js
function _extends$6() {
	_extends$6 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$6.apply(this, arguments);
}
var COVER_PROPS = {
	fill: "transparent",
	pointerEvents: "auto"
};
var Mask = (props) => {
	const { prefixCls, rootClassName, pos, showMask, style: style$1 = {}, fill = "rgba(0,0,0,0.5)", open: open$2, animated, zIndex, disabledInteraction, styles, classNames: tourClassNames, getPopupContainer } = props;
	const maskId = `${prefixCls}-mask-${useId_default()}`;
	const mergedAnimated = typeof animated === "object" ? animated?.placeholder : animated;
	const maskRectSize = typeof navigator !== "undefined" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent) ? {
		width: "100%",
		height: "100%"
	} : {
		width: "100vw",
		height: "100vh"
	};
	const inlineMode = getPopupContainer === false;
	return /* @__PURE__ */ import_react.createElement(es_default$7, {
		open: open$2,
		autoLock: !inlineMode,
		getContainer: getPopupContainer
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-mask`, rootClassName, tourClassNames?.mask),
		style: {
			position: inlineMode ? "absolute" : "fixed",
			left: 0,
			right: 0,
			top: 0,
			bottom: 0,
			zIndex,
			pointerEvents: pos && !disabledInteraction ? "none" : "auto",
			...style$1,
			...styles?.mask
		}
	}, showMask ? /* @__PURE__ */ import_react.createElement("svg", { style: {
		width: "100%",
		height: "100%"
	} }, /* @__PURE__ */ import_react.createElement("defs", null, /* @__PURE__ */ import_react.createElement("mask", { id: maskId }, /* @__PURE__ */ import_react.createElement("rect", _extends$6({
		x: "0",
		y: "0"
	}, maskRectSize, { fill: "white" })), pos && /* @__PURE__ */ import_react.createElement("rect", {
		x: pos.left,
		y: pos.top,
		rx: pos.radius,
		width: pos.width,
		height: pos.height,
		fill: "black",
		className: mergedAnimated ? `${prefixCls}-placeholder-animated` : ""
	}))), /* @__PURE__ */ import_react.createElement("rect", {
		x: "0",
		y: "0",
		width: "100%",
		height: "100%",
		fill,
		mask: `url(#${maskId})`
	}), pos && /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("rect", _extends$6({}, COVER_PROPS, {
		x: "0",
		y: "0",
		width: "100%",
		height: Math.max(pos.top, 0)
	})), /* @__PURE__ */ import_react.createElement("rect", _extends$6({}, COVER_PROPS, {
		x: "0",
		y: "0",
		width: Math.max(pos.left, 0),
		height: "100%"
	})), /* @__PURE__ */ import_react.createElement("rect", _extends$6({}, COVER_PROPS, {
		x: "0",
		y: pos.top + pos.height,
		width: "100%",
		height: `calc(100% - ${pos.top + pos.height}px)`
	})), /* @__PURE__ */ import_react.createElement("rect", _extends$6({}, COVER_PROPS, {
		x: pos.left + pos.width,
		y: "0",
		width: `calc(100% - ${pos.left + pos.width}px)`,
		height: "100%"
	})))) : null));
};
var Mask_default = Mask;

//#endregion
//#region node_modules/@rc-component/tour/es/placements.js
var targetOffset = [0, 0];
var basePlacements = {
	left: {
		points: ["cr", "cl"],
		offset: [-8, 0]
	},
	right: {
		points: ["cl", "cr"],
		offset: [8, 0]
	},
	top: {
		points: ["bc", "tc"],
		offset: [0, -8]
	},
	bottom: {
		points: ["tc", "bc"],
		offset: [0, 8]
	},
	topLeft: {
		points: ["bl", "tl"],
		offset: [0, -8]
	},
	leftTop: {
		points: ["tr", "tl"],
		offset: [-8, 0]
	},
	topRight: {
		points: ["br", "tr"],
		offset: [0, -8]
	},
	rightTop: {
		points: ["tl", "tr"],
		offset: [8, 0]
	},
	bottomRight: {
		points: ["tr", "br"],
		offset: [0, 8]
	},
	rightBottom: {
		points: ["bl", "br"],
		offset: [8, 0]
	},
	bottomLeft: {
		points: ["tl", "bl"],
		offset: [0, 8]
	},
	leftBottom: {
		points: ["br", "bl"],
		offset: [-8, 0]
	}
};
function getPlacements$1(arrowPointAtCenter = false) {
	const placements$4 = {};
	Object.keys(basePlacements).forEach((key) => {
		placements$4[key] = {
			...basePlacements[key],
			autoArrow: arrowPointAtCenter,
			targetOffset
		};
	});
	return placements$4;
}
const placements = getPlacements$1();

//#endregion
//#region node_modules/@rc-component/tour/es/TourStep/DefaultPanel.js
function _extends$5() {
	_extends$5 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$5.apply(this, arguments);
}
function DefaultPanel(props) {
	const { prefixCls, current, total, title, description, onClose, onPrev, onNext, onFinish, className, closable, classNames: tourClassNames, styles } = props;
	const ariaProps = pickAttrs(closable || {}, true);
	const closeIcon = closable?.closeIcon ?? /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-close-x` }, "");
	const mergedClosable = !!closable;
	return /* @__PURE__ */ import_react.createElement("div", { className: clsx(`${prefixCls}-panel`, className) }, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-section`, tourClassNames?.section),
		style: styles?.section
	}, mergedClosable && /* @__PURE__ */ import_react.createElement("button", _extends$5({
		type: "button",
		onClick: onClose,
		"aria-label": "Close"
	}, ariaProps, { className: `${prefixCls}-close` }), closeIcon), /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-header`, tourClassNames?.header),
		style: styles?.header
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-title`, tourClassNames?.title),
		style: styles?.title
	}, title)), /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-description`, tourClassNames?.description),
		style: styles?.description
	}, description), /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-footer`, tourClassNames?.footer),
		style: styles?.footer
	}, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-sliders` }, total > 1 ? [...Array.from({ length: total }).keys()].map((item, index$1) => {
		return /* @__PURE__ */ import_react.createElement("span", {
			key: item,
			className: index$1 === current ? "active" : ""
		});
	}) : null), /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-actions`, tourClassNames?.actions),
		style: styles?.actions
	}, current !== 0 ? /* @__PURE__ */ import_react.createElement("button", {
		className: `${prefixCls}-prev-btn`,
		onClick: onPrev
	}, "Prev") : null, current === total - 1 ? /* @__PURE__ */ import_react.createElement("button", {
		className: `${prefixCls}-finish-btn`,
		onClick: onFinish
	}, "Finish") : /* @__PURE__ */ import_react.createElement("button", {
		className: `${prefixCls}-next-btn`,
		onClick: onNext
	}, "Next")))));
}

//#endregion
//#region node_modules/@rc-component/tour/es/TourStep/index.js
var TourStep = (props) => {
	const { current, renderPanel } = props;
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, typeof renderPanel === "function" ? renderPanel(props, current) : /* @__PURE__ */ import_react.createElement(DefaultPanel, props));
};
var TourStep_default = TourStep;

//#endregion
//#region node_modules/@rc-component/tour/es/Placeholder.js
var Placeholder = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { open: open$2, autoLock, getContainer, domRef, className, style: style$1, fallbackDOM } = props;
	import_react.useImperativeHandle(ref, () => domRef.current || fallbackDOM());
	return /* @__PURE__ */ import_react.createElement(es_default$7, {
		open: open$2,
		autoLock,
		getContainer
	}, /* @__PURE__ */ import_react.createElement("div", {
		ref: domRef,
		className,
		style: style$1
	}));
});
Placeholder.displayName = "Placeholder";
var Placeholder_default = Placeholder;

//#endregion
//#region node_modules/@rc-component/tour/es/Tour.js
function _extends$4() {
	_extends$4 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$4.apply(this, arguments);
}
var CENTER_PLACEHOLDER = {
	left: "50%",
	top: "50%",
	width: 1,
	height: 1
};
var defaultScrollIntoViewOptions = {
	block: "center",
	inline: "center"
};
var Tour$1 = (props) => {
	const { prefixCls = "rc-tour", steps = [], defaultCurrent, current, onChange, onClose, onFinish, open: open$2, defaultOpen, mask = true, arrow = true, rootClassName, placement, renderPanel, gap, animated, scrollIntoViewOptions = defaultScrollIntoViewOptions, zIndex = 1001, closeIcon, closable, builtinPlacements, disabledInteraction, styles, classNames: tourClassNames, className, style: style$1, getPopupContainer, ...restProps } = props;
	const triggerRef = import_react.useRef();
	const [mergedCurrent, setMergedCurrent] = useControlledState(defaultCurrent || 0, current);
	const [internalOpen, setMergedOpen] = useControlledState(defaultOpen, open$2);
	const mergedOpen = mergedCurrent < 0 || mergedCurrent >= steps.length ? false : internalOpen ?? true;
	const [hasOpened, setHasOpened] = import_react.useState(mergedOpen);
	const openRef = import_react.useRef(mergedOpen);
	useLayoutEffect_default(() => {
		if (mergedOpen) {
			if (!openRef.current) setMergedCurrent(0);
			setHasOpened(true);
		}
		openRef.current = mergedOpen;
	}, [mergedOpen]);
	const { target, placement: stepPlacement, style: stepStyle, arrow: stepArrow, className: stepClassName, mask: stepMask, scrollIntoViewOptions: stepScrollIntoViewOptions = defaultScrollIntoViewOptions, closeIcon: stepCloseIcon, closable: stepClosable } = steps[mergedCurrent] || {};
	const mergedClosable = useClosable$1(stepClosable, stepCloseIcon, closable, closeIcon);
	const mergedMask = mergedOpen && (stepMask ?? mask);
	const mergedScrollIntoViewOptions = stepScrollIntoViewOptions ?? scrollIntoViewOptions;
	const placeholderRef = import_react.useRef(null);
	const inlineMode = getPopupContainer === false;
	const [posInfo, targetElement] = useTarget(target, open$2, gap, mergedScrollIntoViewOptions, inlineMode, placeholderRef);
	const mergedPlacement = getPlacement(targetElement, placement, stepPlacement);
	const mergedArrow = targetElement ? typeof stepArrow === "undefined" ? arrow : stepArrow : false;
	const arrowPointAtCenter = typeof mergedArrow === "object" ? mergedArrow.pointAtCenter : false;
	useLayoutEffect_default(() => {
		triggerRef.current?.forceAlign();
	}, [arrowPointAtCenter, mergedCurrent]);
	const onInternalChange = (nextCurrent) => {
		setMergedCurrent(nextCurrent);
		onChange?.(nextCurrent);
	};
	const mergedBuiltinPlacements$1 = (0, import_react.useMemo)(() => {
		if (builtinPlacements) return typeof builtinPlacements === "function" ? builtinPlacements({ arrowPointAtCenter }) : builtinPlacements;
		return getPlacements$1(arrowPointAtCenter);
	}, [builtinPlacements, arrowPointAtCenter]);
	if (targetElement === void 0 || !hasOpened) return null;
	const handleClose = () => {
		setMergedOpen(false);
		onClose?.(mergedCurrent);
	};
	const getPopupElement = () => /* @__PURE__ */ import_react.createElement(TourStep_default, _extends$4({
		styles,
		classNames: tourClassNames,
		arrow: mergedArrow,
		key: "content",
		prefixCls,
		total: steps.length,
		renderPanel,
		onPrev: () => {
			onInternalChange(mergedCurrent - 1);
		},
		onNext: () => {
			onInternalChange(mergedCurrent + 1);
		},
		onClose: handleClose,
		current: mergedCurrent,
		onFinish: () => {
			handleClose();
			onFinish?.();
		}
	}, steps[mergedCurrent], { closable: mergedClosable }));
	const mergedShowMask = typeof mergedMask === "boolean" ? mergedMask : !!mergedMask;
	const mergedMaskStyle = typeof mergedMask === "boolean" ? void 0 : mergedMask;
	const fallbackDOM = () => {
		return targetElement || document.body;
	};
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(Mask_default, {
		getPopupContainer,
		styles,
		classNames: tourClassNames,
		zIndex,
		prefixCls,
		pos: posInfo,
		showMask: mergedShowMask,
		style: mergedMaskStyle?.style,
		fill: mergedMaskStyle?.color,
		open: mergedOpen,
		animated,
		rootClassName,
		disabledInteraction
	}), /* @__PURE__ */ import_react.createElement(es_default$6, _extends$4({}, restProps, {
		getPopupContainer,
		builtinPlacements: mergedBuiltinPlacements$1,
		ref: triggerRef,
		popupStyle: stepStyle,
		popupPlacement: mergedPlacement,
		popupVisible: mergedOpen,
		popupClassName: clsx(rootClassName, stepClassName),
		prefixCls,
		popup: getPopupElement,
		forceRender: false,
		autoDestroy: true,
		zIndex,
		arrow: !!mergedArrow
	}), /* @__PURE__ */ import_react.createElement(Placeholder_default, {
		open: mergedOpen,
		autoLock: !inlineMode,
		getContainer: getPopupContainer,
		domRef: placeholderRef,
		fallbackDOM,
		className: clsx(className, rootClassName, `${prefixCls}-target-placeholder`),
		style: {
			...posInfo || CENTER_PLACEHOLDER,
			position: inlineMode ? "absolute" : "fixed",
			pointerEvents: "none",
			...style$1
		}
	})));
};
var Tour_default = Tour$1;

//#endregion
//#region node_modules/@rc-component/tour/es/index.js
var es_default$5 = Tour_default;

//#endregion
//#region node_modules/antd/es/tour/panelRender.js
var TourPanel = (props) => {
	const { stepProps, current, type: type$2, indicatorsRender, actionsRender } = props;
	const { prefixCls, total = 1, title, onClose, onPrev, onNext, onFinish, cover, description, nextButtonProps, prevButtonProps, type: stepType, closable, classNames = {}, styles = {} } = stepProps;
	const mergedType = stepType ?? type$2;
	const ariaProps = pickAttrs(closable ?? {}, true);
	const [contextLocaleGlobal] = useLocale_default("global", en_US_default.global);
	const [contextLocaleTour] = useLocale_default("Tour", en_US_default.Tour);
	const mergedCloseIcon = /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		onClick: onClose,
		className: `${prefixCls}-close`,
		"aria-label": contextLocaleGlobal?.close,
		...ariaProps
	}, closable?.closeIcon || /* @__PURE__ */ import_react.createElement(CloseOutlined_default, { className: `${prefixCls}-close-icon` }));
	const isLastStep = current === total - 1;
	const prevBtnClick = () => {
		onPrev?.();
		prevButtonProps?.onClick?.();
	};
	const nextBtnClick = () => {
		if (isLastStep) onFinish?.();
		else onNext?.();
		nextButtonProps?.onClick?.();
	};
	const headerNode = isNonNullable_default(title) ? /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-header`, classNames.header),
		style: styles.header
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-title`, classNames.title),
		style: styles.title
	}, title)) : null;
	const descriptionNode = isNonNullable_default(description) ? /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-description`, classNames.description),
		style: styles.description
	}, description) : null;
	const coverNode = isNonNullable_default(cover) ? /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-cover`, classNames.cover),
		style: styles.cover
	}, cover) : null;
	let mergedIndicatorNode;
	if (indicatorsRender) mergedIndicatorNode = indicatorsRender(current, total);
	else mergedIndicatorNode = _toConsumableArray(Array.from({ length: total }).keys()).map((stepItem, index$1) => /* @__PURE__ */ import_react.createElement("span", {
		key: stepItem,
		className: clsx(index$1 === current && `${prefixCls}-indicator-active`, `${prefixCls}-indicator`, classNames.indicator),
		style: styles.indicator
	}));
	const mainBtnType = mergedType === "primary" ? "default" : "primary";
	const secondaryBtnProps = {
		type: "default",
		ghost: mergedType === "primary"
	};
	const defaultActionsNode = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, current !== 0 ? /* @__PURE__ */ import_react.createElement(Button_default, {
		size: "small",
		...secondaryBtnProps,
		...prevButtonProps,
		onClick: prevBtnClick,
		className: clsx(`${prefixCls}-prev-btn`, prevButtonProps?.className)
	}, prevButtonProps?.children ?? contextLocaleTour?.Previous) : null, /* @__PURE__ */ import_react.createElement(Button_default, {
		size: "small",
		type: mainBtnType,
		...nextButtonProps,
		onClick: nextBtnClick,
		className: clsx(`${prefixCls}-next-btn`, nextButtonProps?.className)
	}, nextButtonProps?.children ?? (isLastStep ? contextLocaleTour?.Finish : contextLocaleTour?.Next)));
	return /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-panel` }, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-section`, classNames.section),
		style: styles.section
	}, closable && mergedCloseIcon, coverNode, headerNode, descriptionNode, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-footer`, classNames.footer),
		style: styles.footer
	}, total > 1 && /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-indicators`, classNames.indicators),
		style: styles.indicators
	}, mergedIndicatorNode), /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-actions`, classNames.actions),
		style: styles.actions
	}, actionsRender ? actionsRender(defaultActionsNode, {
		current,
		total
	}) : defaultActionsNode))));
};
var panelRender_default = TourPanel;

//#endregion
//#region node_modules/antd/es/tour/style/index.js
var genBaseStyle$2 = (token$1) => {
	const { componentCls, padding, paddingXS, borderRadius, borderRadiusXS, colorPrimary, colorFill, indicatorHeight, indicatorWidth, boxShadowTertiary, zIndexPopup, colorBgElevated, fontWeightStrong, marginXS, colorTextLightSolid, tourBorderRadius, colorWhite, primaryNextBtnHoverBg, closeBtnSize, motionDurationSlow, antCls, primaryPrevBtnBg } = token$1;
	return [{
		[componentCls]: {
			...resetComponent(token$1),
			position: "absolute",
			zIndex: zIndexPopup,
			maxWidth: "fit-content",
			visibility: "visible",
			width: 520,
			"--antd-arrow-background-color": colorBgElevated,
			"&-pure": {
				maxWidth: "100%",
				position: "relative"
			},
			[`&${componentCls}-hidden`]: { display: "none" },
			[`${componentCls}-panel`]: { position: "relative" },
			[`${componentCls}-section`]: {
				textAlign: "start",
				textDecoration: "none",
				borderRadius: tourBorderRadius,
				boxShadow: boxShadowTertiary,
				position: "relative",
				backgroundColor: colorBgElevated,
				border: "none",
				backgroundClip: "padding-box",
				[`${componentCls}-close`]: {
					position: "absolute",
					top: padding,
					insetInlineEnd: padding,
					color: token$1.colorIcon,
					background: "none",
					border: "none",
					width: closeBtnSize,
					height: closeBtnSize,
					borderRadius: token$1.borderRadiusSM,
					transition: `background-color ${token$1.motionDurationMid}, color ${token$1.motionDurationMid}`,
					display: "flex",
					alignItems: "center",
					justifyContent: "center",
					cursor: "pointer",
					"&:hover": {
						color: token$1.colorIconHover,
						backgroundColor: token$1.colorBgTextHover
					},
					"&:active": { backgroundColor: token$1.colorBgTextActive },
					...genFocusStyle(token$1)
				},
				[`${componentCls}-cover`]: {
					textAlign: "center",
					padding: `${unit(token$1.calc(padding).add(closeBtnSize).add(paddingXS).equal())} ${unit(padding)} 0`,
					img: { width: "100%" }
				},
				[`${componentCls}-header`]: {
					padding: `${unit(padding)} ${unit(padding)} ${unit(paddingXS)}`,
					width: `calc(100% - ${unit(closeBtnSize)})`,
					wordBreak: "break-word",
					[`${componentCls}-title`]: { fontWeight: fontWeightStrong }
				},
				[`${componentCls}-description`]: {
					padding: `0 ${unit(padding)}`,
					wordWrap: "break-word"
				},
				[`${componentCls}-footer`]: {
					padding: `${unit(paddingXS)} ${unit(padding)} ${unit(padding)}`,
					textAlign: "end",
					borderRadius: `0 0 ${unit(borderRadiusXS)} ${unit(borderRadiusXS)}`,
					display: "flex",
					[`${componentCls}-indicators`]: {
						display: "inline-block",
						[`${componentCls}-indicator`]: {
							width: indicatorWidth,
							height: indicatorHeight,
							display: "inline-block",
							borderRadius: "50%",
							background: colorFill,
							"&:not(:last-child)": { marginInlineEnd: indicatorHeight },
							"&-active": { background: colorPrimary }
						}
					},
					[`${componentCls}-actions`]: {
						marginInlineStart: "auto",
						[`${antCls}-btn`]: { marginInlineStart: marginXS }
					}
				}
			},
			[`${componentCls}-primary, &${componentCls}-primary`]: {
				"--antd-arrow-background-color": colorPrimary,
				[`${componentCls}-section`]: {
					color: colorTextLightSolid,
					textAlign: "start",
					textDecoration: "none",
					backgroundColor: colorPrimary,
					borderRadius,
					boxShadow: boxShadowTertiary,
					[`${componentCls}-close`]: { color: colorTextLightSolid },
					[`${componentCls}-indicators`]: { [`${componentCls}-indicator`]: {
						background: primaryPrevBtnBg,
						"&-active": { background: colorTextLightSolid }
					} },
					[`${componentCls}-prev-btn`]: {
						color: colorTextLightSolid,
						borderColor: primaryPrevBtnBg,
						backgroundColor: colorPrimary,
						"&:hover": {
							backgroundColor: primaryPrevBtnBg,
							borderColor: "transparent"
						}
					},
					[`${componentCls}-next-btn`]: {
						color: colorPrimary,
						borderColor: "transparent",
						background: colorWhite,
						"&:hover": { background: primaryNextBtnHoverBg }
					}
				}
			}
		},
		[`${componentCls}-mask`]: { [`${componentCls}-placeholder-animated`]: { transition: `all ${motionDurationSlow}` } },
		[[
			"&-placement-left",
			"&-placement-leftTop",
			"&-placement-leftBottom",
			"&-placement-right",
			"&-placement-rightTop",
			"&-placement-rightBottom"
		].join(",")]: { [`${componentCls}-section`]: { borderRadius: token$1.min(tourBorderRadius, MAX_VERTICAL_CONTENT_RADIUS) } }
	}, getArrowStyle(token$1, "var(--antd-arrow-background-color)")];
};
const prepareComponentToken$3 = (token$1) => ({
	zIndexPopup: token$1.zIndexPopupBase + 70,
	closeBtnSize: token$1.fontSize * token$1.lineHeight,
	primaryPrevBtnBg: new FastColor(token$1.colorTextLightSolid).setA(.15).toRgbString(),
	primaryNextBtnHoverBg: new FastColor(token$1.colorBgTextHover).onBackground(token$1.colorWhite).toRgbString(),
	...getArrowOffsetToken({
		contentRadius: token$1.borderRadiusLG,
		limitVerticalRadius: true
	}),
	...getArrowToken(token$1)
});
var style_default$4 = genStyleHooks("Tour", (token$1) => {
	const { borderRadiusLG } = token$1;
	return genBaseStyle$2(merge(token$1, {
		indicatorWidth: 6,
		indicatorHeight: 6,
		tourBorderRadius: borderRadiusLG
	}));
}, prepareComponentToken$3);

//#endregion
//#region node_modules/antd/es/tour/PurePanel.js
var PurePanel$1 = (props) => {
	const { prefixCls: customizePrefixCls, current = 0, total = 6, className, style: style$1, type: type$2, closable, closeIcon, ...restProps } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("tour", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$4(prefixCls);
	const [mergedClosable, mergedCloseIcon] = useClosable({
		closable,
		closeIcon
	}, null, {
		closable: true,
		closeIconRender: (icon) => /* @__PURE__ */ import_react.isValidElement(icon) ? cloneElement(icon, { className: clsx(icon.props?.className, `${prefixCls}-close-icon`) }) : icon
	});
	return /* @__PURE__ */ import_react.createElement(RawPurePanel, {
		prefixCls,
		hashId,
		className: clsx(className, `${prefixCls}-pure`, type$2 && `${prefixCls}-${type$2}`, cssVarCls),
		style: style$1
	}, /* @__PURE__ */ import_react.createElement(panelRender_default, {
		stepProps: {
			...restProps,
			prefixCls,
			total,
			closable: mergedClosable ? { closeIcon: mergedCloseIcon } : void 0
		},
		current,
		type: type$2
	}));
};
var PurePanel_default$1 = withPureRenderTheme(PurePanel$1);

//#endregion
//#region node_modules/antd/es/tour/index.js
var Tour = (props) => {
	const { prefixCls: customizePrefixCls, type: type$2, rootClassName, indicatorsRender, actionsRender, steps, closeIcon, classNames, styles, className, style: style$1, ...restProps } = props;
	const { getPrefixCls, direction, closeIcon: contextCloseIcon, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("tour");
	const prefixCls = getPrefixCls("tour", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$4(prefixCls);
	const [, token$1] = useToken();
	const mergedSteps = import_react.useMemo(() => steps?.map((step) => ({
		...step,
		className: clsx(step.className, { [`${prefixCls}-primary`]: (step.type ?? type$2) === "primary" })
	})), [
		prefixCls,
		steps,
		type$2
	]);
	const mergedProps = {
		...props,
		steps: mergedSteps
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const builtinPlacements = (config) => getPlacements({
		arrowPointAtCenter: config?.arrowPointAtCenter ?? true,
		autoAdjustOverflow: true,
		offset: token$1.marginXXS,
		arrowWidth: token$1.sizePopupArrow,
		borderRadius: token$1.borderRadius
	});
	const mergedRootClassName = clsx({ [`${prefixCls}-rtl`]: direction === "rtl" }, hashId, cssVarCls, rootClassName, contextClassName, mergedClassNames.root, className);
	const semanticStyles = {
		...mergedStyles,
		mask: {
			...mergedStyles.root,
			...mergedStyles.mask,
			...contextStyle,
			...style$1
		}
	};
	const mergedRenderPanel = (stepProps, stepCurrent) => /* @__PURE__ */ import_react.createElement(panelRender_default, {
		styles: semanticStyles,
		classNames: mergedClassNames,
		type: type$2,
		stepProps,
		current: stepCurrent,
		indicatorsRender,
		actionsRender
	});
	const [zIndex, contextZIndex] = useZIndex("Tour", restProps.zIndex);
	return /* @__PURE__ */ import_react.createElement(zindexContext_default.Provider, { value: contextZIndex }, /* @__PURE__ */ import_react.createElement(es_default$5, {
		...restProps,
		styles: semanticStyles,
		classNames: mergedClassNames,
		closeIcon: closeIcon ?? contextCloseIcon,
		zIndex,
		rootClassName: mergedRootClassName,
		prefixCls,
		animated: true,
		renderPanel: mergedRenderPanel,
		builtinPlacements,
		steps: mergedSteps
	}));
};
Tour.displayName = "Tour";
Tour._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default$1;
var tour_default = Tour;

//#endregion
//#region node_modules/antd/es/_util/transKeys.js
const groupKeysMap = (keys$1) => {
	const map = /* @__PURE__ */ new Map();
	keys$1.forEach((key, index$1) => {
		map.set(key, index$1);
	});
	return map;
};
const groupDisabledKeysMap = (dataSource) => {
	const map = /* @__PURE__ */ new Map();
	dataSource.forEach(({ disabled, key }, index$1) => {
		if (disabled) map.set(key, index$1);
	});
	return map;
};

//#endregion
//#region node_modules/antd/es/transfer/Actions.js
function getArrowIcon(type$2, direction) {
	const isRight = type$2 === "right";
	if (direction !== "rtl") return isRight ? /* @__PURE__ */ import_react.createElement(RightOutlined_default, null) : /* @__PURE__ */ import_react.createElement(LeftOutlined_default, null);
	return isRight ? /* @__PURE__ */ import_react.createElement(LeftOutlined_default, null) : /* @__PURE__ */ import_react.createElement(RightOutlined_default, null);
}
var Action = ({ type: type$2, actions, moveToLeft, moveToRight, leftActive, rightActive, direction, disabled }) => {
	const isRight = type$2 === "right";
	const button = isRight ? actions[0] : actions[1];
	const moveHandler = isRight ? moveToRight : moveToLeft;
	const active = isRight ? rightActive : leftActive;
	const icon = getArrowIcon(type$2, direction);
	if (/* @__PURE__ */ import_react.isValidElement(button)) {
		const element = button;
		const onClick = (event) => {
			element?.props?.onClick?.(event);
			moveHandler?.(event);
		};
		return /* @__PURE__ */ import_react.cloneElement(element, {
			disabled: disabled || !active,
			onClick
		});
	}
	return /* @__PURE__ */ import_react.createElement(Button_default, {
		type: "primary",
		size: "small",
		disabled: disabled || !active,
		onClick: (event) => moveHandler?.(event),
		icon
	}, button);
};
var Actions = (props) => {
	const { className, style: style$1, oneWay, actions, ...restProps } = props;
	return /* @__PURE__ */ import_react.createElement("div", {
		className,
		style: style$1
	}, /* @__PURE__ */ import_react.createElement(Action, {
		type: "right",
		actions,
		...restProps
	}), !oneWay && /* @__PURE__ */ import_react.createElement(Action, {
		type: "left",
		actions,
		...restProps
	}), actions.slice(oneWay ? 1 : 2));
};
Actions.displayName = "Actions";
var Actions_default = Actions;

//#endregion
//#region node_modules/antd/es/transfer/hooks/useData.js
var useData = (dataSource, rowKey, targetKeys) => {
	const mergedDataSource = import_react.useMemo(() => (dataSource || []).map((record) => {
		if (rowKey) return {
			...record,
			key: rowKey(record)
		};
		return record;
	}), [dataSource, rowKey]);
	const [leftDataSource, rightDataSource] = import_react.useMemo(() => {
		const leftData = [];
		const rightData = Array.from({ length: targetKeys?.length ?? 0 });
		const targetKeysMap = groupKeysMap(targetKeys || []);
		mergedDataSource.forEach((record) => {
			if (targetKeysMap.has(record.key)) {
				const idx = targetKeysMap.get(record.key);
				rightData[idx] = record;
			} else leftData.push(record);
		});
		return [leftData, rightData];
	}, [mergedDataSource, targetKeys]);
	return [
		mergedDataSource,
		leftDataSource.filter(Boolean),
		rightDataSource.filter(Boolean)
	];
};
var useData_default = useData;

//#endregion
//#region node_modules/antd/es/transfer/hooks/useSelection.js
var EMPTY_KEYS = [];
function filterKeys(keys$1, dataKeys) {
	const filteredKeys = keys$1.filter((key) => dataKeys.has(key));
	return keys$1.length === filteredKeys.length ? keys$1 : filteredKeys;
}
function flattenKeys(keys$1) {
	return Array.from(keys$1).join(";");
}
function useSelection(leftDataSource, rightDataSource, selectedKeys) {
	const [leftKeys, rightKeys] = import_react.useMemo(() => [new Set(leftDataSource.map((src) => src?.key)), new Set(rightDataSource.map((src) => src?.key))], [leftDataSource, rightDataSource]);
	const [mergedSelectedKeys, setMergedSelectedKeys] = useControlledState(EMPTY_KEYS, selectedKeys);
	const sourceSelectedKeys = import_react.useMemo(() => filterKeys(mergedSelectedKeys, leftKeys), [mergedSelectedKeys, leftKeys]);
	const targetSelectedKeys = import_react.useMemo(() => filterKeys(mergedSelectedKeys, rightKeys), [mergedSelectedKeys, rightKeys]);
	import_react.useEffect(() => {
		setMergedSelectedKeys([].concat(_toConsumableArray(filterKeys(mergedSelectedKeys, leftKeys)), _toConsumableArray(filterKeys(mergedSelectedKeys, rightKeys))));
	}, [flattenKeys(leftKeys), flattenKeys(rightKeys)]);
	return [
		sourceSelectedKeys,
		targetSelectedKeys,
		useEvent_default((nextSrcKeys) => {
			setMergedSelectedKeys([].concat(_toConsumableArray(nextSrcKeys), _toConsumableArray(targetSelectedKeys)));
		}),
		useEvent_default((nextTargetKeys) => {
			setMergedSelectedKeys([].concat(_toConsumableArray(sourceSelectedKeys), _toConsumableArray(nextTargetKeys)));
		})
	];
}
var useSelection_default = useSelection;

//#endregion
//#region node_modules/antd/es/transfer/search.js
var Search = (props) => {
	const { placeholder = "", value, prefixCls, disabled, onChange, handleClear } = props;
	const handleChange = import_react.useCallback((e$2) => {
		onChange?.(e$2);
		if (e$2.target.value === "") handleClear?.();
	}, [onChange]);
	return /* @__PURE__ */ import_react.createElement(Input_default, {
		placeholder,
		className: prefixCls,
		value,
		onChange: handleChange,
		disabled,
		allowClear: true,
		prefix: /* @__PURE__ */ import_react.createElement(SearchOutlined_default, null)
	});
};
Search.displayName = "Search";
var search_default = Search;

//#endregion
//#region node_modules/antd/es/transfer/ListItem.js
var ListItem$1 = (props) => {
	const { prefixCls, classNames, styles, renderedText, renderedEl, item, checked, disabled, onClick, onRemove, showRemove } = props;
	const mergedDisabled = disabled || item?.disabled;
	const classes = clsx(`${prefixCls}-content-item`, classNames.item, {
		[`${prefixCls}-content-item-disabled`]: mergedDisabled,
		[`${prefixCls}-content-item-checked`]: checked && !mergedDisabled
	});
	let title;
	if (typeof renderedText === "string" || typeof renderedText === "number") title = String(renderedText);
	const [contextLocale] = useLocale_default("Transfer", en_US_default.Transfer);
	const liProps = {
		className: classes,
		style: styles.item,
		title
	};
	const labelNode = /* @__PURE__ */ import_react.createElement("span", {
		className: clsx(`${prefixCls}-content-item-text`, classNames.itemContent),
		style: styles.itemContent
	}, renderedEl);
	if (showRemove) return /* @__PURE__ */ import_react.createElement("li", { ...liProps }, labelNode, /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		disabled: mergedDisabled,
		className: `${prefixCls}-content-item-remove`,
		"aria-label": contextLocale?.remove,
		onClick: () => onRemove?.(item)
	}, /* @__PURE__ */ import_react.createElement(DeleteOutlined_default, null)));
	liProps.onClick = mergedDisabled ? void 0 : (event) => onClick(item, event);
	return /* @__PURE__ */ import_react.createElement("li", { ...liProps }, /* @__PURE__ */ import_react.createElement(checkbox_default, {
		className: clsx(`${prefixCls}-checkbox`, classNames.itemIcon),
		style: styles.itemIcon,
		checked,
		disabled: mergedDisabled
	}), labelNode);
};
var ListItem_default$1 = /* @__PURE__ */ import_react.memo(ListItem$1);

//#endregion
//#region node_modules/antd/es/transfer/ListBody.js
const OmitProps = [
	"handleFilter",
	"handleClear",
	"checkedKeys"
];
var parsePagination = (pagination) => {
	return {
		simple: true,
		showSizeChanger: false,
		showLessItems: false,
		...pagination
	};
};
var TransferListBody = (props, ref) => {
	const { prefixCls, classNames, styles, filteredRenderItems, selectedKeys, disabled: globalDisabled, showRemove, pagination, onScroll, onItemSelect, onItemRemove } = props;
	const [current, setCurrent] = import_react.useState(1);
	const mergedPagination = import_react.useMemo(() => {
		if (!pagination) return null;
		return parsePagination(typeof pagination === "object" ? pagination : {});
	}, [pagination]);
	const [pageSize, setPageSize] = useControlledState(10, mergedPagination?.pageSize);
	import_react.useEffect(() => {
		if (mergedPagination) {
			const maxPageCount = Math.ceil(filteredRenderItems.length / pageSize);
			setCurrent(Math.min(current, maxPageCount));
		}
	}, [
		filteredRenderItems,
		mergedPagination,
		pageSize
	]);
	const onInternalClick = (item, e$2) => {
		onItemSelect(item.key, !selectedKeys.includes(item.key), e$2);
	};
	const onRemove = (item) => {
		onItemRemove?.([item.key]);
	};
	const onPageChange = (cur) => {
		setCurrent(cur);
	};
	const onSizeChange = (cur, size) => {
		setCurrent(cur);
		setPageSize(size);
	};
	const memoizedItems = import_react.useMemo(() => {
		return mergedPagination ? filteredRenderItems.slice((current - 1) * pageSize, current * pageSize) : filteredRenderItems;
	}, [
		current,
		filteredRenderItems,
		mergedPagination,
		pageSize
	]);
	import_react.useImperativeHandle(ref, () => ({ items: memoizedItems }));
	const paginationNode = mergedPagination ? /* @__PURE__ */ import_react.createElement(pagination_default, {
		size: "small",
		disabled: globalDisabled,
		simple: mergedPagination.simple,
		pageSize,
		showLessItems: mergedPagination.showLessItems,
		showSizeChanger: mergedPagination.showSizeChanger,
		className: `${prefixCls}-pagination`,
		total: filteredRenderItems.length,
		current,
		onChange: onPageChange,
		onShowSizeChange: onSizeChange
	}) : null;
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("ul", {
		className: clsx(`${prefixCls}-content`, classNames.list, { [`${prefixCls}-content-show-remove`]: showRemove }),
		style: styles.list,
		onScroll
	}, (memoizedItems || []).map(({ renderedEl, renderedText, item }) => /* @__PURE__ */ import_react.createElement(ListItem_default$1, {
		key: item.key,
		prefixCls,
		classNames,
		styles,
		item,
		renderedText,
		renderedEl,
		showRemove,
		onClick: onInternalClick,
		onRemove,
		checked: selectedKeys.includes(item.key),
		disabled: globalDisabled
	}))), paginationNode);
};
TransferListBody.displayName = "TransferListBody";
var ListBody_default = /* @__PURE__ */ import_react.forwardRef(TransferListBody);

//#endregion
//#region node_modules/antd/es/transfer/Section.js
var defaultRender = () => null;
function isRenderResultPlainObject(result) {
	return !!(result && !/* @__PURE__ */ import_react.isValidElement(result) && Object.prototype.toString.call(result) === "[object Object]");
}
function getEnabledItemKeys(items) {
	return items.filter((data) => !data.disabled).map((data) => data.key);
}
var isValidIcon = (icon) => icon !== void 0;
var getShowSearchOption = (showSearch) => {
	if (showSearch && typeof showSearch === "object") return {
		...showSearch,
		defaultValue: showSearch.defaultValue || ""
	};
	return {
		defaultValue: "",
		placeholder: ""
	};
};
var TransferSection = (props) => {
	const { prefixCls, style: style$1, classNames, styles, dataSource = [], titleText = "", checkedKeys, disabled, showSearch = false, searchPlaceholder, notFoundContent, selectAll, deselectAll, selectCurrent, selectInvert, removeAll, removeCurrent, showSelectAll = true, showRemove, pagination, direction, itemsUnit, itemUnit, selectAllLabel, selectionsIcon, footer, renderList, onItemSelectAll, onItemRemove, handleFilter, handleClear, filterOption: filterOption$1, render: render$1 = defaultRender } = props;
	const sectionPrefixCls = `${prefixCls}-section`;
	const listPrefixCls = `${prefixCls}-list`;
	const searchOptions = getShowSearchOption(showSearch);
	const [filterValue, setFilterValue] = (0, import_react.useState)(searchOptions.defaultValue);
	const listBodyRef = (0, import_react.useRef)({});
	const internalHandleFilter = (e$2) => {
		setFilterValue(e$2.target.value);
		handleFilter(e$2);
	};
	const internalHandleClear = () => {
		setFilterValue("");
		handleClear();
	};
	const matchFilter = (text, item) => {
		if (typeof filterOption$1 === "function") return filterOption$1(filterValue, item, direction);
		return text.includes(filterValue);
	};
	const customRenderListBody = (listProps) => {
		let bodyContent = renderList ? renderList({
			...listProps,
			onItemSelect: (key, check) => listProps.onItemSelect(key, check)
		}) : null;
		const customize = !!bodyContent;
		if (!customize) bodyContent = /* @__PURE__ */ import_react.createElement(ListBody_default, {
			ref: listBodyRef,
			...listProps,
			prefixCls: listPrefixCls
		});
		return {
			customize,
			bodyContent
		};
	};
	const renderItem$1 = (item) => {
		const renderResult = render$1(item);
		const isRenderResultPlain = isRenderResultPlainObject(renderResult);
		return {
			item,
			renderedEl: isRenderResultPlain ? renderResult.label : renderResult,
			renderedText: isRenderResultPlain ? renderResult.value : renderResult
		};
	};
	const notFoundContentEle = (0, import_react.useMemo)(() => Array.isArray(notFoundContent) ? notFoundContent[direction === "left" ? 0 : 1] : notFoundContent, [notFoundContent, direction]);
	const [filteredItems, filteredRenderItems] = (0, import_react.useMemo)(() => {
		const filterItems = [];
		const filterRenderItems = [];
		dataSource.forEach((item) => {
			const renderedItem = renderItem$1(item);
			if (filterValue && !matchFilter(renderedItem.renderedText, item)) return;
			filterItems.push(item);
			filterRenderItems.push(renderedItem);
		});
		return [filterItems, filterRenderItems];
	}, [dataSource, filterValue]);
	const checkedActiveItems = (0, import_react.useMemo)(() => {
		return filteredItems.filter((item) => checkedKeys.includes(item.key) && !item.disabled);
	}, [checkedKeys, filteredItems]);
	const checkStatus = (0, import_react.useMemo)(() => {
		if (checkedActiveItems.length === 0) return "none";
		const checkedKeysMap = groupKeysMap(checkedKeys);
		if (filteredItems.every((item) => checkedKeysMap.has(item.key) || !!item.disabled)) return "all";
		return "part";
	}, [
		checkedActiveItems.length,
		checkedKeys,
		filteredItems
	]);
	const renderListBody = () => {
		const search = showSearch ? /* @__PURE__ */ import_react.createElement("div", { className: `${listPrefixCls}-body-search-wrapper` }, /* @__PURE__ */ import_react.createElement(search_default, {
			prefixCls: `${listPrefixCls}-search`,
			onChange: internalHandleFilter,
			handleClear: internalHandleClear,
			placeholder: searchOptions.placeholder || searchPlaceholder,
			value: filterValue,
			disabled
		})) : null;
		const { customize, bodyContent } = customRenderListBody({
			...omit(props, OmitProps),
			filteredItems,
			filteredRenderItems,
			selectedKeys: checkedKeys,
			classNames,
			styles
		});
		let bodyNode;
		if (customize) bodyNode = /* @__PURE__ */ import_react.createElement("div", { className: `${listPrefixCls}-body-customize-wrapper` }, bodyContent);
		else bodyNode = filteredItems.length ? bodyContent : /* @__PURE__ */ import_react.createElement("div", { className: `${listPrefixCls}-body-not-found` }, notFoundContentEle);
		return /* @__PURE__ */ import_react.createElement("div", {
			className: clsx(`${listPrefixCls}-body`, { [`${listPrefixCls}-body-with-search`]: showSearch }, classNames.body),
			style: styles.body
		}, search, bodyNode);
	};
	const checkBox = /* @__PURE__ */ import_react.createElement(checkbox_default, {
		disabled: dataSource.filter((d) => !d.disabled).length === 0 || disabled,
		checked: checkStatus === "all",
		indeterminate: checkStatus === "part",
		className: `${listPrefixCls}-checkbox`,
		onChange: () => {
			onItemSelectAll?.(filteredItems.filter((item) => !item.disabled).map(({ key }) => key), checkStatus !== "all");
		}
	});
	const getSelectAllLabel = (selectedCount, totalCount) => {
		if (selectAllLabel) return typeof selectAllLabel === "function" ? selectAllLabel({
			selectedCount,
			totalCount
		}) : selectAllLabel;
		const unit$2 = totalCount > 1 ? itemsUnit : itemUnit;
		return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, (selectedCount > 0 ? `${selectedCount}/` : "") + totalCount, " ", unit$2);
	};
	const footerDom = footer && (footer.length < 2 ? footer(props) : footer(props, { direction }));
	const listFooter = footerDom ? /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${listPrefixCls}-footer`, classNames.footer),
		style: styles.footer
	}, footerDom) : null;
	const checkAllCheckbox = !showRemove && !pagination && checkBox;
	let items;
	if (showRemove) items = [pagination ? {
		key: "removeCurrent",
		label: removeCurrent,
		onClick() {
			const pageKeys = getEnabledItemKeys((listBodyRef.current?.items || []).map((entity) => entity.item));
			onItemRemove?.(pageKeys);
		}
	} : null, {
		key: "removeAll",
		label: removeAll,
		onClick() {
			onItemRemove?.(getEnabledItemKeys(filteredItems));
		}
	}].filter(Boolean);
	else items = [
		{
			key: "selectAll",
			label: checkStatus === "all" ? deselectAll : selectAll,
			onClick() {
				const keys$1 = getEnabledItemKeys(filteredItems);
				onItemSelectAll?.(keys$1, keys$1.length !== checkedKeys.length);
			}
		},
		pagination ? {
			key: "selectCurrent",
			label: selectCurrent,
			onClick() {
				const pageItems = listBodyRef.current?.items || [];
				onItemSelectAll?.(getEnabledItemKeys(pageItems.map((entity) => entity.item)), true);
			}
		} : null,
		{
			key: "selectInvert",
			label: selectInvert,
			onClick() {
				const availablePageItemKeys = getEnabledItemKeys((listBodyRef.current?.items || []).map((entity) => entity.item));
				const checkedKeySet = new Set(checkedKeys);
				const newCheckedKeysSet = new Set(checkedKeySet);
				availablePageItemKeys.forEach((key) => {
					if (checkedKeySet.has(key)) newCheckedKeysSet.delete(key);
					else newCheckedKeysSet.add(key);
				});
				onItemSelectAll?.(Array.from(newCheckedKeysSet), "replace");
			}
		}
	];
	const dropdown = /* @__PURE__ */ import_react.createElement(dropdown_default, {
		className: `${listPrefixCls}-header-dropdown`,
		menu: { items },
		disabled
	}, isValidIcon(selectionsIcon) ? selectionsIcon : /* @__PURE__ */ import_react.createElement(DownOutlined_default, null));
	return /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(sectionPrefixCls, classNames.section, {
			[`${sectionPrefixCls}-with-pagination`]: !!pagination,
			[`${sectionPrefixCls}-with-footer`]: !!footerDom
		}),
		style: {
			...style$1,
			...styles.section
		}
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${listPrefixCls}-header`, classNames.header),
		style: styles.header
	}, showSelectAll ? /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, checkAllCheckbox, dropdown) : null, /* @__PURE__ */ import_react.createElement("span", { className: `${listPrefixCls}-header-selected` }, getSelectAllLabel(checkedActiveItems.length, filteredItems.length)), /* @__PURE__ */ import_react.createElement("span", {
		className: clsx(`${listPrefixCls}-header-title`, classNames.title),
		style: styles.title
	}, titleText)), renderListBody(), listFooter);
};
TransferSection.displayName = "TransferSection";
var Section_default = TransferSection;

//#endregion
//#region node_modules/antd/es/transfer/style/index.js
var genTransferCustomizeStyle = (token$1) => {
	const { antCls, componentCls, listHeight, controlHeightLG } = token$1;
	const tableCls = `${antCls}-table`;
	const inputCls = `${antCls}-input`;
	return { [`${componentCls}-customize-list`]: {
		[`${componentCls}-section`]: {
			flex: "1 1 50%",
			width: "auto",
			height: "auto",
			minHeight: listHeight,
			minWidth: 0
		},
		[`${tableCls}-wrapper`]: {
			[`${tableCls}-small`]: {
				border: 0,
				borderRadius: 0,
				[`${tableCls}-selection-column`]: {
					width: controlHeightLG,
					minWidth: controlHeightLG
				}
			},
			[`${tableCls}-pagination${tableCls}-pagination`]: {
				margin: 0,
				padding: token$1.paddingXS
			}
		},
		[`${inputCls}[disabled]`]: { backgroundColor: "transparent" }
	} };
};
var genTransferStatusColor = (token$1, color) => {
	const { componentCls, colorBorder } = token$1;
	return { [`${componentCls}-section`]: {
		borderColor: color,
		[`${componentCls}-list-search:not([disabled])`]: { borderColor: colorBorder }
	} };
};
var genTransferStatusStyle = (token$1) => {
	const { componentCls } = token$1;
	return {
		[`${componentCls}-status-error`]: { ...genTransferStatusColor(token$1, token$1.colorError) },
		[`${componentCls}-status-warning`]: { ...genTransferStatusColor(token$1, token$1.colorWarning) }
	};
};
var genTransferListStyle = (token$1) => {
	const { componentCls, colorBorder, colorSplit, lineWidth, itemHeight, headerHeight, transferHeaderVerticalPadding, itemPaddingBlock, controlItemBgActive, colorTextDisabled, colorTextSecondary, listHeight, listWidth, listWidthLG, fontSizeIcon, marginXS, paddingSM, lineType, antCls, iconCls, motionDurationSlow, controlItemBgHover, borderRadiusLG, colorBgContainer, colorText, controlItemBgActiveHover } = token$1;
	const contentBorderRadius = unit(token$1.calc(borderRadiusLG).sub(lineWidth).equal());
	return {
		display: "flex",
		flexDirection: "column",
		width: listWidth,
		height: listHeight,
		border: `${unit(lineWidth)} ${lineType} ${colorBorder}`,
		borderRadius: token$1.borderRadiusLG,
		"&-with-pagination": {
			width: listWidthLG,
			height: "auto"
		},
		[`${componentCls}-list`]: {
			"&-search": { [`${iconCls}-search`]: { color: colorTextDisabled } },
			"&-header": {
				display: "flex",
				flex: "none",
				alignItems: "center",
				height: headerHeight,
				padding: `${unit(token$1.calc(transferHeaderVerticalPadding).sub(lineWidth).equal())} ${unit(paddingSM)} ${unit(transferHeaderVerticalPadding)}`,
				color: colorText,
				background: colorBgContainer,
				borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
				borderRadius: `${unit(borderRadiusLG)} ${unit(borderRadiusLG)} 0 0`,
				"> *:not(:last-child)": { marginInlineEnd: 4 },
				"> *": { flex: "none" },
				"&-title": {
					...textEllipsis,
					flex: "0 1 auto",
					textAlign: "end",
					marginInlineStart: "auto"
				},
				"&-dropdown": {
					...resetIcon(),
					fontSize: fontSizeIcon,
					transform: "translateY(10%)",
					cursor: "pointer",
					"&[disabled]": { cursor: "not-allowed" }
				}
			},
			"&-body": {
				display: "flex",
				flex: "auto",
				flexDirection: "column",
				fontSize: token$1.fontSize,
				minHeight: 0,
				"&-search-wrapper": {
					position: "relative",
					flex: "none",
					padding: paddingSM
				}
			},
			"&-content": {
				flex: "auto",
				margin: 0,
				padding: 0,
				overflow: "auto",
				listStyle: "none",
				borderRadius: `0 0 ${contentBorderRadius} ${contentBorderRadius}`,
				"&-item": {
					display: "flex",
					alignItems: "center",
					minHeight: itemHeight,
					padding: `${unit(itemPaddingBlock)} ${unit(paddingSM)}`,
					transition: `all ${motionDurationSlow}`,
					"> *:not(:last-child)": { marginInlineEnd: marginXS },
					"> *": { flex: "none" },
					"&-text": {
						...textEllipsis,
						flex: "auto"
					},
					"&-remove": {
						...operationUnit(token$1),
						color: colorBorder,
						"&:hover, &:focus": { color: colorTextSecondary }
					},
					[`&:not(${componentCls}-list-content-item-disabled)`]: {
						"&:hover": {
							backgroundColor: controlItemBgHover,
							cursor: "pointer"
						},
						[`&${componentCls}-list-content-item-checked:hover`]: { backgroundColor: controlItemBgActiveHover }
					},
					"&-checked": { backgroundColor: controlItemBgActive },
					"&-disabled": {
						color: colorTextDisabled,
						cursor: "not-allowed"
					}
				},
				[`&-show-remove ${componentCls}-list-content-item:not(${componentCls}-list-content-item-disabled):hover`]: {
					background: "transparent",
					cursor: "default"
				}
			},
			"&-pagination": {
				padding: token$1.paddingXS,
				textAlign: "end",
				borderTop: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
				[`${antCls}-pagination-options`]: { paddingInlineEnd: token$1.paddingXS }
			},
			"&-body-not-found": {
				flex: "none",
				width: "100%",
				margin: "auto 0",
				color: colorTextDisabled,
				textAlign: "center"
			},
			"&-footer": { borderTop: `${unit(lineWidth)} ${lineType} ${colorSplit}` },
			"&-checkbox": { lineHeight: 1 }
		}
	};
};
var genTransferStyle = (token$1) => {
	const { antCls, iconCls, componentCls, marginXS, marginXXS, fontSizeIcon, colorBgContainerDisabled } = token$1;
	return { [componentCls]: {
		...resetComponent(token$1),
		position: "relative",
		display: "flex",
		alignItems: "stretch",
		[`${componentCls}-disabled`]: { [`${componentCls}-section`]: { background: colorBgContainerDisabled } },
		[`${componentCls}-section`]: genTransferListStyle(token$1),
		[`${componentCls}-actions`]: {
			display: "flex",
			flex: "none",
			flexDirection: "column",
			alignSelf: "center",
			margin: `0 ${unit(marginXS)}`,
			verticalAlign: "middle",
			gap: marginXXS,
			[`${antCls}-btn ${iconCls}`]: { fontSize: fontSizeIcon }
		}
	} };
};
var genTransferRTLStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-rtl`]: { direction: "rtl" } };
};
const prepareComponentToken$2 = (token$1) => {
	const { fontSize, lineHeight, controlHeight, controlHeightLG, lineWidth } = token$1;
	const fontHeight = Math.round(fontSize * lineHeight);
	return {
		listWidth: 180,
		listHeight: 200,
		listWidthLG: 250,
		headerHeight: controlHeightLG,
		itemHeight: controlHeight,
		itemPaddingBlock: (controlHeight - fontHeight) / 2,
		transferHeaderVerticalPadding: Math.ceil((controlHeightLG - lineWidth - fontHeight) / 2)
	};
};
var style_default$3 = genStyleHooks("Transfer", (token$1) => {
	const transferToken = merge(token$1);
	return [
		genTransferStyle(transferToken),
		genTransferCustomizeStyle(transferToken),
		genTransferStatusStyle(transferToken),
		genTransferRTLStyle(transferToken)
	];
}, prepareComponentToken$2);

//#endregion
//#region node_modules/antd/es/transfer/index.js
var Transfer = (props) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, classNames, styles, style: style$1, listStyle, operationStyle, operations, actions, dataSource, targetKeys = [], selectedKeys, selectAllLabels = [], locale: locale$5 = {}, titles, disabled, showSearch = false, showSelectAll, oneWay, pagination, status: customStatus, selectionsIcon, filterOption: filterOption$1, render: render$1, footer, children, rowKey, onScroll, onChange, onSearch, onSelectChange } = props;
	const { getPrefixCls, renderEmpty, direction: dir, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles, selectionsIcon: contextSelectionsIcon } = useComponentConfig("transfer");
	const contextDisabled = (0, import_react.useContext)(DisabledContext_default);
	const mergedDisabled = disabled ?? contextDisabled;
	const mergedProps = {
		...props,
		disabled: mergedDisabled
	};
	const prefixCls = getPrefixCls("transfer", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$3(prefixCls);
	const mergedActions = actions || operations || [];
	const [mergedDataSource, leftDataSource, rightDataSource] = useData_default(dataSource, rowKey, targetKeys);
	const [sourceSelectedKeys, targetSelectedKeys, setSourceSelectedKeys, setTargetSelectedKeys] = useSelection_default(leftDataSource, rightDataSource, selectedKeys);
	const [leftMultipleSelect, updateLeftPrevSelectedIndex] = useMultipleSelect((item) => item.key);
	const [rightMultipleSelect, updateRightPrevSelectedIndex] = useMultipleSelect((item) => item.key);
	const setStateKeys = (0, import_react.useCallback)((direction, keys$1) => {
		if (direction === "left") setSourceSelectedKeys(typeof keys$1 === "function" ? keys$1(sourceSelectedKeys || []) : keys$1);
		else setTargetSelectedKeys(typeof keys$1 === "function" ? keys$1(targetSelectedKeys || []) : keys$1);
	}, [sourceSelectedKeys, targetSelectedKeys]);
	const setPrevSelectedIndex = (direction, value) => {
		(direction === "left" ? updateLeftPrevSelectedIndex : updateRightPrevSelectedIndex)(value);
	};
	const handleSelectChange = (0, import_react.useCallback)((direction, holder) => {
		if (direction === "left") onSelectChange?.(holder, targetSelectedKeys);
		else onSelectChange?.(sourceSelectedKeys, holder);
	}, [sourceSelectedKeys, targetSelectedKeys]);
	const getTitles = (transferLocale) => titles ?? transferLocale.titles ?? [];
	const handleLeftScroll = (e$2) => {
		onScroll?.("left", e$2);
	};
	const handleRightScroll = (e$2) => {
		onScroll?.("right", e$2);
	};
	const moveTo = (direction) => {
		const moveKeys = direction === "right" ? sourceSelectedKeys : targetSelectedKeys;
		const dataSourceDisabledKeysMap = groupDisabledKeysMap(mergedDataSource);
		const newMoveKeys = moveKeys.filter((key) => !dataSourceDisabledKeysMap.has(key));
		const newMoveKeysMap = groupKeysMap(newMoveKeys);
		const newTargetKeys = direction === "right" ? newMoveKeys.concat(targetKeys) : targetKeys.filter((targetKey) => !newMoveKeysMap.has(targetKey));
		const oppositeDirection = direction === "right" ? "left" : "right";
		setStateKeys(oppositeDirection, []);
		handleSelectChange(oppositeDirection, []);
		onChange?.(newTargetKeys, direction, newMoveKeys);
	};
	const moveToLeft = () => {
		moveTo("left");
		setPrevSelectedIndex("left", null);
	};
	const moveToRight = () => {
		moveTo("right");
		setPrevSelectedIndex("right", null);
	};
	const onItemSelectAll = (direction, keys$1, checkAll) => {
		setStateKeys(direction, (prevKeys) => {
			let mergedCheckedKeys = [];
			if (checkAll === "replace") mergedCheckedKeys = keys$1;
			else if (checkAll) mergedCheckedKeys = Array.from(new Set([].concat(_toConsumableArray(prevKeys), _toConsumableArray(keys$1))));
			else {
				const selectedKeysMap = groupKeysMap(keys$1);
				mergedCheckedKeys = prevKeys.filter((key) => !selectedKeysMap.has(key));
			}
			handleSelectChange(direction, mergedCheckedKeys);
			return mergedCheckedKeys;
		});
		setPrevSelectedIndex(direction, null);
	};
	const onLeftItemSelectAll = (keys$1, checkAll) => {
		onItemSelectAll("left", keys$1, checkAll);
	};
	const onRightItemSelectAll = (keys$1, checkAll) => {
		onItemSelectAll("right", keys$1, checkAll);
	};
	const leftFilter = (e$2) => onSearch?.("left", e$2.target.value);
	const rightFilter = (e$2) => onSearch?.("right", e$2.target.value);
	const handleLeftClear = () => onSearch?.("left", "");
	const handleRightClear = () => onSearch?.("right", "");
	const handleSingleSelect = (direction, holder, selectedKey, checked, currentSelectedIndex) => {
		if (holder.has(selectedKey)) {
			holder.delete(selectedKey);
			setPrevSelectedIndex(direction, null);
		}
		if (checked) {
			holder.add(selectedKey);
			setPrevSelectedIndex(direction, currentSelectedIndex);
		}
	};
	const handleMultipleSelect = (direction, data, holder, currentSelectedIndex) => {
		(direction === "left" ? leftMultipleSelect : rightMultipleSelect)(currentSelectedIndex, data, holder);
	};
	const onItemSelect = (direction, selectedKey, checked, multiple) => {
		const isLeftDirection = direction === "left";
		const holder = _toConsumableArray(isLeftDirection ? sourceSelectedKeys : targetSelectedKeys);
		const holderSet = new Set(holder);
		const data = _toConsumableArray(isLeftDirection ? leftDataSource : rightDataSource).filter((item) => !item?.disabled);
		const currentSelectedIndex = data.findIndex((item) => item.key === selectedKey);
		if (multiple && holder.length > 0) handleMultipleSelect(direction, data, holderSet, currentSelectedIndex);
		else handleSingleSelect(direction, holderSet, selectedKey, checked, currentSelectedIndex);
		const holderArr = Array.from(holderSet);
		handleSelectChange(direction, holderArr);
		if (!props.selectedKeys) setStateKeys(direction, holderArr);
	};
	const onLeftItemSelect = (selectedKey, checked, e$2) => {
		onItemSelect("left", selectedKey, checked, e$2?.shiftKey);
	};
	const onRightItemSelect = (selectedKey, checked, e$2) => {
		onItemSelect("right", selectedKey, checked, e$2?.shiftKey);
	};
	const onRightItemRemove = (keys$1) => {
		setStateKeys("right", []);
		onChange?.(targetKeys.filter((key) => !keys$1.includes(key)), "left", _toConsumableArray(keys$1));
	};
	const handleListStyle = (direction) => {
		if (typeof listStyle === "function") return listStyle({ direction });
		return listStyle || {};
	};
	const { hasFeedback, status } = (0, import_react.useContext)(FormItemInputContext);
	const getLocale = (transferLocale) => ({
		...transferLocale,
		notFoundContent: renderEmpty?.("Transfer") || /* @__PURE__ */ import_react.createElement(defaultRenderEmpty_default, { componentName: "Transfer" }),
		...locale$5
	});
	const mergedStatus = getMergedStatus(status, customStatus);
	const mergedPagination = !children && pagination;
	const leftActive = rightDataSource.filter((d) => targetSelectedKeys.includes(d.key) && !d.disabled).length > 0;
	const rightActive = leftDataSource.filter((d) => sourceSelectedKeys.includes(d.key) && !d.disabled).length > 0;
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const cls = clsx(prefixCls, {
		[`${prefixCls}-disabled`]: mergedDisabled,
		[`${prefixCls}-customize-list`]: !!children,
		[`${prefixCls}-rtl`]: dir === "rtl"
	}, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), contextClassName, className, rootClassName, hashId, cssVarCls, mergedClassNames.root);
	const [contextLocale] = useLocale_default("Transfer", en_US_default.Transfer);
	const listLocale = getLocale(contextLocale);
	const [leftTitle, rightTitle] = getTitles(listLocale);
	const mergedSelectionsIcon = selectionsIcon ?? contextSelectionsIcon;
	{
		const warning$3 = devUseWarning("Transfer");
		warning$3(!pagination || !children, "usage", "`pagination` not support customize render list.");
		[
			["listStyle", "styles.section"],
			["operationStyle", "styles.actions"],
			["operations", "actions"]
		].forEach(([deprecatedName, newName]) => {
			warning$3.deprecated(!(deprecatedName in props), deprecatedName, newName);
		});
	}
	return /* @__PURE__ */ import_react.createElement("div", {
		className: cls,
		style: {
			...contextStyle,
			...mergedStyles.root,
			...style$1
		}
	}, /* @__PURE__ */ import_react.createElement(Section_default, {
		prefixCls,
		style: handleListStyle("left"),
		classNames: mergedClassNames,
		styles: mergedStyles,
		titleText: leftTitle,
		dataSource: leftDataSource,
		filterOption: filterOption$1,
		checkedKeys: sourceSelectedKeys,
		handleFilter: leftFilter,
		handleClear: handleLeftClear,
		onItemSelect: onLeftItemSelect,
		onItemSelectAll: onLeftItemSelectAll,
		render: render$1,
		showSearch,
		renderList: children,
		footer,
		onScroll: handleLeftScroll,
		disabled: mergedDisabled,
		direction: dir === "rtl" ? "right" : "left",
		showSelectAll,
		selectAllLabel: selectAllLabels[0],
		pagination: mergedPagination,
		selectionsIcon: mergedSelectionsIcon,
		...listLocale
	}), /* @__PURE__ */ import_react.createElement(Actions_default, {
		className: clsx(`${prefixCls}-actions`, mergedClassNames.actions),
		rightActive,
		moveToRight,
		leftActive,
		actions: mergedActions,
		moveToLeft,
		style: {
			...operationStyle,
			...mergedStyles.actions
		},
		disabled: mergedDisabled,
		direction: dir,
		oneWay
	}), /* @__PURE__ */ import_react.createElement(Section_default, {
		prefixCls,
		style: handleListStyle("right"),
		classNames: mergedClassNames,
		styles: mergedStyles,
		titleText: rightTitle,
		dataSource: rightDataSource,
		filterOption: filterOption$1,
		checkedKeys: targetSelectedKeys,
		handleFilter: rightFilter,
		handleClear: handleRightClear,
		onItemSelect: onRightItemSelect,
		onItemSelectAll: onRightItemSelectAll,
		onItemRemove: onRightItemRemove,
		render: render$1,
		showSearch,
		renderList: children,
		footer,
		onScroll: handleRightScroll,
		disabled: mergedDisabled,
		direction: dir === "rtl" ? "left" : "right",
		showSelectAll,
		selectAllLabel: selectAllLabels[1],
		showRemove: oneWay,
		pagination: mergedPagination,
		selectionsIcon: mergedSelectionsIcon,
		...listLocale
	}));
};
Transfer.displayName = "Transfer";
Transfer.List = Section_default;
Transfer.Search = search_default;
Transfer.Operation = Actions_default;
var transfer_default = Transfer;

//#endregion
//#region node_modules/@rc-component/tree-select/es/hooks/useCache.js
/**
* This function will try to call requestIdleCallback if available to save performance.
* No need `getLabel` here since already fetch on `rawLabeledValue`.
*/
var useCache_default = ((values) => {
	const cacheRef = import_react.useRef({ valueLabels: /* @__PURE__ */ new Map() });
	return import_react.useMemo(() => {
		const { valueLabels } = cacheRef.current;
		const valueLabelsCache = /* @__PURE__ */ new Map();
		const filledValues = values.map((item) => {
			const { value, label } = item;
			const mergedLabel = label ?? valueLabels.get(value);
			valueLabelsCache.set(value, mergedLabel);
			return {
				...item,
				label: mergedLabel
			};
		});
		cacheRef.current.valueLabels = valueLabelsCache;
		return [filledValues];
	}, [values]);
});

//#endregion
//#region node_modules/@rc-component/tree-select/es/hooks/useCheckedKeys.js
var useCheckedKeys = (rawLabeledValues, rawHalfCheckedValues, treeConduction, keyEntities) => {
	return import_react.useMemo(() => {
		const extractValues = (values) => values.map(({ value }) => value);
		const checkedKeys = extractValues(rawLabeledValues);
		const halfCheckedKeys = extractValues(rawHalfCheckedValues);
		const missingValues = checkedKeys.filter((key) => !keyEntities[key]);
		let finalCheckedKeys = checkedKeys;
		let finalHalfCheckedKeys = halfCheckedKeys;
		if (treeConduction) {
			const conductResult = conductCheck(checkedKeys, true, keyEntities);
			finalCheckedKeys = conductResult.checkedKeys;
			finalHalfCheckedKeys = conductResult.halfCheckedKeys;
		}
		return [Array.from(new Set([...missingValues, ...finalCheckedKeys])), finalHalfCheckedKeys];
	}, [
		rawLabeledValues,
		rawHalfCheckedValues,
		treeConduction,
		keyEntities
	]);
};
var useCheckedKeys_default = useCheckedKeys;

//#endregion
//#region node_modules/@rc-component/tree-select/es/utils/valueUtil.js
const toArray$1 = (value) => Array.isArray(value) ? value : value !== void 0 ? [value] : [];
const fillFieldNames = (fieldNames) => {
	const { label, value, children } = fieldNames || {};
	return {
		_title: label ? [label] : ["title", "label"],
		value: value || "value",
		key: value || "value",
		children: children || "children"
	};
};
const isCheckDisabled = (node$1) => !node$1 || node$1.disabled || node$1.disableCheckbox || node$1.checkable === false;
const getAllKeys = (treeData, fieldNames) => {
	const keys$1 = [];
	const dig = (list) => {
		list.forEach((item) => {
			const children = item[fieldNames.children];
			if (children) {
				keys$1.push(item[fieldNames.value]);
				dig(children);
			}
		});
	};
	dig(treeData);
	return keys$1;
};
const isNil = (val) => val === null || val === void 0;

//#endregion
//#region node_modules/@rc-component/tree-select/es/hooks/useDataEntities.js
var useDataEntities_default = ((treeData, fieldNames) => import_react.useMemo(() => {
	return convertDataToEntities(treeData, {
		fieldNames,
		initWrapper: (wrapper) => ({
			...wrapper,
			valueEntities: /* @__PURE__ */ new Map()
		}),
		processEntity: (entity, wrapper) => {
			const val = entity.node[fieldNames.value];
			{
				const key = entity.node.key;
				warning_default$1(!isNil(val), "TreeNode `value` is invalidate: undefined");
				warning_default$1(!wrapper.valueEntities.has(val), `Same \`value\` exist in the tree: ${val}`);
				warning_default$1(!key || String(key) === String(val), `\`key\` or \`value\` with TreeNode must be the same or you can remove one of them. key: ${key}, value: ${val}.`);
			}
			wrapper.valueEntities.set(val, entity);
		}
	});
}, [treeData, fieldNames]));

//#endregion
//#region node_modules/@rc-component/tree-select/es/TreeNode.js
/* istanbul ignore file */
/** This is a placeholder, not real render in dom */
var TreeNode = () => null;
var TreeNode_default = TreeNode;

//#endregion
//#region node_modules/@rc-component/tree-select/es/utils/legacyUtil.js
function convertChildrenToData(nodes) {
	return toArray(nodes).map((node$1) => {
		if (!/* @__PURE__ */ import_react.isValidElement(node$1) || !node$1.type) return null;
		const { key, props: { children, value, ...restProps } } = node$1;
		const data = {
			key,
			value,
			...restProps
		};
		const childData = convertChildrenToData(children);
		if (childData.length) data.children = childData;
		return data;
	}).filter((data) => data);
}
function fillLegacyProps(dataNode) {
	if (!dataNode) return dataNode;
	const cloneNode = { ...dataNode };
	if (!("props" in cloneNode)) Object.defineProperty(cloneNode, "props", { get() {
		warning_default$1(false, "New `rc-tree-select` not support return node instance as argument anymore. Please consider to remove `props` access.");
		return cloneNode;
	} });
	return cloneNode;
}
function fillAdditionalInfo(extra, triggerValue, checkedValues, treeData, showPosition, fieldNames) {
	let triggerNode = null;
	let nodeList = null;
	function generateMap() {
		function dig(list, level = "0", parentIncluded = false) {
			return list.map((option, index$1) => {
				const pos = `${level}-${index$1}`;
				const value = option[fieldNames.value];
				const included = checkedValues.includes(value);
				const children = dig(option[fieldNames.children] || [], pos, included);
				const node$1 = /* @__PURE__ */ import_react.createElement(TreeNode_default, option, children.map((child) => child.node));
				if (triggerValue === value) triggerNode = node$1;
				if (included) {
					const checkedNode = {
						pos,
						node: node$1,
						children
					};
					if (!parentIncluded) nodeList.push(checkedNode);
					return checkedNode;
				}
				return null;
			}).filter((node$1) => node$1);
		}
		if (!nodeList) {
			nodeList = [];
			dig(treeData);
			nodeList.sort(({ node: { props: { value: val1 } } }, { node: { props: { value: val2 } } }) => {
				return checkedValues.indexOf(val1) - checkedValues.indexOf(val2);
			});
		}
	}
	Object.defineProperty(extra, "triggerNode", { get() {
		warning_default$1(false, "`triggerNode` is deprecated. Please consider decoupling data with node.");
		generateMap();
		return triggerNode;
	} });
	Object.defineProperty(extra, "allCheckedNodes", { get() {
		warning_default$1(false, "`allCheckedNodes` is deprecated. Please consider decoupling data with node.");
		generateMap();
		if (showPosition) return nodeList;
		return nodeList.map(({ node: node$1 }) => node$1);
	} });
}

//#endregion
//#region node_modules/@rc-component/tree-select/es/hooks/useFilterTreeData.js
var useFilterTreeData = (treeData, searchValue, options) => {
	const { fieldNames, treeNodeFilterProp, filterTreeNode } = options;
	const { children: fieldChildren } = fieldNames;
	return import_react.useMemo(() => {
		if (!searchValue || filterTreeNode === false) return treeData;
		const filterOptionFunc = typeof filterTreeNode === "function" ? filterTreeNode : (_, dataNode) => String(dataNode[treeNodeFilterProp]).toUpperCase().includes(searchValue.toUpperCase());
		const filterTreeNodes = (nodes, keepAll = false) => nodes.reduce((filtered, node$1) => {
			const children = node$1[fieldChildren];
			const isMatch = keepAll || filterOptionFunc(searchValue, fillLegacyProps(node$1));
			const filteredChildren = filterTreeNodes(children || [], isMatch);
			if (isMatch || filteredChildren.length) filtered.push({
				...node$1,
				isLeaf: void 0,
				[fieldChildren]: filteredChildren
			});
			return filtered;
		}, []);
		return filterTreeNodes(treeData);
	}, [
		treeData,
		searchValue,
		fieldChildren,
		treeNodeFilterProp,
		filterTreeNode
	]);
};
var useFilterTreeData_default = useFilterTreeData;

//#endregion
//#region node_modules/@rc-component/tree-select/es/hooks/useRefFunc.js
/**
* Same as `React.useCallback` but always return a memoized function
* but redirect to real function.
*/
function useRefFunc(callback) {
	const funcRef = import_react.useRef();
	funcRef.current = callback;
	return import_react.useCallback((...args) => {
		return funcRef.current(...args);
	}, []);
}

//#endregion
//#region node_modules/@rc-component/tree-select/es/hooks/useTreeData.js
function buildTreeStructure(nodes, config) {
	const { id, pId, rootPId } = config;
	const nodeMap = /* @__PURE__ */ new Map();
	const rootNodes = [];
	nodes.forEach((node$1) => {
		const nodeKey = node$1[id];
		const clonedNode = {
			...node$1,
			key: node$1.key || nodeKey
		};
		nodeMap.set(nodeKey, clonedNode);
	});
	nodeMap.forEach((node$1) => {
		const parentKey = node$1[pId];
		const parent = nodeMap.get(parentKey);
		if (parent) {
			parent.children = parent.children || [];
			parent.children.push(node$1);
		} else if (parentKey === rootPId || rootPId === null) rootNodes.push(node$1);
	});
	return rootNodes;
}
/**
*  `treeData`  `children`  `treeData`
*  `treeData`  `children` 
*/
function useTreeData(treeData, children, simpleMode) {
	return import_react.useMemo(() => {
		if (treeData) {
			if (simpleMode) return buildTreeStructure(treeData, {
				id: "id",
				pId: "pId",
				rootPId: null,
				...typeof simpleMode === "object" ? simpleMode : {}
			});
			return treeData;
		}
		return convertChildrenToData(children);
	}, [
		children,
		simpleMode,
		treeData
	]);
}

//#endregion
//#region node_modules/@rc-component/tree-select/es/LegacyContext.js
var LegacySelectContext = /* @__PURE__ */ import_react.createContext(null);
var LegacyContext_default = LegacySelectContext;

//#endregion
//#region node_modules/@rc-component/tree-select/es/TreeSelectContext.js
var TreeSelectContext = /* @__PURE__ */ import_react.createContext(null);
var TreeSelectContext_default = TreeSelectContext;

//#endregion
//#region node_modules/@rc-component/tree-select/es/OptionList.js
function _extends$3() {
	_extends$3 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$3.apply(this, arguments);
}
var HIDDEN_STYLE = {
	width: 0,
	height: 0,
	display: "flex",
	overflow: "hidden",
	opacity: 0,
	border: 0,
	padding: 0,
	margin: 0
};
var OptionList = (_, ref) => {
	const { prefixCls, multiple, searchValue, toggleOpen, open: open$2, notFoundContent } = useBaseProps();
	const { virtual, listHeight, listItemHeight, listItemScrollOffset, treeData, fieldNames, onSelect, popupMatchSelectWidth, treeExpandAction, treeTitleRender, onPopupScroll, leftMaxCount, leafCountOnly, valueEntities, classNames: treeClassNames, styles } = import_react.useContext(TreeSelectContext_default);
	const { checkable, checkedKeys, halfCheckedKeys, treeExpandedKeys, treeDefaultExpandAll, treeDefaultExpandedKeys, onTreeExpand, treeIcon, showTreeIcon, switcherIcon, treeLine, treeNodeFilterProp, loadData, treeLoadedKeys, treeMotion, onTreeLoad, keyEntities } = import_react.useContext(LegacyContext_default);
	const treeRef = import_react.useRef();
	const memoTreeData = useMemo$1(() => treeData, [open$2, treeData], (prev$1, next$1) => next$1[0] && prev$1[1] !== next$1[1]);
	const mergedCheckedKeys = import_react.useMemo(() => {
		if (!checkable) return null;
		return {
			checked: checkedKeys,
			halfChecked: halfCheckedKeys
		};
	}, [
		checkable,
		checkedKeys,
		halfCheckedKeys
	]);
	import_react.useEffect(() => {
		if (open$2 && !multiple && checkedKeys.length) treeRef.current?.scrollTo({ key: checkedKeys[0] });
	}, [open$2]);
	const onListMouseDown = (event) => {
		event.preventDefault();
	};
	const onInternalSelect = (__, info) => {
		const { node: node$1 } = info;
		if (checkable && isCheckDisabled(node$1)) return;
		onSelect(node$1.key, { selected: !checkedKeys.includes(node$1.key) });
		if (!multiple) toggleOpen(false);
	};
	const [expandedKeys, setExpandedKeys] = import_react.useState(treeDefaultExpandedKeys);
	const [searchExpandedKeys, setSearchExpandedKeys] = import_react.useState(null);
	const mergedExpandedKeys = import_react.useMemo(() => {
		if (treeExpandedKeys) return [...treeExpandedKeys];
		return searchValue ? searchExpandedKeys : expandedKeys;
	}, [
		expandedKeys,
		searchExpandedKeys,
		treeExpandedKeys,
		searchValue
	]);
	const onInternalExpand = (keys$1) => {
		setExpandedKeys(keys$1);
		setSearchExpandedKeys(keys$1);
		if (onTreeExpand) onTreeExpand(keys$1);
	};
	const lowerSearchValue = String(searchValue).toLowerCase();
	const filterTreeNode = (treeNode) => {
		if (!lowerSearchValue) return false;
		return String(treeNode[treeNodeFilterProp]).toLowerCase().includes(lowerSearchValue);
	};
	import_react.useEffect(() => {
		if (searchValue) setSearchExpandedKeys(getAllKeys(treeData, fieldNames));
	}, [searchValue]);
	const [disabledCache, setDisabledCache] = import_react.useState(() => /* @__PURE__ */ new Map());
	import_react.useEffect(() => {
		if (leftMaxCount) setDisabledCache(/* @__PURE__ */ new Map());
	}, [leftMaxCount]);
	function getDisabledWithCache(node$1) {
		const value = node$1[fieldNames.value];
		if (!disabledCache.has(value)) {
			const entity = valueEntities.get(value);
			if (!((entity.children || []).length === 0)) {
				const checkableChildrenCount = entity.children.filter((childTreeNode) => !childTreeNode.node.disabled && !childTreeNode.node.disableCheckbox && !checkedKeys.includes(childTreeNode.node[fieldNames.value])).length;
				disabledCache.set(value, checkableChildrenCount > leftMaxCount);
			} else disabledCache.set(value, false);
		}
		return disabledCache.get(value);
	}
	const nodeDisabled = useEvent_default((node$1) => {
		const nodeValue = node$1[fieldNames.value];
		if (checkedKeys.includes(nodeValue)) return false;
		if (leftMaxCount === null) return false;
		if (leftMaxCount <= 0) return true;
		if (leafCountOnly && leftMaxCount) return getDisabledWithCache(node$1);
		return false;
	});
	const getFirstMatchingNode = (nodes) => {
		for (const node$1 of nodes) {
			if (node$1.disabled || node$1.selectable === false) continue;
			if (searchValue) {
				if (filterTreeNode(node$1)) return node$1;
			} else return node$1;
			if (node$1[fieldNames.children]) {
				const matchInChildren = getFirstMatchingNode(node$1[fieldNames.children]);
				if (matchInChildren) return matchInChildren;
			}
		}
		return null;
	};
	const [activeKey, setActiveKey] = import_react.useState(null);
	const activeEntity = keyEntities[activeKey];
	import_react.useEffect(() => {
		if (!open$2) return;
		let nextActiveKey = null;
		const getFirstNode = () => {
			const firstNode = getFirstMatchingNode(memoTreeData);
			return firstNode ? firstNode[fieldNames.value] : null;
		};
		if (!multiple && checkedKeys.length && !searchValue) nextActiveKey = checkedKeys[0];
		else nextActiveKey = getFirstNode();
		setActiveKey(nextActiveKey);
	}, [open$2, searchValue]);
	import_react.useImperativeHandle(ref, () => ({
		scrollTo: treeRef.current?.scrollTo,
		onKeyDown: (event) => {
			const { which } = event;
			switch (which) {
				case KeyCode_default.UP:
				case KeyCode_default.DOWN:
				case KeyCode_default.LEFT:
				case KeyCode_default.RIGHT:
					treeRef.current?.onKeyDown(event);
					break;
				case KeyCode_default.ENTER:
					if (activeEntity) {
						const isNodeDisabled = nodeDisabled(activeEntity.node);
						const { selectable, value, disabled } = activeEntity?.node || {};
						if (selectable !== false && !disabled && !isNodeDisabled) onInternalSelect(null, {
							node: { key: activeKey },
							selected: !checkedKeys.includes(value)
						});
					}
					break;
				case KeyCode_default.ESC: toggleOpen(false);
			}
		},
		onKeyUp: () => {}
	}));
	const syncLoadData = useMemo$1(() => searchValue ? false : true, [searchValue, treeExpandedKeys || expandedKeys], ([preSearchValue], [nextSearchValue, nextExcludeSearchExpandedKeys]) => preSearchValue !== nextSearchValue && !!(nextSearchValue || nextExcludeSearchExpandedKeys)) ? loadData : null;
	if (memoTreeData.length === 0) return /* @__PURE__ */ import_react.createElement("div", {
		role: "listbox",
		className: `${prefixCls}-empty`,
		onMouseDown: onListMouseDown
	}, notFoundContent);
	const treeProps = { fieldNames };
	if (treeLoadedKeys) treeProps.loadedKeys = treeLoadedKeys;
	if (mergedExpandedKeys) treeProps.expandedKeys = mergedExpandedKeys;
	return /* @__PURE__ */ import_react.createElement("div", { onMouseDown: onListMouseDown }, activeEntity && open$2 && /* @__PURE__ */ import_react.createElement("span", {
		style: HIDDEN_STYLE,
		"aria-live": "assertive"
	}, activeEntity.node.value), /* @__PURE__ */ import_react.createElement(UnstableContext.Provider, { value: { nodeDisabled } }, /* @__PURE__ */ import_react.createElement(es_default$4, _extends$3({
		classNames: treeClassNames?.popup,
		styles: styles?.popup,
		ref: treeRef,
		focusable: false,
		prefixCls: `${prefixCls}-tree`,
		treeData: memoTreeData,
		height: listHeight,
		itemHeight: listItemHeight,
		itemScrollOffset: listItemScrollOffset,
		virtual: virtual !== false && popupMatchSelectWidth !== false,
		multiple,
		icon: treeIcon,
		showIcon: showTreeIcon,
		switcherIcon,
		showLine: treeLine,
		loadData: syncLoadData,
		motion: treeMotion,
		activeKey,
		checkable,
		checkStrictly: true,
		checkedKeys: mergedCheckedKeys,
		selectedKeys: !checkable ? checkedKeys : [],
		defaultExpandAll: treeDefaultExpandAll,
		titleRender: treeTitleRender
	}, treeProps, {
		onActiveChange: setActiveKey,
		onSelect: onInternalSelect,
		onCheck: onInternalSelect,
		onExpand: onInternalExpand,
		onLoad: onTreeLoad,
		filterTreeNode,
		expandAction: treeExpandAction,
		onScroll: onPopupScroll
	}))));
};
var RefOptionList = /* @__PURE__ */ import_react.forwardRef(OptionList);
RefOptionList.displayName = "OptionList";
var OptionList_default = RefOptionList;

//#endregion
//#region node_modules/@rc-component/tree-select/es/utils/strategyUtil.js
const SHOW_ALL = "SHOW_ALL";
const SHOW_PARENT = "SHOW_PARENT";
const SHOW_CHILD = "SHOW_CHILD";
function formatStrategyValues(values, strategy, keyEntities, fieldNames) {
	const valueSet = new Set(values);
	if (strategy === SHOW_CHILD) return values.filter((key) => {
		const entity = keyEntities[key];
		return !entity || !entity.children || !entity.children.some(({ node: node$1 }) => valueSet.has(node$1[fieldNames.value])) || !entity.children.every(({ node: node$1 }) => isCheckDisabled(node$1) || valueSet.has(node$1[fieldNames.value]));
	});
	if (strategy === SHOW_PARENT) return values.filter((key) => {
		const entity = keyEntities[key];
		const parent = entity ? entity.parent : null;
		return !parent || isCheckDisabled(parent.node) || !valueSet.has(parent.key);
	});
	return values;
}

//#endregion
//#region node_modules/@rc-component/tree-select/es/utils/warningPropsUtil.js
function warningProps(props) {
	const { searchPlaceholder, treeCheckStrictly, treeCheckable, labelInValue, value, multiple, showCheckedStrategy, maxCount } = props;
	warning_default$1(!searchPlaceholder, "`searchPlaceholder` has been removed.");
	if (treeCheckStrictly && labelInValue === false) warning_default$1(false, "`treeCheckStrictly` will force set `labelInValue` to `true`.");
	if (labelInValue || treeCheckStrictly) warning_default$1(toArray$1(value).every((val) => val && typeof val === "object" && "value" in val), "Invalid prop `value` supplied to `TreeSelect`. You should use { label: string, value: string | number } or [{ label: string, value: string | number }] instead.");
	if (treeCheckStrictly || multiple || treeCheckable) warning_default$1(!value || Array.isArray(value), "`value` should be an array when `TreeSelect` is checkable or multiple.");
	else warning_default$1(!Array.isArray(value), "`value` should not be array when `TreeSelect` is single mode.");
	if (maxCount && (showCheckedStrategy === "SHOW_ALL" && !treeCheckStrictly || showCheckedStrategy === "SHOW_PARENT")) warning_default$1(false, "`maxCount` not work with `showCheckedStrategy=SHOW_ALL` (when `treeCheckStrictly=false`) or `showCheckedStrategy=SHOW_PARENT`.");
}
var warningPropsUtil_default = warningProps;

//#endregion
//#region node_modules/@rc-component/tree-select/es/hooks/useSearchConfig.js
function useSearchConfig(showSearch, props) {
	const { searchValue, inputValue, onSearch, autoClearSearchValue, filterTreeNode, treeNodeFilterProp } = props;
	return import_react.useMemo(() => {
		const isObject$1 = typeof showSearch === "object";
		const searchConfig = {
			searchValue: searchValue ?? inputValue,
			onSearch,
			autoClearSearchValue,
			filterTreeNode,
			treeNodeFilterProp,
			...isObject$1 ? showSearch : {}
		};
		return [isObject$1 ? true : showSearch, searchConfig];
	}, [
		showSearch,
		searchValue,
		inputValue,
		onSearch,
		autoClearSearchValue,
		filterTreeNode,
		treeNodeFilterProp
	]);
}

//#endregion
//#region node_modules/@rc-component/tree-select/es/TreeSelect.js
function _extends$2() {
	_extends$2 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$2.apply(this, arguments);
}
function isRawValue(value) {
	return !value || typeof value !== "object";
}
var TreeSelect$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { id, prefixCls = "rc-tree-select", value, defaultValue, onChange, onSelect, onDeselect, showSearch, searchValue: legacySearchValue, inputValue: legacyinputValue, onSearch: legacyOnSearch, autoClearSearchValue: legacyAutoClearSearchValue, filterTreeNode: legacyFilterTreeNode, treeNodeFilterProp: legacytreeNodeFilterProp, showCheckedStrategy, treeNodeLabelProp, multiple, treeCheckable, treeCheckStrictly, labelInValue, maxCount, fieldNames, treeDataSimpleMode, treeData, children, loadData, treeLoadedKeys, onTreeLoad, treeDefaultExpandAll, treeExpandedKeys, treeDefaultExpandedKeys, onTreeExpand, treeExpandAction, virtual, listHeight = 200, listItemHeight = 20, listItemScrollOffset = 0, onPopupVisibleChange, popupMatchSelectWidth = true, treeLine, treeIcon, showTreeIcon, switcherIcon, treeMotion, treeTitleRender, onPopupScroll, classNames: treeSelectClassNames, styles, ...restProps } = props;
	const mergedId = useId_default(id);
	const treeConduction = treeCheckable && !treeCheckStrictly;
	const mergedCheckable = treeCheckable || treeCheckStrictly;
	const mergedLabelInValue = treeCheckStrictly || labelInValue;
	const mergedMultiple = mergedCheckable || multiple;
	const [mergedShowSearch, searchConfig] = useSearchConfig(showSearch, {
		searchValue: legacySearchValue,
		inputValue: legacyinputValue,
		onSearch: legacyOnSearch,
		autoClearSearchValue: legacyAutoClearSearchValue,
		filterTreeNode: legacyFilterTreeNode,
		treeNodeFilterProp: legacytreeNodeFilterProp
	});
	const { searchValue, onSearch, autoClearSearchValue = true, filterTreeNode, treeNodeFilterProp = "value" } = searchConfig;
	const [internalValue, setInternalValue] = useControlledState(defaultValue, value);
	const mergedShowCheckedStrategy = import_react.useMemo(() => {
		if (!treeCheckable) return SHOW_ALL;
		return showCheckedStrategy || SHOW_CHILD;
	}, [showCheckedStrategy, treeCheckable]);
	warningPropsUtil_default(props);
	const mergedFieldNames = import_react.useMemo(() => fillFieldNames(fieldNames), [JSON.stringify(fieldNames)]);
	const [internalSearchValue, setSearchValue] = useControlledState("", searchValue);
	const mergedSearchValue = internalSearchValue || "";
	const onInternalSearch = (searchText) => {
		setSearchValue(searchText);
		onSearch?.(searchText);
	};
	const mergedTreeData = useTreeData(treeData, children, treeDataSimpleMode);
	const { keyEntities, valueEntities } = useDataEntities_default(mergedTreeData, mergedFieldNames);
	/** Get `missingRawValues` which not exist in the tree yet */
	const splitRawValues = import_react.useCallback((newRawValues) => {
		const missingRawValues = [];
		const existRawValues = [];
		newRawValues.forEach((val) => {
			if (valueEntities.has(val)) existRawValues.push(val);
			else missingRawValues.push(val);
		});
		return {
			missingRawValues,
			existRawValues
		};
	}, [valueEntities]);
	const filteredTreeData = useFilterTreeData_default(mergedTreeData, mergedSearchValue, {
		fieldNames: mergedFieldNames,
		treeNodeFilterProp,
		filterTreeNode
	});
	const getLabel = import_react.useCallback((item) => {
		if (item) {
			if (treeNodeLabelProp) return item[treeNodeLabelProp];
			const { _title: titleList } = mergedFieldNames;
			for (let i = 0; i < titleList.length; i += 1) {
				const title = item[titleList[i]];
				if (title !== void 0) return title;
			}
		}
	}, [mergedFieldNames, treeNodeLabelProp]);
	const toLabeledValues = import_react.useCallback((draftValues) => {
		return toArray$1(draftValues).map((val) => {
			if (isRawValue(val)) return { value: val };
			return val;
		});
	}, []);
	const convert2LabelValues = import_react.useCallback((draftValues) => {
		return toLabeledValues(draftValues).map((item) => {
			let { label: rawLabel } = item;
			const { value: rawValue, halfChecked: rawHalfChecked } = item;
			let rawDisabled;
			const entity = valueEntities.get(rawValue);
			if (entity) {
				rawLabel = treeTitleRender ? treeTitleRender(entity.node) : rawLabel ?? getLabel(entity.node);
				rawDisabled = entity.node.disabled;
			} else if (rawLabel === void 0) rawLabel = toLabeledValues(internalValue).find((labeledItem) => labeledItem.value === rawValue).label;
			return {
				label: rawLabel,
				value: rawValue,
				halfChecked: rawHalfChecked,
				disabled: rawDisabled
			};
		});
	}, [
		valueEntities,
		getLabel,
		toLabeledValues,
		internalValue
	]);
	const rawMixedLabeledValues = import_react.useMemo(() => toLabeledValues(internalValue === null ? [] : internalValue), [toLabeledValues, internalValue]);
	const [rawLabeledValues, rawHalfLabeledValues] = import_react.useMemo(() => {
		const fullCheckValues = [];
		const halfCheckValues = [];
		rawMixedLabeledValues.forEach((item) => {
			if (item.halfChecked) halfCheckValues.push(item);
			else fullCheckValues.push(item);
		});
		return [fullCheckValues, halfCheckValues];
	}, [rawMixedLabeledValues]);
	const rawValues = import_react.useMemo(() => rawLabeledValues.map((item) => item.value), [rawLabeledValues]);
	const [rawCheckedValues, rawHalfCheckedValues] = useCheckedKeys_default(rawLabeledValues, rawHalfLabeledValues, treeConduction, keyEntities);
	const [cachedDisplayValues] = useCache_default(import_react.useMemo(() => {
		const rawDisplayValues = convert2LabelValues(formatStrategyValues(rawCheckedValues, mergedShowCheckedStrategy, keyEntities, mergedFieldNames).map((key) => keyEntities[key]?.node?.[mergedFieldNames.value] ?? key).map((val) => {
			const targetItem = rawLabeledValues.find((item) => item.value === val);
			return {
				value: val,
				label: labelInValue ? targetItem?.label : treeTitleRender?.(targetItem)
			};
		}));
		const firstVal = rawDisplayValues[0];
		if (!mergedMultiple && firstVal && isNil(firstVal.value) && isNil(firstVal.label)) return [];
		return rawDisplayValues.map((item) => ({
			...item,
			label: item.label ?? item.value
		}));
	}, [
		mergedFieldNames,
		mergedMultiple,
		rawCheckedValues,
		rawLabeledValues,
		convert2LabelValues,
		mergedShowCheckedStrategy,
		keyEntities
	]));
	const mergedMaxCount = import_react.useMemo(() => {
		if (mergedMultiple && (mergedShowCheckedStrategy === "SHOW_CHILD" || treeCheckStrictly || !treeCheckable)) return maxCount;
		return null;
	}, [
		maxCount,
		mergedMultiple,
		treeCheckStrictly,
		mergedShowCheckedStrategy,
		treeCheckable
	]);
	const triggerChange = useRefFunc((newRawValues, extra, source) => {
		const formattedKeyList = formatStrategyValues(newRawValues, mergedShowCheckedStrategy, keyEntities, mergedFieldNames);
		if (mergedMaxCount && formattedKeyList.length > mergedMaxCount) return;
		setInternalValue(convert2LabelValues(newRawValues));
		if (autoClearSearchValue) setSearchValue("");
		if (onChange) {
			let eventValues = newRawValues;
			if (treeConduction) eventValues = formattedKeyList.map((key) => {
				const entity = valueEntities.get(key);
				return entity ? entity.node[mergedFieldNames.value] : key;
			});
			const { triggerValue, selected } = extra || {
				triggerValue: void 0,
				selected: void 0
			};
			let returnRawValues = eventValues;
			if (treeCheckStrictly) {
				const halfValues = rawHalfLabeledValues.filter((item) => !eventValues.includes(item.value));
				returnRawValues = [...returnRawValues, ...halfValues];
			}
			const returnLabeledValues = convert2LabelValues(returnRawValues);
			const additionalInfo = {
				preValue: rawLabeledValues,
				triggerValue
			};
			let showPosition = true;
			if (treeCheckStrictly || source === "selection" && !selected) showPosition = false;
			fillAdditionalInfo(additionalInfo, triggerValue, newRawValues, mergedTreeData, showPosition, mergedFieldNames);
			if (mergedCheckable) additionalInfo.checked = selected;
			else additionalInfo.selected = selected;
			const returnValues = mergedLabelInValue ? returnLabeledValues : returnLabeledValues.map((item) => item.value);
			onChange(mergedMultiple ? returnValues : returnValues[0], mergedLabelInValue ? null : returnLabeledValues.map((item) => item.label), additionalInfo);
		}
	});
	/** Trigger by option list */
	const onOptionSelect = import_react.useCallback((selectedKey, { selected, source }) => {
		const node$1 = keyEntities[selectedKey]?.node;
		const selectedValue = node$1?.[mergedFieldNames.value] ?? selectedKey;
		if (!mergedMultiple) triggerChange([selectedValue], {
			selected: true,
			triggerValue: selectedValue
		}, "option");
		else {
			let newRawValues = selected ? [...rawValues, selectedValue] : rawCheckedValues.filter((v) => v !== selectedValue);
			if (treeConduction) {
				const { missingRawValues, existRawValues } = splitRawValues(newRawValues);
				const keyList = existRawValues.map((val) => valueEntities.get(val).key);
				let checkedKeys;
				if (selected) ({checkedKeys} = conductCheck(keyList, true, keyEntities));
				else ({checkedKeys} = conductCheck(keyList, {
					checked: false,
					halfCheckedKeys: rawHalfCheckedValues
				}, keyEntities));
				newRawValues = [...missingRawValues, ...checkedKeys.map((key) => keyEntities[key].node[mergedFieldNames.value])];
			}
			triggerChange(newRawValues, {
				selected,
				triggerValue: selectedValue
			}, source || "option");
		}
		if (selected || !mergedMultiple) onSelect?.(selectedValue, fillLegacyProps(node$1));
		else onDeselect?.(selectedValue, fillLegacyProps(node$1));
	}, [
		splitRawValues,
		valueEntities,
		keyEntities,
		mergedFieldNames,
		mergedMultiple,
		rawValues,
		triggerChange,
		treeConduction,
		onSelect,
		onDeselect,
		rawCheckedValues,
		rawHalfCheckedValues,
		maxCount
	]);
	const onInternalPopupVisibleChange = import_react.useCallback((open$2) => {
		if (onPopupVisibleChange) onPopupVisibleChange(open$2);
	}, [onPopupVisibleChange]);
	const onDisplayValuesChange = useRefFunc((newValues, info) => {
		const newRawValues = newValues.map((item) => item.value);
		if (info.type === "clear") {
			triggerChange(newRawValues, {}, "selection");
			return;
		}
		if (info.values.length) onOptionSelect(info.values[0].value, {
			selected: false,
			source: "selection"
		});
	});
	const treeSelectContext = import_react.useMemo(() => {
		return {
			virtual,
			popupMatchSelectWidth,
			listHeight,
			listItemHeight,
			listItemScrollOffset,
			treeData: filteredTreeData,
			fieldNames: mergedFieldNames,
			onSelect: onOptionSelect,
			treeExpandAction,
			treeTitleRender,
			onPopupScroll,
			leftMaxCount: maxCount === void 0 ? null : maxCount - cachedDisplayValues.length,
			leafCountOnly: mergedShowCheckedStrategy === "SHOW_CHILD" && !treeCheckStrictly && !!treeCheckable,
			valueEntities,
			classNames: treeSelectClassNames,
			styles
		};
	}, [
		virtual,
		popupMatchSelectWidth,
		listHeight,
		listItemHeight,
		listItemScrollOffset,
		filteredTreeData,
		mergedFieldNames,
		onOptionSelect,
		treeExpandAction,
		treeTitleRender,
		onPopupScroll,
		maxCount,
		cachedDisplayValues.length,
		mergedShowCheckedStrategy,
		treeCheckStrictly,
		treeCheckable,
		valueEntities,
		treeSelectClassNames,
		styles
	]);
	const legacyContext = import_react.useMemo(() => ({
		checkable: mergedCheckable,
		loadData,
		treeLoadedKeys,
		onTreeLoad,
		checkedKeys: rawCheckedValues,
		halfCheckedKeys: rawHalfCheckedValues,
		treeDefaultExpandAll,
		treeExpandedKeys,
		treeDefaultExpandedKeys,
		onTreeExpand,
		treeIcon,
		treeMotion,
		showTreeIcon,
		switcherIcon,
		treeLine,
		treeNodeFilterProp,
		keyEntities
	}), [
		mergedCheckable,
		loadData,
		treeLoadedKeys,
		onTreeLoad,
		rawCheckedValues,
		rawHalfCheckedValues,
		treeDefaultExpandAll,
		treeExpandedKeys,
		treeDefaultExpandedKeys,
		onTreeExpand,
		treeIcon,
		treeMotion,
		showTreeIcon,
		switcherIcon,
		treeLine,
		treeNodeFilterProp,
		keyEntities
	]);
	return /* @__PURE__ */ import_react.createElement(TreeSelectContext_default.Provider, { value: treeSelectContext }, /* @__PURE__ */ import_react.createElement(LegacyContext_default.Provider, { value: legacyContext }, /* @__PURE__ */ import_react.createElement(BaseSelect_default, _extends$2({ ref }, restProps, {
		classNames: treeSelectClassNames,
		styles,
		id: mergedId,
		prefixCls,
		mode: mergedMultiple ? "multiple" : void 0,
		displayValues: cachedDisplayValues,
		onDisplayValuesChange,
		autoClearSearchValue,
		showSearch: mergedShowSearch,
		searchValue: mergedSearchValue,
		onSearch: onInternalSearch,
		OptionList: OptionList_default,
		emptyOptions: !mergedTreeData.length,
		onPopupVisibleChange: onInternalPopupVisibleChange,
		popupMatchSelectWidth
	}))));
});
TreeSelect$1.displayName = "TreeSelect";
var GenericTreeSelect = TreeSelect$1;
GenericTreeSelect.TreeNode = TreeNode_default;
GenericTreeSelect.SHOW_ALL = SHOW_ALL;
GenericTreeSelect.SHOW_PARENT = SHOW_PARENT;
GenericTreeSelect.SHOW_CHILD = SHOW_CHILD;
var TreeSelect_default = GenericTreeSelect;

//#endregion
//#region node_modules/@rc-component/tree-select/es/index.js
var es_default$3 = TreeSelect_default;

//#endregion
//#region node_modules/antd/es/tree-select/style/index.js
var genBaseStyle$1 = (token$1) => {
	const { componentCls, treePrefixCls, colorBgElevated } = token$1;
	const treeCls = `.${treePrefixCls}`;
	return [{ [`${componentCls}-dropdown`]: [
		{ padding: `${unit(token$1.paddingXS)} ${unit(token$1.calc(token$1.paddingXS).div(2).equal())}` },
		genTreeStyle(treePrefixCls, merge(token$1, { colorBgContainer: colorBgElevated }), false),
		{ [treeCls]: {
			borderRadius: 0,
			[`${treeCls}-list-holder-inner`]: {
				alignItems: "stretch",
				[`${treeCls}-treenode`]: { [`${treeCls}-node-content-wrapper`]: { flex: "auto" } }
			}
		} },
		getStyle(`${treePrefixCls}-checkbox`, token$1),
		{ "&-rtl": {
			direction: "rtl",
			[`${treeCls}-switcher${treeCls}-switcher_close`]: { [`${treeCls}-switcher-icon svg`]: { transform: "rotate(90deg)" } }
		} }
	] }];
};
function useTreeSelectStyle(prefixCls, treePrefixCls, rootCls) {
	return genStyleHooks("TreeSelect", (token$1) => {
		return genBaseStyle$1(merge(token$1, { treePrefixCls }));
	}, initComponentToken, { resetFont: false })(prefixCls, rootCls);
}

//#endregion
//#region node_modules/antd/es/tree-select/index.js
var InternalTreeSelect = (props, ref) => {
	const { prefixCls: customizePrefixCls, size: customizeSize, disabled: customDisabled, bordered = true, style: style$1, className, rootClassName, treeCheckable, multiple, listHeight = 256, listItemHeight: customListItemHeight, placement, notFoundContent, switcherIcon: customSwitcherIcon, treeLine, getPopupContainer, popupClassName, dropdownClassName, treeIcon = false, transitionName, choiceTransitionName = "", status: customStatus, treeExpandAction, builtinPlacements, dropdownMatchSelectWidth, popupMatchSelectWidth, allowClear, variant: customVariant, dropdownStyle: _dropdownStyle, dropdownRender, popupRender, onDropdownVisibleChange, onOpenChange, tagRender, maxCount, showCheckedStrategy, treeCheckStrictly, styles, classNames, ...restProps } = props;
	const { getPrefixCls, getPopupContainer: getContextPopupContainer, direction, styles: contextStyles, classNames: contextClassNames, switcherIcon } = useComponentConfig("treeSelect");
	const { renderEmpty, virtual, popupMatchSelectWidth: contextPopupMatchSelectWidth, popupOverflow } = import_react.useContext(ConfigContext);
	const [, token$1] = useToken();
	const listItemHeight = customListItemHeight ?? token$1?.controlHeightSM + token$1?.paddingXXS;
	{
		const warning$3 = devUseWarning("TreeSelect");
		Object.entries({
			dropdownMatchSelectWidth: "popupMatchSelectWidth",
			dropdownStyle: "styles.popup.root",
			dropdownClassName: "classNames.popup.root",
			popupClassName: "classNames.popup.root",
			dropdownRender: "popupRender",
			onDropdownVisibleChange: "onOpenChange",
			bordered: "variant"
		}).forEach(([oldProp, newProp]) => {
			warning$3.deprecated(!(oldProp in props), oldProp, newProp);
		});
		warning$3(multiple !== false || !treeCheckable, "usage", "`multiple` will always be `true` when `treeCheckable` is true");
		warning$3(!("showArrow" in props), "deprecated", "`showArrow` is deprecated which will be removed in next major version. It will be a default behavior, you can hide it by setting `suffixIcon` to null.");
	}
	const rootPrefixCls = getPrefixCls();
	const prefixCls = getPrefixCls("select", customizePrefixCls);
	const treePrefixCls = getPrefixCls("select-tree", customizePrefixCls);
	const treeSelectPrefixCls = getPrefixCls("tree-select", customizePrefixCls);
	const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
	const rootCls = useCSSVarCls_default(prefixCls);
	const treeSelectRootCls = useCSSVarCls_default(treeSelectPrefixCls);
	const [hashId, cssVarCls] = style_default$2(prefixCls, rootCls);
	useTreeSelectStyle(treeSelectPrefixCls, treePrefixCls, treeSelectRootCls);
	const [variant, enableVariantCls] = useVariants_default("treeSelect", customVariant, bordered);
	const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
	const disabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = customDisabled ?? disabled;
	const { status: contextStatus, hasFeedback, isFormItemInput, feedbackIcon } = import_react.useContext(FormItemInputContext);
	const mergedStatus = getMergedStatus(contextStatus, customStatus);
	const mergedProps = {
		...props,
		size: mergedSize,
		disabled: mergedDisabled,
		status: mergedStatus,
		variant
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps }, { popup: { _default: "root" } });
	const mergedPopupClassName = clsx(popupClassName || dropdownClassName, `${treeSelectPrefixCls}-dropdown`, { [`${treeSelectPrefixCls}-dropdown-rtl`]: direction === "rtl" }, rootClassName, mergedClassNames.root, mergedClassNames.popup?.root, cssVarCls, rootCls, treeSelectRootCls, hashId);
	const mergedPopupRender = usePopupRender_default(popupRender || dropdownRender);
	const mergedOnOpenChange = onOpenChange || onDropdownVisibleChange;
	const isMultiple$1 = !!(treeCheckable || multiple);
	const mergedMaxCount = import_react.useMemo(() => {
		if (maxCount && (showCheckedStrategy === "SHOW_ALL" && !treeCheckStrictly || showCheckedStrategy === "SHOW_PARENT")) return;
		return maxCount;
	}, [
		maxCount,
		showCheckedStrategy,
		treeCheckStrictly
	]);
	const showSuffixIcon = useShowArrow(props.suffixIcon, props.showArrow);
	const mergedPopupMatchSelectWidth = popupMatchSelectWidth ?? dropdownMatchSelectWidth ?? contextPopupMatchSelectWidth;
	const { suffixIcon, removeIcon, clearIcon } = useIcons({
		...restProps,
		multiple: isMultiple$1,
		showSuffixIcon,
		hasFeedback,
		feedbackIcon,
		prefixCls,
		componentName: "TreeSelect"
	});
	const mergedAllowClear = allowClear === true ? { clearIcon } : allowClear;
	let mergedNotFound;
	if (notFoundContent !== void 0) mergedNotFound = notFoundContent;
	else mergedNotFound = renderEmpty?.("Select") || /* @__PURE__ */ import_react.createElement(defaultRenderEmpty_default, { componentName: "Select" });
	const selectProps = omit(restProps, [
		"suffixIcon",
		"removeIcon",
		"clearIcon",
		"itemIcon",
		"switcherIcon",
		"style"
	]);
	const memoizedPlacement = import_react.useMemo(() => {
		if (placement !== void 0) return placement;
		return direction === "rtl" ? "bottomRight" : "bottomLeft";
	}, [placement, direction]);
	const mergedClassName = clsx(!customizePrefixCls && treeSelectPrefixCls, {
		[`${prefixCls}-lg`]: mergedSize === "large",
		[`${prefixCls}-sm`]: mergedSize === "small",
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-${variant}`]: enableVariantCls,
		[`${prefixCls}-in-form-item`]: isFormItemInput
	}, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), compactItemClassnames, className, rootClassName, mergedClassNames?.root, cssVarCls, rootCls, treeSelectRootCls, hashId);
	const mergedSwitcherIcon = customSwitcherIcon ?? switcherIcon;
	const renderSwitcherIcon = (nodeProps) => /* @__PURE__ */ import_react.createElement(iconUtil_default, {
		prefixCls: treePrefixCls,
		switcherIcon: mergedSwitcherIcon,
		treeNodeProps: nodeProps,
		showLine: treeLine
	});
	const [zIndex] = useZIndex("SelectLike", mergedStyles.popup?.root?.zIndex);
	return /* @__PURE__ */ import_react.createElement(es_default$3, {
		classNames: mergedClassNames,
		styles: mergedStyles,
		virtual,
		disabled: mergedDisabled,
		...selectProps,
		popupMatchSelectWidth: mergedPopupMatchSelectWidth,
		builtinPlacements: mergedBuiltinPlacements_default(builtinPlacements, popupOverflow),
		ref,
		prefixCls,
		className: mergedClassName,
		style: {
			...mergedStyles?.root,
			...style$1
		},
		listHeight,
		listItemHeight,
		treeCheckable: treeCheckable ? /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-tree-checkbox-inner` }) : treeCheckable,
		treeLine: !!treeLine,
		suffixIcon,
		multiple: isMultiple$1,
		placement: memoizedPlacement,
		removeIcon,
		allowClear: mergedAllowClear,
		switcherIcon: renderSwitcherIcon,
		showTreeIcon: treeIcon,
		notFoundContent: mergedNotFound,
		getPopupContainer: getPopupContainer || getContextPopupContainer,
		treeMotion: null,
		popupClassName: mergedPopupClassName,
		popupStyle: {
			...mergedStyles.root,
			...mergedStyles.popup?.root,
			zIndex
		},
		popupRender: mergedPopupRender,
		onPopupVisibleChange: mergedOnOpenChange,
		choiceTransitionName: getTransitionName(rootPrefixCls, "", choiceTransitionName),
		transitionName: getTransitionName(rootPrefixCls, "slide-up", transitionName),
		treeExpandAction,
		tagRender: isMultiple$1 ? tagRender : void 0,
		maxCount: mergedMaxCount,
		showCheckedStrategy,
		treeCheckStrictly
	});
};
var TreeSelect = /* @__PURE__ */ import_react.forwardRef(InternalTreeSelect);
/* istanbul ignore next */
var PurePanel = PurePanel_default(TreeSelect, "popupAlign", (props) => omit(props, ["visible"]));
TreeSelect.TreeNode = TreeNode_default;
TreeSelect.SHOW_ALL = SHOW_ALL;
TreeSelect.SHOW_PARENT = SHOW_PARENT;
TreeSelect.SHOW_CHILD = SHOW_CHILD;
TreeSelect._InternalPanelDoNotUseOrYouWillBeFired = PurePanel;
TreeSelect.displayName = "TreeSelect";
var tree_select_default = TreeSelect;

//#endregion
//#region node_modules/antd/es/typography/style/mixins.js
var getTitleStyle = (fontSize, lineHeight, color, token$1) => {
	const { titleMarginBottom, fontWeightStrong } = token$1;
	return {
		marginBottom: titleMarginBottom,
		color,
		fontWeight: fontWeightStrong,
		fontSize,
		lineHeight
	};
};
const getTitleStyles = (token$1) => {
	const headings = [
		1,
		2,
		3,
		4,
		5
	];
	const styles = {};
	headings.forEach((headingLevel) => {
		styles[`
      h${headingLevel}&,
      div&-h${headingLevel},
      div&-h${headingLevel} > textarea,
      h${headingLevel}
    `] = getTitleStyle(token$1[`fontSizeHeading${headingLevel}`], token$1[`lineHeightHeading${headingLevel}`], token$1.colorTextHeading, token$1);
	});
	return styles;
};
const getLinkStyles = (token$1) => {
	const { componentCls } = token$1;
	return { "a&, a": {
		...operationUnit(token$1),
		userSelect: "text",
		[`&[disabled], &${componentCls}-disabled`]: {
			color: token$1.colorTextDisabled,
			cursor: "not-allowed",
			"&:active, &:hover": { color: token$1.colorTextDisabled },
			"&:active": { pointerEvents: "none" }
		}
	} };
};
const getResetStyles = (token$1) => ({
	code: {
		margin: "0 0.2em",
		paddingInline: "0.4em",
		paddingBlock: "0.2em 0.1em",
		fontSize: "85%",
		fontFamily: token$1.fontFamilyCode,
		background: "rgba(150, 150, 150, 0.1)",
		border: "1px solid rgba(100, 100, 100, 0.2)",
		borderRadius: 3
	},
	kbd: {
		margin: "0 0.2em",
		paddingInline: "0.4em",
		paddingBlock: "0.15em 0.1em",
		fontSize: "90%",
		fontFamily: token$1.fontFamilyCode,
		background: "rgba(150, 150, 150, 0.06)",
		border: "1px solid rgba(100, 100, 100, 0.2)",
		borderBottomWidth: 2,
		borderRadius: 3
	},
	mark: {
		padding: 0,
		backgroundColor: gold[2]
	},
	"u, ins": {
		textDecoration: "underline",
		textDecorationSkipInk: "auto"
	},
	"s, del": { textDecoration: "line-through" },
	strong: { fontWeight: token$1.fontWeightStrong },
	"ul, ol": {
		marginInline: 0,
		marginBlock: "0 1em",
		padding: 0,
		li: {
			marginInline: "20px 0",
			marginBlock: 0,
			paddingInline: "4px 0",
			paddingBlock: 0
		}
	},
	ul: {
		listStyleType: "circle",
		ul: { listStyleType: "disc" }
	},
	ol: { listStyleType: "decimal" },
	"pre, blockquote": { margin: "1em 0" },
	pre: {
		padding: "0.4em 0.6em",
		whiteSpace: "pre-wrap",
		wordWrap: "break-word",
		background: "rgba(150, 150, 150, 0.1)",
		border: "1px solid rgba(100, 100, 100, 0.2)",
		borderRadius: 3,
		fontFamily: token$1.fontFamilyCode,
		code: {
			display: "inline",
			margin: 0,
			padding: 0,
			fontSize: "inherit",
			fontFamily: "inherit",
			background: "transparent",
			border: 0
		}
	},
	blockquote: {
		paddingInline: "0.6em 0",
		paddingBlock: 0,
		borderInlineStart: "4px solid rgba(100, 100, 100, 0.2)",
		opacity: .85
	}
});
const getEditableStyles = (token$1) => {
	const { componentCls, paddingSM } = token$1;
	const inputShift = paddingSM;
	return { "&-edit-content": {
		position: "relative",
		"div&": {
			insetInlineStart: token$1.calc(token$1.paddingSM).mul(-1).equal(),
			insetBlockStart: token$1.calc(inputShift).div(-2).add(1).equal(),
			marginBottom: token$1.calc(inputShift).div(2).sub(2).equal()
		},
		[`${componentCls}-edit-content-confirm`]: {
			position: "absolute",
			insetInlineEnd: token$1.calc(token$1.marginXS).add(2).equal(),
			insetBlockEnd: token$1.marginXS,
			color: token$1.colorIcon,
			fontWeight: "normal",
			fontSize: token$1.fontSize,
			fontStyle: "normal",
			pointerEvents: "none"
		},
		textarea: {
			margin: "0!important",
			MozTransition: "none",
			height: "1em"
		}
	} };
};
const getCopyableStyles = (token$1) => ({
	[`${token$1.componentCls}-copy-success`]: { [`
    &,
    &:hover,
    &:focus`]: { color: token$1.colorSuccess } },
	[`${token$1.componentCls}-copy-icon-only`]: { marginInlineStart: 0 }
});
const getEllipsisStyles = () => ({
	[`
  a&-ellipsis,
  span&-ellipsis
  `]: {
		display: "inline-block",
		maxWidth: "100%"
	},
	"&-ellipsis-single-line": {
		whiteSpace: "nowrap",
		overflow: "hidden",
		textOverflow: "ellipsis",
		"a&, span&": { verticalAlign: "bottom" },
		"> code": {
			paddingBlock: 0,
			maxWidth: "calc(100% - 1.2em)",
			display: "inline-block",
			overflow: "hidden",
			textOverflow: "ellipsis",
			verticalAlign: "bottom",
			boxSizing: "content-box"
		}
	},
	"&-ellipsis-multiple-line": {
		display: "-webkit-box",
		overflow: "hidden",
		WebkitLineClamp: 3,
		WebkitBoxOrient: "vertical"
	}
});

//#endregion
//#region node_modules/antd/es/typography/style/index.js
var genTypographyStyle = (token$1) => {
	const { componentCls, titleMarginTop } = token$1;
	return { [componentCls]: {
		color: token$1.colorText,
		wordBreak: "break-word",
		lineHeight: token$1.lineHeight,
		[`&${componentCls}-secondary`]: { color: token$1.colorTextDescription },
		[`&${componentCls}-success`]: { color: token$1.colorSuccessText },
		[`&${componentCls}-warning`]: { color: token$1.colorWarningText },
		[`&${componentCls}-danger`]: {
			color: token$1.colorErrorText,
			"a&:active, a&:focus": { color: token$1.colorErrorTextActive },
			"a&:hover": { color: token$1.colorErrorTextHover }
		},
		[`&${componentCls}-disabled`]: {
			color: token$1.colorTextDisabled,
			cursor: "not-allowed",
			userSelect: "none"
		},
		[`
        div&,
        p
      `]: { marginBottom: "1em" },
		...getTitleStyles(token$1),
		[`
      & + h1${componentCls},
      & + h2${componentCls},
      & + h3${componentCls},
      & + h4${componentCls},
      & + h5${componentCls}
      `]: { marginTop: titleMarginTop },
		[`
      div,
      ul,
      li,
      p,
      h1,
      h2,
      h3,
      h4,
      h5`]: { [`
        + h1,
        + h2,
        + h3,
        + h4,
        + h5
        `]: { marginTop: titleMarginTop } },
		...getResetStyles(token$1),
		...getLinkStyles(token$1),
		[`
        ${componentCls}-expand,
        ${componentCls}-collapse,
        ${componentCls}-edit,
        ${componentCls}-copy
      `]: {
			...operationUnit(token$1),
			marginInlineStart: token$1.marginXXS
		},
		...getEditableStyles(token$1),
		...getCopyableStyles(token$1),
		...getEllipsisStyles(),
		"&-rtl": { direction: "rtl" }
	} };
};
const prepareComponentToken$1 = () => ({
	titleMarginTop: "1.2em",
	titleMarginBottom: "0.5em"
});
var style_default$1 = genStyleHooks("Typography", genTypographyStyle, prepareComponentToken$1);

//#endregion
//#region node_modules/antd/es/typography/Editable.js
var Editable = (props) => {
	const { prefixCls, "aria-label": ariaLabel, className, style: style$1, direction, maxLength, autoSize = true, value, onSave, onCancel, onEnd, component, enterIcon = /* @__PURE__ */ import_react.createElement(EnterOutlined_default, null) } = props;
	const ref = import_react.useRef(null);
	const inComposition = import_react.useRef(false);
	const lastKeyCode = import_react.useRef(null);
	const [current, setCurrent] = import_react.useState(value);
	import_react.useEffect(() => {
		setCurrent(value);
	}, [value]);
	import_react.useEffect(() => {
		if (ref.current?.resizableTextArea) {
			const { textArea } = ref.current.resizableTextArea;
			textArea.focus();
			const { length: length$1 } = textArea.value;
			textArea.setSelectionRange(length$1, length$1);
		}
	}, []);
	const onChange = ({ target }) => {
		setCurrent(target.value.replace(/[\n\r]/g, ""));
	};
	const onCompositionStart = () => {
		inComposition.current = true;
	};
	const onCompositionEnd = () => {
		inComposition.current = false;
	};
	const onKeyDown$1 = ({ keyCode }) => {
		if (inComposition.current) return;
		lastKeyCode.current = keyCode;
	};
	const confirmChange = () => {
		onSave(current.trim());
	};
	const onKeyUp = ({ keyCode, ctrlKey, altKey, metaKey, shiftKey }) => {
		if (lastKeyCode.current !== keyCode || inComposition.current || ctrlKey || altKey || metaKey || shiftKey) return;
		if (keyCode === KeyCode_default.ENTER) {
			confirmChange();
			onEnd?.();
		} else if (keyCode === KeyCode_default.ESC) onCancel();
	};
	const onBlur = () => {
		confirmChange();
	};
	const [hashId, cssVarCls] = style_default$1(prefixCls);
	const textAreaClassName = clsx(prefixCls, `${prefixCls}-edit-content`, {
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-${component}`]: !!component
	}, className, hashId, cssVarCls);
	return /* @__PURE__ */ import_react.createElement("div", {
		className: textAreaClassName,
		style: style$1
	}, /* @__PURE__ */ import_react.createElement(TextArea_default, {
		ref,
		maxLength,
		value: current,
		onChange,
		onKeyDown: onKeyDown$1,
		onKeyUp,
		onCompositionStart,
		onCompositionEnd,
		onBlur,
		"aria-label": ariaLabel,
		rows: 1,
		autoSize
	}), enterIcon !== null ? cloneElement(enterIcon, { className: `${prefixCls}-edit-content-confirm` }) : null);
};
var Editable_default = Editable;

//#endregion
//#region node_modules/antd/es/_util/copy.js
var execCopy = (text, isHtmlFormat) => {
	let copySuccess = false;
	const onCopy = (event) => {
		event.stopPropagation();
		event.preventDefault();
		event.clipboardData?.clearData();
		event.clipboardData?.setData("text/plain", text);
		if (isHtmlFormat) event.clipboardData?.setData("text/html", text);
		copySuccess = true;
	};
	try {
		document.addEventListener("copy", onCopy, { capture: true });
		document.execCommand("copy");
		return copySuccess;
	} catch {
		return false;
	} finally {
		document.removeEventListener("copy", onCopy, { capture: true });
	}
};
var asyncCopy = async (text, isHtmlFormat) => {
	try {
		if (isHtmlFormat) await navigator.clipboard.write([new ClipboardItem({
			"text/html": new Blob([text], { type: "text/html" }),
			"text/plain": new Blob([text], { type: "text/plain" })
		})]);
		else await navigator.clipboard.writeText(text);
		return true;
	} catch {
		return false;
	}
};
async function copy(text, config) {
	if (typeof text !== "string") {
		warning_default(false, "The clipboard content must be of string type", "");
		return false;
	}
	const isHtmlFormat = config?.format === "text/html";
	if (await asyncCopy(text, isHtmlFormat)) return true;
	if (execCopy(text, isHtmlFormat)) return true;
	return false;
}
var copy_default = copy;

//#endregion
//#region node_modules/antd/es/typography/hooks/useCopyClick.js
var useCopyClick = ({ copyConfig, children }) => {
	const [copied, setCopied] = import_react.useState(false);
	const [copyLoading, setCopyLoading] = import_react.useState(false);
	const copyIdRef = import_react.useRef(null);
	const cleanCopyId = () => {
		if (copyIdRef.current) clearTimeout(copyIdRef.current);
	};
	const copyOptions = {};
	if (copyConfig.format) copyOptions.format = copyConfig.format;
	import_react.useEffect(() => cleanCopyId, []);
	return {
		copied,
		copyLoading,
		onClick: useEvent_default(async (e$2) => {
			e$2?.preventDefault();
			e$2?.stopPropagation();
			setCopyLoading(true);
			try {
				await copy_default((typeof copyConfig.text === "function" ? await copyConfig.text() : copyConfig.text) || toList_default(children, true).join("") || "", copyOptions);
				setCopyLoading(false);
				setCopied(true);
				cleanCopyId();
				copyIdRef.current = setTimeout(() => {
					setCopied(false);
				}, 3e3);
				copyConfig.onCopy?.(e$2);
			} catch (error) {
				setCopyLoading(false);
				throw error;
			}
		})
	};
};
var useCopyClick_default = useCopyClick;

//#endregion
//#region node_modules/antd/es/typography/hooks/useMergedConfig.js
function useMergedConfig(propConfig, templateConfig) {
	return import_react.useMemo(() => {
		const support = !!propConfig;
		return [support, {
			...templateConfig,
			...support && typeof propConfig === "object" ? propConfig : null
		}];
	}, [propConfig]);
}

//#endregion
//#region node_modules/antd/es/typography/hooks/usePrevious.js
var usePrevious = (value) => {
	const ref = (0, import_react.useRef)(void 0);
	(0, import_react.useEffect)(() => {
		ref.current = value;
	});
	return ref.current;
};
var usePrevious_default = usePrevious;

//#endregion
//#region node_modules/antd/es/typography/hooks/useTooltipProps.js
var useTooltipProps = (tooltip, editConfigText, children) => (0, import_react.useMemo)(() => {
	if (tooltip === true) return { title: editConfigText ?? children };
	if (/* @__PURE__ */ (0, import_react.isValidElement)(tooltip)) return { title: tooltip };
	if (typeof tooltip === "object") return {
		title: editConfigText ?? children,
		...tooltip
	};
	return { title: tooltip };
}, [
	tooltip,
	editConfigText,
	children
]);
var useTooltipProps_default = useTooltipProps;

//#endregion
//#region node_modules/antd/es/typography/Typography.js
var Typography$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, component: Component$2 = "article", className, rootClassName, children, direction: typographyDirection, style: style$1, ...restProps } = props;
	const { getPrefixCls, direction: contextDirection, className: contextClassName, style: contextStyle } = useComponentConfig("typography");
	const direction = typographyDirection ?? contextDirection;
	const prefixCls = getPrefixCls("typography", customizePrefixCls);
	const [hashId, cssVarCls] = style_default$1(prefixCls);
	const componentClassName = clsx(prefixCls, contextClassName, { [`${prefixCls}-rtl`]: direction === "rtl" }, className, rootClassName, hashId, cssVarCls);
	const mergedStyle = {
		...contextStyle,
		...style$1
	};
	return /* @__PURE__ */ import_react.createElement(Component$2, {
		className: componentClassName,
		style: mergedStyle,
		ref,
		...restProps
	}, children);
});
Typography$1.displayName = "Typography";
var Typography_default = Typography$1;

//#endregion
//#region node_modules/antd/es/typography/Base/util.js
function toList(val) {
	if (val === false) return [false, false];
	return Array.isArray(val) ? val : [val];
}
function getNode(dom, defaultNode, needDom) {
	if (dom === true || dom === void 0) return defaultNode;
	return dom || needDom && defaultNode;
}
/**
* Check for element is native ellipsis
* ref:
* - https://github.com/ant-design/ant-design/issues/50143
* - https://github.com/ant-design/ant-design/issues/50414
*/
function isEleEllipsis(ele) {
	const childDiv = document.createElement("em");
	ele.appendChild(childDiv);
	childDiv.className = "ant-typography-css-ellipsis-content-measure";
	const rect = ele.getBoundingClientRect();
	const childRect = childDiv.getBoundingClientRect();
	ele.removeChild(childDiv);
	return rect.left > childRect.left || childRect.right > rect.right || rect.top > childRect.top || childRect.bottom > rect.bottom;
}
const isValidText = (val) => ["string", "number"].includes(typeof val);

//#endregion
//#region node_modules/antd/es/typography/Base/CopyBtn.js
var CopyBtn = ({ prefixCls, copied, locale: locale$5, iconOnly, tooltips, icon, tabIndex, onCopy, loading: btnLoading }) => {
	const tooltipNodes = toList(tooltips);
	const iconNodes = toList(icon);
	const { copied: copiedText, copy: copyText } = locale$5 ?? {};
	const systemStr = copied ? copiedText : copyText;
	const copyTitle = getNode(tooltipNodes[copied ? 1 : 0], systemStr);
	const ariaLabel = typeof copyTitle === "string" ? copyTitle : systemStr;
	return /* @__PURE__ */ import_react.createElement(tooltip_default, { title: copyTitle }, /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		className: clsx(`${prefixCls}-copy`, {
			[`${prefixCls}-copy-success`]: copied,
			[`${prefixCls}-copy-icon-only`]: iconOnly
		}),
		onClick: onCopy,
		"aria-label": ariaLabel,
		tabIndex
	}, copied ? getNode(iconNodes[1], /* @__PURE__ */ import_react.createElement(CheckOutlined_default, null), true) : getNode(iconNodes[0], btnLoading ? /* @__PURE__ */ import_react.createElement(LoadingOutlined_default, null) : /* @__PURE__ */ import_react.createElement(CopyOutlined_default, null), true)));
};
var CopyBtn_default = CopyBtn;

//#endregion
//#region node_modules/antd/es/typography/Base/Ellipsis.js
var MeasureText = /* @__PURE__ */ import_react.forwardRef(({ style: style$1, children }, ref) => {
	const spanRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => ({
		isExceed: () => {
			const span = spanRef.current;
			return span.scrollHeight > span.clientHeight;
		},
		getHeight: () => spanRef.current.clientHeight
	}));
	return /* @__PURE__ */ import_react.createElement("span", {
		"aria-hidden": true,
		ref: spanRef,
		style: {
			position: "fixed",
			display: "block",
			left: 0,
			top: 0,
			pointerEvents: "none",
			backgroundColor: "rgba(255, 0, 0, 0.65)",
			...style$1
		}
	}, children);
});
var getNodesLen = (nodeList) => nodeList.reduce((totalLen, node$1) => totalLen + (isValidText(node$1) ? String(node$1).length : 1), 0);
function sliceNodes(nodeList, len) {
	let currLen = 0;
	const currentNodeList = [];
	for (let i = 0; i < nodeList.length; i += 1) {
		if (currLen === len) return currentNodeList;
		const node$1 = nodeList[i];
		const nodeLen = isValidText(node$1) ? String(node$1).length : 1;
		const nextLen = currLen + nodeLen;
		if (nextLen > len) {
			const restLen = len - currLen;
			currentNodeList.push(String(node$1).slice(0, restLen));
			return currentNodeList;
		}
		currentNodeList.push(node$1);
		currLen = nextLen;
	}
	return nodeList;
}
var STATUS_MEASURE_NONE = 0;
var STATUS_MEASURE_PREPARE = 1;
var STATUS_MEASURE_START = 2;
var STATUS_MEASURE_NEED_ELLIPSIS = 3;
var STATUS_MEASURE_NO_NEED_ELLIPSIS = 4;
var lineClipStyle = {
	display: "-webkit-box",
	overflow: "hidden",
	WebkitBoxOrient: "vertical"
};
function EllipsisMeasure(props) {
	const { enableMeasure, width, text, children, rows, expanded, miscDeps, onEllipsis } = props;
	const nodeList = import_react.useMemo(() => toArray(text), [text]);
	const nodeLen = import_react.useMemo(() => getNodesLen(nodeList), [text]);
	const fullContent = import_react.useMemo(() => children(nodeList, false), [text]);
	const [ellipsisCutIndex, setEllipsisCutIndex] = import_react.useState(null);
	const cutMidRef = import_react.useRef(null);
	const measureWhiteSpaceRef = import_react.useRef(null);
	const needEllipsisRef = import_react.useRef(null);
	const descRowsEllipsisRef = import_react.useRef(null);
	const symbolRowEllipsisRef = import_react.useRef(null);
	const [canEllipsis, setCanEllipsis] = import_react.useState(false);
	const [needEllipsis, setNeedEllipsis] = import_react.useState(STATUS_MEASURE_NONE);
	const [ellipsisHeight, setEllipsisHeight] = import_react.useState(0);
	const [parentWhiteSpace, setParentWhiteSpace] = import_react.useState(null);
	useLayoutEffect_default(() => {
		if (enableMeasure && width && nodeLen) setNeedEllipsis(STATUS_MEASURE_PREPARE);
		else setNeedEllipsis(STATUS_MEASURE_NONE);
	}, [
		width,
		text,
		rows,
		enableMeasure,
		nodeList
	]);
	useLayoutEffect_default(() => {
		if (needEllipsis === STATUS_MEASURE_PREPARE) {
			setNeedEllipsis(STATUS_MEASURE_START);
			setParentWhiteSpace(measureWhiteSpaceRef.current && getComputedStyle(measureWhiteSpaceRef.current).whiteSpace);
		} else if (needEllipsis === STATUS_MEASURE_START) {
			const isOverflow = !!needEllipsisRef.current?.isExceed();
			setNeedEllipsis(isOverflow ? STATUS_MEASURE_NEED_ELLIPSIS : STATUS_MEASURE_NO_NEED_ELLIPSIS);
			setEllipsisCutIndex(isOverflow ? [0, nodeLen] : null);
			setCanEllipsis(isOverflow);
			const baseRowsEllipsisHeight = needEllipsisRef.current?.getHeight() || 0;
			const descRowsEllipsisHeight = rows === 1 ? 0 : descRowsEllipsisRef.current?.getHeight() || 0;
			const symbolRowEllipsisHeight = symbolRowEllipsisRef.current?.getHeight() || 0;
			setEllipsisHeight(Math.max(baseRowsEllipsisHeight, descRowsEllipsisHeight + symbolRowEllipsisHeight) + 1);
			onEllipsis(isOverflow);
		}
	}, [needEllipsis]);
	const cutMidIndex = ellipsisCutIndex ? Math.ceil((ellipsisCutIndex[0] + ellipsisCutIndex[1]) / 2) : 0;
	useLayoutEffect_default(() => {
		const [minIndex, maxIndex] = ellipsisCutIndex || [0, 0];
		if (minIndex !== maxIndex) {
			const isOverflow = (cutMidRef.current?.getHeight() || 0) > ellipsisHeight;
			let targetMidIndex = cutMidIndex;
			if (maxIndex - minIndex === 1) targetMidIndex = isOverflow ? minIndex : maxIndex;
			setEllipsisCutIndex(isOverflow ? [minIndex, targetMidIndex] : [targetMidIndex, maxIndex]);
		}
	}, [ellipsisCutIndex, cutMidIndex]);
	const finalContent = import_react.useMemo(() => {
		if (!enableMeasure) return children(nodeList, false);
		if (needEllipsis !== STATUS_MEASURE_NEED_ELLIPSIS || !ellipsisCutIndex || ellipsisCutIndex[0] !== ellipsisCutIndex[1]) {
			const content = children(nodeList, false);
			if ([STATUS_MEASURE_NO_NEED_ELLIPSIS, STATUS_MEASURE_NONE].includes(needEllipsis)) return content;
			return /* @__PURE__ */ import_react.createElement("span", { style: {
				...lineClipStyle,
				WebkitLineClamp: rows
			} }, content);
		}
		return children(expanded ? nodeList : sliceNodes(nodeList, ellipsisCutIndex[0]), canEllipsis);
	}, [
		expanded,
		needEllipsis,
		ellipsisCutIndex,
		nodeList
	].concat(_toConsumableArray(miscDeps)));
	const measureStyle = {
		width,
		margin: 0,
		padding: 0,
		whiteSpace: parentWhiteSpace === "nowrap" ? "normal" : "inherit"
	};
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, finalContent, needEllipsis === STATUS_MEASURE_START && /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(MeasureText, {
		style: {
			...measureStyle,
			...lineClipStyle,
			WebkitLineClamp: rows
		},
		ref: needEllipsisRef
	}, fullContent), /* @__PURE__ */ import_react.createElement(MeasureText, {
		style: {
			...measureStyle,
			...lineClipStyle,
			WebkitLineClamp: rows - 1
		},
		ref: descRowsEllipsisRef
	}, fullContent), /* @__PURE__ */ import_react.createElement(MeasureText, {
		style: {
			...measureStyle,
			...lineClipStyle,
			WebkitLineClamp: 1
		},
		ref: symbolRowEllipsisRef
	}, children([], true))), needEllipsis === STATUS_MEASURE_NEED_ELLIPSIS && ellipsisCutIndex && ellipsisCutIndex[0] !== ellipsisCutIndex[1] && /* @__PURE__ */ import_react.createElement(MeasureText, {
		style: {
			...measureStyle,
			top: 400
		},
		ref: cutMidRef
	}, children(sliceNodes(nodeList, cutMidIndex), true)), needEllipsis === STATUS_MEASURE_PREPARE && /* @__PURE__ */ import_react.createElement("span", {
		style: { whiteSpace: "inherit" },
		ref: measureWhiteSpaceRef
	}));
}

//#endregion
//#region node_modules/antd/es/typography/Base/EllipsisTooltip.js
var EllipsisTooltip = ({ enableEllipsis, isEllipsis, children, tooltipProps }) => {
	if (!tooltipProps?.title || !enableEllipsis) return children;
	return /* @__PURE__ */ import_react.createElement(tooltip_default, {
		open: isEllipsis ? void 0 : false,
		...tooltipProps
	}, children);
};
EllipsisTooltip.displayName = "EllipsisTooltip";
var EllipsisTooltip_default = EllipsisTooltip;

//#endregion
//#region node_modules/antd/es/typography/Base/index.js
function wrapperDecorations({ mark, code, underline, delete: del, strong, keyboard, italic }, content) {
	let currentContent = content;
	function wrap(tag, needed) {
		if (!needed) return;
		currentContent = /* @__PURE__ */ import_react.createElement(tag, {}, currentContent);
	}
	wrap("strong", strong);
	wrap("u", underline);
	wrap("del", del);
	wrap("code", code);
	wrap("mark", mark);
	wrap("kbd", keyboard);
	wrap("i", italic);
	return currentContent;
}
var ELLIPSIS_STR = "...";
var DECORATION_PROPS = [
	"delete",
	"mark",
	"code",
	"underline",
	"strong",
	"keyboard",
	"italic"
];
var Base = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, className, style: style$1, type: type$2, disabled, children, ellipsis, editable, copyable, component, title, ...restProps } = props;
	const { getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const [textLocale] = useLocale_default("Text");
	const typographyRef = import_react.useRef(null);
	const editIconRef = import_react.useRef(null);
	const prefixCls = getPrefixCls("typography", customizePrefixCls);
	const textProps = omit(restProps, DECORATION_PROPS);
	const [enableEdit, editConfig] = useMergedConfig(editable);
	const [editing, setEditing] = useControlledState(false, editConfig.editing);
	const { triggerType = ["icon"] } = editConfig;
	const triggerEdit = (edit) => {
		if (edit) editConfig.onStart?.();
		setEditing(edit);
	};
	const prevEditing = usePrevious_default(editing);
	useLayoutEffect_default(() => {
		if (!editing && prevEditing) editIconRef.current?.focus();
	}, [editing]);
	const onEditClick = (e$2) => {
		e$2?.preventDefault();
		triggerEdit(true);
	};
	const onEditChange = (value) => {
		editConfig.onChange?.(value);
		triggerEdit(false);
	};
	const onEditCancel = () => {
		editConfig.onCancel?.();
		triggerEdit(false);
	};
	const [enableCopy, copyConfig] = useMergedConfig(copyable);
	const { copied, copyLoading, onClick: onCopyClick } = useCopyClick_default({
		copyConfig,
		children
	});
	const [isLineClampSupport, setIsLineClampSupport] = import_react.useState(false);
	const [isTextOverflowSupport, setIsTextOverflowSupport] = import_react.useState(false);
	const [isJsEllipsis, setIsJsEllipsis] = import_react.useState(false);
	const [isNativeEllipsis, setIsNativeEllipsis] = import_react.useState(false);
	const [isNativeVisible, setIsNativeVisible] = import_react.useState(true);
	const [enableEllipsis, ellipsisConfig] = useMergedConfig(ellipsis, {
		expandable: false,
		symbol: (isExpanded) => isExpanded ? textLocale?.collapse : textLocale?.expand
	});
	const [expanded, setExpanded] = useControlledState(ellipsisConfig.defaultExpanded || false, ellipsisConfig.expanded);
	const mergedEnableEllipsis = enableEllipsis && (!expanded || ellipsisConfig.expandable === "collapsible");
	const { rows = 1 } = ellipsisConfig;
	const needMeasureEllipsis = import_react.useMemo(() => mergedEnableEllipsis && (ellipsisConfig.suffix !== void 0 || ellipsisConfig.onEllipsis || ellipsisConfig.expandable || enableEdit || enableCopy), [
		mergedEnableEllipsis,
		ellipsisConfig,
		enableEdit,
		enableCopy
	]);
	useLayoutEffect_default(() => {
		if (enableEllipsis && !needMeasureEllipsis) {
			setIsLineClampSupport(isStyleSupport("webkitLineClamp"));
			setIsTextOverflowSupport(isStyleSupport("textOverflow"));
		}
	}, [needMeasureEllipsis, enableEllipsis]);
	const [cssEllipsis, setCssEllipsis] = import_react.useState(mergedEnableEllipsis);
	const canUseCssEllipsis = import_react.useMemo(() => {
		if (needMeasureEllipsis) return false;
		if (rows === 1) return isTextOverflowSupport;
		return isLineClampSupport;
	}, [
		needMeasureEllipsis,
		isTextOverflowSupport,
		isLineClampSupport
	]);
	useLayoutEffect_default(() => {
		setCssEllipsis(canUseCssEllipsis && mergedEnableEllipsis);
	}, [canUseCssEllipsis, mergedEnableEllipsis]);
	const isMergedEllipsis = mergedEnableEllipsis && (cssEllipsis ? isNativeEllipsis : isJsEllipsis);
	const cssTextOverflow = mergedEnableEllipsis && rows === 1 && cssEllipsis;
	const cssLineClamp = mergedEnableEllipsis && rows > 1 && cssEllipsis;
	const onExpandClick = (e$2, info) => {
		setExpanded(info.expanded);
		ellipsisConfig.onExpand?.(e$2, info);
	};
	const [ellipsisWidth, setEllipsisWidth] = import_react.useState(0);
	const onResize$1 = ({ offsetWidth }) => {
		setEllipsisWidth(offsetWidth);
	};
	const onJsEllipsis = (jsEllipsis) => {
		setIsJsEllipsis(jsEllipsis);
		if (isJsEllipsis !== jsEllipsis) ellipsisConfig.onEllipsis?.(jsEllipsis);
	};
	import_react.useEffect(() => {
		const textEle = typographyRef.current;
		if (enableEllipsis && cssEllipsis && textEle) {
			const currentEllipsis = isEleEllipsis(textEle);
			if (isNativeEllipsis !== currentEllipsis) setIsNativeEllipsis(currentEllipsis);
		}
	}, [
		enableEllipsis,
		cssEllipsis,
		children,
		cssLineClamp,
		isNativeVisible,
		ellipsisWidth
	]);
	import_react.useEffect(() => {
		const textEle = typographyRef.current;
		if (typeof IntersectionObserver === "undefined" || !textEle || !cssEllipsis || !mergedEnableEllipsis) return;
		const observer$1 = new IntersectionObserver(() => {
			setIsNativeVisible(!!textEle.offsetParent);
		});
		observer$1.observe(textEle);
		return () => {
			observer$1.disconnect();
		};
	}, [cssEllipsis, mergedEnableEllipsis]);
	const tooltipProps = useTooltipProps_default(ellipsisConfig.tooltip, editConfig.text, children);
	const topAriaLabel = import_react.useMemo(() => {
		if (!enableEllipsis || cssEllipsis) return;
		return [
			editConfig.text,
			children,
			title,
			tooltipProps.title
		].find(isValidText);
	}, [
		enableEllipsis,
		cssEllipsis,
		title,
		tooltipProps.title,
		isMergedEllipsis
	]);
	if (editing) return /* @__PURE__ */ import_react.createElement(Editable_default, {
		value: editConfig.text ?? (typeof children === "string" ? children : ""),
		onSave: onEditChange,
		onCancel: onEditCancel,
		onEnd: editConfig.onEnd,
		prefixCls,
		className,
		style: style$1,
		direction,
		component,
		maxLength: editConfig.maxLength,
		autoSize: editConfig.autoSize,
		enterIcon: editConfig.enterIcon
	});
	const renderExpand = () => {
		const { expandable, symbol } = ellipsisConfig;
		return expandable ? /* @__PURE__ */ import_react.createElement("button", {
			type: "button",
			key: "expand",
			className: `${prefixCls}-${expanded ? "collapse" : "expand"}`,
			onClick: (e$2) => onExpandClick(e$2, { expanded: !expanded }),
			"aria-label": expanded ? textLocale.collapse : textLocale?.expand
		}, typeof symbol === "function" ? symbol(expanded) : symbol) : null;
	};
	const renderEdit = () => {
		if (!enableEdit) return;
		const { icon, tooltip, tabIndex } = editConfig;
		const editTitle = toArray(tooltip)[0] || textLocale?.edit;
		const ariaLabel = typeof editTitle === "string" ? editTitle : "";
		return triggerType.includes("icon") ? /* @__PURE__ */ import_react.createElement(tooltip_default, {
			key: "edit",
			title: tooltip === false ? "" : editTitle
		}, /* @__PURE__ */ import_react.createElement("button", {
			type: "button",
			ref: editIconRef,
			className: `${prefixCls}-edit`,
			onClick: onEditClick,
			"aria-label": ariaLabel,
			tabIndex
		}, icon || /* @__PURE__ */ import_react.createElement(EditOutlined_default, { role: "button" }))) : null;
	};
	const renderCopy = () => {
		if (!enableCopy) return null;
		return /* @__PURE__ */ import_react.createElement(CopyBtn_default, {
			key: "copy",
			...copyConfig,
			prefixCls,
			copied,
			locale: textLocale,
			onCopy: onCopyClick,
			loading: copyLoading,
			iconOnly: !isNonNullable_default(children)
		});
	};
	const renderOperations = (canEllipsis) => [
		canEllipsis && renderExpand(),
		renderEdit(),
		renderCopy()
	];
	const renderEllipsis = (canEllipsis) => [
		canEllipsis && !expanded && /* @__PURE__ */ import_react.createElement("span", {
			"aria-hidden": true,
			key: "ellipsis"
		}, ELLIPSIS_STR),
		ellipsisConfig.suffix,
		renderOperations(canEllipsis)
	];
	return /* @__PURE__ */ import_react.createElement(es_default$2, {
		onResize: onResize$1,
		disabled: !mergedEnableEllipsis
	}, (resizeRef) => /* @__PURE__ */ import_react.createElement(EllipsisTooltip_default, {
		tooltipProps,
		enableEllipsis: mergedEnableEllipsis,
		isEllipsis: isMergedEllipsis
	}, /* @__PURE__ */ import_react.createElement(Typography_default, {
		className: clsx({
			[`${prefixCls}-${type$2}`]: type$2,
			[`${prefixCls}-disabled`]: disabled,
			[`${prefixCls}-ellipsis`]: enableEllipsis,
			[`${prefixCls}-ellipsis-single-line`]: cssTextOverflow,
			[`${prefixCls}-ellipsis-multiple-line`]: cssLineClamp
		}, className),
		prefixCls: customizePrefixCls,
		style: {
			...style$1,
			WebkitLineClamp: cssLineClamp ? rows : void 0
		},
		component,
		ref: composeRef(resizeRef, typographyRef, ref),
		direction,
		onClick: triggerType.includes("text") ? onEditClick : void 0,
		"aria-label": topAriaLabel?.toString(),
		title,
		...textProps
	}, /* @__PURE__ */ import_react.createElement(EllipsisMeasure, {
		enableMeasure: mergedEnableEllipsis && !cssEllipsis,
		text: children,
		rows,
		width: ellipsisWidth,
		onEllipsis: onJsEllipsis,
		expanded,
		miscDeps: [
			copied,
			expanded,
			copyLoading,
			enableEdit,
			enableCopy,
			textLocale
		].concat(_toConsumableArray(DECORATION_PROPS.map((key) => props[key])))
	}, (node$1, canEllipsis) => wrapperDecorations(props, /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, node$1.length > 0 && canEllipsis && !expanded && topAriaLabel ? /* @__PURE__ */ import_react.createElement("span", {
		key: "show-content",
		"aria-hidden": true
	}, node$1) : node$1, renderEllipsis(canEllipsis)))))));
});
var Base_default = Base;

//#endregion
//#region node_modules/antd/es/typography/Link.js
var Link = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { ellipsis, rel, children, navigate: _navigate, ...restProps } = props;
	devUseWarning("Typography.Link")(typeof ellipsis !== "object", "usage", "`ellipsis` only supports boolean value.");
	const mergedProps = {
		...restProps,
		rel: rel === void 0 && restProps.target === "_blank" ? "noopener noreferrer" : rel
	};
	return /* @__PURE__ */ import_react.createElement(Base_default, {
		...mergedProps,
		ref,
		ellipsis: !!ellipsis,
		component: "a"
	}, children);
});
var Link_default = Link;

//#endregion
//#region node_modules/antd/es/typography/Paragraph.js
var Paragraph = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { children, ...restProps } = props;
	return /* @__PURE__ */ import_react.createElement(Base_default, {
		ref,
		...restProps,
		component: "div"
	}, children);
});
var Paragraph_default = Paragraph;

//#endregion
//#region node_modules/antd/es/typography/Text.js
var Text = (props, ref) => {
	const { ellipsis, children, ...restProps } = props;
	const mergedEllipsis = import_react.useMemo(() => {
		if (ellipsis && typeof ellipsis === "object") return omit(ellipsis, ["expandable", "rows"]);
		return ellipsis;
	}, [ellipsis]);
	devUseWarning("Typography.Text")(typeof ellipsis !== "object" || !ellipsis || !("expandable" in ellipsis) && !("rows" in ellipsis), "usage", "`ellipsis` do not support `expandable` or `rows` props.");
	return /* @__PURE__ */ import_react.createElement(Base_default, {
		ref,
		...restProps,
		ellipsis: mergedEllipsis,
		component: "span"
	}, children);
};
var Text_default = /* @__PURE__ */ import_react.forwardRef(Text);

//#endregion
//#region node_modules/antd/es/typography/Title.js
var TITLE_ELE_LIST = [
	1,
	2,
	3,
	4,
	5
];
var Title = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { level = 1, children, ...restProps } = props;
	devUseWarning("Typography.Title")(TITLE_ELE_LIST.includes(level), "usage", "Title only accept `1 | 2 | 3 | 4 | 5` as `level` value. And `5` need 4.6.0+ version.");
	const component = TITLE_ELE_LIST.includes(level) ? `h${level}` : `h1`;
	return /* @__PURE__ */ import_react.createElement(Base_default, {
		ref,
		...restProps,
		component
	}, children);
});
var Title_default = Title;

//#endregion
//#region node_modules/antd/es/typography/index.js
var Typography = Typography_default;
Typography.Text = Text_default;
Typography.Link = Link_default;
Typography.Title = Title_default;
Typography.Paragraph = Paragraph_default;
var typography_default = Typography;

//#endregion
//#region node_modules/@rc-component/upload/es/attr-accept.js
var attr_accept_default = ((file, acceptedFiles) => {
	if (file && acceptedFiles) {
		const acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(",");
		const fileName = file.name || "";
		const mimeType = file.type || "";
		const baseMimeType = mimeType.replace(/\/.*$/, "");
		return acceptedFilesArray.some((type$2) => {
			const validType = type$2.trim();
			if (/^\*(\/\*)?$/.test(type$2)) return true;
			if (validType.charAt(0) === ".") {
				const lowerFileName = fileName.toLowerCase();
				const lowerType = validType.toLowerCase();
				let affixList = [lowerType];
				if (lowerType === ".jpg" || lowerType === ".jpeg") affixList = [".jpg", ".jpeg"];
				return affixList.some((affix) => lowerFileName.endsWith(affix));
			}
			if (/\/\*$/.test(validType)) return baseMimeType === validType.replace(/\/.*$/, "");
			if (mimeType === validType) return true;
			if (/^\w+$/.test(validType)) {
				warning_default$1(false, `Upload takes an invalidate 'accept' type '${validType}'.Skip for check.`);
				return true;
			}
			return false;
		});
	}
	return true;
});

//#endregion
//#region node_modules/@rc-component/upload/es/request.js
function getError(option, xhr) {
	const msg = `cannot ${option.method} ${option.action} ${xhr.status}'`;
	const err = new Error(msg);
	err.status = xhr.status;
	err.method = option.method;
	err.url = option.action;
	return err;
}
function getBody(xhr) {
	const text = xhr.responseText || xhr.response;
	if (!text) return text;
	try {
		return JSON.parse(text);
	} catch (e$2) {
		return text;
	}
}
function upload(option) {
	const xhr = new XMLHttpRequest();
	if (option.onProgress && xhr.upload) xhr.upload.onprogress = function progress(e$2) {
		if (e$2.total > 0) e$2.percent = e$2.loaded / e$2.total * 100;
		option.onProgress(e$2);
	};
	const formData = new FormData();
	if (option.data) Object.keys(option.data).forEach((key) => {
		const value = option.data[key];
		if (Array.isArray(value)) {
			value.forEach((item) => {
				formData.append(`${key}[]`, item);
			});
			return;
		}
		formData.append(key, value);
	});
	if (option.file instanceof Blob) formData.append(option.filename, option.file, option.file.name);
	else formData.append(option.filename, option.file);
	xhr.onerror = function error(e$2) {
		option.onError(e$2);
	};
	xhr.onload = function onload() {
		if (xhr.status < 200 || xhr.status >= 300) return option.onError(getError(option, xhr), getBody(xhr));
		return option.onSuccess(getBody(xhr), xhr);
	};
	xhr.open(option.method, option.action, true);
	if (option.withCredentials && "withCredentials" in xhr) xhr.withCredentials = true;
	const headers = option.headers || {};
	if (headers["X-Requested-With"] !== null) xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
	Object.keys(headers).forEach((h) => {
		if (headers[h] !== null) xhr.setRequestHeader(h, headers[h]);
	});
	xhr.send(formData);
	return { abort() {
		xhr.abort();
	} };
}

//#endregion
//#region node_modules/@rc-component/upload/es/traverseFileTree.js
var traverseFileTree = async (files, isAccepted) => {
	const flattenFileList = [];
	const progressFileList = [];
	files.forEach((file) => progressFileList.push(file.webkitGetAsEntry()));
	async function readDirectory(directory) {
		const dirReader = directory.createReader();
		const entries = [];
		while (true) {
			const results = await new Promise((resolve) => {
				dirReader.readEntries(resolve, () => resolve([]));
			});
			const n$1 = results.length;
			if (!n$1) break;
			for (let i = 0; i < n$1; i++) entries.push(results[i]);
		}
		return entries;
	}
	async function readFile(item) {
		return new Promise((reslove) => {
			item.file((file) => {
				if (isAccepted(file)) {
					if (item.fullPath && !file.webkitRelativePath) {
						Object.defineProperties(file, { webkitRelativePath: { writable: true } });
						file.webkitRelativePath = item.fullPath.replace(/^\//, "");
						Object.defineProperties(file, { webkitRelativePath: { writable: false } });
					}
					reslove(file);
				} else reslove(null);
			});
		});
	}
	const _traverseFileTree = async (item, path$1) => {
		if (!item) return;
		item.path = path$1 || "";
		if (item.isFile) {
			const file = await readFile(item);
			if (file) flattenFileList.push(file);
		} else if (item.isDirectory) {
			const entries = await readDirectory(item);
			progressFileList.push(...entries);
		}
	};
	let wipIndex = 0;
	while (wipIndex < progressFileList.length) {
		await _traverseFileTree(progressFileList[wipIndex]);
		wipIndex++;
	}
	return flattenFileList;
};
var traverseFileTree_default = traverseFileTree;

//#endregion
//#region node_modules/@rc-component/upload/es/uid.js
var now = +/* @__PURE__ */ new Date();
var index = 0;
function uid() {
	return `rc-upload-${now}-${++index}`;
}

//#endregion
//#region node_modules/@rc-component/upload/es/AjaxUploader.js
function _extends$1() {
	_extends$1 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$1.apply(this, arguments);
}
var AjaxUploader = class extends import_react.Component {
	state = { uid: uid() };
	reqs = {};
	fileInput;
	_isMounted;
	filterFile = (file, force = false) => {
		const { accept, directory } = this.props;
		let filterFn;
		let acceptFormat;
		if (typeof accept === "string") acceptFormat = accept;
		else {
			const { filter: filter$2, format: format$1 } = accept || {};
			acceptFormat = format$1;
			if (filter$2 === "native") filterFn = () => true;
			else filterFn = filter$2;
		}
		return (filterFn || (directory || force ? (currentFile) => attr_accept_default(currentFile, acceptFormat) : () => true))(file);
	};
	onChange = (e$2) => {
		const { files } = e$2.target;
		const acceptedFiles = [...files].filter((file) => this.filterFile(file));
		this.uploadFiles(acceptedFiles);
		this.reset();
	};
	onClick = (event) => {
		const el = this.fileInput;
		if (!el) return;
		const target = event.target;
		const { onClick } = this.props;
		if (target && target.tagName === "BUTTON") {
			el.parentNode.focus();
			target.blur();
		}
		el.click();
		if (onClick) onClick(event);
	};
	onKeyDown = (e$2) => {
		if (e$2.key === "Enter") this.onClick(e$2);
	};
	onDataTransferFiles = async (dataTransfer, existFileCallback) => {
		const { multiple, directory } = this.props;
		const items = [...dataTransfer.items || []];
		let files = [...dataTransfer.files || []];
		if (files.length > 0 || items.some((item) => item.kind === "file")) existFileCallback?.();
		if (directory) {
			files = await traverseFileTree_default(Array.prototype.slice.call(items), this.filterFile);
			this.uploadFiles(files);
		} else {
			let acceptFiles = [...files].filter((file) => this.filterFile(file, true));
			if (multiple === false) acceptFiles = files.slice(0, 1);
			this.uploadFiles(acceptFiles);
		}
	};
	onFilePaste = async (e$2) => {
		const { pastable } = this.props;
		if (!pastable) return;
		if (e$2.type === "paste") {
			const clipboardData = e$2.clipboardData;
			return this.onDataTransferFiles(clipboardData, () => {
				e$2.preventDefault();
			});
		}
	};
	onFileDragOver = (e$2) => {
		e$2.preventDefault();
	};
	onFileDrop = async (e$2) => {
		e$2.preventDefault();
		if (e$2.type === "drop") {
			const dataTransfer = e$2.dataTransfer;
			return this.onDataTransferFiles(dataTransfer);
		}
	};
	componentDidMount() {
		this._isMounted = true;
		const { pastable } = this.props;
		if (pastable) document.addEventListener("paste", this.onFilePaste);
	}
	componentWillUnmount() {
		this._isMounted = false;
		this.abort();
		document.removeEventListener("paste", this.onFilePaste);
	}
	componentDidUpdate(prevProps) {
		const { pastable } = this.props;
		if (pastable && !prevProps.pastable) document.addEventListener("paste", this.onFilePaste);
		else if (!pastable && prevProps.pastable) document.removeEventListener("paste", this.onFilePaste);
	}
	uploadFiles = (files) => {
		const originFiles = [...files];
		const postFiles = originFiles.map((file) => {
			file.uid = uid();
			return this.processFile(file, originFiles);
		});
		Promise.all(postFiles).then((fileList) => {
			const { onBatchStart } = this.props;
			onBatchStart?.(fileList.map(({ origin, parsedFile }) => ({
				file: origin,
				parsedFile
			})));
			fileList.filter((file) => file.parsedFile !== null).forEach((file) => {
				this.post(file);
			});
		});
	};
	/**
	* Process file before upload. When all the file is ready, we start upload.
	*/
	processFile = async (file, fileList) => {
		const { beforeUpload } = this.props;
		let transformedFile = file;
		if (beforeUpload) {
			try {
				transformedFile = await beforeUpload(file, fileList);
			} catch (e$2) {
				transformedFile = false;
			}
			if (transformedFile === false) return {
				origin: file,
				parsedFile: null,
				action: null,
				data: null
			};
		}
		const { action } = this.props;
		let mergedAction;
		if (typeof action === "function") mergedAction = await action(file);
		else mergedAction = action;
		const { data } = this.props;
		let mergedData;
		if (typeof data === "function") mergedData = await data(file);
		else mergedData = data;
		const parsedData = (typeof transformedFile === "object" || typeof transformedFile === "string") && transformedFile ? transformedFile : file;
		let parsedFile;
		if (parsedData instanceof File) parsedFile = parsedData;
		else parsedFile = new File([parsedData], file.name, { type: file.type });
		const mergedParsedFile = parsedFile;
		mergedParsedFile.uid = file.uid;
		return {
			origin: file,
			data: mergedData,
			parsedFile: mergedParsedFile,
			action: mergedAction
		};
	};
	post({ data, origin, action, parsedFile }) {
		if (!this._isMounted) return;
		const { onStart, customRequest, name, headers, withCredentials, method: method$1 } = this.props;
		const { uid: uid$2 } = origin;
		const request = customRequest || upload;
		const requestOption = {
			action,
			filename: name,
			data,
			file: parsedFile,
			headers,
			withCredentials,
			method: method$1 || "post",
			onProgress: (e$2) => {
				const { onProgress } = this.props;
				onProgress?.(e$2, parsedFile);
			},
			onSuccess: (ret, xhr) => {
				const { onSuccess } = this.props;
				onSuccess?.(ret, parsedFile, xhr);
				delete this.reqs[uid$2];
			},
			onError: (err, ret) => {
				const { onError } = this.props;
				onError?.(err, ret, parsedFile);
				delete this.reqs[uid$2];
			}
		};
		onStart(origin);
		this.reqs[uid$2] = request(requestOption, { defaultRequest: upload });
	}
	reset() {
		this.setState({ uid: uid() });
	}
	abort(file) {
		const { reqs } = this;
		if (file) {
			const uid$2 = file.uid ? file.uid : file;
			if (reqs[uid$2] && reqs[uid$2].abort) reqs[uid$2].abort();
			delete reqs[uid$2];
		} else Object.keys(reqs).forEach((uid$2) => {
			if (reqs[uid$2] && reqs[uid$2].abort) reqs[uid$2].abort();
			delete reqs[uid$2];
		});
	}
	saveFileInput = (node$1) => {
		this.fileInput = node$1;
	};
	render() {
		const { component: Tag$1, prefixCls, className, classNames = {}, disabled, id, name, style: style$1, styles = {}, multiple, accept, capture, children, directory, openFileDialogOnClick, onMouseEnter, onMouseLeave, hasControlInside, ...otherProps } = this.props;
		const acceptFormat = typeof accept === "string" ? accept : accept?.format;
		const cls = clsx(prefixCls, {
			[`${prefixCls}-disabled`]: disabled,
			[className]: className
		});
		const dirProps = directory ? {
			directory: "directory",
			webkitdirectory: "webkitdirectory"
		} : {};
		const events = disabled ? {} : {
			onClick: openFileDialogOnClick ? this.onClick : () => {},
			onKeyDown: openFileDialogOnClick ? this.onKeyDown : () => {},
			onMouseEnter,
			onMouseLeave,
			onDrop: this.onFileDrop,
			onDragOver: this.onFileDragOver,
			tabIndex: hasControlInside ? void 0 : "0"
		};
		return /* @__PURE__ */ import_react.createElement(Tag$1, _extends$1({}, events, {
			className: cls,
			role: hasControlInside ? void 0 : "button",
			style: style$1
		}), /* @__PURE__ */ import_react.createElement("input", _extends$1({}, pickAttrs(otherProps, {
			aria: true,
			data: true
		}), {
			id,
			name,
			disabled,
			type: "file",
			ref: this.saveFileInput,
			onClick: (e$2) => e$2.stopPropagation(),
			key: this.state.uid,
			style: {
				display: "none",
				...styles.input
			},
			className: classNames.input,
			accept: acceptFormat
		}, dirProps, {
			multiple,
			onChange: this.onChange
		}, capture != null ? { capture } : {})), children);
	}
};
var AjaxUploader_default = AjaxUploader;

//#endregion
//#region node_modules/@rc-component/upload/es/Upload.js
function _extends() {
	_extends = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends.apply(this, arguments);
}
function empty() {}
var Upload$2 = class extends import_react.Component {
	static defaultProps = {
		component: "span",
		prefixCls: "rc-upload",
		data: {},
		headers: {},
		name: "file",
		multipart: false,
		onStart: empty,
		onError: empty,
		onSuccess: empty,
		multiple: false,
		beforeUpload: null,
		customRequest: null,
		withCredentials: false,
		openFileDialogOnClick: true,
		hasControlInside: false
	};
	uploader;
	abort(file) {
		this.uploader.abort(file);
	}
	saveUploader = (node$1) => {
		this.uploader = node$1;
	};
	render() {
		return /* @__PURE__ */ import_react.createElement(AjaxUploader_default, _extends({}, this.props, { ref: this.saveUploader }));
	}
};
var Upload_default$1 = Upload$2;

//#endregion
//#region node_modules/@rc-component/upload/es/index.js
var es_default = Upload_default$1;

//#endregion
//#region node_modules/antd/es/upload/style/dragger.js
var genDraggerStyle = (token$1) => {
	const { componentCls, iconCls } = token$1;
	return { [`${componentCls}-wrapper`]: { [`${componentCls}-drag`]: {
		position: "relative",
		width: "100%",
		height: "100%",
		textAlign: "center",
		background: token$1.colorFillAlter,
		border: `${unit(token$1.lineWidth)} dashed ${token$1.colorBorder}`,
		borderRadius: token$1.borderRadiusLG,
		cursor: "pointer",
		transition: `border-color ${token$1.motionDurationSlow}`,
		[componentCls]: { padding: token$1.padding },
		[`${componentCls}-btn`]: {
			display: "table",
			width: "100%",
			height: "100%",
			outline: "none",
			borderRadius: token$1.borderRadiusLG,
			"&:focus-visible": { outline: `${unit(token$1.lineWidthFocus)} solid ${token$1.colorPrimaryBorder}` }
		},
		[`${componentCls}-drag-container`]: {
			display: "table-cell",
			verticalAlign: "middle"
		},
		[`
          &:not(${componentCls}-disabled):hover,
          &-hover:not(${componentCls}-disabled)
        `]: { borderColor: token$1.colorPrimaryHover },
		[`p${componentCls}-drag-icon`]: {
			marginBottom: token$1.margin,
			[iconCls]: {
				color: token$1.colorPrimary,
				fontSize: token$1.uploadThumbnailSize
			}
		},
		[`p${componentCls}-text`]: {
			margin: `0 0 ${unit(token$1.marginXXS)}`,
			color: token$1.colorTextHeading,
			fontSize: token$1.fontSizeLG
		},
		[`p${componentCls}-hint`]: {
			color: token$1.colorTextDescription,
			fontSize: token$1.fontSize
		},
		[`&${componentCls}-disabled`]: { [`p${componentCls}-drag-icon ${iconCls},
            p${componentCls}-text,
            p${componentCls}-hint
          `]: { color: token$1.colorTextDisabled } }
	} } };
};
var dragger_default = genDraggerStyle;

//#endregion
//#region node_modules/antd/es/upload/style/list.js
var genListStyle = (token$1) => {
	const { componentCls, iconCls, fontSize, lineHeight, calc } = token$1;
	const itemCls = `${componentCls}-list-item`;
	const actionsCls = `${itemCls}-actions`;
	const actionCls = `${itemCls}-action`;
	return { [`${componentCls}-wrapper`]: { [`${componentCls}-list`]: {
		...clearFix(),
		lineHeight: token$1.lineHeight,
		[itemCls]: {
			position: "relative",
			height: calc(token$1.lineHeight).mul(fontSize).equal(),
			marginTop: token$1.marginXS,
			fontSize,
			display: "flex",
			alignItems: "center",
			transition: `background-color ${token$1.motionDurationSlow}`,
			borderRadius: token$1.borderRadiusSM,
			"&:hover": { backgroundColor: token$1.controlItemBgHover },
			[`${itemCls}-name`]: {
				...textEllipsis,
				padding: `0 ${unit(token$1.paddingXS)}`,
				lineHeight,
				flex: "auto",
				transition: `all ${token$1.motionDurationSlow}`
			},
			[actionsCls]: {
				whiteSpace: "nowrap",
				[actionCls]: { opacity: 0 },
				[iconCls]: {
					color: token$1.actionsColor,
					transition: `all ${token$1.motionDurationSlow}`
				},
				[`
              ${actionCls}:focus-visible,
              &.picture ${actionCls}
            `]: { opacity: 1 }
			},
			[`${componentCls}-icon ${iconCls}`]: {
				color: token$1.colorIcon,
				fontSize
			},
			[`${itemCls}-progress`]: {
				position: "absolute",
				bottom: token$1.calc(token$1.uploadProgressOffset).mul(-1).equal(),
				width: "100%",
				paddingInlineStart: calc(fontSize).add(token$1.paddingXS).equal(),
				fontSize,
				lineHeight: 0,
				pointerEvents: "none",
				"> div": { margin: 0 }
			}
		},
		[`${itemCls}:hover ${actionCls}`]: { opacity: 1 },
		[`${itemCls}-error`]: {
			color: token$1.colorError,
			[`${itemCls}-name, ${componentCls}-icon ${iconCls}`]: { color: token$1.colorError },
			[actionsCls]: {
				[`${iconCls}, ${iconCls}:hover`]: { color: token$1.colorError },
				[actionCls]: { opacity: 1 }
			}
		},
		[`${componentCls}-list-item-container`]: {
			transition: `opacity ${token$1.motionDurationSlow}, height ${token$1.motionDurationSlow}`,
			"&::before": {
				display: "table",
				width: 0,
				height: 0,
				content: "\"\""
			}
		}
	} } };
};
var list_default$1 = genListStyle;

//#endregion
//#region node_modules/antd/es/upload/style/motion.js
var genMotionStyle = (token$1) => {
	const { componentCls } = token$1;
	const uploadAnimateInlineIn = new Keyframes_default("uploadAnimateInlineIn", { from: {
		width: 0,
		height: 0,
		padding: 0,
		opacity: 0,
		margin: token$1.calc(token$1.marginXS).div(-2).equal()
	} });
	const uploadAnimateInlineOut = new Keyframes_default("uploadAnimateInlineOut", { to: {
		width: 0,
		height: 0,
		padding: 0,
		opacity: 0,
		margin: token$1.calc(token$1.marginXS).div(-2).equal()
	} });
	const inlineCls = `${componentCls}-animate-inline`;
	return [
		{ [`${componentCls}-wrapper`]: {
			[`${inlineCls}-appear, ${inlineCls}-enter, ${inlineCls}-leave`]: {
				animationDuration: token$1.motionDurationSlow,
				animationTimingFunction: token$1.motionEaseInOutCirc,
				animationFillMode: "forwards"
			},
			[`${inlineCls}-appear, ${inlineCls}-enter`]: { animationName: uploadAnimateInlineIn },
			[`${inlineCls}-leave`]: { animationName: uploadAnimateInlineOut }
		} },
		{ [`${componentCls}-wrapper`]: initFadeMotion(token$1) },
		uploadAnimateInlineIn,
		uploadAnimateInlineOut
	];
};
var motion_default$1 = genMotionStyle;

//#endregion
//#region node_modules/antd/es/upload/style/picture.js
var genPictureStyle = (token$1) => {
	const { componentCls, iconCls, uploadThumbnailSize, uploadProgressOffset, calc } = token$1;
	const listCls = `${componentCls}-list`;
	const itemCls = `${listCls}-item`;
	return { [`${componentCls}-wrapper`]: {
		[`
        ${listCls}${listCls}-picture,
        ${listCls}${listCls}-picture-card,
        ${listCls}${listCls}-picture-circle
      `]: {
			[itemCls]: {
				position: "relative",
				height: calc(uploadThumbnailSize).add(calc(token$1.lineWidth).mul(2)).add(calc(token$1.paddingXS).mul(2)).equal(),
				padding: token$1.paddingXS,
				border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`,
				borderRadius: token$1.borderRadiusLG,
				"&:hover": { background: "transparent" },
				[`${itemCls}-thumbnail`]: {
					...textEllipsis,
					width: uploadThumbnailSize,
					height: uploadThumbnailSize,
					lineHeight: unit(calc(uploadThumbnailSize).add(token$1.paddingSM).equal()),
					textAlign: "center",
					flex: "none",
					[iconCls]: {
						fontSize: token$1.fontSizeHeading2,
						color: token$1.colorPrimary
					},
					img: {
						display: "block",
						width: "100%",
						height: "100%",
						overflow: "hidden"
					}
				},
				[`${itemCls}-progress`]: {
					bottom: calc(token$1.fontSize).mul(token$1.lineHeight).div(2).add(uploadProgressOffset).equal(),
					width: `calc(100% - ${unit(calc(token$1.paddingSM).mul(2).equal())})`,
					marginTop: 0,
					paddingInlineStart: calc(uploadThumbnailSize).add(token$1.paddingXS).equal()
				}
			},
			[`${itemCls}-error`]: {
				borderColor: token$1.colorError,
				[`${itemCls}-thumbnail ${iconCls}`]: {
					[`svg path[fill='${blue[0]}']`]: { fill: token$1.colorErrorBg },
					[`svg path[fill='${blue.primary}']`]: { fill: token$1.colorError }
				}
			},
			[`${itemCls}-uploading`]: {
				borderStyle: "dashed",
				[`${itemCls}-name`]: { marginBottom: uploadProgressOffset }
			}
		},
		[`${listCls}${listCls}-picture-circle ${itemCls}`]: { [`&, &::before, ${itemCls}-thumbnail`]: { borderRadius: "50%" } }
	} };
};
var genPictureCardStyle = (token$1) => {
	const { componentCls, iconCls, fontSizeLG, colorTextLightSolid, calc } = token$1;
	const listCls = `${componentCls}-list`;
	const itemCls = `${listCls}-item`;
	const uploadPictureCardSize = token$1.uploadPicCardSize;
	return {
		[`
      ${componentCls}-wrapper${componentCls}-picture-card-wrapper,
      ${componentCls}-wrapper${componentCls}-picture-circle-wrapper
    `]: {
			...clearFix(),
			display: "block",
			[`${componentCls}${componentCls}-select`]: {
				width: uploadPictureCardSize,
				height: uploadPictureCardSize,
				textAlign: "center",
				verticalAlign: "top",
				backgroundColor: token$1.colorFillAlter,
				border: `${unit(token$1.lineWidth)} dashed ${token$1.colorBorder}`,
				borderRadius: token$1.borderRadiusLG,
				cursor: "pointer",
				transition: `border-color ${token$1.motionDurationSlow}`,
				[`> ${componentCls}`]: {
					display: "flex",
					alignItems: "center",
					justifyContent: "center",
					height: "100%",
					textAlign: "center"
				},
				[`&:not(${componentCls}-disabled):hover`]: { borderColor: token$1.colorPrimary }
			},
			[`${listCls}${listCls}-picture-card, ${listCls}${listCls}-picture-circle`]: {
				display: "flex",
				flexWrap: "wrap",
				"@supports not (gap: 1px)": { "& > *": {
					marginBlockEnd: token$1.marginXS,
					marginInlineEnd: token$1.marginXS
				} },
				"@supports (gap: 1px)": { gap: token$1.marginXS },
				[`${listCls}-item-container`]: {
					display: "inline-block",
					width: uploadPictureCardSize,
					height: uploadPictureCardSize,
					verticalAlign: "top"
				},
				"&::after": { display: "none" },
				"&::before": { display: "none" },
				[itemCls]: {
					height: "100%",
					margin: 0,
					"&::before": {
						position: "absolute",
						zIndex: 1,
						width: `calc(100% - ${unit(calc(token$1.paddingXS).mul(2).equal())})`,
						height: `calc(100% - ${unit(calc(token$1.paddingXS).mul(2).equal())})`,
						backgroundColor: token$1.colorBgMask,
						opacity: 0,
						transition: `all ${token$1.motionDurationSlow}`,
						content: "\" \""
					}
				},
				[`${itemCls}:hover`]: { [`&::before, ${itemCls}-actions`]: { opacity: 1 } },
				[`${itemCls}-actions`]: {
					position: "absolute",
					insetInlineStart: 0,
					zIndex: 10,
					width: "100%",
					whiteSpace: "nowrap",
					textAlign: "center",
					opacity: 0,
					transition: `all ${token$1.motionDurationSlow}`,
					[`
            ${iconCls}-eye,
            ${iconCls}-download,
            ${iconCls}-delete
          `]: {
						zIndex: 10,
						width: fontSizeLG,
						margin: `0 ${unit(token$1.marginXXS)}`,
						fontSize: fontSizeLG,
						cursor: "pointer",
						transition: `all ${token$1.motionDurationSlow}`,
						color: colorTextLightSolid,
						"&:hover": { color: colorTextLightSolid },
						svg: { verticalAlign: "baseline" }
					}
				},
				[`${itemCls}-thumbnail, ${itemCls}-thumbnail img`]: {
					position: "static",
					display: "block",
					width: "100%",
					height: "100%",
					objectFit: "contain"
				},
				[`${itemCls}-name`]: {
					display: "none",
					textAlign: "center"
				},
				[`${itemCls}-file + ${itemCls}-name`]: {
					position: "absolute",
					bottom: token$1.margin,
					display: "block",
					width: `calc(100% - ${unit(calc(token$1.paddingXS).mul(2).equal())})`
				},
				[`${itemCls}-uploading`]: {
					[`&${itemCls}`]: { backgroundColor: token$1.colorFillAlter },
					[`&::before, ${iconCls}-eye, ${iconCls}-download, ${iconCls}-delete`]: { display: "none" }
				},
				[`${itemCls}-progress`]: {
					bottom: token$1.marginXL,
					width: `calc(100% - ${unit(calc(token$1.paddingXS).mul(2).equal())})`,
					paddingInlineStart: 0
				}
			}
		},
		[`${componentCls}-wrapper${componentCls}-picture-circle-wrapper`]: { [`${componentCls}${componentCls}-select`]: { borderRadius: "50%" } }
	};
};

//#endregion
//#region node_modules/antd/es/upload/style/rtl.js
var genRtlStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-rtl`]: { direction: "rtl" } };
};
var rtl_default = genRtlStyle;

//#endregion
//#region node_modules/antd/es/upload/style/index.js
var genBaseStyle = (token$1) => {
	const { componentCls, colorTextDisabled } = token$1;
	return { [`${componentCls}-wrapper`]: {
		...resetComponent(token$1),
		[componentCls]: {
			outline: 0,
			"input[type='file']": { cursor: "pointer" }
		},
		[`${componentCls}-select`]: { display: "inline-block" },
		[`${componentCls}-hidden`]: { display: "none" },
		[`${componentCls}-disabled`]: {
			color: colorTextDisabled,
			cursor: "not-allowed"
		}
	} };
};
const prepareComponentToken = (token$1) => ({
	actionsColor: token$1.colorIcon,
	pictureCardSize: token$1.controlHeightLG * 2.55
});
var style_default = genStyleHooks("Upload", (token$1) => {
	const { fontSizeHeading3, marginXS, lineWidth, pictureCardSize, calc } = token$1;
	const uploadToken = merge(token$1, {
		uploadThumbnailSize: calc(fontSizeHeading3).mul(2).equal(),
		uploadProgressOffset: calc(calc(marginXS).div(2)).add(lineWidth).equal(),
		uploadPicCardSize: pictureCardSize
	});
	return [
		genBaseStyle(uploadToken),
		dragger_default(uploadToken),
		genPictureStyle(uploadToken),
		genPictureCardStyle(uploadToken),
		list_default$1(uploadToken),
		motion_default$1(uploadToken),
		rtl_default(uploadToken),
		collapse_default$1(uploadToken)
	];
}, prepareComponentToken);

//#endregion
//#region node_modules/antd/es/upload/utils.js
function file2Obj(file) {
	return {
		...file,
		lastModified: file.lastModified,
		lastModifiedDate: file.lastModifiedDate,
		name: file.name,
		size: file.size,
		type: file.type,
		uid: file.uid,
		percent: 0,
		originFileObj: file
	};
}
/** Upload fileList. Replace file if exist or just push into it. */
function updateFileList(file, fileList) {
	const nextFileList = _toConsumableArray(fileList);
	const fileIndex = nextFileList.findIndex(({ uid: uid$2 }) => uid$2 === file.uid);
	if (fileIndex === -1) nextFileList.push(file);
	else nextFileList[fileIndex] = file;
	return nextFileList;
}
function getFileItem(file, fileList) {
	const matchKey = file.uid !== void 0 ? "uid" : "name";
	return fileList.filter((item) => item[matchKey] === file[matchKey])[0];
}
function removeFileItem(file, fileList) {
	const matchKey = file.uid !== void 0 ? "uid" : "name";
	const removed = fileList.filter((item) => item[matchKey] !== file[matchKey]);
	if (removed.length === fileList.length) return null;
	return removed;
}
var extname = (url = "") => {
	const temp = url.split("/");
	const filenameWithoutSuffix = temp[temp.length - 1].split(/#|\?/)[0];
	return (/\.[^./\\]*$/.exec(filenameWithoutSuffix) || [""])[0];
};
var isImageFileType = (type$2) => type$2.indexOf("image/") === 0;
const isImageUrl = (file) => {
	if (file.type && !file.thumbUrl) return isImageFileType(file.type);
	const url = file.thumbUrl || file.url || "";
	const extension = extname(url);
	if (/^data:image\//.test(url) || /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico|heic|heif)$/i.test(extension)) return true;
	if (/^data:/.test(url)) return false;
	if (extension) return false;
	return true;
};
var MEASURE_SIZE = 200;
function previewImage(file) {
	return new Promise((resolve) => {
		if (!file.type || !isImageFileType(file.type)) {
			resolve("");
			return;
		}
		const canvas = document.createElement("canvas");
		canvas.width = MEASURE_SIZE;
		canvas.height = MEASURE_SIZE;
		canvas.style.cssText = `position: fixed; left: 0; top: 0; width: ${MEASURE_SIZE}px; height: ${MEASURE_SIZE}px; z-index: 9999; display: none;`;
		document.body.appendChild(canvas);
		const ctx = canvas.getContext("2d");
		const img = new Image();
		img.onload = () => {
			const { width, height } = img;
			let drawWidth = MEASURE_SIZE;
			let drawHeight = MEASURE_SIZE;
			let offsetX = 0;
			let offsetY = 0;
			if (width > height) {
				drawHeight = height * (MEASURE_SIZE / width);
				offsetY = -(drawHeight - drawWidth) / 2;
			} else {
				drawWidth = width * (MEASURE_SIZE / height);
				offsetX = -(drawWidth - drawHeight) / 2;
			}
			ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
			const dataURL = canvas.toDataURL();
			document.body.removeChild(canvas);
			window.URL.revokeObjectURL(img.src);
			resolve(dataURL);
		};
		img.crossOrigin = "anonymous";
		if (file.type.startsWith("image/svg+xml")) {
			const reader = new FileReader();
			reader.onload = () => {
				if (reader.result && typeof reader.result === "string") img.src = reader.result;
			};
			reader.readAsDataURL(file);
		} else if (file.type.startsWith("image/gif")) {
			const reader = new FileReader();
			reader.onload = () => {
				if (reader.result) resolve(reader.result);
			};
			reader.readAsDataURL(file);
		} else img.src = window.URL.createObjectURL(file);
	});
}

//#endregion
//#region node_modules/antd/es/upload/UploadList/ListItem.js
var ListItem = /* @__PURE__ */ import_react.forwardRef(({ prefixCls, className, style: style$1, classNames: itemClassNames, styles, locale: locale$5, listType, file, items, progress: progressProps, iconRender, actionIconRender, itemRender, isImgUrl, showPreviewIcon, showRemoveIcon, showDownloadIcon, previewIcon: customPreviewIcon, removeIcon: customRemoveIcon, downloadIcon: customDownloadIcon, extra: customExtra, onPreview, onDownload, onClose }, ref) => {
	const { status } = file;
	const [mergedStatus, setMergedStatus] = import_react.useState(status);
	import_react.useEffect(() => {
		if (status !== "removed") setMergedStatus(status);
	}, [status]);
	const [showProgress, setShowProgress] = import_react.useState(false);
	import_react.useEffect(() => {
		const timer = setTimeout(() => {
			setShowProgress(true);
		}, 300);
		return () => {
			clearTimeout(timer);
		};
	}, []);
	const iconNode = iconRender(file);
	let icon = /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-icon` }, iconNode);
	if (listType === "picture" || listType === "picture-card" || listType === "picture-circle") if (mergedStatus === "uploading" || !file.thumbUrl && !file.url) {
		const uploadingClassName = clsx(`${prefixCls}-list-item-thumbnail`, { [`${prefixCls}-list-item-file`]: mergedStatus !== "uploading" });
		icon = /* @__PURE__ */ import_react.createElement("div", { className: uploadingClassName }, iconNode);
	} else {
		const thumbnail = isImgUrl?.(file) ? /* @__PURE__ */ import_react.createElement("img", {
			src: file.thumbUrl || file.url,
			alt: file.name,
			className: `${prefixCls}-list-item-image`,
			crossOrigin: file.crossOrigin
		}) : iconNode;
		const aClassName = clsx(`${prefixCls}-list-item-thumbnail`, { [`${prefixCls}-list-item-file`]: isImgUrl && !isImgUrl(file) });
		icon = /* @__PURE__ */ import_react.createElement("a", {
			className: aClassName,
			onClick: (e$2) => onPreview(file, e$2),
			href: file.url || file.thumbUrl,
			target: "_blank",
			rel: "noopener noreferrer"
		}, thumbnail);
	}
	const listItemClassName = clsx(`${prefixCls}-list-item`, `${prefixCls}-list-item-${mergedStatus}`, itemClassNames?.item);
	const linkProps = typeof file.linkProps === "string" ? JSON.parse(file.linkProps) : file.linkProps;
	const removeIcon = (typeof showRemoveIcon === "function" ? showRemoveIcon(file) : showRemoveIcon) ? actionIconRender((typeof customRemoveIcon === "function" ? customRemoveIcon(file) : customRemoveIcon) || /* @__PURE__ */ import_react.createElement(DeleteOutlined_default, null), () => onClose(file), prefixCls, locale$5.removeFile, true) : null;
	const downloadIcon = (typeof showDownloadIcon === "function" ? showDownloadIcon(file) : showDownloadIcon) && mergedStatus === "done" ? actionIconRender((typeof customDownloadIcon === "function" ? customDownloadIcon(file) : customDownloadIcon) || /* @__PURE__ */ import_react.createElement(DownloadOutlined_default, null), () => onDownload(file), prefixCls, locale$5.downloadFile) : null;
	const downloadOrDelete = listType !== "picture-card" && listType !== "picture-circle" && /* @__PURE__ */ import_react.createElement("span", {
		key: "download-delete",
		className: clsx(`${prefixCls}-list-item-actions`, { picture: listType === "picture" })
	}, downloadIcon, removeIcon);
	const extraContent = typeof customExtra === "function" ? customExtra(file) : customExtra;
	const extra = extraContent && /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-list-item-extra` }, extraContent);
	const listItemNameClass = clsx(`${prefixCls}-list-item-name`);
	const fileName = file.url ? /* @__PURE__ */ import_react.createElement("a", {
		key: "view",
		target: "_blank",
		rel: "noopener noreferrer",
		className: listItemNameClass,
		title: file.name,
		...linkProps,
		href: file.url,
		onClick: (e$2) => onPreview(file, e$2)
	}, file.name, extra) : /* @__PURE__ */ import_react.createElement("span", {
		key: "view",
		className: listItemNameClass,
		onClick: (e$2) => onPreview(file, e$2),
		title: file.name
	}, file.name, extra);
	const previewIcon = (typeof showPreviewIcon === "function" ? showPreviewIcon(file) : showPreviewIcon) && (file.url || file.thumbUrl) ? /* @__PURE__ */ import_react.createElement("a", {
		href: file.url || file.thumbUrl,
		target: "_blank",
		rel: "noopener noreferrer",
		onClick: (e$2) => onPreview(file, e$2),
		title: locale$5.previewFile
	}, typeof customPreviewIcon === "function" ? customPreviewIcon(file) : customPreviewIcon || /* @__PURE__ */ import_react.createElement(EyeOutlined_default, null)) : null;
	const pictureCardActions = (listType === "picture-card" || listType === "picture-circle") && mergedStatus !== "uploading" && /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-list-item-actions` }, previewIcon, mergedStatus === "done" && downloadIcon, removeIcon);
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const rootPrefixCls = getPrefixCls();
	const dom = /* @__PURE__ */ import_react.createElement("div", {
		className: listItemClassName,
		style: styles?.item
	}, icon, fileName, downloadOrDelete, pictureCardActions, showProgress && /* @__PURE__ */ import_react.createElement(es_default$1, {
		motionName: `${rootPrefixCls}-fade`,
		visible: mergedStatus === "uploading",
		motionDeadline: 2e3
	}, ({ className: motionClassName }) => {
		const loadingProgress = "percent" in file ? /* @__PURE__ */ import_react.createElement(progress_default, {
			type: "line",
			percent: file.percent,
			"aria-label": file["aria-label"],
			"aria-labelledby": file["aria-labelledby"],
			...progressProps
		}) : null;
		return /* @__PURE__ */ import_react.createElement("div", { className: clsx(`${prefixCls}-list-item-progress`, motionClassName) }, loadingProgress);
	}));
	const message$1 = file.response && typeof file.response === "string" ? file.response : file.error?.statusText || file.error?.message || locale$5.uploadError;
	const item = mergedStatus === "error" ? /* @__PURE__ */ import_react.createElement(tooltip_default, {
		title: message$1,
		getPopupContainer: (node$1) => node$1.parentNode
	}, dom) : dom;
	return /* @__PURE__ */ import_react.createElement("div", {
		className: clsx(`${prefixCls}-list-item-container`, className),
		style: style$1,
		ref
	}, itemRender ? itemRender(item, file, items, {
		download: onDownload.bind(null, file),
		preview: onPreview.bind(null, file),
		remove: onClose.bind(null, file)
	}) : item);
});
var ListItem_default = ListItem;

//#endregion
//#region node_modules/antd/es/upload/UploadList/index.js
var InternalUploadList = (props, ref) => {
	const { listType = "text", previewFile = previewImage, onPreview, onDownload, onRemove, locale: locale$5, iconRender, isImageUrl: isImgUrl = isImageUrl, prefixCls: customizePrefixCls, items = [], showPreviewIcon = true, showRemoveIcon = true, showDownloadIcon = false, removeIcon, previewIcon, downloadIcon, extra, progress = {
		size: [-1, 2],
		showInfo: false
	}, appendAction, appendActionVisible = true, itemRender, disabled, classNames: uploadListClassNames, styles } = props;
	const [, forceUpdate] = useForceUpdate();
	const [motionAppear, setMotionAppear] = import_react.useState(false);
	const isPictureCardOrCirle = ["picture-card", "picture-circle"].includes(listType);
	import_react.useEffect(() => {
		if (!listType.startsWith("picture")) return;
		(items || []).forEach((file) => {
			if (!(file.originFileObj instanceof File || file.originFileObj instanceof Blob) || file.thumbUrl !== void 0) return;
			file.thumbUrl = "";
			previewFile?.(file.originFileObj).then((previewDataUrl) => {
				file.thumbUrl = previewDataUrl || "";
				forceUpdate();
			});
		});
	}, [
		listType,
		items,
		previewFile
	]);
	import_react.useEffect(() => {
		setMotionAppear(true);
	}, []);
	const onInternalPreview = (file, e$2) => {
		if (!onPreview) return;
		e$2?.preventDefault();
		return onPreview(file);
	};
	const onInternalDownload = (file) => {
		if (typeof onDownload === "function") onDownload(file);
		else if (file.url) window.open(file.url);
	};
	const onInternalClose = (file) => {
		onRemove?.(file);
	};
	const internalIconRender = (file) => {
		if (iconRender) return iconRender(file, listType);
		const isLoading = file.status === "uploading";
		if (listType.startsWith("picture")) {
			const loadingIcon = listType === "picture" ? /* @__PURE__ */ import_react.createElement(LoadingOutlined_default, null) : locale$5.uploading;
			const fileIcon = isImgUrl?.(file) ? /* @__PURE__ */ import_react.createElement(PictureTwoTone_default, null) : /* @__PURE__ */ import_react.createElement(FileTwoTone_default, null);
			return isLoading ? loadingIcon : fileIcon;
		}
		return isLoading ? /* @__PURE__ */ import_react.createElement(LoadingOutlined_default, null) : /* @__PURE__ */ import_react.createElement(PaperClipOutlined_default, null);
	};
	const actionIconRender = (customIcon, callback, prefixCls$1, title, acceptUploadDisabled) => {
		const btnProps = {
			type: "text",
			size: "small",
			title,
			onClick: (e$2) => {
				callback();
				if (/* @__PURE__ */ import_react.isValidElement(customIcon)) customIcon.props.onClick?.(e$2);
			},
			className: `${prefixCls$1}-list-item-action`,
			disabled: acceptUploadDisabled ? disabled : false
		};
		return /* @__PURE__ */ import_react.isValidElement(customIcon) ? /* @__PURE__ */ import_react.createElement(Button_default, {
			...btnProps,
			icon: cloneElement(customIcon, {
				...customIcon.props,
				onClick: () => {}
			})
		}) : /* @__PURE__ */ import_react.createElement(Button_default, { ...btnProps }, /* @__PURE__ */ import_react.createElement("span", null, customIcon));
	};
	import_react.useImperativeHandle(ref, () => ({
		handlePreview: onInternalPreview,
		handleDownload: onInternalDownload
	}));
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("upload", customizePrefixCls);
	const rootPrefixCls = getPrefixCls();
	const listClassNames = clsx(`${prefixCls}-list`, `${prefixCls}-list-${listType}`, uploadListClassNames?.list);
	const listItemMotion = import_react.useMemo(() => omit(motion_default(rootPrefixCls), [
		"onAppearEnd",
		"onEnterEnd",
		"onLeaveEnd"
	]), [rootPrefixCls]);
	const motionConfig = {
		...isPictureCardOrCirle ? {} : listItemMotion,
		motionDeadline: 2e3,
		motionName: `${prefixCls}-${isPictureCardOrCirle ? "animate-inline" : "animate"}`,
		keys: _toConsumableArray(items.map((file) => ({
			key: file.uid,
			file
		}))),
		motionAppear
	};
	return /* @__PURE__ */ import_react.createElement("div", {
		className: listClassNames,
		style: styles?.list
	}, /* @__PURE__ */ import_react.createElement(CSSMotionList_default, {
		...motionConfig,
		component: false
	}, ({ key, file, className: motionClassName, style: motionStyle }) => /* @__PURE__ */ import_react.createElement(ListItem_default, {
		key,
		locale: locale$5,
		prefixCls,
		className: motionClassName,
		style: motionStyle,
		classNames: uploadListClassNames,
		styles,
		file,
		items,
		progress,
		listType,
		isImgUrl,
		showPreviewIcon,
		showRemoveIcon,
		showDownloadIcon,
		removeIcon,
		previewIcon,
		downloadIcon,
		extra,
		iconRender: internalIconRender,
		actionIconRender,
		itemRender,
		onPreview: onInternalPreview,
		onDownload: onInternalDownload,
		onClose: onInternalClose
	})), appendAction && /* @__PURE__ */ import_react.createElement(es_default$1, {
		...motionConfig,
		visible: appendActionVisible,
		forceRender: true
	}, ({ className: motionClassName, style: motionStyle }) => cloneElement(appendAction, (oriProps) => ({
		className: clsx(oriProps.className, motionClassName),
		style: {
			...motionStyle,
			pointerEvents: motionClassName ? "none" : void 0,
			...oriProps.style
		}
	}))));
};
var UploadList = /* @__PURE__ */ import_react.forwardRef(InternalUploadList);
UploadList.displayName = "UploadList";
var UploadList_default = UploadList;

//#endregion
//#region node_modules/antd/es/upload/Upload.js
var import_react_dom = require_react_dom();
const LIST_IGNORE = `__LIST_IGNORE_${Date.now()}__`;
var InternalUpload = (props, ref) => {
	const config = useComponentConfig("upload");
	const { fileList, defaultFileList, onRemove, showUploadList = true, listType = "text", onPreview, onDownload, onChange, onDrop, previewFile, disabled: customDisabled, locale: propLocale, iconRender, isImageUrl: isImageUrl$1, progress, prefixCls: customizePrefixCls, className, type: type$2 = "select", children, style: style$1, itemRender, maxCount, data = {}, multiple = false, hasControlInside = true, action = "", accept = "", supportServerRender = true, rootClassName, styles, classNames } = props;
	const disabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = customDisabled ?? disabled;
	const customRequest = props.customRequest || config.customRequest;
	const [internalFileList, setMergedFileList] = useControlledState(defaultFileList, fileList);
	const mergedFileList = internalFileList || [];
	const [dragState, setDragState] = import_react.useState("drop");
	const upload$1 = import_react.useRef(null);
	const wrapRef = import_react.useRef(null);
	devUseWarning("Upload")("fileList" in props || !("value" in props), "usage", "`value` is not a valid prop, do you mean `fileList`?");
	import_react.useMemo(() => {
		const timestamp = Date.now();
		(fileList || []).forEach((file, index$1) => {
			if (!file.uid && !Object.isFrozen(file)) file.uid = `__AUTO__${timestamp}_${index$1}__`;
		});
	}, [fileList]);
	const onInternalChange = (file, changedFileList, event) => {
		let cloneList = _toConsumableArray(changedFileList);
		let exceedMaxCount = false;
		if (maxCount === 1) cloneList = cloneList.slice(-1);
		else if (maxCount) {
			exceedMaxCount = cloneList.length > maxCount;
			cloneList = cloneList.slice(0, maxCount);
		}
		(0, import_react_dom.flushSync)(() => {
			setMergedFileList(cloneList);
		});
		const changeInfo = {
			file,
			fileList: cloneList
		};
		if (event) changeInfo.event = event;
		if (!exceedMaxCount || file.status === "removed" || cloneList.some((f) => f.uid === file.uid)) (0, import_react_dom.flushSync)(() => {
			onChange?.(changeInfo);
		});
	};
	const mergedBeforeUpload = async (file, fileListArgs) => {
		const { beforeUpload } = props;
		let parsedFile = file;
		if (beforeUpload) {
			const result = await beforeUpload(file, fileListArgs);
			if (result === false) return false;
			delete file[LIST_IGNORE];
			if (result === LIST_IGNORE) {
				Object.defineProperty(file, LIST_IGNORE, {
					value: true,
					configurable: true
				});
				return false;
			}
			if (typeof result === "object" && result) parsedFile = result;
		}
		return parsedFile;
	};
	const onBatchStart = (batchFileInfoList) => {
		const filteredFileInfoList = batchFileInfoList.filter((info) => !info.file[LIST_IGNORE]);
		if (!filteredFileInfoList.length) return;
		const objectFileList = filteredFileInfoList.map((info) => file2Obj(info.file));
		let newFileList = _toConsumableArray(mergedFileList);
		objectFileList.forEach((fileObj) => {
			newFileList = updateFileList(fileObj, newFileList);
		});
		objectFileList.forEach((fileObj, index$1) => {
			let triggerFileObj = fileObj;
			if (!filteredFileInfoList[index$1].parsedFile) {
				const { originFileObj } = fileObj;
				let clone;
				try {
					clone = new File([originFileObj], originFileObj.name, { type: originFileObj.type });
				} catch {
					clone = new Blob([originFileObj], { type: originFileObj.type });
					clone.name = originFileObj.name;
					clone.lastModifiedDate = /* @__PURE__ */ new Date();
					clone.lastModified = (/* @__PURE__ */ new Date()).getTime();
				}
				clone.uid = fileObj.uid;
				triggerFileObj = clone;
			} else fileObj.status = "uploading";
			onInternalChange(triggerFileObj, newFileList);
		});
	};
	const onSuccess = (response, file, xhr) => {
		try {
			if (typeof response === "string") response = JSON.parse(response);
		} catch {}
		if (!getFileItem(file, mergedFileList)) return;
		const targetItem = file2Obj(file);
		targetItem.status = "done";
		targetItem.percent = 100;
		targetItem.response = response;
		targetItem.xhr = xhr;
		onInternalChange(targetItem, updateFileList(targetItem, mergedFileList));
	};
	const onProgress = (e$2, file) => {
		if (!getFileItem(file, mergedFileList)) return;
		const targetItem = file2Obj(file);
		targetItem.status = "uploading";
		targetItem.percent = e$2.percent;
		onInternalChange(targetItem, updateFileList(targetItem, mergedFileList), e$2);
	};
	const onError = (error, response, file) => {
		if (!getFileItem(file, mergedFileList)) return;
		const targetItem = file2Obj(file);
		targetItem.error = error;
		targetItem.response = response;
		targetItem.status = "error";
		onInternalChange(targetItem, updateFileList(targetItem, mergedFileList));
	};
	const handleRemove = (file) => {
		let currentFile;
		Promise.resolve(typeof onRemove === "function" ? onRemove(file) : onRemove).then((ret) => {
			if (ret === false) return;
			const removedFileList = removeFileItem(file, mergedFileList);
			if (removedFileList) {
				currentFile = {
					...file,
					status: "removed"
				};
				mergedFileList?.forEach((item) => {
					const matchKey = currentFile.uid !== void 0 ? "uid" : "name";
					if (item[matchKey] === currentFile[matchKey] && !Object.isFrozen(item)) item.status = "removed";
				});
				upload$1.current?.abort(currentFile);
				onInternalChange(currentFile, removedFileList);
			}
		});
	};
	const onFileDrop = (e$2) => {
		setDragState(e$2.type);
		if (e$2.type === "drop") onDrop?.(e$2);
	};
	import_react.useImperativeHandle(ref, () => ({
		onBatchStart,
		onSuccess,
		onProgress,
		onError,
		fileList: mergedFileList,
		upload: upload$1.current,
		nativeElement: wrapRef.current
	}));
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("upload");
	const prefixCls = getPrefixCls("upload", customizePrefixCls);
	const mergedProps = {
		...props,
		listType,
		showUploadList,
		type: type$2,
		multiple,
		hasControlInside,
		supportServerRender,
		disabled: mergedDisabled
	};
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], { props: mergedProps });
	const rcUploadProps = {
		onBatchStart,
		onError,
		onProgress,
		onSuccess,
		...props,
		customRequest,
		data,
		multiple,
		action,
		accept,
		supportServerRender,
		prefixCls,
		disabled: mergedDisabled,
		beforeUpload: mergedBeforeUpload,
		onChange: void 0,
		hasControlInside
	};
	delete rcUploadProps.className;
	delete rcUploadProps.style;
	if (!children || mergedDisabled) delete rcUploadProps.id;
	const wrapperCls = `${prefixCls}-wrapper`;
	const [hashId, cssVarCls] = style_default(prefixCls, wrapperCls);
	const [contextLocale] = useLocale_default("Upload", en_US_default.Upload);
	const { showRemoveIcon, showPreviewIcon, showDownloadIcon, removeIcon, previewIcon, downloadIcon, extra } = typeof showUploadList === "boolean" ? {} : showUploadList;
	const realShowRemoveIcon = typeof showRemoveIcon === "undefined" ? !mergedDisabled : showRemoveIcon;
	const renderUploadList = (button, buttonVisible) => {
		if (!showUploadList) return button;
		return /* @__PURE__ */ import_react.createElement(UploadList_default, {
			classNames: mergedClassNames,
			styles: mergedStyles,
			prefixCls,
			listType,
			items: mergedFileList,
			previewFile,
			onPreview,
			onDownload,
			onRemove: handleRemove,
			showRemoveIcon: realShowRemoveIcon,
			showPreviewIcon,
			showDownloadIcon,
			removeIcon,
			previewIcon,
			downloadIcon,
			iconRender,
			extra,
			locale: {
				...contextLocale,
				...propLocale
			},
			isImageUrl: isImageUrl$1,
			progress,
			appendAction: button,
			appendActionVisible: buttonVisible,
			itemRender,
			disabled: mergedDisabled
		});
	};
	const mergedRootCls = clsx(wrapperCls, className, rootClassName, hashId, cssVarCls, contextClassName, mergedClassNames.root, {
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-picture-card-wrapper`]: listType === "picture-card",
		[`${prefixCls}-picture-circle-wrapper`]: listType === "picture-circle"
	});
	const mergedRootStyle = { ...mergedStyles.root };
	const mergedStyle = {
		...contextStyle,
		...style$1
	};
	if (type$2 === "drag") {
		const dragCls = clsx(hashId, prefixCls, `${prefixCls}-drag`, {
			[`${prefixCls}-drag-uploading`]: mergedFileList.some((file) => file.status === "uploading"),
			[`${prefixCls}-drag-hover`]: dragState === "dragover",
			[`${prefixCls}-disabled`]: mergedDisabled,
			[`${prefixCls}-rtl`]: direction === "rtl"
		});
		return /* @__PURE__ */ import_react.createElement("span", {
			className: mergedRootCls,
			ref: wrapRef,
			style: mergedRootStyle
		}, /* @__PURE__ */ import_react.createElement("div", {
			className: dragCls,
			style: mergedStyle,
			onDrop: onFileDrop,
			onDragOver: onFileDrop,
			onDragLeave: onFileDrop
		}, /* @__PURE__ */ import_react.createElement(es_default, {
			...rcUploadProps,
			ref: upload$1,
			className: `${prefixCls}-btn`
		}, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-drag-container` }, children))), renderUploadList());
	}
	const uploadBtnCls = clsx(prefixCls, `${prefixCls}-select`, {
		[`${prefixCls}-disabled`]: mergedDisabled,
		[`${prefixCls}-hidden`]: !children
	});
	const uploadButton = /* @__PURE__ */ import_react.createElement("div", {
		className: uploadBtnCls,
		style: mergedStyle
	}, /* @__PURE__ */ import_react.createElement(es_default, {
		...rcUploadProps,
		ref: upload$1
	}));
	if (listType === "picture-card" || listType === "picture-circle") return /* @__PURE__ */ import_react.createElement("span", {
		className: mergedRootCls,
		ref: wrapRef,
		style: mergedRootStyle
	}, renderUploadList(uploadButton, !!children));
	return /* @__PURE__ */ import_react.createElement("span", {
		className: mergedRootCls,
		ref: wrapRef,
		style: mergedRootStyle
	}, uploadButton, renderUploadList());
};
var Upload$1 = /* @__PURE__ */ import_react.forwardRef(InternalUpload);
Upload$1.displayName = "Upload";
var Upload_default = Upload$1;

//#endregion
//#region node_modules/antd/es/upload/Dragger.js
var Dragger = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { style: style$1, height, hasControlInside = false, children, ...restProps } = props;
	const mergedStyle = {
		...style$1,
		height
	};
	return /* @__PURE__ */ import_react.createElement(Upload_default, {
		ref,
		hasControlInside,
		...restProps,
		style: mergedStyle,
		type: "drag"
	}, children);
});
Dragger.displayName = "Dragger";
var Dragger_default = Dragger;

//#endregion
//#region node_modules/antd/es/upload/index.js
var Upload = Upload_default;
Upload.Dragger = Dragger_default;
Upload.LIST_IGNORE = LIST_IGNORE;
var upload_default = Upload;

//#endregion
//#region node_modules/@rc-component/mutate-observer/es/useMutateObserver.js
var defaultOptions = {
	subtree: true,
	childList: true,
	attributeFilter: ["style", "class"]
};
var useMutateObserver = (nodeOrList, callback, options = defaultOptions) => {
	import_react.useEffect(() => {
		if (!canUseDom() || !nodeOrList) return;
		let instance;
		const nodeList = Array.isArray(nodeOrList) ? nodeOrList : [nodeOrList];
		if ("MutationObserver" in window) {
			instance = new MutationObserver(callback);
			nodeList.forEach((element) => {
				instance.observe(element, options);
			});
		}
		return () => {
			instance?.takeRecords();
			instance?.disconnect();
		};
	}, [options, nodeOrList]);
};
var useMutateObserver_default = useMutateObserver;

//#endregion
//#region node_modules/antd/es/watermark/useClips.js
const FontGap = 3;
var prepareCanvas = (width, height, ratio = 1) => {
	const canvas = document.createElement("canvas");
	const ctx = canvas.getContext("2d");
	const realWidth = width * ratio;
	const realHeight = height * ratio;
	canvas.setAttribute("width", `${realWidth}px`);
	canvas.setAttribute("height", `${realHeight}px`);
	ctx.save();
	return [
		ctx,
		canvas,
		realWidth,
		realHeight
	];
};
var getRotatePos = (x, y, angle) => {
	return [x * Math.cos(angle) - y * Math.sin(angle), x * Math.sin(angle) + y * Math.cos(angle)];
};
/**
* Get the clips of text content.
* This is a lazy hook function since SSR no need this
*/
var useClips = () => {
	const getClips = (content, rotate, ratio, width, height, font, gapX, gapY) => {
		const [ctx, canvas, contentWidth, contentHeight] = prepareCanvas(width, height, ratio);
		if (content instanceof HTMLImageElement) ctx.drawImage(content, 0, 0, contentWidth, contentHeight);
		else {
			const { color, fontSize, fontStyle, fontWeight, fontFamily, textAlign } = font;
			const mergedFontSize = Number(fontSize) * ratio;
			ctx.font = `${fontStyle} normal ${fontWeight} ${mergedFontSize}px/${height}px ${fontFamily}`;
			ctx.fillStyle = color;
			ctx.textAlign = textAlign;
			ctx.textBaseline = "top";
			toList_default(content)?.forEach((item, index$1) => {
				ctx.fillText(item ?? "", contentWidth / 2, index$1 * (mergedFontSize + FontGap * ratio));
			});
		}
		const angle = Math.PI / 180 * Number(rotate);
		const maxSize = Math.max(width, height);
		const [rCtx, rCanvas, realMaxSize] = prepareCanvas(maxSize, maxSize, ratio);
		rCtx.translate(realMaxSize / 2, realMaxSize / 2);
		rCtx.rotate(angle);
		if (contentWidth > 0 && contentHeight > 0) rCtx.drawImage(canvas, -contentWidth / 2, -contentHeight / 2);
		let left = 0;
		let right = 0;
		let top = 0;
		let bottom = 0;
		const halfWidth = contentWidth / 2;
		const halfHeight = contentHeight / 2;
		[
			[0 - halfWidth, 0 - halfHeight],
			[0 + halfWidth, 0 - halfHeight],
			[0 + halfWidth, 0 + halfHeight],
			[0 - halfWidth, 0 + halfHeight]
		].forEach(([x, y]) => {
			const [targetX, targetY] = getRotatePos(x, y, angle);
			left = Math.min(left, targetX);
			right = Math.max(right, targetX);
			top = Math.min(top, targetY);
			bottom = Math.max(bottom, targetY);
		});
		const cutLeft = left + realMaxSize / 2;
		const cutTop = top + realMaxSize / 2;
		const cutWidth = right - left;
		const cutHeight = bottom - top;
		const realGapX = gapX * ratio;
		const realGapY = gapY * ratio;
		const filledWidth = (cutWidth + realGapX) * 2;
		const filledHeight = cutHeight + realGapY;
		const [fCtx, fCanvas] = prepareCanvas(filledWidth, filledHeight);
		const drawImg = (targetX = 0, targetY = 0) => {
			fCtx.drawImage(rCanvas, cutLeft, cutTop, cutWidth, cutHeight, targetX, targetY, cutWidth, cutHeight);
		};
		drawImg();
		drawImg(cutWidth + realGapX, -cutHeight / 2 - realGapY / 2);
		drawImg(cutWidth + realGapX, +cutHeight / 2 + realGapY / 2);
		return [
			fCanvas.toDataURL(),
			filledWidth / ratio,
			filledHeight / ratio
		];
	};
	return import_react.useCallback(getClips, []);
};
var useClips_default = useClips;

//#endregion
//#region node_modules/antd/es/watermark/useRafDebounce.js
/**
* Callback will only execute last one for each raf
*/
function useRafDebounce(callback) {
	const executeRef = import_react.useRef(false);
	const rafRef = import_react.useRef(null);
	const wrapperCallback = useEvent_default(callback);
	return () => {
		if (executeRef.current) return;
		executeRef.current = true;
		wrapperCallback();
		rafRef.current = raf_default(() => {
			executeRef.current = false;
		});
	};
}

//#endregion
//#region node_modules/antd/es/watermark/useSingletonCache.js
/**
* Singleton cache will only take latest `cacheParams` as key
* and return the result for callback matching.
*/
function useSingletonCache() {
	const cacheRef = import_react.useRef([null, null]);
	const getCache = (cacheKeys, callback) => {
		const filteredKeys = cacheKeys.map((item) => item instanceof HTMLElement || Number.isNaN(item) ? "" : item);
		if (!isEqual_default(cacheRef.current[0], filteredKeys)) cacheRef.current = [filteredKeys, callback()];
		return cacheRef.current[1];
	};
	return getCache;
}

//#endregion
//#region node_modules/antd/es/watermark/utils.js
/** converting camel-cased strings to be lowercase and link it with Separator */
function toLowercaseSeparator(key) {
	return key.replace(/([A-Z])/g, "-$1").toLowerCase();
}
function getStyleStr(style$1) {
	return Object.keys(style$1).map((key) => `${toLowercaseSeparator(key)}: ${style$1[key]};`).join(" ");
}
/** Returns the ratio of the device's physical pixel resolution to the css pixel resolution */
function getPixelRatio() {
	return window.devicePixelRatio || 1;
}
/** Whether to re-render the watermark */
const reRendering = (mutation, isWatermarkEle) => {
	let flag = false;
	if (mutation.removedNodes.length) flag = Array.from(mutation.removedNodes).some((node$1) => isWatermarkEle(node$1));
	if (mutation.type === "attributes" && isWatermarkEle(mutation.target)) flag = true;
	return flag;
};

//#endregion
//#region node_modules/antd/es/watermark/useWatermark.js
var emphasizedStyle = { visibility: "visible !important" };
function useWatermark(markStyle, onRemove) {
	const watermarkMap = import_react.useRef(/* @__PURE__ */ new Map());
	const onRemoveEvent = useEvent_default(onRemove);
	const appendWatermark = (base64Url, markWidth, container) => {
		if (container) {
			const exist = watermarkMap.current.get(container);
			if (!exist) {
				const newWatermarkEle = document.createElement("div");
				watermarkMap.current.set(container, newWatermarkEle);
			}
			const watermarkEle = watermarkMap.current.get(container);
			watermarkEle.setAttribute("style", getStyleStr({
				...markStyle,
				backgroundImage: `url('${base64Url}')`,
				backgroundSize: `${Math.floor(markWidth)}px`,
				...emphasizedStyle
			}));
			watermarkEle.removeAttribute("class");
			watermarkEle.removeAttribute("hidden");
			if (watermarkEle.parentElement !== container) {
				if (exist && onRemove) onRemoveEvent();
				container.append(watermarkEle);
			}
		}
		return watermarkMap.current.get(container);
	};
	const removeWatermark = (container) => {
		const watermarkEle = watermarkMap.current.get(container);
		if (watermarkEle && container) container.removeChild(watermarkEle);
		watermarkMap.current.delete(container);
	};
	const isWatermarkEle = (ele) => Array.from(watermarkMap.current.values()).includes(ele);
	return [
		appendWatermark,
		removeWatermark,
		isWatermarkEle
	];
}

//#endregion
//#region node_modules/antd/es/watermark/index.js
/**
* Only return `next` when size changed.
* This is only used for elements compare, not a shallow equal!
*/
function getSizeDiff(prev$1, next$1) {
	return prev$1.size === next$1.size ? prev$1 : next$1;
}
var DEFAULT_GAP_X = 100;
var DEFAULT_GAP_Y = 100;
var fixedStyle = {
	position: "relative",
	overflow: "hidden"
};
var Watermark = (props) => {
	const { zIndex = 9, rotate = -22, width, height, image, content, font = {}, style: style$1, className, rootClassName, gap = [DEFAULT_GAP_X, DEFAULT_GAP_Y], offset: offset$2, children, inherit = true, onRemove } = props;
	const { className: contextClassName, style: contextStyle } = useComponentConfig("watermark");
	const mergedStyle = {
		...fixedStyle,
		...contextStyle,
		...style$1
	};
	const [, token$1] = useToken();
	const { color = token$1.colorFill, fontSize = token$1.fontSizeLG, fontWeight = "normal", fontStyle = "normal", fontFamily = "sans-serif", textAlign = "center" } = font;
	const [gapX = DEFAULT_GAP_X, gapY = DEFAULT_GAP_Y] = gap;
	const gapXCenter = gapX / 2;
	const gapYCenter = gapY / 2;
	const offsetLeft = offset$2?.[0] ?? gapXCenter;
	const offsetTop = offset$2?.[1] ?? gapYCenter;
	const markStyle = import_react.useMemo(() => {
		const mergedMarkStyle = {
			zIndex,
			position: "absolute",
			left: 0,
			top: 0,
			width: "100%",
			height: "100%",
			pointerEvents: "none",
			backgroundRepeat: "repeat"
		};
		/** Calculate the style of the offset */
		let positionLeft = offsetLeft - gapXCenter;
		let positionTop = offsetTop - gapYCenter;
		if (positionLeft > 0) {
			mergedMarkStyle.left = `${positionLeft}px`;
			mergedMarkStyle.width = `calc(100% - ${positionLeft}px)`;
			positionLeft = 0;
		}
		if (positionTop > 0) {
			mergedMarkStyle.top = `${positionTop}px`;
			mergedMarkStyle.height = `calc(100% - ${positionTop}px)`;
			positionTop = 0;
		}
		mergedMarkStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`;
		return mergedMarkStyle;
	}, [
		zIndex,
		offsetLeft,
		gapXCenter,
		offsetTop,
		gapYCenter
	]);
	const [container, setContainer] = import_react.useState();
	const [subElements, setSubElements] = import_react.useState(() => /* @__PURE__ */ new Set());
	const targetElements = import_react.useMemo(() => {
		const list = container ? [container] : [];
		return [].concat(list, _toConsumableArray(Array.from(subElements)));
	}, [container, subElements]);
	/**
	* Get the width and height of the watermark. The default values are as follows
	* Image: [120, 64]; Content: It's calculated by content;
	*/
	const getMarkSize = (ctx) => {
		let defaultWidth = 120;
		let defaultHeight = 64;
		if (!image && ctx.measureText) {
			ctx.font = `${Number(fontSize)}px ${fontFamily}`;
			const contents = toList_default(content);
			const sizes$1 = contents.map((item) => {
				const metrics = ctx.measureText(item);
				return [metrics.width, metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent];
			});
			defaultWidth = Math.ceil(Math.max.apply(Math, _toConsumableArray(sizes$1.map((size) => size[0]))));
			defaultHeight = Math.ceil(Math.max.apply(Math, _toConsumableArray(sizes$1.map((size) => size[1])))) * contents.length + (contents.length - 1) * FontGap;
		}
		return [width ?? defaultWidth, height ?? defaultHeight];
	};
	const getClips = useClips_default();
	const getClipsCache = useSingletonCache();
	const [watermarkInfo, setWatermarkInfo] = import_react.useState(null);
	const renderWatermark = () => {
		const ctx = document.createElement("canvas").getContext("2d");
		if (ctx) {
			const ratio = getPixelRatio();
			const [markWidth, markHeight] = getMarkSize(ctx);
			const drawCanvas = (drawContent) => {
				const params = [
					drawContent || "",
					rotate,
					ratio,
					markWidth,
					markHeight,
					{
						color,
						fontSize,
						fontStyle,
						fontWeight,
						fontFamily,
						textAlign
					},
					gapX,
					gapY
				];
				const [nextClips, clipWidth] = getClipsCache(params, () => getClips.apply(void 0, params));
				setWatermarkInfo([nextClips, clipWidth]);
			};
			if (image) {
				const img = new Image();
				img.onload = () => {
					drawCanvas(img);
				};
				img.onerror = () => {
					drawCanvas(content);
				};
				img.crossOrigin = "anonymous";
				img.referrerPolicy = "no-referrer";
				img.src = image;
			} else drawCanvas(content);
		}
	};
	const syncWatermark = useRafDebounce(renderWatermark);
	const [appendWatermark, removeWatermark, isWatermarkEle] = useWatermark(markStyle, onRemove);
	(0, import_react.useEffect)(() => {
		if (watermarkInfo) targetElements.forEach((holder) => {
			appendWatermark(watermarkInfo[0], watermarkInfo[1], holder);
		});
	}, [watermarkInfo, targetElements]);
	useMutateObserver_default(targetElements, useEvent_default((mutations) => {
		mutations.forEach((mutation) => {
			if (reRendering(mutation, isWatermarkEle)) syncWatermark();
			else if (mutation.target === container && mutation.attributeName === "style") {
				const keyStyles = Object.keys(fixedStyle);
				for (let i = 0; i < keyStyles.length; i += 1) {
					const key = keyStyles[i];
					const oriValue = mergedStyle[key];
					const currentValue = container.style[key];
					if (oriValue && oriValue !== currentValue) container.style[key] = oriValue;
				}
			}
		});
	}));
	(0, import_react.useEffect)(syncWatermark, [
		rotate,
		zIndex,
		width,
		height,
		image,
		content,
		color,
		fontSize,
		fontWeight,
		fontStyle,
		fontFamily,
		textAlign,
		gapX,
		gapY,
		offsetLeft,
		offsetTop
	]);
	const watermarkContext = import_react.useMemo(() => ({
		add: (ele) => {
			setSubElements((prev$1) => {
				const clone = new Set(prev$1);
				clone.add(ele);
				return getSizeDiff(prev$1, clone);
			});
		},
		remove: (ele) => {
			removeWatermark(ele);
			setSubElements((prev$1) => {
				const clone = new Set(prev$1);
				clone.delete(ele);
				return getSizeDiff(prev$1, clone);
			});
		}
	}), []);
	const childNode = inherit ? /* @__PURE__ */ import_react.createElement(context_default.Provider, { value: watermarkContext }, children) : children;
	return /* @__PURE__ */ import_react.createElement("div", {
		ref: setContainer,
		className: clsx(className, contextClassName, rootClassName),
		style: mergedStyle
	}, childNode);
};
Watermark.displayName = "Watermark";
var watermark_default = Watermark;

//#endregion
//#region node_modules/antd/es/index.js
const unstableSetRender = () => {
	warning_default(false, "compatible", "antd v6 support React 19 already, it's no need to call the compatible function or just remove `@ant-design/v5-patch-for-react-19`");
};
warning_default(getReactMajorVersion() >= 18, "version", `antd v6 no longer supports React versions below 18. Please upgrade to React 18 or higher.`);

//#endregion
export { affix_default as Affix, alert_default as Alert, anchor_default as Anchor, app_default as App, auto_complete_default as AutoComplete, avatar_default as Avatar, back_top_default as BackTop, badge_default as Badge, breadcrumb_default as Breadcrumb, button_default as Button, calendar_default as Calendar, card_default as Card, carousel_default as Carousel, cascader_default as Cascader, checkbox_default as Checkbox, col_default as Col, collapse_default as Collapse, color_picker_default as ColorPicker, config_provider_default as ConfigProvider, date_picker_default as DatePicker, descriptions_default as Descriptions, divider_default as Divider, drawer_default as Drawer, dropdown_default as Dropdown, empty_default as Empty, flex_default as Flex, float_button_default as FloatButton, form_default as Form, grid_default as Grid, image_default as Image, input_default as Input, input_number_default as InputNumber, layout_default as Layout, list_default as List, masonry_default as Masonry, mentions_default as Mentions, menu_default as Menu, modal_default as Modal, pagination_default as Pagination, popconfirm_default as Popconfirm, popover_default as Popover, progress_default as Progress, qr_code_default as QRCode, radio_default as Radio, rate_default as Rate, result_default as Result, row_default as Row, segmented_default as Segmented, select_default as Select, skeleton_default as Skeleton, slider_default as Slider, space_default as Space, spin_default as Spin, splitter_default as Splitter, statistic_default as Statistic, steps_default as Steps, switch_default as Switch, table_default as Table, tabs_default as Tabs, tag_default as Tag, time_picker_default as TimePicker, timeline_default as Timeline, tooltip_default as Tooltip, tour_default as Tour, transfer_default as Transfer, tree_default as Tree, tree_select_default as TreeSelect, typography_default as Typography, upload_default as Upload, watermark_default as Watermark, message_default as message, notification_default as notification, theme_default as theme, unstableSetRender, version_default as version };
//# sourceMappingURL=antd.js.map